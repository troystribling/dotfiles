"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var vector_1 = require("./vector");
/**
 * A concrete implementation of [[IObservableVector]].
 */
var ObservableVector = (function (_super) {
    __extends(ObservableVector, _super);
    /**
     * Construct a new observable map.
     */
    function ObservableVector(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, options.values || []) || this;
        _this._isDisposed = false;
        _this._changed = new signaling_1.Signal(_this);
        _this._itemCmp = options.itemCmp || Private.itemCmp;
        return _this;
    }
    Object.defineProperty(ObservableVector.prototype, "type", {
        /**
         * The type of the Observable.
         */
        get: function () {
            return 'Vector';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableVector.prototype, "changed", {
        /**
         * A signal emitted when the vector has changed.
         */
        get: function () {
            return this._changed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableVector.prototype, "isDisposed", {
        /**
         * Test whether the vector has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the vector.
     */
    ObservableVector.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.clear();
    };
    /**
     * Set the value at the specified index.
     *
     * @param index - The positive integer index of interest.
     *
     * @param value - The value to set at the specified index.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral or out of range.
     */
    ObservableVector.prototype.set = function (index, value) {
        var oldValues = [this.at(index)];
        if (value === undefined) {
            value = null;
        }
        // Bail if the value does not change.
        var itemCmp = this._itemCmp;
        if (itemCmp(oldValues[0], value)) {
            return;
        }
        _super.prototype.set.call(this, index, value);
        this._changed.emit({
            type: 'set',
            oldIndex: index,
            newIndex: index,
            oldValues: oldValues,
            newValues: [value]
        });
    };
    /**
     * Add a value to the back of the vector.
     *
     * @param value - The value to add to the back of the vector.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableVector.prototype.pushBack = function (value) {
        var num = _super.prototype.pushBack.call(this, value);
        // Bail if in the constructor.
        if (!this._changed) {
            return;
        }
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: this.length - 1,
            oldValues: [],
            newValues: [value]
        });
        return num;
    };
    /**
     * Remove and return the value at the back of the vector.
     *
     * @returns The value at the back of the vector, or `undefined` if
     *   the vector is empty.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value are invalidated.
     */
    ObservableVector.prototype.popBack = function () {
        var value = _super.prototype.popBack.call(this);
        this._changed.emit({
            type: 'remove',
            oldIndex: this.length,
            newIndex: -1,
            oldValues: [value],
            newValues: []
        });
        return value;
    };
    /**
     * Insert a value into the vector at a specific index.
     *
     * @param index - The index at which to insert the value.
     *
     * @param value - The value to set at the specified index.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the vector.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    ObservableVector.prototype.insert = function (index, value) {
        var num = _super.prototype.insert.call(this, index, value);
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: index,
            oldValues: [],
            newValues: [value]
        });
        return num;
    };
    /**
     * Remove the first occurrence of a value from the vector.
     *
     * @param value - The value of interest.
     *
     * @returns The index of the removed value, or `-1` if the value
     *   is not contained in the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value and beyond are invalidated.
     */
    ObservableVector.prototype.remove = function (value) {
        var itemCmp = this._itemCmp;
        var index = algorithm_1.ArrayExt.findFirstIndex(algorithm_1.toArray(this), function (item) { return itemCmp(item, value); });
        this.removeAt(index);
        return index;
    };
    /**
     * Remove and return the value at a specific index.
     *
     * @param index - The index of the value of interest.
     *
     * @returns The value at the specified index, or `undefined` if the
     *   index is out of range.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value and beyond are invalidated.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    ObservableVector.prototype.removeAt = function (index) {
        var value = _super.prototype.removeAt.call(this, index);
        this._changed.emit({
            type: 'remove',
            oldIndex: index,
            newIndex: -1,
            oldValues: [value],
            newValues: []
        });
        return value;
    };
    /**
     * Remove all values from the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * All current iterators are invalidated.
     */
    ObservableVector.prototype.clear = function () {
        var oldValues = algorithm_1.toArray(this);
        _super.prototype.clear.call(this);
        this._changed.emit({
            type: 'remove',
            oldIndex: 0,
            newIndex: 0,
            oldValues: oldValues,
            newValues: []
        });
    };
    /**
     * Move a value from one index to another.
     *
     * @parm fromIndex - The index of the element to move.
     *
     * @param toIndex - The index to move the element to.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
     * and beyond are invalidated.
     *
     * #### Undefined Behavior
     * A `fromIndex` or a `toIndex` which is non-integral.
     */
    ObservableVector.prototype.move = function (fromIndex, toIndex) {
        if (this.length <= 1 || fromIndex === toIndex) {
            return;
        }
        var value = this.at(fromIndex);
        var step = fromIndex < toIndex ? 1 : -1;
        for (var i = fromIndex; i !== toIndex; i += step) {
            _super.prototype.set.call(this, i, this.at(i + step));
        }
        _super.prototype.set.call(this, toIndex, value);
        var arr = [value];
        this._changed.emit({
            type: 'move',
            oldIndex: fromIndex,
            newIndex: toIndex,
            oldValues: arr,
            newValues: arr
        });
    };
    /**
     * Push a set of values to the back of the vector.
     *
     * @param values - An iterable or array-like set of values to add.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableVector.prototype.pushAll = function (values) {
        var _this = this;
        var newIndex = this.length;
        var newValues = algorithm_1.toArray(values);
        algorithm_1.each(newValues, function (value) { _super.prototype.pushBack.call(_this, value); });
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: newIndex,
            oldValues: [],
            newValues: newValues
        });
        return this.length;
    };
    /**
     * Insert a set of items into the vector at the specified index.
     *
     * @param index - The index at which to insert the values.
     *
     * @param values - The values to insert at the specified index.
     *
     * @returns The new length of the vector.
     *
     * #### Complexity.
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the vector.
     *
     * #### Undefined Behavior.
     * An `index` which is non-integral.
     */
    ObservableVector.prototype.insertAll = function (index, values) {
        var _this = this;
        var newIndex = index;
        var newValues = algorithm_1.toArray(values);
        algorithm_1.each(newValues, function (value) { _super.prototype.insert.call(_this, index++, value); });
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: newIndex,
            oldValues: [],
            newValues: newValues
        });
        return this.length;
    };
    /**
     * Remove a range of items from the vector.
     *
     * @param startIndex - The start index of the range to remove (inclusive).
     *
     * @param endIndex - The end index of the range to remove (exclusive).
     *
     * @returns The new length of the vector.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing to the first removed value and beyond are invalid.
     *
     * #### Undefined Behavior
     * A `startIndex` or `endIndex` which is non-integral.
     */
    ObservableVector.prototype.removeRange = function (startIndex, endIndex) {
        var oldValues = [];
        for (var i = startIndex; i < endIndex; i++) {
            oldValues.push(_super.prototype.removeAt.call(this, startIndex));
        }
        this._changed.emit({
            type: 'remove',
            oldIndex: startIndex,
            newIndex: -1,
            oldValues: oldValues,
            newValues: []
        });
        return this.length;
    };
    return ObservableVector;
}(vector_1.Vector));
exports.ObservableVector = ObservableVector;
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * The default strict equality item cmp.
     */
    function itemCmp(first, second) {
        return first === second;
    }
    Private.itemCmp = itemCmp;
})(Private || (Private = {}));
