"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Ajv = require("ajv");
var json = require("comment-json");
var algorithm_1 = require("@phosphor/algorithm");
var coreutils_1 = require("@phosphor/coreutils");
var signaling_1 = require("@phosphor/signaling");
/**
 * The key in the schema for setting editor icon class hints.
 */
exports.ICON_CLASS_KEY = 'jupyter.lab.setting-icon-class';
/**
 * The key in the schema for setting editor icon label hints.
 */
exports.ICON_LABEL_KEY = 'jupyter.lab.setting-icon-label';
/**
 * An alias for the JSON deep copy function.
 */
var copy = coreutils_1.JSONExt.deepCopy;
/* tslint:disable */
/**
 * The setting registry token.
 */
exports.ISettingRegistry = new coreutils_1.Token('@jupyterlab/coreutils:ISettingRegistry');
/**
 * The default implementation of a schema validator.
 */
var DefaultSchemaValidator = /** @class */ (function () {
    /**
     * Instantiate a schema validator.
     */
    function DefaultSchemaValidator() {
        this._composer = new Ajv({ useDefaults: true });
        this._validator = new Ajv();
        this._composer.addSchema(Private.SCHEMA, 'main');
        this._validator.addSchema(Private.SCHEMA, 'main');
    }
    /**
     * Validate a plugin's schema and user data; populate the `composite` data.
     *
     * @param plugin - The plugin being validated. Its `composite` data will be
     * populated by reference.
     *
     * @param populate - Whether plugin data should be populated, defaults to
     * `true`.
     *
     * @return A list of errors if either the schema or data fail to validate or
     * `null` if there are no errors.
     */
    DefaultSchemaValidator.prototype.validateData = function (plugin, populate) {
        if (populate === void 0) { populate = true; }
        var validate = this._validator.getSchema(plugin.id);
        var compose = this._composer.getSchema(plugin.id);
        // If the schemas do not exist, add them to the validator and continue.
        if (!validate || !compose) {
            var errors = this._addSchema(plugin.id, plugin.schema);
            if (errors) {
                return errors;
            }
            return this.validateData(plugin);
        }
        // Parse the raw commented JSON into a user map.
        var user;
        try {
            var strip = true;
            user = json.parse(plugin.raw, null, strip);
        }
        catch (error) {
            if (error instanceof SyntaxError) {
                return [{
                        dataPath: '', keyword: 'syntax', schemaPath: '',
                        message: error.message
                    }];
            }
            var column = error.column, description = error.description;
            var line = error.lineNumber;
            return [{
                    dataPath: '', keyword: 'parse', schemaPath: '',
                    message: description + " (line " + line + " column " + column + ")"
                }];
        }
        if (!validate(user)) {
            return validate.errors;
        }
        // Copy the user data before merging defaults into composite map.
        var composite = copy(user);
        if (!compose(composite)) {
            return compose.errors;
        }
        if (populate) {
            plugin.data = { composite: composite, user: user };
        }
        return null;
    };
    /**
     * Add a schema to the validator.
     *
     * @param plugin - The plugin ID.
     *
     * @param schema - The schema being added.
     *
     * @return A list of errors if the schema fails to validate or `null` if there
     * are no errors.
     *
     * #### Notes
     * It is safe to call this function multiple times with the same plugin name.
     */
    DefaultSchemaValidator.prototype._addSchema = function (plugin, schema) {
        var composer = this._composer;
        var validator = this._validator;
        var validate = validator.getSchema('main');
        // Validate against the main schema.
        if (!validate(schema)) {
            return validate.errors;
        }
        // Validate against the JSON schema meta-schema.
        if (!validator.validateSchema(schema)) {
            return validator.errors;
        }
        // Remove if schema already exists.
        composer.removeSchema(plugin);
        validator.removeSchema(plugin);
        // Add schema to the validator and composer.
        composer.addSchema(schema, plugin);
        validator.addSchema(schema, plugin);
        return null;
    };
    return DefaultSchemaValidator;
}());
exports.DefaultSchemaValidator = DefaultSchemaValidator;
/**
 * The default concrete implementation of a setting registry.
 */
var SettingRegistry = /** @class */ (function () {
    /**
     * Create a new setting registry.
     */
    function SettingRegistry(options) {
        /**
         * The schema of the setting registry.
         */
        this.schema = Private.SCHEMA;
        this._pluginChanged = new signaling_1.Signal(this);
        this._plugins = Object.create(null);
        this._connector = options.connector;
        this.validator = options.validator || new DefaultSchemaValidator();
    }
    Object.defineProperty(SettingRegistry.prototype, "pluginChanged", {
        /**
         * A signal that emits the name of a plugin when its settings change.
         */
        get: function () {
            return this._pluginChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SettingRegistry.prototype, "plugins", {
        /**
         * Returns a list of plugin settings held in the registry.
         */
        get: function () {
            var plugins = this._plugins;
            return Object.keys(plugins)
                .map(function (p) { return copy(plugins[p]); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get an individual setting.
     *
     * @param plugin - The name of the plugin whose settings are being retrieved.
     *
     * @param key - The name of the setting being retrieved.
     *
     * @returns A promise that resolves when the setting is retrieved.
     */
    SettingRegistry.prototype.get = function (plugin, key) {
        var _this = this;
        var plugins = this._plugins;
        if (plugin in plugins) {
            var _a = plugins[plugin].data, composite = _a.composite, user = _a.user;
            var result = {
                composite: key in composite ? copy(composite[key]) : undefined,
                user: key in user ? copy(user[key]) : undefined
            };
            return Promise.resolve(result);
        }
        return this.load(plugin).then(function () { return _this.get(plugin, key); });
    };
    /**
     * Load a plugin's settings into the setting registry.
     *
     * @param plugin - The name of the plugin whose settings are being loaded.
     *
     * @returns A promise that resolves with a plugin settings object or rejects
     * if the plugin is not found.
     */
    SettingRegistry.prototype.load = function (plugin) {
        var plugins = this._plugins;
        var registry = this;
        // If the plugin exists, resolve.
        if (plugin in plugins) {
            var settings = new Settings({ plugin: plugins[plugin], registry: registry });
            return Promise.resolve(settings);
        }
        // If the plugin needs to be loaded from the data connector, fetch.
        return this.reload(plugin);
    };
    /**
     * Reload a plugin's settings into the registry even if they already exist.
     *
     * @param plugin - The name of the plugin whose settings are being reloaded.
     *
     * @returns A promise that resolves with a plugin settings object or rejects
     * with a list of `ISchemaValidator.IError` objects if it fails.
     */
    SettingRegistry.prototype.reload = function (plugin) {
        var _this = this;
        var connector = this._connector;
        var plugins = this._plugins;
        var registry = this;
        // If the plugin needs to be loaded from the connector, fetch.
        return connector.fetch(plugin).then(function (data) {
            // Validate the response from the connector; populate `composite` field.
            try {
                _this._validate(data);
            }
            catch (errors) {
                var output_1 = ["Validating " + plugin + " failed:"];
                errors.forEach(function (error, index) {
                    var dataPath = error.dataPath, schemaPath = error.schemaPath, keyword = error.keyword, message = error.message;
                    output_1.push(index + " - schema @ " + schemaPath + ", data @ " + dataPath);
                    output_1.push("\t" + keyword + " " + message);
                });
                console.error(output_1.join('\n'));
                throw new Error("Failed validating " + plugin);
            }
            // Emit that a plugin has changed.
            _this._pluginChanged.emit(plugin);
            return new Settings({ plugin: plugins[plugin], registry: registry });
        });
    };
    /**
     * Remove a single setting in the registry.
     *
     * @param plugin - The name of the plugin whose setting is being removed.
     *
     * @param key - The name of the setting being removed.
     *
     * @returns A promise that resolves when the setting is removed.
     */
    SettingRegistry.prototype.remove = function (plugin, key) {
        var plugins = this._plugins;
        if (!(plugin in plugins)) {
            return Promise.resolve(undefined);
        }
        var raw = json.parse(plugins[plugin].raw);
        // Delete both the value and any associated comment.
        delete raw[key];
        delete raw["// " + key];
        plugins[plugin].raw = json.stringify(raw);
        return this._save(plugin);
    };
    /**
     * Set a single setting in the registry.
     *
     * @param plugin - The name of the plugin whose setting is being set.
     *
     * @param key - The name of the setting being set.
     *
     * @param value - The value of the setting being set.
     *
     * @returns A promise that resolves when the setting has been saved.
     *
     */
    SettingRegistry.prototype.set = function (plugin, key, value) {
        var _this = this;
        var plugins = this._plugins;
        if (!(plugin in plugins)) {
            return this.load(plugin).then(function () { return _this.set(plugin, key, value); });
        }
        var raw = json.parse(plugins[plugin].raw);
        plugins[plugin].raw = json.stringify(__assign({}, raw, (_a = {}, _a[key] = value, _a)));
        return this._save(plugin);
        var _a;
    };
    /**
     * Upload a plugin's settings.
     *
     * @param plugin - The name of the plugin whose settings are being set.
     *
     * @param raw - The raw plugin settings being uploaded.
     *
     * @returns A promise that resolves when the settings have been saved.
     */
    SettingRegistry.prototype.upload = function (plugin, raw) {
        var _this = this;
        var plugins = this._plugins;
        if (!(plugin in plugins)) {
            return this.load(plugin).then(function () { return _this.upload(plugin, raw); });
        }
        // Set the local copy.
        plugins[plugin].raw = raw;
        return this._save(plugin);
    };
    /**
     * Save a plugin in the registry.
     */
    SettingRegistry.prototype._save = function (plugin) {
        var _this = this;
        var plugins = this._plugins;
        if (!(plugin in plugins)) {
            var message = plugin + " does not exist in setting registry.";
            return Promise.reject(new Error(message));
        }
        try {
            this._validate(plugins[plugin]);
        }
        catch (errors) {
            var message = plugin + " failed to validate; check console for errors.";
            console.warn(plugin + " validation errors:", errors);
            return Promise.reject(new Error(message));
        }
        return this._connector.save(plugin, plugins[plugin].raw)
            .then(function () { _this._pluginChanged.emit(plugin); });
    };
    /**
     * Validate a plugin's data and schema, compose the `composite` data.
     */
    SettingRegistry.prototype._validate = function (plugin) {
        // Validate the user data and create the composite data.
        var errors = this.validator.validateData(plugin);
        if (errors) {
            throw errors;
        }
        // Set the local copy.
        this._plugins[plugin.id] = plugin;
    };
    return SettingRegistry;
}());
exports.SettingRegistry = SettingRegistry;
/**
 * A manager for a specific plugin's settings.
 */
var Settings = /** @class */ (function () {
    /**
     * Instantiate a new plugin settings manager.
     */
    function Settings(options) {
        this._changed = new signaling_1.Signal(this);
        this._composite = Object.create(null);
        this._isDisposed = false;
        this._raw = '{ }';
        this._schema = Object.create(null);
        this._user = Object.create(null);
        var plugin = options.plugin;
        this.plugin = plugin.id;
        this.registry = options.registry;
        this._composite = plugin.data.composite || {};
        this._raw = plugin.raw || '{ }';
        this._schema = plugin.schema || { type: 'object' };
        this._user = plugin.data.user || {};
        this.registry.pluginChanged.connect(this._onPluginChanged, this);
    }
    Object.defineProperty(Settings.prototype, "changed", {
        /**
         * A signal that emits when the plugin's settings have changed.
         */
        get: function () {
            return this._changed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings.prototype, "composite", {
        /**
         * Get the composite of user settings and extension defaults.
         */
        get: function () {
            return this._composite;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings.prototype, "isDisposed", {
        /**
         * Test whether the plugin settings manager disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings.prototype, "schema", {
        /**
         * Get the plugin settings schema.
         */
        get: function () {
            return this._schema;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings.prototype, "raw", {
        /**
         * Get the plugin settings raw text value.
         */
        get: function () {
            return this._raw;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Settings.prototype, "user", {
        /**
         * Get the user settings.
         */
        get: function () {
            return this._user;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Return the defaults in a commented JSON format.
     */
    Settings.prototype.annotatedDefaults = function () {
        return Private.annotatedDefaults(this._schema, this.plugin);
    };
    /**
     * Calculate the default value of a setting by iterating through the schema.
     *
     * @param key - The name of the setting whose default value is calculated.
     *
     * @returns A calculated default JSON value for a specific setting.
     */
    Settings.prototype.default = function (key) {
        return Private.reifyDefault(this.schema, key);
    };
    /**
     * Dispose of the plugin settings resources.
     */
    Settings.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
    };
    /**
     * Get an individual setting.
     *
     * @param key - The name of the setting being retrieved.
     *
     * @returns The setting value.
     *
     * #### Notes
     * This method returns synchronously because it uses a cached copy of the
     * plugin settings that is synchronized with the registry.
     */
    Settings.prototype.get = function (key) {
        var _a = this, composite = _a.composite, user = _a.user;
        return {
            composite: key in composite ? copy(composite[key]) : undefined,
            user: key in user ? copy(user[key]) : undefined
        };
    };
    /**
     * Remove a single setting.
     *
     * @param key - The name of the setting being removed.
     *
     * @returns A promise that resolves when the setting is removed.
     *
     * #### Notes
     * This function is asynchronous because it writes to the setting registry.
     */
    Settings.prototype.remove = function (key) {
        return this.registry.remove(this.plugin, key);
    };
    /**
     * Save all of the plugin's user settings at once.
     */
    Settings.prototype.save = function (raw) {
        return this.registry.upload(this.plugin, raw);
    };
    /**
     * Set a single setting.
     *
     * @param key - The name of the setting being set.
     *
     * @param value - The value of the setting.
     *
     * @returns A promise that resolves when the setting has been saved.
     *
     * #### Notes
     * This function is asynchronous because it writes to the setting registry.
     */
    Settings.prototype.set = function (key, value) {
        return this.registry.set(this.plugin, key, value);
    };
    /**
     * Validates raw settings with comments.
     *
     * @param raw - The JSON with comments string being validated.
     *
     * @returns A list of errors or `null` if valid.
     */
    Settings.prototype.validate = function (raw) {
        var data = { composite: {}, user: {} };
        var id = this.plugin;
        var schema = this._schema;
        var validator = this.registry.validator;
        return validator.validateData({ data: data, id: id, raw: raw, schema: schema }, false);
    };
    /**
     * Handle plugin changes in the setting registry.
     */
    Settings.prototype._onPluginChanged = function (sender, plugin) {
        if (plugin === this.plugin) {
            var found = algorithm_1.find(this.registry.plugins, function (p) { return p.id === plugin; });
            if (!found) {
                return;
            }
            var _a = found.data, composite = _a.composite, user = _a.user;
            var raw = found.raw, schema = found.schema;
            this._composite = composite || {};
            this._raw = raw;
            this._schema = schema || { type: 'object' };
            this._user = user || {};
            this._changed.emit(undefined);
        }
    };
    return Settings;
}());
exports.Settings = Settings;
/**
 * A namespace for private module data.
 */
var Private;
(function (Private) {
    /* tslint:disable */
    /**
     * The schema for settings.
     */
    Private.SCHEMA = {
        "$schema": "http://json-schema.org/draft-06/schema",
        "title": "Jupyter Settings/Preferences Schema",
        "description": "Jupyter settings/preferences schema v0.1.0",
        "type": "object",
        "additionalProperties": true,
        "properties": (_a = {},
            _a[exports.ICON_CLASS_KEY] = { "type": "string", "default": "jp-FileIcon" },
            _a[exports.ICON_LABEL_KEY] = { "type": "string", "default": "Plugin" },
            _a)
    };
    /* tslint:enable */
    /**
     * The default indentation level, uses spaces instead of tabs.
     */
    var indent = '    ';
    /**
     * Replacement text for schema properties missing a `description` field.
     */
    var nondescript = '[missing schema description]';
    /**
     * Replacement text for schema properties missing a `default` field.
     */
    var undefaulted = '[missing schema default]';
    /**
     * Replacement text for schema properties missing a `title` field.
     */
    var untitled = '[missing schema title]';
    /**
     * Returns an annotated (JSON with comments) version of a schema's defaults.
     */
    function annotatedDefaults(schema, plugin) {
        var description = schema.description, properties = schema.properties, title = schema.title;
        var keys = Object.keys(properties).sort(function (a, b) { return a.localeCompare(b); });
        var length = Math.max((description || nondescript).length, plugin.length);
        return [
            '{',
            prefix("" + (title || untitled)),
            prefix(plugin),
            prefix(description || nondescript),
            prefix(line(length)),
            '',
            keys.map(function (key) { return docstring(schema, key); }).join('\n\n'),
            '}'
        ].join('\n');
    }
    Private.annotatedDefaults = annotatedDefaults;
    /**
     * Returns a documentation string for a specific schema property.
     */
    function docstring(schema, key) {
        var _a = schema.properties[key], description = _a.description, title = _a.title;
        var reified = reifyDefault(schema, key);
        var defaults = reified === undefined ? prefix("\"" + key + "\": " + undefaulted)
            : prefix("\"" + key + "\": " + JSON.stringify(reified, null, 2), indent);
        return [
            prefix("" + (title || untitled)),
            prefix(description || nondescript),
            defaults
        ].join('\n');
    }
    /**
     * Returns a line of a specified length.
     */
    function line(length, ch) {
        if (ch === void 0) { ch = '*'; }
        return (new Array(length + 1)).join(ch);
    }
    /**
     * Returns a documentation string with a comment prefix added on every line.
     */
    function prefix(source, pre) {
        if (pre === void 0) { pre = indent + "// "; }
        return pre + source.split('\n').join("\n" + pre);
    }
    /**
     * Create a fully extrapolated default value for a root key in a schema.
     */
    function reifyDefault(schema, root) {
        // If the property is at the root level, traverse its schema.
        schema = (root ? schema.properties[root] : schema) || {};
        // If the property has no default or is a primitive, return.
        if (!('default' in schema) || schema.type !== 'object') {
            return schema.default;
        }
        // Make a copy of the default value to populate.
        var result = coreutils_1.JSONExt.deepCopy(schema.default);
        // Iterate through and populate each child property.
        for (var property in schema.properties || {}) {
            result[property] = reifyDefault(schema.properties[property]);
        }
        return result;
    }
    Private.reifyDefault = reifyDefault;
    var _a;
})(Private = exports.Private || (exports.Private = {}));
