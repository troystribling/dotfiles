import { ReadonlyJSONValue, Token } from '@phosphor/coreutils';
import { IDataConnector } from './interfaces';
/**
 * The default state database token.
 */
export declare const IStateDB: Token<IStateDB>;
/**
 * An object which holds an id/value pair.
 */
export interface IStateItem {
    /**
     * The identifier key for a state item.
     */
    id: string;
    /**
     * The data value for a state item.
     */
    value: ReadonlyJSONValue;
}
/**
 * The description of a state database.
 */
export interface IStateDB extends IDataConnector<ReadonlyJSONValue> {
    /**
     * The maximum allowed length of the data after it has been serialized.
     */
    readonly maxLength: number;
    /**
     * The namespace prefix for all state database entries.
     *
     * #### Notes
     * This value should be set at instantiation and will only be used
     * internally by a state database. That means, for example, that an
     * app could have multiple, mutually exclusive state databases.
     */
    readonly namespace: string;
    /**
     * Retrieve all the saved bundles for a namespace.
     *
     * @param namespace - The namespace to retrieve.
     *
     * @returns A promise that bears a collection data payloads for a namespace.
     *
     * #### Notes
     * Namespaces are entirely conventional entities. The `id` values of stored
     * items in the state database are formatted: `'namespace:identifier'`, which
     * is the same convention that command identifiers in JupyterLab use as well.
     *
     * If there are any errors in retrieving the data, they will be logged to the
     * console in order to optimistically return any extant data without failing.
     * This promise will always succeed.
     */
    fetchNamespace(namespace: string): Promise<IStateItem[]>;
}
/**
 * The default concrete implementation of a state database.
 */
export declare class StateDB implements IStateDB {
    /**
     * Create a new state database.
     *
     * @param options - The instantiation options for a state database.
     */
    constructor(options: StateDB.IOptions);
    /**
     * The maximum allowed length of the data after it has been serialized.
     */
    readonly maxLength: number;
    /**
     * The namespace prefix for all state database entries.
     *
     * #### Notes
     * This value should be set at instantiation and will only be used internally
     * by a state database. That means, for example, that an app could have
     * multiple, mutually exclusive state databases.
     */
    readonly namespace: string;
    /**
     * Clear the entire database.
     */
    clear(): Promise<void>;
    /**
     * Retrieve a saved bundle from the database.
     *
     * @param id - The identifier used to retrieve a data bundle.
     *
     * @returns A promise that bears a data payload if available.
     *
     * #### Notes
     * The `id` values of stored items in the state database are formatted:
     * `'namespace:identifier'`, which is the same convention that command
     * identifiers in JupyterLab use as well. While this is not a technical
     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
     * using the `fetchNamespace()` method.
     *
     * The promise returned by this method may be rejected if an error occurs in
     * retrieving the data. Non-existence of an `id` will succeed with `null`.
     */
    fetch(id: string): Promise<ReadonlyJSONValue | undefined>;
    /**
     * Retrieve all the saved bundles for a namespace.
     *
     * @param namespace - The namespace to retrieve.
     *
     * @returns A promise that bears a collection data payloads for a namespace.
     *
     * #### Notes
     * Namespaces are entirely conventional entities. The `id` values of stored
     * items in the state database are formatted: `'namespace:identifier'`, which
     * is the same convention that command identifiers in JupyterLab use as well.
     *
     * If there are any errors in retrieving the data, they will be logged to the
     * console in order to optimistically return any extant data without failing.
     * This promise will always succeed.
     */
    fetchNamespace(namespace: string): Promise<IStateItem[]>;
    /**
     * Remove a value from the database.
     *
     * @param id - The identifier for the data being removed.
     *
     * @returns A promise that is rejected if remove fails and succeeds otherwise.
     */
    remove(id: string): Promise<void>;
    /**
     * Save a value in the database.
     *
     * @param id - The identifier for the data being saved.
     *
     * @param value - The data being saved.
     *
     * @returns A promise that is rejected if saving fails and succeeds otherwise.
     *
     * #### Notes
     * The `id` values of stored items in the state database are formatted:
     * `'namespace:identifier'`, which is the same convention that command
     * identifiers in JupyterLab use as well. While this is not a technical
     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
     * using the `fetchNamespace()` method.
     */
    save(id: string, value: ReadonlyJSONValue): Promise<void>;
}
/**
 * A namespace for StateDB statics.
 */
export declare namespace StateDB {
    /**
     * The instantiation options for a state database.
     */
    interface IOptions {
        /**
         * The namespace prefix for all state database entries.
         */
        namespace: string;
    }
}
