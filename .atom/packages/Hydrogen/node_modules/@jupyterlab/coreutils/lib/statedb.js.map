{"version":3,"file":"statedb.js","sourceRoot":"","sources":["../../../../coreutils/src/statedb.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  ReadonlyJSONObject, Token\n} from '@phosphor/coreutils';\n\nimport {\n  IDataConnector\n} from '.';\n\n\n/* tslint:disable */\n/**\n * The default state database token.\n */\nexport\nconst IStateDB = new Token<IStateDB>('@jupyterlab/coreutils:IStateDB');\n/* tslint:enable */\n\n\n/**\n * An object which holds an id/value pair.\n */\nexport\ninterface IStateItem {\n  /**\n   * The identifier key for a state item.\n   */\n  id: string;\n\n  /**\n   * The data value for a state item.\n   */\n  value: ReadonlyJSONObject;\n}\n\n\n/**\n * The description of a state database.\n */\nexport\ninterface IStateDB extends IDataConnector<ReadonlyJSONObject> {\n  /**\n   * The maximum allowed length of the data after it has been serialized.\n   */\n  readonly maxLength: number;\n\n  /**\n   * The namespace prefix for all state database entries.\n   *\n   * #### Notes\n   * This value should be set at instantiation and will only be used\n   * internally by a state database. That means, for example, that an\n   * app could have multiple, mutually exclusive state databases.\n   */\n  readonly namespace: string;\n\n  /**\n   * Retrieve all the saved bundles for a namespace.\n   *\n   * @param namespace - The namespace to retrieve.\n   *\n   * @returns A promise that bears a collection data payloads for a namespace.\n   *\n   * #### Notes\n   * Namespaces are entirely conventional entities. The `id` values of stored\n   * items in the state database are formatted: `'namespace:identifier'`, which\n   * is the same convention that command identifiers in JupyterLab use as well.\n   *\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   * This promise will always succeed.\n   */\n  fetchNamespace(namespace: string): Promise<IStateItem[]>;\n}\n\n\n/**\n * The default concrete implementation of a state database.\n */\nexport\nclass StateDB implements IStateDB {\n  /**\n   * Create a new state database.\n   *\n   * @param options - The instantiation options for a state database.\n   */\n  constructor(options: StateDB.IOptions) {\n    this.namespace = options.namespace;\n  }\n\n  /**\n   * The maximum allowed length of the data after it has been serialized.\n   */\n  readonly maxLength = 2000;\n\n  /**\n   * The namespace prefix for all state database entries.\n   *\n   * #### Notes\n   * This value should be set at instantiation and will only be used internally\n   * by a state database. That means, for example, that an app could have\n   * multiple, mutually exclusive state databases.\n   */\n  readonly namespace: string;\n\n  /**\n   * Clear the entire database.\n   */\n  clear(): Promise<void> {\n    const prefix = `${this.namespace}:`;\n    let i = window.localStorage.length;\n    while (i) {\n      let key = window.localStorage.key(--i);\n      if (key && key.indexOf(prefix) === 0) {\n        window.localStorage.removeItem(key);\n      }\n    }\n    return Promise.resolve(void 0);\n  }\n\n  /**\n   * Retrieve a saved bundle from the database.\n   *\n   * @param id - The identifier used to retrieve a data bundle.\n   *\n   * @returns A promise that bears a data payload if available.\n   *\n   * #### Notes\n   * The `id` values of stored items in the state database are formatted:\n   * `'namespace:identifier'`, which is the same convention that command\n   * identifiers in JupyterLab use as well. While this is not a technical\n   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n   * using the `fetchNamespace()` method.\n   *\n   * The promise returned by this method may be rejected if an error occurs in\n   * retrieving the data. Non-existence of an `id` will succeed with `null`.\n   */\n  fetch(id: string): Promise<ReadonlyJSONObject | undefined> {\n    const key = `${this.namespace}:${id}`;\n    const value = window.localStorage.getItem(key);\n    if (!value) {\n      return Promise.resolve(undefined);\n    }\n    try {\n      return Promise.resolve(JSON.parse(value));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n   * Retrieve all the saved bundles for a namespace.\n   *\n   * @param namespace - The namespace to retrieve.\n   *\n   * @returns A promise that bears a collection data payloads for a namespace.\n   *\n   * #### Notes\n   * Namespaces are entirely conventional entities. The `id` values of stored\n   * items in the state database are formatted: `'namespace:identifier'`, which\n   * is the same convention that command identifiers in JupyterLab use as well.\n   *\n   * If there are any errors in retrieving the data, they will be logged to the\n   * console in order to optimistically return any extant data without failing.\n   * This promise will always succeed.\n   */\n  fetchNamespace(namespace: string): Promise<IStateItem[]> {\n    const prefix = `${this.namespace}:${namespace}:`;\n    const regex = new RegExp(`^${this.namespace}\\:`);\n    let items: IStateItem[] = [];\n    let i = window.localStorage.length;\n    while (i) {\n      let key = window.localStorage.key(--i);\n      if (key && key.indexOf(prefix) === 0) {\n        let value = window.localStorage.getItem(key);\n        try {\n          items.push({\n            id: key.replace(regex, ''),\n            value: value ? JSON.parse(value) : undefined\n          });\n        } catch (error) {\n          console.warn(error);\n          window.localStorage.removeItem(key);\n        }\n      }\n    }\n    return Promise.resolve(items);\n  }\n\n  /**\n   * Remove a value from the database.\n   *\n   * @param id - The identifier for the data being removed.\n   *\n   * @returns A promise that is rejected if remove fails and succeeds otherwise.\n   */\n  remove(id: string): Promise<void> {\n    window.localStorage.removeItem(`${this.namespace}:${id}`);\n    return Promise.resolve(void 0);\n  }\n\n  /**\n   * Save a value in the database.\n   *\n   * @param id - The identifier for the data being saved.\n   *\n   * @param value - The data being saved.\n   *\n   * @returns A promise that is rejected if saving fails and succeeds otherwise.\n   *\n   * #### Notes\n   * The `id` values of stored items in the state database are formatted:\n   * `'namespace:identifier'`, which is the same convention that command\n   * identifiers in JupyterLab use as well. While this is not a technical\n   * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n   * using the `fetchNamespace()` method.\n   */\n  save(id: string, value: ReadonlyJSONObject): Promise<void> {\n    try {\n      const key = `${this.namespace}:${id}`;\n      const serialized = JSON.stringify(value);\n      const length = serialized.length;\n      const max = this.maxLength;\n      if (length > max) {\n        throw new Error(`Data length (${length}) exceeds maximum (${max})`);\n      }\n      window.localStorage.setItem(key, serialized);\n      return Promise.resolve(void 0);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n}\n\n/**\n * A namespace for StateDB statics.\n */\nexport\nnamespace StateDB {\n  /**\n   * The instantiation options for a state database.\n   */\n  export\n  interface IOptions {\n    /**\n     * The namespace prefix for all state database entries.\n     */\n    namespace: string;\n  }\n}\n"]}