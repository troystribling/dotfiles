"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var observablevector_1 = require("./observablevector");
/**
 * A concrete implementation of an observable undoable vector.
 */
var ObservableUndoableVector = (function (_super) {
    __extends(ObservableUndoableVector, _super);
    /**
     * Construct a new undoable observable vector.
     */
    function ObservableUndoableVector(serializer) {
        var _this = _super.call(this) || this;
        _this._inCompound = false;
        _this._isUndoable = true;
        _this._madeCompoundChange = false;
        _this._index = -1;
        _this._stack = [];
        _this._serializer = null;
        _this._serializer = serializer;
        _this.changed.connect(_this._onVectorChanged, _this);
        return _this;
    }
    Object.defineProperty(ObservableUndoableVector.prototype, "canRedo", {
        /**
         * Whether the object can redo changes.
         */
        get: function () {
            return this._index < this._stack.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableUndoableVector.prototype, "canUndo", {
        /**
         * Whether the object can undo changes.
         */
        get: function () {
            return this._index >= 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    ObservableUndoableVector.prototype.dispose = function () {
        this._serializer = null;
        this._stack = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Begin a compound operation.
     *
     * @param isUndoAble - Whether the operation is undoable.
     *   The default is `true`.
     */
    ObservableUndoableVector.prototype.beginCompoundOperation = function (isUndoAble) {
        this._inCompound = true;
        this._isUndoable = (isUndoAble !== false);
        this._madeCompoundChange = false;
    };
    /**
     * End a compound operation.
     */
    ObservableUndoableVector.prototype.endCompoundOperation = function () {
        this._inCompound = false;
        this._isUndoable = true;
        if (this._madeCompoundChange) {
            this._index++;
        }
    };
    /**
     * Undo an operation.
     */
    ObservableUndoableVector.prototype.undo = function () {
        if (!this.canUndo) {
            return;
        }
        var changes = this._stack[this._index];
        this._isUndoable = false;
        for (var _i = 0, _a = changes.reverse(); _i < _a.length; _i++) {
            var change = _a[_i];
            this._undoChange(change);
        }
        this._isUndoable = true;
        this._index--;
    };
    /**
     * Redo an operation.
     */
    ObservableUndoableVector.prototype.redo = function () {
        if (!this.canRedo) {
            return;
        }
        this._index++;
        var changes = this._stack[this._index];
        this._isUndoable = false;
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            this._redoChange(change);
        }
        this._isUndoable = true;
    };
    /**
     * Clear the change stack.
     */
    ObservableUndoableVector.prototype.clearUndo = function () {
        this._index = -1;
        this._stack = [];
    };
    /**
     * Handle a change in the vector.
     */
    ObservableUndoableVector.prototype._onVectorChanged = function (list, change) {
        if (this.isDisposed || !this._isUndoable) {
            return;
        }
        // Clear everything after this position if necessary.
        if (!this._inCompound || !this._madeCompoundChange) {
            this._stack = this._stack.slice(0, this._index + 1);
        }
        // Copy the change.
        var evt = this._copyChange(change);
        // Put the change in the stack.
        if (this._stack[this._index + 1]) {
            this._stack[this._index + 1].push(evt);
        }
        else {
            this._stack.push([evt]);
        }
        // If not in a compound operation, increase index.
        if (!this._inCompound) {
            this._index++;
        }
        else {
            this._madeCompoundChange = true;
        }
    };
    /**
     * Undo a change event.
     */
    ObservableUndoableVector.prototype._undoChange = function (change) {
        var _this = this;
        var index = 0;
        var serializer = this._serializer;
        switch (change.type) {
            case 'add':
                algorithm_1.each(change.newValues, function () {
                    _this.removeAt(change.newIndex);
                });
                break;
            case 'set':
                index = change.oldIndex;
                algorithm_1.each(change.oldValues, function (value) {
                    _this.set(index++, serializer.fromJSON(value));
                });
                break;
            case 'remove':
                index = change.oldIndex;
                algorithm_1.each(change.oldValues, function (value) {
                    _this.insert(index++, serializer.fromJSON(value));
                });
                break;
            case 'move':
                this.move(change.newIndex, change.oldIndex);
                break;
            default:
                return;
        }
    };
    /**
     * Redo a change event.
     */
    ObservableUndoableVector.prototype._redoChange = function (change) {
        var _this = this;
        var index = 0;
        var serializer = this._serializer;
        switch (change.type) {
            case 'add':
                index = change.newIndex;
                algorithm_1.each(change.newValues, function (value) {
                    _this.insert(index++, serializer.fromJSON(value));
                });
                break;
            case 'set':
                index = change.newIndex;
                algorithm_1.each(change.newValues, function (value) {
                    _this.set(change.newIndex++, serializer.fromJSON(value));
                });
                break;
            case 'remove':
                algorithm_1.each(change.oldValues, function () {
                    _this.removeAt(change.oldIndex);
                });
                break;
            case 'move':
                this.move(change.oldIndex, change.newIndex);
                break;
            default:
                return;
        }
    };
    /**
     * Copy a change as JSON.
     */
    ObservableUndoableVector.prototype._copyChange = function (change) {
        var _this = this;
        var oldValues = [];
        algorithm_1.each(change.oldValues, function (value) {
            oldValues.push(_this._serializer.toJSON(value));
        });
        var newValues = [];
        algorithm_1.each(change.newValues, function (value) {
            newValues.push(_this._serializer.toJSON(value));
        });
        return {
            type: change.type,
            oldIndex: change.oldIndex,
            newIndex: change.newIndex,
            oldValues: oldValues,
            newValues: newValues
        };
    };
    return ObservableUndoableVector;
}(observablevector_1.ObservableVector));
exports.ObservableUndoableVector = ObservableUndoableVector;
/**
 * Namespace for ObservableUndoableVector utilities.
 */
(function (ObservableUndoableVector) {
    /**
     * A default, identity serializer.
     */
    var IdentitySerializer = (function () {
        function IdentitySerializer() {
        }
        /**
         * Identity serialize.
         */
        IdentitySerializer.prototype.toJSON = function (value) {
            return value;
        };
        /**
         * Identity deserialize.
         */
        IdentitySerializer.prototype.fromJSON = function (value) {
            return value;
        };
        return IdentitySerializer;
    }());
    ObservableUndoableVector.IdentitySerializer = IdentitySerializer;
})(ObservableUndoableVector = exports.ObservableUndoableVector || (exports.ObservableUndoableVector = {}));
exports.ObservableUndoableVector = ObservableUndoableVector;
