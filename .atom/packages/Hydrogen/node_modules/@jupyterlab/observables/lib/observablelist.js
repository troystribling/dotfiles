"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
/**
 * A concrete implementation of [[IObservableList]].
 */
var ObservableList = /** @class */ (function () {
    /**
     * Construct a new observable map.
     */
    function ObservableList(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this._array = [];
        this._isDisposed = false;
        this._changed = new signaling_1.Signal(this);
        if (options.values !== void 0) {
            algorithm_1.each(options.values, function (value) { _this._array.push(value); });
        }
        this._itemCmp = options.itemCmp || Private.itemCmp;
    }
    Object.defineProperty(ObservableList.prototype, "type", {
        /**
         * The type of this object.
         */
        get: function () {
            return 'List';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableList.prototype, "changed", {
        /**
         * A signal emitted when the list has changed.
         */
        get: function () {
            return this._changed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableList.prototype, "length", {
        /**
         * The length of the list.
         */
        get: function () {
            return this._array.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableList.prototype, "isDisposed", {
        /**
         * Test whether the list has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the list.
     */
    ObservableList.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.clear();
    };
    /**
     * Create an iterator over the values in the list.
     *
     * @returns A new iterator starting at the front of the list.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableList.prototype.iter = function () {
        return new algorithm_1.ArrayIterator(this._array);
    };
    /**
     * Get the value at the specified index.
     *
     * @param index - The positive integer index of interest.
     *
     * @returns The value at the specified index.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral or out of range.
     */
    ObservableList.prototype.get = function (index) {
        return this._array[index];
    };
    /**
     * Set the value at the specified index.
     *
     * @param index - The positive integer index of interest.
     *
     * @param value - The value to set at the specified index.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral or out of range.
     */
    ObservableList.prototype.set = function (index, value) {
        var oldValue = this._array[index];
        if (value === undefined) {
            throw new Error('Cannot set an undefined item');
        }
        // Bail if the value does not change.
        var itemCmp = this._itemCmp;
        if (itemCmp(oldValue, value)) {
            return;
        }
        this._array[index] = value;
        this._changed.emit({
            type: 'set',
            oldIndex: index,
            newIndex: index,
            oldValues: [oldValue],
            newValues: [value]
        });
    };
    /**
     * Add a value to the end of the list.
     *
     * @param value - The value to add to the end of the list.
     *
     * @returns The new length of the list.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableList.prototype.push = function (value) {
        var num = this._array.push(value);
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: this.length - 1,
            oldValues: [],
            newValues: [value]
        });
        return num;
    };
    /**
     * Insert a value into the list at a specific index.
     *
     * @param index - The index at which to insert the value.
     *
     * @param value - The value to set at the specified index.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the list.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    ObservableList.prototype.insert = function (index, value) {
        algorithm_1.ArrayExt.insert(this._array, index, value);
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: index,
            oldValues: [],
            newValues: [value]
        });
    };
    /**
     * Remove the first occurrence of a value from the list.
     *
     * @param value - The value of interest.
     *
     * @returns The index of the removed value, or `-1` if the value
     *   is not contained in the list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value and beyond are invalidated.
     */
    ObservableList.prototype.removeValue = function (value) {
        var itemCmp = this._itemCmp;
        var index = algorithm_1.ArrayExt.findFirstIndex(this._array, function (item) {
            return itemCmp(item, value);
        });
        this.remove(index);
        return index;
    };
    /**
     * Remove and return the value at a specific index.
     *
     * @param index - The index of the value of interest.
     *
     * @returns The value at the specified index, or `undefined` if the
     *   index is out of range.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the removed value and beyond are invalidated.
     *
     * #### Undefined Behavior
     * An `index` which is non-integral.
     */
    ObservableList.prototype.remove = function (index) {
        var value = algorithm_1.ArrayExt.removeAt(this._array, index);
        if (value === undefined) {
            return;
        }
        this._changed.emit({
            type: 'remove',
            oldIndex: index,
            newIndex: -1,
            newValues: [],
            oldValues: [value]
        });
        return value;
    };
    /**
     * Remove all values from the list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * All current iterators are invalidated.
     */
    ObservableList.prototype.clear = function () {
        var copy = this._array.slice();
        this._array.length = 0;
        this._changed.emit({
            type: 'remove',
            oldIndex: 0,
            newIndex: 0,
            newValues: [],
            oldValues: copy
        });
    };
    /**
     * Move a value from one index to another.
     *
     * @parm fromIndex - The index of the element to move.
     *
     * @param toIndex - The index to move the element to.
     *
     * #### Complexity
     * Constant.
     *
     * #### Iterator Validity
     * Iterators pointing at the lesser of the `fromIndex` and the `toIndex`
     * and beyond are invalidated.
     *
     * #### Undefined Behavior
     * A `fromIndex` or a `toIndex` which is non-integral.
     */
    ObservableList.prototype.move = function (fromIndex, toIndex) {
        if (this.length <= 1 || fromIndex === toIndex) {
            return;
        }
        var values = [this._array[fromIndex]];
        algorithm_1.ArrayExt.move(this._array, fromIndex, toIndex);
        this._changed.emit({
            type: 'move',
            oldIndex: fromIndex,
            newIndex: toIndex,
            oldValues: values,
            newValues: values
        });
    };
    /**
     * Push a set of values to the back of the list.
     *
     * @param values - An iterable or array-like set of values to add.
     *
     * @returns The new length of the list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     */
    ObservableList.prototype.pushAll = function (values) {
        var _this = this;
        var newIndex = this.length;
        algorithm_1.each(values, function (value) {
            _this._array.push(value);
        });
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: newIndex,
            oldValues: [],
            newValues: algorithm_1.toArray(values)
        });
        return this.length;
    };
    /**
     * Insert a set of items into the list at the specified index.
     *
     * @param index - The index at which to insert the values.
     *
     * @param values - The values to insert at the specified index.
     *
     * #### Complexity.
     * Linear.
     *
     * #### Iterator Validity
     * No changes.
     *
     * #### Notes
     * The `index` will be clamped to the bounds of the list.
     *
     * #### Undefined Behavior.
     * An `index` which is non-integral.
     */
    ObservableList.prototype.insertAll = function (index, values) {
        var _this = this;
        var newIndex = index;
        algorithm_1.each(values, function (value) {
            algorithm_1.ArrayExt.insert(_this._array, index++, value);
        });
        this._changed.emit({
            type: 'add',
            oldIndex: -1,
            newIndex: newIndex,
            oldValues: [],
            newValues: algorithm_1.toArray(values)
        });
    };
    /**
     * Remove a range of items from the list.
     *
     * @param startIndex - The start index of the range to remove (inclusive).
     *
     * @param endIndex - The end index of the range to remove (exclusive).
     *
     * @returns The new length of the list.
     *
     * #### Complexity
     * Linear.
     *
     * #### Iterator Validity
     * Iterators pointing to the first removed value and beyond are invalid.
     *
     * #### Undefined Behavior
     * A `startIndex` or `endIndex` which is non-integral.
     */
    ObservableList.prototype.removeRange = function (startIndex, endIndex) {
        var oldValues = this._array.slice(startIndex, endIndex);
        for (var i = startIndex; i < endIndex; i++) {
            algorithm_1.ArrayExt.removeAt(this._array, startIndex);
        }
        this._changed.emit({
            type: 'remove',
            oldIndex: startIndex,
            newIndex: -1,
            oldValues: oldValues,
            newValues: []
        });
        return this.length;
    };
    return ObservableList;
}());
exports.ObservableList = ObservableList;
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * The default strict equality item cmp.
     */
    function itemCmp(first, second) {
        return first === second;
    }
    Private.itemCmp = itemCmp;
})(Private || (Private = {}));
