{"version":3,"file":"observablemap.js","sourceRoot":"","sources":["../../../../observables/src/observablemap.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  IDisposable\n} from '@phosphor/disposable';\n\nimport {\n  ISignal, Signal\n} from '@phosphor/signaling';\n\nimport {\n  IObservable\n} from './modeldb';\n\n\n/**\n * A map which can be observed for changes.\n */\nexport\ninterface IObservableMap<T> extends IDisposable, IObservable {\n  /**\n   * The type of the Observable.\n   */\n  type: 'Map';\n\n  /**\n   * A signal emitted when the map has changed.\n   */\n  readonly changed: ISignal<this, IObservableMap.IChangedArgs<T>>;\n\n  /**\n   * The number of key-value pairs in the map.\n   */\n  readonly size: number;\n\n  /**\n   * Set a key-value pair in the map\n   *\n   * @param key - The key to set.\n   *\n   * @param value - The value for the key.\n   *\n   * @returns the old value for the key, or undefined\n   *   if that did not exist.\n   */\n  set(key: string, value: T): T | undefined;\n\n  /**\n   * Get a value for a given key.\n   *\n   * @param key - the key.\n   *\n   * @returns the value for that key.\n   */\n  get(key: string): T | undefined;\n\n  /**\n   * Check whether the map has a key.\n   *\n   * @param key - the key to check.\n   *\n   * @returns `true` if the map has the key, `false` otherwise.\n   */\n  has(key: string): boolean;\n\n  /**\n   * Get a list of the keys in the map.\n   *\n   * @returns - a list of keys.\n   */\n  keys(): string[];\n\n  /**\n   * Get a list of the values in the map.\n   *\n   * @returns - a list of values.\n   */\n  values(): T[];\n\n  /**\n   * Remove a key from the map\n   *\n   * @param key - the key to remove.\n   *\n   * @returns the value of the given key,\n   *   or undefined if that does not exist.\n   */\n  delete(key: string): T | undefined;\n\n  /**\n   * Set the ObservableMap to an empty map.\n   */\n  clear(): void;\n\n  /**\n   * Dispose of the resources held by the map.\n   */\n  dispose(): void;\n}\n\n\n/**\n * The interfaces associated with an IObservableMap.\n */\nexport\nnamespace IObservableMap {\n  /**\n   * The change types which occur on an observable map.\n   */\n  export\n  type ChangeType =\n    /**\n     * An entry was added.\n     */\n    'add' |\n\n    /**\n     * An entry was removed.\n     */\n    'remove' |\n\n    /**\n     * An entry was changed.\n     */\n    'change';\n\n  /**\n   * The changed args object which is emitted by an observable map.\n   */\n  export\n  interface IChangedArgs<T> {\n    /**\n     * The type of change undergone by the map.\n     */\n    type: ChangeType;\n\n    /**\n     * The key of the change.\n     */\n    key: string;\n\n    /**\n     * The old value of the change.\n     */\n    oldValue: T | undefined;\n\n    /**\n     * The new value of the change.\n     */\n    newValue: T | undefined;\n  }\n}\n\n\n/**\n * A concrete implementation of IObservbleMap<T>.\n */\nexport\nclass ObservableMap<T> implements IObservableMap<T> {\n  /**\n   * Construct a new observable map.\n   */\n  constructor(options: ObservableMap.IOptions<T> = {}) {\n    this._itemCmp = options.itemCmp || Private.itemCmp;\n    if (options.values) {\n      for (let key in options.values) {\n        this._map.set(key, options.values[key]);\n      }\n    }\n  }\n\n  /**\n   * The type of the Observable.\n   */\n  get type(): 'Map' {\n    return 'Map';\n  }\n\n\n  /**\n   * A signal emitted when the map has changed.\n   */\n  get changed(): ISignal<this, IObservableMap.IChangedArgs<T>> {\n    return this._changed;\n  }\n\n  /**\n   * Whether this map has been disposed.\n   */\n  get isDisposed(): boolean {\n    return this._isDisposed;\n  }\n\n  /**\n   * The number of key-value pairs in the map.\n   */\n  get size(): number {\n    return this._map.size;\n  }\n\n  /**\n   * Set a key-value pair in the map\n   *\n   * @param key - The key to set.\n   *\n   * @param value - The value for the key.\n   *\n   * @returns the old value for the key, or undefined\n   *   if that did not exist.\n   *\n   * @throws if the new value is undefined.\n   *\n   * #### Notes\n   * This is a no-op if the value does not change.\n   */\n  set(key: string, value: T): T | undefined {\n    let oldVal = this._map.get(key);\n    if (value === undefined) {\n      throw Error('Cannot set an undefined value, use remove');\n    }\n    // Bail if the value does not change.\n    let itemCmp = this._itemCmp;\n    if (oldVal !== undefined && itemCmp(oldVal, value)) {\n      return oldVal;\n    }\n    this._map.set(key, value);\n    this._changed.emit({\n      type: oldVal ? 'change' : 'add',\n      key: key,\n      oldValue: oldVal,\n      newValue: value\n    });\n    return oldVal;\n  }\n\n  /**\n   * Get a value for a given key.\n   *\n   * @param key - the key.\n   *\n   * @returns the value for that key.\n   */\n  get(key: string): T | undefined {\n    return this._map.get(key);\n  }\n\n  /**\n   * Check whether the map has a key.\n   *\n   * @param key - the key to check.\n   *\n   * @returns `true` if the map has the key, `false` otherwise.\n   */\n  has(key: string): boolean {\n    return this._map.has(key);\n  }\n\n  /**\n   * Get a list of the keys in the map.\n   *\n   * @returns - a list of keys.\n   */\n  keys(): string[] {\n    let keyList: string[] = [];\n    this._map.forEach((v: T, k: string) => {\n      keyList.push(k);\n    });\n    return keyList;\n  }\n\n\n  /**\n   * Get a list of the values in the map.\n   *\n   * @returns - a list of values.\n   */\n  values(): T[] {\n    let valList: T[] = [];\n    this._map.forEach((v: T, k: string) => {\n      valList.push(v);\n    });\n    return valList;\n  }\n\n  /**\n   * Remove a key from the map\n   *\n   * @param key - the key to remove.\n   *\n   * @returns the value of the given key,\n   *   or undefined if that does not exist.\n   */\n  delete(key: string): T | undefined {\n    let oldVal = this._map.get(key);\n    this._map.delete(key);\n    this._changed.emit({\n      type: 'remove',\n      key: key,\n      oldValue: oldVal,\n      newValue: undefined\n    });\n    return oldVal;\n  }\n\n  /**\n   * Set the ObservableMap to an empty map.\n   */\n  clear(): void {\n    // Delete one by one to emit the correct signals.\n    let keyList = this.keys();\n    for (let i = 0; i < keyList.length; i++) {\n      this.delete(keyList[i]);\n    }\n  }\n\n  /**\n   * Dispose of the resources held by the map.\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    this._isDisposed = true;\n    Signal.clearData(this);\n    this._map.clear();\n  }\n\n  private _map: Map<string, T> = new Map<string, T>();\n  private _itemCmp: (first: T, second: T) => boolean;\n  private _changed = new Signal<this, IObservableMap.IChangedArgs<T>>(this);\n  private _isDisposed = false;\n}\n\n\n/**\n * The namespace for `ObservableMap` class statics.\n */\nexport\nnamespace ObservableMap {\n  /**\n   * The options used to initialize an observable map.\n   */\n  export\n  interface IOptions<T> {\n    /**\n     * An optional intial set of values.\n     */\n    values?: { [key: string]: T };\n\n    /**\n     * The item comparison function for change detection on `set`.\n     *\n     * If not given, strict `===` equality will be used.\n     */\n    itemCmp?: (first: T, second: T) => boolean;\n  }\n}\n\n\n/**\n * The namespace for module private data.\n */\nnamespace Private {\n  /**\n   * The default strict equality item comparator.\n   */\n  export\n  function itemCmp(first: any, second: any): boolean {\n    return first === second;\n  }\n}\n"]}