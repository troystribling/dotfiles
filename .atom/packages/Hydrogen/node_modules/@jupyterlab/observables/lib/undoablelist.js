"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var observablelist_1 = require("./observablelist");
/**
 * A concrete implementation of an observable undoable list.
 */
var ObservableUndoableList = /** @class */ (function (_super) {
    __extends(ObservableUndoableList, _super);
    /**
     * Construct a new undoable observable list.
     */
    function ObservableUndoableList(serializer) {
        var _this = _super.call(this) || this;
        _this._inCompound = false;
        _this._isUndoable = true;
        _this._madeCompoundChange = false;
        _this._index = -1;
        _this._stack = [];
        _this._serializer = serializer;
        _this.changed.connect(_this._onListChanged, _this);
        return _this;
    }
    Object.defineProperty(ObservableUndoableList.prototype, "canRedo", {
        /**
         * Whether the object can redo changes.
         */
        get: function () {
            return this._index < this._stack.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObservableUndoableList.prototype, "canUndo", {
        /**
         * Whether the object can undo changes.
         */
        get: function () {
            return this._index >= 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Begin a compound operation.
     *
     * @param isUndoAble - Whether the operation is undoable.
     *   The default is `true`.
     */
    ObservableUndoableList.prototype.beginCompoundOperation = function (isUndoAble) {
        this._inCompound = true;
        this._isUndoable = (isUndoAble !== false);
        this._madeCompoundChange = false;
    };
    /**
     * End a compound operation.
     */
    ObservableUndoableList.prototype.endCompoundOperation = function () {
        this._inCompound = false;
        this._isUndoable = true;
        if (this._madeCompoundChange) {
            this._index++;
        }
    };
    /**
     * Undo an operation.
     */
    ObservableUndoableList.prototype.undo = function () {
        if (!this.canUndo) {
            return;
        }
        var changes = this._stack[this._index];
        this._isUndoable = false;
        for (var _i = 0, _a = changes.reverse(); _i < _a.length; _i++) {
            var change = _a[_i];
            this._undoChange(change);
        }
        this._isUndoable = true;
        this._index--;
    };
    /**
     * Redo an operation.
     */
    ObservableUndoableList.prototype.redo = function () {
        if (!this.canRedo) {
            return;
        }
        this._index++;
        var changes = this._stack[this._index];
        this._isUndoable = false;
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            this._redoChange(change);
        }
        this._isUndoable = true;
    };
    /**
     * Clear the change stack.
     */
    ObservableUndoableList.prototype.clearUndo = function () {
        this._index = -1;
        this._stack = [];
    };
    /**
     * Handle a change in the list.
     */
    ObservableUndoableList.prototype._onListChanged = function (list, change) {
        if (this.isDisposed || !this._isUndoable) {
            return;
        }
        // Clear everything after this position if necessary.
        if (!this._inCompound || !this._madeCompoundChange) {
            this._stack = this._stack.slice(0, this._index + 1);
        }
        // Copy the change.
        var evt = this._copyChange(change);
        // Put the change in the stack.
        if (this._stack[this._index + 1]) {
            this._stack[this._index + 1].push(evt);
        }
        else {
            this._stack.push([evt]);
        }
        // If not in a compound operation, increase index.
        if (!this._inCompound) {
            this._index++;
        }
        else {
            this._madeCompoundChange = true;
        }
    };
    /**
     * Undo a change event.
     */
    ObservableUndoableList.prototype._undoChange = function (change) {
        var _this = this;
        var index = 0;
        var serializer = this._serializer;
        switch (change.type) {
            case 'add':
                algorithm_1.each(change.newValues, function () {
                    _this.remove(change.newIndex);
                });
                break;
            case 'set':
                index = change.oldIndex;
                algorithm_1.each(change.oldValues, function (value) {
                    _this.set(index++, serializer.fromJSON(value));
                });
                break;
            case 'remove':
                index = change.oldIndex;
                algorithm_1.each(change.oldValues, function (value) {
                    _this.insert(index++, serializer.fromJSON(value));
                });
                break;
            case 'move':
                this.move(change.newIndex, change.oldIndex);
                break;
            default:
                return;
        }
    };
    /**
     * Redo a change event.
     */
    ObservableUndoableList.prototype._redoChange = function (change) {
        var _this = this;
        var index = 0;
        var serializer = this._serializer;
        switch (change.type) {
            case 'add':
                index = change.newIndex;
                algorithm_1.each(change.newValues, function (value) {
                    _this.insert(index++, serializer.fromJSON(value));
                });
                break;
            case 'set':
                index = change.newIndex;
                algorithm_1.each(change.newValues, function (value) {
                    _this.set(change.newIndex++, serializer.fromJSON(value));
                });
                break;
            case 'remove':
                algorithm_1.each(change.oldValues, function () {
                    _this.remove(change.oldIndex);
                });
                break;
            case 'move':
                this.move(change.oldIndex, change.newIndex);
                break;
            default:
                return;
        }
    };
    /**
     * Copy a change as JSON.
     */
    ObservableUndoableList.prototype._copyChange = function (change) {
        var _this = this;
        var oldValues = [];
        algorithm_1.each(change.oldValues, function (value) {
            oldValues.push(_this._serializer.toJSON(value));
        });
        var newValues = [];
        algorithm_1.each(change.newValues, function (value) {
            newValues.push(_this._serializer.toJSON(value));
        });
        return {
            type: change.type,
            oldIndex: change.oldIndex,
            newIndex: change.newIndex,
            oldValues: oldValues,
            newValues: newValues
        };
    };
    return ObservableUndoableList;
}(observablelist_1.ObservableList));
exports.ObservableUndoableList = ObservableUndoableList;
/**
 * Namespace for ObservableUndoableList utilities.
 */
(function (ObservableUndoableList) {
    /**
     * A default, identity serializer.
     */
    var IdentitySerializer = /** @class */ (function () {
        function IdentitySerializer() {
        }
        /**
         * Identity serialize.
         */
        IdentitySerializer.prototype.toJSON = function (value) {
            return value;
        };
        /**
         * Identity deserialize.
         */
        IdentitySerializer.prototype.fromJSON = function (value) {
            return value;
        };
        return IdentitySerializer;
    }());
    ObservableUndoableList.IdentitySerializer = IdentitySerializer;
})(ObservableUndoableList = exports.ObservableUndoableList || (exports.ObservableUndoableList = {}));
exports.ObservableUndoableList = ObservableUndoableList;
