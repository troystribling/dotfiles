"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var __1 = require("..");
var validate = require("./validate");
/**
 * The url for the default drive service.
 */
var SERVICE_DRIVE_URL = 'api/contents';
/**
 * The url for the file access.
 */
var FILES_URL = 'files';
/**
 * A namespace for contents interfaces.
 */
var Contents;
(function (Contents) {
    /**
     * Validates an IModel, thowing an error if it does not pass.
     */
    function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
    }
    Contents.validateContentsModel = validateContentsModel;
    /**
     * Validates an ICheckpointModel, thowing an error if it does not pass.
     */
    function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
    }
    Contents.validateCheckpointModel = validateCheckpointModel;
})(Contents = exports.Contents || (exports.Contents = {}));
/**
 * A contents manager that passes file operations to the server.
 * Multiple servers implementing the `IDrive` interface can be
 * attached to the contents manager, so that the same session can
 * perform file operations on multiple backends.
 *
 * This includes checkpointing with the normal file operations.
 */
var ContentsManager = /** @class */ (function () {
    /**
     * Construct a new contents manager object.
     *
     * @param options - The options used to initialize the object.
     */
    function ContentsManager(options) {
        if (options === void 0) { options = {}; }
        this._isDisposed = false;
        this._additionalDrives = new Map();
        this._fileChanged = new signaling_1.Signal(this);
        this._defaultDrive = options.defaultDrive || new Drive();
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
    }
    Object.defineProperty(ContentsManager.prototype, "fileChanged", {
        /**
         * A signal emitted when a file operation takes place.
         */
        get: function () {
            return this._fileChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContentsManager.prototype, "isDisposed", {
        /**
         * Test whether the manager has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the manager.
     */
    ContentsManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
    };
    /**
     * Add an `IDrive` to the manager.
     */
    ContentsManager.prototype.addDrive = function (drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
    };
    /**
     * Given a path, get a ModelDB.IFactory from the
     * relevant backend. Returns `null` if the backend
     * does not provide one.
     */
    ContentsManager.prototype.getModelDBFactory = function (path) {
        var drive = this._driveForPath(path)[0];
        return drive && drive.modelDBFactory || null;
    };
    /**
     * Get a file or directory.
     *
     * @param path: The path to the file.
     *
     * @param options: The options used to fetch the file.
     *
     * @returns A promise which resolves with the file content.
     */
    ContentsManager.prototype.get = function (path, options) {
        var _this = this;
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        if (!drive) {
            return Promise.reject("No valid drive for path: " + path);
        }
        return drive.get(localPath, options).then(function (contentsModel) {
            var listing = [];
            if (contentsModel.type === 'directory' && contentsModel.content) {
                algorithm_1.each(contentsModel.content, function (item) {
                    listing.push(__assign({}, item, { path: _this._toGlobalPath(drive, item.path) }));
                });
                return __assign({}, contentsModel, { path: _this._toGlobalPath(drive, localPath), content: listing });
            }
            else {
                return __assign({}, contentsModel, { path: _this._toGlobalPath(drive, localPath) });
            }
        });
    };
    /**
     * Get an encoded download url given a file path.
     *
     * @param path - An absolute POSIX file path on the server.
     *
     * #### Notes
     * It is expected that the path contains no relative paths.
     */
    ContentsManager.prototype.getDownloadUrl = function (path) {
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.getDownloadUrl(localPath);
    };
    /**
     * Create a new untitled file or directory in the specified directory path.
     *
     * @param options: The options used to create the file.
     *
     * @returns A promise which resolves with the created file content when the
     *    file is created.
     */
    ContentsManager.prototype.newUntitled = function (options) {
        if (options === void 0) { options = {}; }
        if (options.path) {
            var globalPath_1 = Private.normalize(options.path);
            var _a = this._driveForPath(globalPath_1), drive = _a[0], localPath = _a[1];
            if (!drive) {
                return Promise.reject("No valid drive for path: " + globalPath_1);
            }
            return drive.newUntitled(__assign({}, options, { path: localPath })).then(function (contentsModel) {
                return __assign({}, contentsModel, { path: coreutils_1.PathExt.join(globalPath_1, contentsModel.name) });
            });
        }
        else {
            return this._defaultDrive.newUntitled(options);
        }
    };
    /**
     * Delete a file.
     *
     * @param path - The path to the file.
     *
     * @returns A promise which resolves when the file is deleted.
     */
    ContentsManager.prototype.delete = function (path) {
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.delete(localPath);
    };
    /**
     * Rename a file or directory.
     *
     * @param path - The original file path.
     *
     * @param newPath - The new file path.
     *
     * @returns A promise which resolves with the new file contents model when
     *   the file is renamed.
     */
    ContentsManager.prototype.rename = function (path, newPath) {
        var _this = this;
        var _a = this._driveForPath(path), drive1 = _a[0], path1 = _a[1];
        var _b = this._driveForPath(newPath), drive2 = _b[0], path2 = _b[1];
        if (drive1 !== drive2) {
            throw Error('ContentsManager: renaming files must occur within a Drive');
        }
        return drive1.rename(path1, path2).then(function (contentsModel) {
            return __assign({}, contentsModel, { path: _this._toGlobalPath(drive1, path2) });
        });
    };
    /**
     * Save a file.
     *
     * @param path - The desired file path.
     *
     * @param options - Optional overrides to the model.
     *
     * @returns A promise which resolves with the file content model when the
     *   file is saved.
     *
     * #### Notes
     * Ensure that `model.content` is populated for the file.
     */
    ContentsManager.prototype.save = function (path, options) {
        if (options === void 0) { options = {}; }
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.save(localPath, __assign({}, options, { path: localPath })).then(function (contentsModel) {
            return __assign({}, contentsModel, { path: Private.normalize(path) });
        });
    };
    /**
     * Copy a file into a given directory.
     *
     * @param path - The original file path.
     *
     * @param toDir - The destination directory path.
     *
     * @returns A promise which resolves with the new contents model when the
     *  file is copied.
     *
     * #### Notes
     * The server will select the name of the copied file.
     */
    ContentsManager.prototype.copy = function (fromFile, toDir) {
        var _this = this;
        var _a = this._driveForPath(fromFile), drive1 = _a[0], path1 = _a[1];
        var _b = this._driveForPath(toDir), drive2 = _b[0], path2 = _b[1];
        if (drive1 === drive2) {
            return drive1.copy(path1, path2).then(function (contentsModel) {
                return __assign({}, contentsModel, { path: _this._toGlobalPath(drive1, contentsModel.path) });
            });
        }
        else {
            throw Error('Copying files between drives is not currently implemented');
        }
    };
    /**
     * Create a checkpoint for a file.
     *
     * @param path - The path of the file.
     *
     * @returns A promise which resolves with the new checkpoint model when the
     *   checkpoint is created.
     */
    ContentsManager.prototype.createCheckpoint = function (path) {
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.createCheckpoint(localPath);
    };
    /**
     * List available checkpoints for a file.
     *
     * @param path - The path of the file.
     *
     * @returns A promise which resolves with a list of checkpoint models for
     *    the file.
     */
    ContentsManager.prototype.listCheckpoints = function (path) {
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.listCheckpoints(localPath);
    };
    /**
     * Restore a file to a known checkpoint state.
     *
     * @param path - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to restore.
     *
     * @returns A promise which resolves when the checkpoint is restored.
     */
    ContentsManager.prototype.restoreCheckpoint = function (path, checkpointID) {
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.restoreCheckpoint(localPath, checkpointID);
    };
    /**
     * Delete a checkpoint for a file.
     *
     * @param path - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to delete.
     *
     * @returns A promise which resolves when the checkpoint is deleted.
     */
    ContentsManager.prototype.deleteCheckpoint = function (path, checkpointID) {
        var _a = this._driveForPath(path), drive = _a[0], localPath = _a[1];
        return drive.deleteCheckpoint(localPath, checkpointID);
    };
    /**
     * Given a drive and a local path, construct a fully qualified
     * path. The inverse of `_driveForPath`.
     *
     * @param drive: an `IDrive`.
     *
     * @param localPath: the local path on the drive.
     *
     * @returns the fully qualified path.
     */
    ContentsManager.prototype._toGlobalPath = function (drive, localPath) {
        if (drive === this._defaultDrive) {
            return coreutils_1.PathExt.removeSlash(localPath);
        }
        else {
            return drive.name + ':' + coreutils_1.PathExt.removeSlash(localPath);
        }
    };
    /**
     * Given a path, get the `IDrive to which it refers,
     * where the path satisfies the pattern
     * `'driveName:path/to/file'`. If there is no `driveName`
     * prepended to the path, it returns the default drive.
     *
     * @param path: a path to a file.
     *
     * @returns A tuple containing an `IDrive` object for the path,
     * and a local path for that drive.
     */
    ContentsManager.prototype._driveForPath = function (path) {
        // Split the path at ':'
        var parts = path.split(':');
        if (parts.length === 1) {
            return [this._defaultDrive, path];
        }
        else {
            var drive = this._additionalDrives.get(parts[0]);
            if (!drive) {
                throw Error('ContentsManager: cannot find requested drive');
            }
            return [drive, Private.normalize(parts[1])];
        }
    };
    /**
     * Respond to fileChanged signals from the drives attached to
     * the manager. This prepends the drive name to the path if necessary,
     * and then forwards the signal.
     */
    ContentsManager.prototype._onFileChanged = function (sender, args) {
        if (sender === this._defaultDrive) {
            this._fileChanged.emit(args);
        }
        else {
            var newValue = null;
            var oldValue = null;
            if (args.newValue && args.newValue.path) {
                newValue = __assign({}, args.newValue, { path: this._toGlobalPath(sender, args.newValue.path) });
            }
            if (args.oldValue && args.oldValue.path) {
                oldValue = __assign({}, args.oldValue, { path: this._toGlobalPath(sender, args.oldValue.path) });
            }
            this._fileChanged.emit({
                type: args.type,
                newValue: newValue,
                oldValue: oldValue
            });
        }
    };
    return ContentsManager;
}());
exports.ContentsManager = ContentsManager;
/**
 * A default implementation for an `IDrive`, talking to the
 * server using the Jupyter REST API.
 */
var Drive = /** @class */ (function () {
    /**
     * Construct a new contents manager object.
     *
     * @param options - The options used to initialize the object.
     */
    function Drive(options) {
        if (options === void 0) { options = {}; }
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = options.name || 'Default';
        this._apiEndpoint = options.apiEndpoint || SERVICE_DRIVE_URL;
        this.serverSettings = options.serverSettings || __1.ServerConnection.makeSettings();
    }
    Object.defineProperty(Drive.prototype, "fileChanged", {
        /**
         * A signal emitted when a file operation takes place.
         */
        get: function () {
            return this._fileChanged;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Drive.prototype, "isDisposed", {
        /**
         * Test whether the manager has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the manager.
     */
    Drive.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
    };
    /**
     * Get a file or directory.
     *
     * @param localPath: The path to the file.
     *
     * @param options: The options used to fetch the file.
     *
     * @returns A promise which resolves with the file content.
     *
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.get = function (localPath, options) {
        var url = this._getUrl(localPath);
        if (options) {
            // The notebook type cannot take an format option.
            if (options.type === 'notebook') {
                delete options['format'];
            }
            var content = options.content ? '1' : '0';
            var params = __assign({}, options, { content: content });
            url += coreutils_1.URLExt.objectToQueryString(params);
        }
        var request = {
            url: url,
            method: 'GET',
            cache: false
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            try {
                validate.validateContentsModel(response.data);
            }
            catch (error) {
                throw __1.ServerConnection.makeError(response, error.message);
            }
            return response.data;
        });
    };
    /**
     * Get an encoded download url given a file path.
     *
     * @param localPath - An absolute POSIX file path on the server.
     *
     * #### Notes
     * It is expected that the path contains no relative paths.
     */
    Drive.prototype.getDownloadUrl = function (localPath) {
        var baseUrl = this.serverSettings.baseUrl;
        return Promise.resolve(coreutils_1.URLExt.join(baseUrl, FILES_URL, coreutils_1.URLExt.encodeParts(localPath)));
    };
    /**
     * Create a new untitled file or directory in the specified directory path.
     *
     * @param options: The options used to create the file.
     *
     * @returns A promise which resolves with the created file content when the
     *    file is created.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.newUntitled = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var data = '{}';
        if (options) {
            if (options.ext) {
                options.ext = Private.normalizeExtension(options.ext);
            }
            data = JSON.stringify(options);
        }
        var request = {
            url: this._getUrl(options.path || ''),
            method: 'POST',
            data: data,
            contentType: 'application/json'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 201) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            try {
                validate.validateContentsModel(data);
            }
            catch (error) {
                throw __1.ServerConnection.makeError(response, error.message);
            }
            _this._fileChanged.emit({
                type: 'new',
                oldValue: null,
                newValue: data
            });
            return data;
        });
    };
    /**
     * Delete a file.
     *
     * @param localPath - The path to the file.
     *
     * @returns A promise which resolves when the file is deleted.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).
     */
    Drive.prototype.delete = function (localPath) {
        var _this = this;
        var request = {
            url: this._getUrl(localPath),
            method: 'DELETE'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 204) {
                throw __1.ServerConnection.makeError(response);
            }
            _this._fileChanged.emit({
                type: 'delete',
                oldValue: { path: localPath },
                newValue: null
            });
        }, function (error) {
            // Translate certain errors to more specific ones.
            // TODO: update IPEP27 to specify errors more precisely, so
            // that error types can be detected here with certainty.
            if (error.xhr.status === 400) {
                var err = JSON.parse(error.xhr.response);
                if (err.message) {
                    error.message = err.message;
                }
            }
            return Promise.reject(error);
        });
    };
    /**
     * Rename a file or directory.
     *
     * @param oldLocalPath - The original file path.
     *
     * @param newLocalPath - The new file path.
     *
     * @returns A promise which resolves with the new file contents model when
     *   the file is renamed.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.rename = function (oldLocalPath, newLocalPath) {
        var _this = this;
        var request = {
            url: this._getUrl(oldLocalPath),
            method: 'PATCH',
            data: JSON.stringify({ path: newLocalPath })
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            try {
                validate.validateContentsModel(data);
            }
            catch (error) {
                throw __1.ServerConnection.makeError(response, error.message);
            }
            _this._fileChanged.emit({
                type: 'rename',
                oldValue: { path: oldLocalPath },
                newValue: data
            });
            return data;
        });
    };
    /**
     * Save a file.
     *
     * @param localPath - The desired file path.
     *
     * @param options - Optional overrides to the model.
     *
     * @returns A promise which resolves with the file content model when the
     *   file is saved.
     *
     * #### Notes
     * Ensure that `model.content` is populated for the file.
     *
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.save = function (localPath, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var request = {
            url: this._getUrl(localPath),
            method: 'PUT',
            cache: false,
            data: JSON.stringify(options),
            contentType: 'application/json'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            // will return 200 for an existing file and 201 for a new file
            if (response.xhr.status !== 200 && response.xhr.status !== 201) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            try {
                validate.validateContentsModel(data);
            }
            catch (error) {
                throw __1.ServerConnection.makeError(response, error.message);
            }
            _this._fileChanged.emit({
                type: 'save',
                oldValue: null,
                newValue: data
            });
            return data;
        });
    };
    /**
     * Copy a file into a given directory.
     *
     * @param localPath - The original file path.
     *
     * @param toDir - The destination directory path.
     *
     * @returns A promise which resolves with the new contents model when the
     *  file is copied.
     *
     * #### Notes
     * The server will select the name of the copied file.
     *
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.copy = function (fromFile, toDir) {
        var _this = this;
        var request = {
            url: this._getUrl(toDir),
            method: 'POST',
            data: JSON.stringify({ copy_from: fromFile }),
            contentType: 'application/json'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 201) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            try {
                validate.validateContentsModel(data);
            }
            catch (error) {
                throw __1.ServerConnection.makeError(response, error.message);
            }
            _this._fileChanged.emit({
                type: 'new',
                oldValue: null,
                newValue: data
            });
            return data;
        });
    };
    /**
     * Create a checkpoint for a file.
     *
     * @param localPath - The path of the file.
     *
     * @returns A promise which resolves with the new checkpoint model when the
     *   checkpoint is created.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.createCheckpoint = function (localPath) {
        var request = {
            url: this._getUrl(localPath, 'checkpoints'),
            method: 'POST'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 201) {
                throw __1.ServerConnection.makeError(response);
            }
            var data = response.data;
            try {
                validate.validateCheckpointModel(data);
            }
            catch (error) {
                throw __1.ServerConnection.makeError(response, error.message);
            }
            return data;
        });
    };
    /**
     * List available checkpoints for a file.
     *
     * @param localPath - The path of the file.
     *
     * @returns A promise which resolves with a list of checkpoint models for
     *    the file.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents) and validates the response model.
     */
    Drive.prototype.listCheckpoints = function (localPath) {
        var request = {
            url: this._getUrl(localPath, 'checkpoints'),
            method: 'GET',
            cache: false
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 200) {
                throw __1.ServerConnection.makeError(response);
            }
            if (!Array.isArray(response.data)) {
                throw __1.ServerConnection.makeError(response, 'Invalid Checkpoint list');
            }
            for (var i = 0; i < response.data.length; i++) {
                try {
                    validate.validateCheckpointModel(response.data[i]);
                }
                catch (error) {
                    throw __1.ServerConnection.makeError(response, error.message);
                }
            }
            return response.data;
        });
    };
    /**
     * Restore a file to a known checkpoint state.
     *
     * @param localPath - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to restore.
     *
     * @returns A promise which resolves when the checkpoint is restored.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).
     */
    Drive.prototype.restoreCheckpoint = function (localPath, checkpointID) {
        var request = {
            url: this._getUrl(localPath, 'checkpoints', checkpointID),
            method: 'POST'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 204) {
                throw __1.ServerConnection.makeError(response);
            }
        });
    };
    /**
     * Delete a checkpoint for a file.
     *
     * @param localPath - The path of the file.
     *
     * @param checkpointID - The id of the checkpoint to delete.
     *
     * @returns A promise which resolves when the checkpoint is deleted.
     *
     * #### Notes
     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/contents).
     */
    Drive.prototype.deleteCheckpoint = function (localPath, checkpointID) {
        var request = {
            url: this._getUrl(localPath, 'checkpoints', checkpointID),
            method: 'DELETE'
        };
        return __1.ServerConnection.makeRequest(request, this.serverSettings).then(function (response) {
            if (response.xhr.status !== 204) {
                throw __1.ServerConnection.makeError(response);
            }
        });
    };
    /**
     * Get a REST url for a file given a path.
     */
    Drive.prototype._getUrl = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var parts = args.map(function (path) { return coreutils_1.URLExt.encodeParts(path); });
        var baseUrl = this.serverSettings.baseUrl;
        return coreutils_1.URLExt.join.apply(coreutils_1.URLExt, [baseUrl, this._apiEndpoint].concat(parts));
    };
    return Drive;
}());
exports.Drive = Drive;
/**
 * A namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Normalize a file extension to be of the type `'.foo'`.
     *
     * Adds a leading dot if not present and converts to lower case.
     */
    function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf('.') !== 0) {
            extension = "." + extension;
        }
        return extension;
    }
    Private.normalizeExtension = normalizeExtension;
    /**
     * Normalize a global path. Reduces '..' and '.' parts, and removes
     * leading slashes from the local part of the path, while retaining
     * the drive name if it exists.
     */
    function normalize(path) {
        var parts = path.split(':');
        if (parts.length === 1) {
            return coreutils_1.PathExt.normalize(path);
        }
        if (parts.length === 2) {
            return parts[0] + ':' + coreutils_1.PathExt.normalize(parts[1]);
        }
        throw new Error('Malformed path: ' + path);
    }
    Private.normalize = normalize;
})(Private || (Private = {}));
