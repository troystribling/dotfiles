{"version":3,"file":"kernel.js","sourceRoot":"","sources":["../../../../../services/src/kernel/kernel.ts"],"names":[],"mappings":";AAAA,0CAA0C;AAC1C,2DAA2D;;AAsB3D,qCAEmB;AAOnB;;GAEG;AACH,IACU,MAAM,CAg1Bf;AAj1BD,WACU,MAAM;IA2Wd;;;;;;;;;;;;;;;;;OAiBG;IACH,kBACkB,EAAU,EAAE,QAAqC;QACjE,MAAM,CAAC,uBAAa,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAFQ,eAAQ,WAEhB,CAAA;IAED;;;;;;;;;OASG;IACH,kBACkB,QAAqC;QACrD,MAAM,CAAC,uBAAa,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC1C,CAAC;IAFQ,eAAQ,WAEhB,CAAA;IAED;;;;;;;;;;;OAWG;IACH,qBACqB,QAAqC;QACxD,MAAM,CAAC,uBAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAFQ,kBAAW,cAEnB,CAAA;IAED;;;;;;;;;;;;;;;OAeG;IACH,kBACkB,OAA6B;QAA7B,wBAAA,EAAA,YAA6B;QAC7C,MAAM,CAAC,uBAAa,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC;IAFQ,eAAQ,WAEhB,CAAA;IAED;;;;;;;;;;;;;;;;;;;;OAoBG;IACH,mBACmB,EAAU,EAAE,QAAqC;QAClE,MAAM,CAAC,uBAAa,CAAC,SAAS,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IAC/C,CAAC;IAFQ,gBAAS,YAEjB,CAAA;IAED;;;;;;;;OAQG;IACH,kBACkB,EAAU,EAAE,QAAqC;QACjE,MAAM,CAAC,uBAAa,CAAC,QAAQ,CAAC,EAAE,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAFQ,eAAQ,WAEhB,CAAA;AAmXH,CAAC,EAh1BS,MAAM,GAAN,cAAM,KAAN,cAAM,QAg1Bf","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\nimport {\n  IIterator\n} from '@phosphor/algorithm';\n\nimport {\n  JSONObject, JSONValue\n} from '@phosphor/coreutils';\n\nimport {\n  IDisposable\n} from '@phosphor/disposable';\n\nimport {\n  ISignal\n} from '@phosphor/signaling';\n\nimport {\n  ServerConnection\n} from '..';\n\nimport {\n  DefaultKernel\n} from './default';\n\nimport {\n  KernelMessage\n} from './messages';\n\n\n/**\n * A namespace for kernel types, interfaces, and type checker functions.\n */\nexport\nnamespace Kernel {\n  /**\n   * Interface of a Kernel connection that is managed by a session.\n   *\n   * #### Notes\n   * The Kernel object is tied to the lifetime of the Kernel id, which is\n   * a unique id for the Kernel session on the server.  The Kernel object\n   * manages a websocket connection internally, and will auto-restart if the\n   * websocket temporarily loses connection.  Restarting creates a new Kernel\n   * process on the server, but preserves the Kernel id.\n   */\n  export\n  interface IKernelConnection extends IDisposable {\n    /**\n     * The id of the server-side kernel.\n     */\n    readonly id: string;\n\n    /**\n     * The name of the server-side kernel.\n     */\n    readonly name: string;\n\n    /**\n     * The model associated with the kernel.\n     */\n    readonly model: Kernel.IModel;\n\n    /**\n     * The client username.\n     */\n    readonly username: string;\n\n    /**\n     * The client unique id.\n     */\n    readonly clientId: string;\n\n    /**\n     * The current status of the kernel.\n     */\n    readonly status: Kernel.Status;\n\n    /**\n     * The cached kernel info.\n     *\n     * #### Notes\n     * This value will be null until the kernel is ready.\n     */\n    readonly info: KernelMessage.IInfoReply | null;\n\n    /**\n     * Test whether the manager is ready.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that resolves when the kernel is initially ready.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Get the kernel spec.\n     *\n     * @returns A promise that resolves with the kernel spec.\n     */\n    getSpec(): Promise<Kernel.ISpecModel>;\n\n    /**\n     * Send a shell message to the kernel.\n     *\n     * @param msg - The fully formed shell message to send.\n     *\n     * @param expectReply - Whether to expect a shell reply message.\n     *\n     * @param disposeOnDone - Whether to dispose of the future when done.\n     *\n     * #### Notes\n     * Send a message to the kernel's shell channel, yielding a future object\n     * for accepting replies.\n     *\n     * If `expectReply` is given and `true`, the future is disposed when both a\n     * shell reply and an idle status message are received. If `expectReply`\n     * is not given or is `false`, the future is disposed when an idle status\n     * message is received.\n     *\n     * If `disposeOnDone` is given and `false`, the future will not be disposed\n     * of when the future is done, instead relying on the caller to dispose of it.\n     * This allows for the handling of out-of-order output from ill-behaved kernels.\n     *\n     * All replies are validated as valid kernel messages.\n     *\n     * If the kernel status is `'dead'`, this will throw an error.\n     */\n    sendShellMessage(msg: KernelMessage.IShellMessage, expectReply?: boolean, disposeOnDone?: boolean): Kernel.IFuture;\n\n    /**\n     * Reconnect to a disconnected kernel.\n     *\n     * @returns A promise that resolves when the kernel has reconnected.\n     *\n     * #### Notes\n     * This is not actually a  standard HTTP request, but useful function\n     * nonetheless for reconnecting to the kernel if the connection is somehow\n     * lost.\n     */\n    reconnect(): Promise<void>;\n\n    /**\n     * Interrupt a kernel.\n     *\n     * @returns A promise that resolves when the kernel has interrupted.\n     *\n     * #### Notes\n     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n     *\n     * The promise is fulfilled on a valid response and rejected otherwise.\n     *\n     * It is assumed that the API call does not mutate the kernel id or name.\n     *\n     * The promise will be rejected if the kernel status is `'dead'` or if the\n     * request fails or the response is invalid.\n     */\n    interrupt(): Promise<void>;\n\n    /**\n     * Restart a kernel.\n     *\n     * @returns A promise that resolves when the kernel has restarted.\n     *\n     * #### Notes\n     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n     *\n     * Any existing Future or Comm objects are cleared.\n     *\n     * It is assumed that the API call does not mutate the kernel id or name.\n     *\n     * The promise will be rejected if the kernel status is `'dead'` or if the\n     * request fails or the response is invalid.\n     */\n    restart(): Promise<void>;\n\n    /**\n     * Send a `kernel_info_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).\n     *\n     * Fulfills with the `kernel_info_response` content when the shell reply is\n     * received and validated.\n     */\n    requestKernelInfo(): Promise<KernelMessage.IInfoReplyMsg>;\n\n    /**\n     * Send a `complete_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).\n     *\n     * Fulfills with the `complete_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestComplete(content: KernelMessage.ICompleteRequest): Promise<KernelMessage.ICompleteReplyMsg>;\n\n    /**\n     * Send an `inspect_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).\n     *\n     * Fulfills with the `inspect_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestInspect(content: KernelMessage.IInspectRequest): Promise<KernelMessage.IInspectReplyMsg>;\n\n    /**\n     * Send a `history_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).\n     *\n     * Fulfills with the `history_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestHistory(content: KernelMessage.IHistoryRequest): Promise<KernelMessage.IHistoryReplyMsg>;\n\n    /**\n     * Send an `execute_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @param disposeOnDone - Whether to dispose of the future when done.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).\n     *\n     * Future `onReply` is called with the `execute_reply` content when the\n     * shell reply is received and validated.\n     *\n     * **See also:** [[IExecuteReply]]\n     */\n    requestExecute(content: KernelMessage.IExecuteRequest, disposeOnDone?: boolean): Kernel.IFuture;\n\n    /**\n     * Send an `is_complete_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).\n     *\n     * Fulfills with the `is_complete_response` content when the shell reply is\n     * received and validated.\n     */\n    requestIsComplete(content: KernelMessage.IIsCompleteRequest): Promise<KernelMessage.IIsCompleteReplyMsg>;\n\n    /**\n     * Send a `comm_info_request` message.\n     *\n     * @param content - The content of the request.\n     *\n     * @returns A promise that resolves with the response message.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#comm_info).\n     *\n     * Fulfills with the `comm_info_reply` content when the shell reply is\n     * received and validated.\n     */\n    requestCommInfo(content: KernelMessage.ICommInfoRequest): Promise<KernelMessage.ICommInfoReplyMsg>;\n\n    /**\n     * Send an `input_reply` message.\n     *\n     * @param content - The content of the reply.\n     *\n     * #### Notes\n     * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).\n     */\n    sendInputReply(content: KernelMessage.IInputReply): void;\n\n    /**\n     * Connect to a comm, or create a new one.\n     *\n     * @param targetName - The name of the comm target.\n     *\n     * @param id - The comm id.\n     *\n     * @returns A comm instance.\n     *\n     * #### Notes\n     * If a client-side comm already exists, it is returned.\n     */\n    connectToComm(targetName: string, commId?: string): Kernel.IComm;\n\n    /**\n     * Register a comm target handler.\n     *\n     * @param targetName - The name of the comm target.\n     *\n     * @param callback - The callback invoked for a comm open message.\n     *\n     * @returns A disposable used to unregister the comm target.\n     *\n     * #### Notes\n     * Only one comm target can be registered at a time, an existing\n     * callback will be overidden.  A registered comm target handler will take\n     * precedence over a comm which specifies a `target_module`.\n     */\n    registerCommTarget(targetName: string, callback: (comm: Kernel.IComm, msg: KernelMessage.ICommOpenMsg) => void): IDisposable;\n\n    /**\n     * Register an IOPub message hook.\n     *\n     * @param msg_id - The parent_header message id in messages the hook should intercept.\n     *\n     * @param hook - The callback invoked for the message.\n     *\n     * @returns A disposable used to unregister the message hook.\n     *\n     * #### Notes\n     * The IOPub hook system allows you to preempt the handlers for IOPub messages with a\n     * given parent_header message id. The most recently registered hook is run first.\n     * If the hook returns false, any later hooks and the future's onIOPub handler will not run.\n     * If a hook throws an error, the error is logged to the console and the next hook is run.\n     * If a hook is registered during the hook processing, it won't run until the next message.\n     * If a hook is disposed during the hook processing, it will be deactivated immediately.\n     *\n     * See also [[IFuture.registerMessageHook]].\n     */\n    registerMessageHook(msgId: string, hook: (msg: KernelMessage.IIOPubMessage) => boolean): IDisposable;\n  }\n\n  /**\n   * The full interface of a kernel.\n   */\n  export\n  interface IKernel extends IKernelConnection {\n    /**\n     * A signal emitted when the kernel is shut down.\n     */\n    terminated: ISignal<this, void>;\n\n    /**\n     * A signal emitted when the kernel status changes.\n     */\n    statusChanged: ISignal<this, Kernel.Status>;\n\n    /**\n     * A signal emitted for iopub kernel messages.\n     */\n    iopubMessage: ISignal<this, KernelMessage.IIOPubMessage>;\n\n    /**\n     * A signal emitted for unhandled kernel message.\n     */\n    unhandledMessage: ISignal<this, KernelMessage.IMessage>;\n\n    /**\n     * The server settings for the kernel.\n     */\n    readonly serverSettings: ServerConnection.ISettings;\n\n    /**\n     * Shutdown a kernel.\n     *\n     * @returns A promise that resolves when the kernel has shut down.\n     *\n     * #### Notes\n     * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n     *\n     * On a valid response, closes the websocket and disposes of the kernel\n     * object, and fulfills the promise.\n     *\n     * The promise will be rejected if the kernel status is `'dead'` or if the\n     * request fails or the response is invalid.\n     *\n     * If the server call is successful, the [[terminated]] signal will be\n     * emitted.\n     */\n    shutdown(): Promise<void>;\n  }\n\n  /**\n   * Find a kernel by id.\n   *\n   * @param id - The id of the kernel of interest.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the model for the kernel.\n   *\n   * #### Notes\n   * If the kernel was already started via `startNewKernel`, we return its\n   * `Kernel.IModel`.\n   *\n   * Otherwise, we attempt to find to the existing\n   * kernel.\n   * The promise is fulfilled when the kernel is found,\n   * otherwise the promise is rejected.\n   */\n  export\n  function findById(id: string, settings?: ServerConnection.ISettings): Promise<IModel> {\n    return DefaultKernel.findById(id, settings);\n  }\n\n  /**\n   * Fetch all of the kernel specs.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the kernel specs.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernelspecs).\n   */\n  export\n  function getSpecs(settings?: ServerConnection.ISettings): Promise<Kernel.ISpecModels> {\n    return DefaultKernel.getSpecs(settings);\n  }\n\n  /**\n   * Fetch the running kernels.\n   *\n   * @param settings - The optional server settings.\n   *\n   * @returns A promise that resolves with the list of running kernels.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * The promise is fulfilled on a valid response and rejected otherwise.\n   */\n  export\n  function listRunning(settings?: ServerConnection.ISettings): Promise<Kernel.IModel[]> {\n    return DefaultKernel.listRunning(settings);\n  }\n\n  /**\n   * Start a new kernel.\n   *\n   * @param options - The options used to create the kernel.\n   *\n   * @returns A promise that resolves with a kernel object.\n   *\n   * #### Notes\n   * Uses the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels) and validates the response model.\n   *\n   * If no options are given or the kernel name is not given, the\n   * default kernel will by started by the server.\n   *\n   * Wraps the result in a Kernel object. The promise is fulfilled\n   * when the kernel is started by the server, otherwise the promise is rejected.\n   */\n  export\n  function startNew(options: Kernel.IOptions = {}): Promise<IKernel> {\n    return DefaultKernel.startNew(options);\n  }\n\n  /**\n   * Connect to a running kernel.\n   *\n   * @param id - The id of the running kernel.\n   *\n   * @param settings - The server settings for the request.\n   *\n   * @returns A promise that resolves with the kernel object.\n   *\n   * #### Notes\n   * If the kernel was already started via `startNewKernel`, the existing\n   * Kernel object info is used to create another instance.\n   *\n   * Otherwise, if `options` are given, we attempt to connect to the existing\n   * kernel found by calling `listRunningKernels`.\n   * The promise is fulfilled when the kernel is running on the server,\n   * otherwise the promise is rejected.\n   *\n   * If the kernel was not already started and no `options` are given,\n   * the promise is rejected.\n   */\n  export\n  function connectTo(id: string, settings?: ServerConnection.ISettings): Promise<IKernel> {\n    return DefaultKernel.connectTo(id, settings);\n  }\n\n  /**\n   * Shut down a kernel by id.\n   *\n   * @param id - The id of the running kernel.\n   *\n   * @param settings - The server settings for the request.\n   *\n   * @returns A promise that resolves when the kernel is shut down.\n   */\n  export\n  function shutdown(id: string, settings?: ServerConnection.ISettings): Promise<void> {\n    return DefaultKernel.shutdown(id, settings);\n  }\n\n  /**\n   * The options object used to initialize a kernel.\n   */\n  export\n  interface IOptions {\n    /**\n     * The kernel type (e.g. python3).\n     */\n    name?: string;\n\n    /**\n     * The server settings for the kernel.\n     */\n    serverSettings?: ServerConnection.ISettings;\n\n    /**\n     * The username of the kernel client.\n     */\n    username?: string;\n\n    /**\n     * The unique identifier for the kernel client.\n     */\n    clientId?: string;\n  }\n\n  /**\n   * Object which manages kernel instances for a given base url.\n   *\n   * #### Notes\n   * The manager is responsible for maintaining the state of running\n   * kernels and the initial fetch of kernel specs.\n   */\n  export\n  interface IManager extends IDisposable {\n    /**\n     * A signal emitted when the kernel specs change.\n     */\n    specsChanged: ISignal<IManager, ISpecModels>;\n\n    /**\n     * A signal emitted when the running kernels change.\n     */\n    runningChanged: ISignal<IManager, IModel[]>;\n\n    /**\n     * The server settings for the manager.\n     */\n    serverSettings?: ServerConnection.ISettings;\n\n    /**\n     * The kernel spec models.\n     *\n     * #### Notes\n     * The value will be null until the manager is ready.\n     */\n    readonly specs: Kernel.ISpecModels | null;\n\n    /**\n     * Whether the manager is ready.\n     */\n    readonly isReady: boolean;\n\n    /**\n     * A promise that resolves when the manager is initially ready.\n     */\n    readonly ready: Promise<void>;\n\n    /**\n     * Create an iterator over the known running kernels.\n     *\n     * @returns A new iterator over the running kernels.\n     */\n    running(): IIterator<IModel>;\n\n    /**\n     * Force a refresh of the specs from the server.\n     *\n     * @returns A promise that resolves when the specs are fetched.\n     *\n     * #### Notes\n     * This is intended to be called only in response to a user action,\n     * since the manager maintains its internal state.\n     */\n    refreshSpecs(): Promise<void>;\n\n    /**\n     * Force a refresh of the running kernels.\n     *\n     * @returns A promise that resolves when the models are refreshed.\n     *\n     * #### Notes\n     * This is intended to be called only in response to a user action,\n     * since the manager maintains its internal state.\n     */\n    refreshRunning(): Promise<void>;\n\n    /**\n     * Start a new kernel.\n     *\n     * @param options - The kernel options to use.\n     *\n     * @returns A promise that resolves with the kernel instance.\n     *\n     * #### Notes\n     * The manager `serverSettings` will be always be used.\n     */\n    startNew(options?: IOptions): Promise<IKernel>;\n\n    /**\n     * Find a kernel by id.\n     *\n     * @param id - The id of the target kernel.\n     *\n     * @returns A promise that resolves with the kernel's model.\n     */\n    findById(id: string): Promise<IModel>;\n\n    /**\n     * Connect to an existing  kernel.\n     *\n     * @param id - The id of the target kernel.\n     *\n     * @returns A promise that resolves with the new kernel instance.\n     */\n    connectTo(id: string): Promise<IKernel>;\n\n    /**\n     * Shut down a kernel by id.\n     *\n     * @param id - The id of the target kernel.\n     *\n     * @returns A promise that resolves when the operation is complete.\n     */\n    shutdown(id: string): Promise<void>;\n  }\n\n  /**\n   * Object providing a Future interface for message callbacks.\n   *\n   * The future will self-dispose after `isDone` is\n   * set and the registered `onDone` handler is called.\n   *\n   * If a `reply` is expected, the Future is considered done when\n   * both a `reply` message and an `idle` iopub status message have\n   * been received.  Otherwise, it is considered done when the `idle` status is\n   * received.\n   */\n  export\n  interface IFuture extends IDisposable {\n    /**\n     * The original outgoing message.\n     */\n    readonly msg: KernelMessage.IShellMessage;\n\n    /**\n     * A promise that resolves when the future is done.\n     *\n     * The contents of the promise is the reply message.\n     */\n    readonly done: Promise<KernelMessage.IShellMessage>;\n\n    /**\n     * The reply handler for the kernel future.\n     */\n    onReply: (msg: KernelMessage.IShellMessage) => void;\n\n    /**\n     * The stdin handler for the kernel future.\n     */\n    onStdin: (msg: KernelMessage.IStdinMessage) => void;\n\n    /**\n     * The iopub handler for the kernel future.\n     */\n    onIOPub: (msg: KernelMessage.IIOPubMessage) => void;\n\n    /**\n     * Register hook for IOPub messages.\n     *\n     * @param hook - The callback invoked for an IOPub message.\n     *\n     * #### Notes\n     * The IOPub hook system allows you to preempt the handlers for IOPub messages handled\n     * by the future. The most recently registered hook is run first.\n     * If the hook returns false, any later hooks and the future's onIOPub handler will not run.\n     * If a hook throws an error, the error is logged to the console and the next hook is run.\n     * If a hook is registered during the hook processing, it won't run until the next message.\n     * If a hook is removed during the hook processing, it will be deactivated immediately.\n     */\n    registerMessageHook(hook: (msg: KernelMessage.IIOPubMessage) => boolean): void;\n\n    /**\n     * Remove a hook for IOPub messages.\n     *\n     * @param hook - The hook to remove.\n     *\n     * #### Notes\n     * If a hook is removed during the hook processing, it will be deactivated immediately.\n     */\n    removeMessageHook(hook: (msg: KernelMessage.IIOPubMessage) => boolean): void;\n\n    /**\n     * Send an `input_reply` message.\n     */\n    sendInputReply(content: KernelMessage.IInputReply): void;\n  }\n\n  /**\n   * A client side Comm interface.\n   */\n  export\n  interface IComm extends IDisposable {\n    /**\n     * The unique id for the comm channel.\n     */\n    readonly commId: string;\n\n    /**\n     * The target name for the comm channel.\n     */\n    readonly targetName: string;\n\n    /**\n     * Callback for a comm close event.\n     *\n     * #### Notes\n     * This is called when the comm is closed from either the server or\n     * client.\n     */\n    onClose: (msg: KernelMessage.ICommCloseMsg) => void;\n\n    /**\n     * Callback for a comm message received event.\n     */\n    onMsg: (msg: KernelMessage.ICommMsgMsg) => void;\n\n    /**\n     * Open a comm with optional data and metadata.\n     *\n     * @param data - The data to send to the server on opening.\n     *\n     * @param metadata - Additional metatada for the message.\n     *\n     * @returns A future for the generated message.\n     *\n     * #### Notes\n     * This sends a `comm_open` message to the server.\n     */\n    open(data?: JSONValue, metadata?: JSONObject, buffers?: (ArrayBuffer | ArrayBufferView)[]): IFuture;\n\n    /**\n     * Send a `comm_msg` message to the kernel.\n     *\n     * @param data - The data to send to the server on opening.\n     *\n     * @param metadata - Additional metatada for the message.\n     *\n     * @param buffers - Optional buffer data.\n     *\n     * @param disposeOnDone - Whether to dispose of the future when done.\n     *\n     * @returns A future for the generated message.\n     *\n     * #### Notes\n     * This is a no-op if the comm has been closed.\n     */\n    send(data: JSONValue, metadata?: JSONObject, buffers?: (ArrayBuffer | ArrayBufferView)[], disposeOnDone?: boolean): IFuture;\n\n    /**\n     * Close the comm.\n     *\n     * @param data - The data to send to the server on opening.\n     *\n     * @param metadata - Additional metatada for the message.\n     *\n     * @returns A future for the generated message.\n     *\n     * #### Notes\n     * This will send a `comm_close` message to the kernel, and call the\n     * `onClose` callback if set.\n     *\n     * This is a no-op if the comm is already closed.\n     */\n    close(data?: JSONValue, metadata?: JSONObject, buffers?: (ArrayBuffer | ArrayBufferView)[]): IFuture;\n  }\n\n  /**\n   * The valid Kernel status states.\n   */\n  export\n  type Status = 'unknown' | 'starting' | 'reconnecting' | 'idle' | 'busy' | 'restarting' | 'dead' | 'connected';\n\n  /**\n   * The kernel model provided by the server.\n   *\n   * #### Notes\n   * See the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernels).\n   */\n  export\n  interface IModel extends JSONObject {\n    /**\n     * Unique identifier of the kernel server session.\n     */\n    readonly id: string;\n\n    /**\n     * The name of the kernel.\n     */\n    readonly name: string;\n  }\n\n  /**\n   * Kernel Spec interface.\n   *\n   * #### Notes\n   * See [Kernel specs](https://jupyter-client.readthedocs.io/en/latest/kernels.html#kernelspecs).\n   */\n  export\n  interface ISpecModel extends JSONObject {\n    /**\n     * The name of the kernel spec.\n     */\n    readonly name: string;\n\n    /**\n     * The name of the language of the kernel.\n     */\n    readonly language: string;\n\n    /**\n     * A list of command line arguments used to start the kernel.\n     */\n    readonly argv: string[];\n\n    /**\n     * The kernel’s name as it should be displayed in the UI.\n     */\n    readonly display_name: string;\n\n    /**\n     * A dictionary of environment variables to set for the kernel.\n     */\n    readonly env?: JSONObject;\n\n    /**\n     * A mapping of resource file name to download path.\n     */\n    readonly resources: { [key: string]: string; };\n  }\n\n  /**\n   * The available kernelSpec models.\n   *\n   * #### Notes\n   * See the [Jupyter Notebook API](http://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter/notebook/master/notebook/services/api/api.yaml#!/kernelspecs).\n   */\n  export\n  interface ISpecModels extends JSONObject {\n    /**\n     * The name of the default kernel spec.\n     */\n    default: string;\n\n    /**\n     * A mapping of kernel spec name to spec.\n     */\n    readonly kernelspecs: { [key: string]: ISpecModel };\n  }\n}\n"]}