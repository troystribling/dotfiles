"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var coreutils_1 = require("@jupyterlab/coreutils");
var coreutils_2 = require("@phosphor/coreutils");
/**
 * The namespace for ServerConnection functions.
 */
var ServerConnection;
(function (ServerConnection) {
    /**
     * Make an Asynchronous XMLHttpRequest.
     *
     * @param request - The data for the request.
     *
     * @param settings - The server settings to apply to the request.
     *
     * @returns a Promise that resolves with the response data.
     */
    function makeRequest(request, settings) {
        var url = request.url;
        if (request.cache !== true) {
            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache.
            url += ((/\?/).test(url) ? '&' : '?') + (new Date()).getTime();
        }
        var xhr = settings.xhrFactory();
        xhr.open(request.method || 'GET', url, true, settings.user, settings.password);
        Private.populateRequest(xhr, request, settings);
        return Private.handleRequest(xhr, request, settings);
    }
    ServerConnection.makeRequest = makeRequest;
    /**
     * Create a settings object given a subset of options.
     *
     * @param options - An optional partial set of options.
     *
     * @returns The full settings object.
     */
    function makeSettings(options) {
        // Use the singleton default settings if no options are given.
        if (options === void 0) {
            if (Private.defaultSettings === void 0) {
                Private.defaultSettings = Private.makeSettings();
            }
            return Private.defaultSettings;
        }
        return Private.makeSettings(options);
    }
    ServerConnection.makeSettings = makeSettings;
    /**
     * Create an AJAX error from an AJAX success.
     *
     * @param response - The response object.
     *
     * @param message - The optional new error message.  If not given
     *  we use "Invalid Status: <xhr.status>"
     */
    function makeError(response, message) {
        var xhr = response.xhr, request = response.request, settings = response.settings, event = response.event;
        message = message || "Invalid Status: " + xhr.status;
        return { xhr: xhr, request: request, settings: settings, event: event, message: message };
    }
    ServerConnection.makeError = makeError;
})(ServerConnection = exports.ServerConnection || (exports.ServerConnection = {}));
/**
 * The namespace for module private data.
 */
var Private;
(function (Private) {
    /**
     * Handle the server connection settings, returning a new value.
     */
    function makeSettings(options) {
        if (options === void 0) { options = {}; }
        var baseUrl = options.baseUrl || coreutils_1.PageConfig.getBaseUrl();
        return {
            baseUrl: baseUrl,
            wsUrl: options.wsUrl || coreutils_1.PageConfig.getWsUrl(baseUrl),
            user: options.user || '',
            password: options.password || '',
            withCredentials: !!options.withCredentials,
            timeout: options.timeout || 0,
            token: options.token || coreutils_1.PageConfig.getOption('token'),
            requestHeaders: __assign({}, options.requestHeaders || {}),
            xhrFactory: options.xhrFactory || xhrFactory,
            wsFactory: options.wsFactory || wsFactory
        };
    }
    Private.makeSettings = makeSettings;
    /**
     * Make an xhr request using settings.
     */
    function populateRequest(xhr, request, settings) {
        if (request.contentType !== void 0) {
            xhr.setRequestHeader('Content-Type', request.contentType);
        }
        xhr.timeout = settings.timeout;
        if (settings.withCredentials) {
            xhr.withCredentials = true;
        }
        // Write the request headers.
        var headers = request.headers;
        if (headers) {
            for (var prop in headers) {
                xhr.setRequestHeader(prop, headers[prop]);
            }
        }
        headers = settings.requestHeaders;
        for (var prop in headers) {
            xhr.setRequestHeader(prop, headers[prop]);
        }
        // Handle authorization.
        if (settings.token) {
            xhr.setRequestHeader('Authorization', "token " + settings.token);
        }
        else if (typeof document !== 'undefined' && document.cookie) {
            var xsrfToken = getCookie('_xsrf');
            if (xsrfToken !== void 0) {
                xhr.setRequestHeader('X-XSRFToken', xsrfToken);
            }
        }
    }
    Private.populateRequest = populateRequest;
    /**
     * Handle a request.
     */
    function handleRequest(xhr, request, settings) {
        var delegate = new coreutils_2.PromiseDelegate();
        xhr.onload = function (event) {
            if (xhr.status >= 300) {
                var message = xhr.statusText || "Invalid Status: " + xhr.status;
                delegate.reject({ event: event, xhr: xhr, request: request, settings: settings, message: message });
                return;
            }
            var data = xhr.responseText;
            if (request.dataType === 'json' || request.dataType === undefined) {
                try {
                    data = JSON.parse(data);
                }
                catch (err) {
                    // no-op
                }
            }
            delegate.resolve({ xhr: xhr, request: request, settings: settings, data: data, event: event });
        };
        xhr.onabort = function (event) {
            delegate.reject({ xhr: xhr, event: event, request: request, settings: settings, message: 'Aborted' });
        };
        xhr.onerror = function (event) {
            delegate.reject({ xhr: xhr, event: event, request: request, settings: settings, message: event ? event.message : 'Errored' });
        };
        xhr.ontimeout = function (event) {
            delegate.reject({ xhr: xhr, event: event, request: request, settings: settings, message: 'Timed Out' });
        };
        // Send the request, adding data if needed.
        switch (request.method) {
            case 'GET':
            case 'DELETE':
            case 'HEAD':
            case 'CONNECT':
            case 'TRACE':
                // These methods take no payload.
                xhr.send();
                break;
            default:
                // Set the content type if there is no given data.
                if (!request.data) {
                    xhr.setRequestHeader('Content-Type', 'application/json');
                }
                xhr.send(request.data || '{}');
        }
        return delegate.promise;
    }
    Private.handleRequest = handleRequest;
    /**
     * Create a new xhr object.
     */
    function xhrFactory() {
        return new XMLHttpRequest();
    }
    /**
     * Create a new ws object.
     */
    function wsFactory(url, protocols) {
        return new WebSocket(url, protocols);
    }
    /**
     * Get a cookie from the document.
     */
    function getCookie(name) {
        // from tornado docs: http://www.tornadoweb.org/en/stable/guide/security.html
        var r = document.cookie.match('\\b' + name + '=([^;]*)\\b');
        return r ? r[1] : void 0;
    }
})(Private || (Private = {}));
