"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
Object.defineProperty(exports, "__esModule", { value: true });
var algorithm_1 = require("@phosphor/algorithm");
var signaling_1 = require("@phosphor/signaling");
var utils = require("../utils");
var terminal_1 = require("./terminal");
/**
 * The url for the terminal service.
 */
var TERMINAL_SERVICE_URL = 'api/terminals';
/**
 * An implementation of a terminal interface.
 */
var DefaultTerminalSession = (function () {
    /**
     * Construct a new terminal session.
     */
    function DefaultTerminalSession(name, options) {
        if (options === void 0) { options = {}; }
        this._token = '';
        this._ajaxSettings = '';
        this._ws = null;
        this._isDisposed = false;
        this._isReady = false;
        this._messageReceived = new signaling_1.Signal(this);
        this._name = name;
        this._baseUrl = options.baseUrl || utils.getBaseUrl();
        this._token = options.token || utils.getConfigOption('token');
        this._ajaxSettings = JSON.stringify(utils.ajaxSettingsWithToken(options.ajaxSettings, this._token));
        this._wsUrl = options.wsUrl || utils.getWsUrl(this._baseUrl);
        this._readyPromise = this._initializeSocket();
        this.terminated = new signaling_1.Signal(this);
    }
    Object.defineProperty(DefaultTerminalSession.prototype, "messageReceived", {
        /**
         * A signal emitted when a message is received from the server.
         */
        get: function () {
            return this._messageReceived;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "name", {
        /**
         * Get the name of the terminal session.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "model", {
        /**
         * Get the model for the terminal session.
         */
        get: function () {
            return { name: this._name };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "baseUrl", {
        /**
         * The base url of the terminal.
         */
        get: function () {
            return this._baseUrl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "ajaxSettings", {
        /**
         * Get a copy of the default ajax settings for the terminal.
         */
        get: function () {
            return JSON.parse(this._ajaxSettings);
        },
        /**
         * Set the default ajax settings for the terminal.
         */
        set: function (value) {
            this._ajaxSettings = JSON.stringify(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isReady", {
        /**
         * Test whether the session is ready.
         */
        get: function () {
            return this._isReady;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "ready", {
        /**
         * A promise that fulfills when the session is ready.
         */
        get: function () {
            return this._readyPromise;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultTerminalSession.prototype, "isDisposed", {
        /**
         * Test whether the session is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the session.
     */
    DefaultTerminalSession.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        if (this._ws) {
            this._ws.close();
            this._ws = null;
        }
        delete Private.running[this._url];
        this._readyPromise = null;
        signaling_1.Signal.clearData(this);
    };
    /**
     * Send a message to the terminal session.
     */
    DefaultTerminalSession.prototype.send = function (message) {
        var _this = this;
        if (this._isDisposed) {
            return;
        }
        var msg = [message.type];
        msg.push.apply(msg, message.content);
        var value = JSON.stringify(msg);
        if (this._isReady) {
            this._ws.send(value);
            return;
        }
        this.ready.then(function () {
            _this._ws.send(value);
        });
    };
    /**
     * Reconnect to the terminal.
     *
     * @returns A promise that resolves when the terminal has reconnected.
     */
    DefaultTerminalSession.prototype.reconnect = function () {
        this._readyPromise = this._initializeSocket();
        return this._readyPromise;
    };
    /**
     * Shut down the terminal session.
     */
    DefaultTerminalSession.prototype.shutdown = function () {
        var options = {
            baseUrl: this._baseUrl,
            ajaxSettings: this.ajaxSettings
        };
        return DefaultTerminalSession.shutdown(this.name, options);
    };
    /**
     * Connect to the websocket.
     */
    DefaultTerminalSession.prototype._initializeSocket = function () {
        var _this = this;
        var name = this._name;
        if (this._ws) {
            this._ws.close();
        }
        this._isReady = false;
        this._url = Private.getTermUrl(this._baseUrl, this._name);
        Private.running[this._url] = this;
        var wsUrl = utils.urlPathJoin(this._wsUrl, "terminals/websocket/" + name);
        if (this._token) {
            wsUrl = wsUrl + ("?token=" + this._token);
        }
        this._ws = new WebSocket(wsUrl);
        this._ws.onmessage = function (event) {
            if (_this._isDisposed) {
                return;
            }
            var data = JSON.parse(event.data);
            _this._messageReceived.emit({
                type: data[0],
                content: data.slice(1)
            });
        };
        return new Promise(function (resolve, reject) {
            _this._ws.onopen = function (event) {
                if (_this._isDisposed) {
                    return;
                }
                _this._isReady = true;
                resolve(void 0);
            };
            _this._ws.onerror = function (event) {
                if (_this._isDisposed) {
                    return;
                }
                reject(event);
            };
        });
    };
    return DefaultTerminalSession;
}());
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * The static namespace for `DefaultTerminalSession`.
 */
(function (DefaultTerminalSession) {
    /**
     * Whether the terminal service is available.
     */
    function isAvailable() {
        var available = String(utils.getConfigOption('terminalsAvailable'));
        return available.toLowerCase() === 'true';
    }
    DefaultTerminalSession.isAvailable = isAvailable;
    /**
     * Start a new terminal session.
     *
     * @options - The session options to use.
     *
     * @returns A promise that resolves with the session instance.
     */
    function startNew(options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            throw Private.unavailableMsg;
        }
        var baseUrl = options.baseUrl || utils.getBaseUrl();
        var url = Private.getBaseUrl(baseUrl);
        var ajaxSettings = utils.ajaxSettingsWithToken(options.ajaxSettings, options.token);
        ajaxSettings.method = 'POST';
        ajaxSettings.dataType = 'json';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                throw utils.makeAjaxError(success);
            }
            var name = success.data.name;
            return new DefaultTerminalSession(name, options);
        });
    }
    DefaultTerminalSession.startNew = startNew;
    /*
     * Connect to a running session.
     *
     * @param name - The name of the target session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the new session instance.
     *
     * #### Notes
     * If the session was already started via `startNew`, the existing
     * session object is used as the fulfillment value.
     *
     * Otherwise, if `options` are given, we resolve the promise after
     * confirming that the session exists on the server.
     *
     * If the session does not exist on the server, the promise is rejected.
     */
    function connectTo(name, options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        var baseUrl = options.baseUrl || utils.getBaseUrl();
        var url = Private.getTermUrl(baseUrl, name);
        if (url in Private.running) {
            return Promise.resolve(Private.running[url]);
        }
        return listRunning(options).then(function (models) {
            var index = algorithm_1.ArrayExt.findFirstIndex(models, function (model) {
                return model.name === name;
            });
            if (index !== -1) {
                var session = new DefaultTerminalSession(name, options);
                return Promise.resolve(session);
            }
            return Promise.reject('Could not find session');
        });
    }
    DefaultTerminalSession.connectTo = connectTo;
    /**
     * List the running terminal sessions.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves with the list of running session models.
     */
    function listRunning(options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        var url = Private.getBaseUrl(options.baseUrl);
        var ajaxSettings = utils.ajaxSettingsWithToken(options.ajaxSettings, options.token);
        ajaxSettings.method = 'GET';
        ajaxSettings.dataType = 'json';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 200) {
                throw utils.makeAjaxError(success);
            }
            var data = success.data;
            if (!Array.isArray(data)) {
                throw utils.makeAjaxError(success, 'Invalid terminal data');
            }
            // Update the local data store.
            var urls = algorithm_1.toArray(algorithm_1.map(data, function (item) {
                return utils.urlPathJoin(url, item.name);
            }));
            algorithm_1.each(Object.keys(Private.running), function (runningUrl) {
                if (urls.indexOf(runningUrl) === -1) {
                    var session = Private.running[runningUrl];
                    session.terminated.emit(void 0);
                    session.dispose();
                }
            });
            return data;
        });
    }
    DefaultTerminalSession.listRunning = listRunning;
    /**
     * Shut down a terminal session by name.
     *
     * @param name - The name of the target session.
     *
     * @param options - The session options to use.
     *
     * @returns A promise that resolves when the session is shut down.
     */
    function shutdown(name, options) {
        if (options === void 0) { options = {}; }
        if (!terminal_1.TerminalSession.isAvailable()) {
            return Promise.reject(Private.unavailableMsg);
        }
        var url = Private.getTermUrl(options.baseUrl, name);
        var ajaxSettings = utils.ajaxSettingsWithToken(options.ajaxSettings, options.token);
        ajaxSettings.method = 'DELETE';
        return utils.ajaxRequest(url, ajaxSettings).then(function (success) {
            if (success.xhr.status !== 204) {
                throw utils.makeAjaxError(success);
            }
            Private.killTerminal(url);
        }, function (err) {
            if (err.xhr.status === 404) {
                var response = JSON.parse(err.xhr.responseText);
                console.warn(response['message']);
                Private.killTerminal(url);
                return;
            }
            return Promise.reject(err);
        });
    }
    DefaultTerminalSession.shutdown = shutdown;
})(DefaultTerminalSession = exports.DefaultTerminalSession || (exports.DefaultTerminalSession = {}));
exports.DefaultTerminalSession = DefaultTerminalSession;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A mapping of running terminals by url.
     */
    Private.running = Object.create(null);
    /**
     * A promise returned for when terminals are unavailable.
     */
    Private.unavailableMsg = 'Terminals Unavailable';
    /**
     * Get the url for a terminal.
     */
    function getTermUrl(baseUrl, name) {
        return utils.urlPathJoin(baseUrl, TERMINAL_SERVICE_URL, name);
    }
    Private.getTermUrl = getTermUrl;
    /**
     * Get the base url.
     */
    function getBaseUrl(baseUrl) {
        return utils.urlPathJoin(baseUrl, TERMINAL_SERVICE_URL);
    }
    Private.getBaseUrl = getBaseUrl;
    /**
     * Kill a terminal by url.
     */
    function killTerminal(url) {
        // Update the local data store.
        if (Private.running[url]) {
            var session = Private.running[url];
            session.terminated.emit(void 0);
            session.dispose();
        }
    }
    Private.killTerminal = killTerminal;
})(Private || (Private = {}));
