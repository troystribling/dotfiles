"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringifyNotebook = exports.toJS = exports.fromJS = exports.parseNotebook = void 0;
/**
 *
 * This is the top level data structure for in memory data structures,
 * and allows converting from on-disk v4 and v3 Jupyter Notebooks
 *
 */
const v3 = __importStar(require("./v3"));
const v4 = __importStar(require("./v4"));
const immutable_1 = require("immutable");
function freezeReviver(_k, v) {
    return Object.freeze(v);
}
/**
 * Converts a string representation of a notebook into a JSON representation.
 *
 * @param notebookString A string representation of a notebook.
 *
 * @returns A JSON representation of the same notebook.
 */
function parseNotebook(notebookString) {
    return JSON.parse(notebookString, freezeReviver);
}
exports.parseNotebook = parseNotebook;
function fromJS(notebook) {
    if (immutable_1.Record.isRecord(notebook)) {
        if (notebook.has("cellOrder") && notebook.has("cellMap")) {
            return notebook;
        }
        throw new TypeError(`
      commutable was passed an Immutable.Record 
      structure that is not a notebook
    `);
    }
    if (v4.isNotebookV4(notebook)) {
        if (Array.isArray(notebook.cells) &&
            typeof notebook.metadata === "object") {
            return v4.fromJS(notebook);
        }
    }
    else if (v3.isNotebookV3(notebook)) {
        return v3.fromJS(notebook);
    }
    if (notebook.nbformat) {
        throw new TypeError(`nbformat v${notebook.nbformat}.${notebook.nbformat_minor} not recognized`);
    }
    throw new TypeError("This notebook format is not supported");
}
exports.fromJS = fromJS;
/**
 * Converts an immutable representation of a notebook
 * to a JSON representation of the notebook using the
 * v4 of the nbformat specification.
 *
 * @param immnb The immutable representation of a notebook.
 *
 * @returns The JSON representation of a notebook.
 */
function toJS(immnb) {
    const minorVersion = immnb.get("nbformat_minor", null);
    if (immnb.get("nbformat") === 4 &&
        typeof minorVersion === "number" &&
        minorVersion >= 0) {
        return v4.toJS(immnb);
    }
    throw new TypeError("Only notebook formats 3 and 4 are supported!");
}
exports.toJS = toJS;
/**
 * Converts a JSON representation of a notebook into a string representation.
 *
 * @param notebook The JSON representation of a notebook.
 *
 * @returns A string containing the notebook data.
 */
function stringifyNotebook(notebook) {
    return JSON.stringify(notebook, null, 2);
}
exports.stringifyNotebook = stringifyNotebook;
//# sourceMappingURL=notebook.js.map