"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const v4_1 = __importDefault(require("uuid/v4"));
function createCellId() {
    return v4_1.default();
}
exports.createCellId = createCellId;
/**
 * Turn nbformat multiline strings (arrays of strings for simplifying diffs)
 * into strings
 */
function demultiline(s) {
    if (Array.isArray(s)) {
        return s.join("");
    }
    return s;
}
exports.demultiline = demultiline;
/**
 * Split string into a list of strings delimited by newlines; useful for on-disk
 * git comparisons; and is the expectation for jupyter notebooks on disk
 */
function remultiline(s) {
    if (Array.isArray(s)) {
        // Assume already multiline string
        return s;
    }
    // Split on newline and retain newline char
    return s.split(/(.*?(?:\r\n|\n))/g).filter(x => x !== "");
}
exports.remultiline = remultiline;
function isJSONKey(key) {
    return /^application\/(.*\+)json$/.test(key);
}
// tslint:disable-next-line:max-line-length
// Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
function deepFreeze(object) {
    // Retrieve the property names defined on object
    const propNames = Object.getOwnPropertyNames(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        // getOwnPropertyNames assures us we can index on name
        const value = object[name];
        object[name] =
            value && typeof value === "object" ? deepFreeze(value) : value;
    }
    return Object.freeze(object);
}
exports.deepFreeze = deepFreeze;
function createFrozenMediaBundle(mediaBundle) {
    // Map over all the mimetypes; turning them into our in-memory format
    //
    // {
    //   "application/json": {"a": 3; "b": 2};
    //   "text/html": ["<p>\n"; "Hey\n"; "</p>"];
    //   "text/plain": "Hey"
    // }
    //
    // to
    //
    // {
    //   "application/json": {"a": 3; "b": 2};
    //   "text/html": "<p>\nHey\n</p>";
    //   "text/plain": "Hey"
    // }
    // Since we have to convert from one type to another that has conflicting
    // types; we need to hand convert it in a way that flow is able to verify
    // correctly.
    // FIXME: Is above comment still valid with the move from flow to ts?
    //
    // The way we do that is create a new object that we declare with the type
    // we want; set the keys and values we need; then seal the object with
    // Object.freeze
    const bundle = {};
    for (const key in mediaBundle) {
        if (typeof mediaBundle[key] === "string") {
            // Strings are immutable and can be just taken as-is.
            //
            // N.B.: This is even true of strings sent directly as the JSON root
            // object -- which Bokeh's output_notebook() is known to do -- so we
            // have to check for them even in the JSON case, as deepFreeze will fail
            // on strings.
            bundle[key] = mediaBundle[key];
        }
        else if (!isJSONKey(key) && Array.isArray(mediaBundle[key])) {
            bundle[key] = demultiline(mediaBundle[key]);
        }
        else {
            // we now know it's an Object of some kind (or a JSON array)
            bundle[key] = deepFreeze(mediaBundle[key]);
        }
    }
    return Object.freeze(bundle);
}
exports.createFrozenMediaBundle = createFrozenMediaBundle;
function createOnDiskMediaBundle(mediaBundle) {
    // Technically we could return just the mediaBundle as is
    // return mediaBundle;
    // However for the sake of on-disk readability we write out remultilined
    // versions of the array and string ones
    const freshBundle = {};
    for (const key in mediaBundle) {
        if (!isJSONKey(key) &&
            (typeof mediaBundle[key] === "string" || Array.isArray(mediaBundle[key]))) {
            freshBundle[key] = remultiline(mediaBundle[key]);
        }
        else {
            freshBundle[key] = mediaBundle[key];
        }
    }
    return freshBundle;
}
exports.createOnDiskMediaBundle = createOnDiskMediaBundle;
