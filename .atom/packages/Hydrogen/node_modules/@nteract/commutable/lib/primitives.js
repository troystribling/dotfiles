"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOnDiskMediaBundle = exports.createFrozenMediaBundle = exports.deepFreeze = exports.remultiline = exports.demultiline = exports.createCellId = void 0;
const uuid_1 = require("uuid");
function createCellId() {
    return uuid_1.v4();
}
exports.createCellId = createCellId;
/**
 * Turn nbformat multiline strings (arrays of strings for simplifying diffs)
 * into strings
 */
function demultiline(s) {
    if (Array.isArray(s)) {
        return s.join("");
    }
    return s;
}
exports.demultiline = demultiline;
/**
 * Split string into a list of strings delimited by newlines; useful for on-disk
 * git comparisons; and is the expectation for jupyter notebooks on disk
 */
function remultiline(s) {
    if (Array.isArray(s)) {
        // Assume already multiline string
        return s;
    }
    // Split on newline and retain newline char
    return s.split(/(.*?(?:\r\n|\n))/g).filter(x => x !== "");
}
exports.remultiline = remultiline;
function isJSONKey(key) {
    return /^application\/(.*\+)json$/.test(key);
}
// tslint:disable-next-line:max-line-length
// Taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
function deepFreeze(object) {
    // Retrieve the property names defined on object
    const propNames = Object.getOwnPropertyNames(object);
    // Freeze properties before freezing self
    for (const name of propNames) {
        // getOwnPropertyNames assures us we can index on name
        const value = object[name];
        object[name] =
            value && typeof value === "object" ? deepFreeze(value) : value;
    }
    return Object.freeze(object);
}
exports.deepFreeze = deepFreeze;
const IS_VEGA = /^application\/vnd.vega(.*\+)json$/;
function createFrozenMediaBundle(mediaBundle) {
    // Map over all the mimetypes; turning them into our in-memory format
    //
    // {
    //   "application/json": {"a": 3; "b": 2};
    //   "text/html": ["<p>\n"; "Hey\n"; "</p>"];
    //   "text/plain": "Hey"
    // }
    //
    // to
    //
    // {
    //   "application/json": {"a": 3; "b": 2};
    //   "text/html": "<p>\nHey\n</p>";
    //   "text/plain": "Hey"
    // }
    // Since we have to convert from one type to another that has conflicting
    // types; we need to hand convert it in a way that flow is able to verify
    // correctly.
    // FIXME: Is above comment still valid with the move from flow to ts?
    //
    // The way we do that is create a new object that we declare with the type
    // we want; set the keys and values we need; then seal the object with
    // Object.freeze
    const bundle = {};
    for (const key in mediaBundle) {
        if (IS_VEGA.test(key)) {
            bundle[key] = JSON.stringify(mediaBundle[key]);
        }
        else if (typeof mediaBundle[key] === "string") {
            // Strings are immutable and can be just taken as-is.
            //
            // N.B.: This is even true of strings sent directly as the JSON root
            // object -- which Bokeh's output_notebook() is known to do -- so we
            // have to check for them even in the JSON case, as deepFreeze will fail
            // on strings.
            bundle[key] = mediaBundle[key];
        }
        else if (!isJSONKey(key) && Array.isArray(mediaBundle[key])) {
            bundle[key] = demultiline(mediaBundle[key]);
        }
        else {
            // we now know it's an Object of some kind (or a JSON array)
            bundle[key] = deepFreeze(mediaBundle[key]);
        }
    }
    return Object.freeze(bundle);
}
exports.createFrozenMediaBundle = createFrozenMediaBundle;
function createOnDiskMediaBundle(mediaBundle) {
    // Return the bundle as is
    return mediaBundle;
    // The remultiline function in the code below is costly when the data payload is large
    // TODO: figure out a configurable way to reformat the string when needed.
    // However for the sake of on-disk readability we write out remultilined
    // versions of the array and string ones
    // const freshBundle: OnDiskMediaBundle = {};
    // for (const key in mediaBundle) {
    //   if (IS_VEGA.test(key)) {
    //     freshBundle[key] = JSON.parse(mediaBundle[key] as string);
    //   } else if (
    //     !isJSONKey(key) &&
    //     (typeof mediaBundle[key] === "string" || Array.isArray(mediaBundle[key]))
    //   ) {
    //     freshBundle[key] = remultiline(mediaBundle[key] as MultiLineString);
    //   } else {
    //     freshBundle[key] = mediaBundle[key];
    //   }
    // }
    // return freshBundle;
}
exports.createOnDiskMediaBundle = createOnDiskMediaBundle;
//# sourceMappingURL=primitives.js.map