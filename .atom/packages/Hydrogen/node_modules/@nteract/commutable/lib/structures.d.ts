import { CellId } from "./primitives";
import { ImmutableCell } from "./cells";
import { List as ImmutableList, Map as ImmutableMap, Record as ImmutableRecord } from "immutable";
export declare const createCodeCell: ImmutableRecord.Factory<import("./cells").CodeCellParams>;
export declare const createMarkdownCell: ImmutableRecord.Factory<import("./cells").MarkdownCellParams>;
export declare const emptyCodeCell: import("immutable").RecordOf<import("./cells").CodeCellParams>;
export declare const emptyMarkdownCell: import("immutable").RecordOf<import("./cells").MarkdownCellParams>;
export interface CellStructure {
    cellOrder: ImmutableList<CellId>;
    cellMap: ImmutableMap<CellId, ImmutableCell>;
}
export interface NotebookRecordParams {
    cellOrder: ImmutableList<CellId>;
    cellMap: ImmutableMap<CellId, ImmutableCell>;
    nbformat_minor: number;
    nbformat: number;
    metadata: ImmutableMap<string, any>;
}
export declare type ImmutableNotebook = ImmutableRecord<NotebookRecordParams> & Readonly<NotebookRecordParams>;
export declare const makeNotebookRecord: ImmutableRecord.Factory<NotebookRecordParams>;
export declare const defaultNotebook: ImmutableRecord<NotebookRecordParams> & Readonly<NotebookRecordParams>;
export declare const createNotebook: ImmutableRecord.Factory<NotebookRecordParams>;
export declare const emptyNotebook: ImmutableRecord<NotebookRecordParams> & Readonly<NotebookRecordParams>;
/**
 * A function that appends a new cell to a CellStructure object.
 *
 * @param cellStructure The cellOrder and cellMap of the current notebook
 * @param immutableCell The cell that will be inserted into the cellStructure
 * @param id The id of the new cell, defaults to a new UUID
 *
 * @returns Cell structure with the new cell appended at the end
 */
export declare function appendCell(cellStructure: CellStructure, immutableCell: ImmutableCell, id?: CellId): CellStructure;
/**
 * A function that appends a cell to an immutable notebook.
 *
 * @param immnb An immutable data structure representing the notebook that will be modified
 * @param immCell The new cell that will be inserted into the notebook
 *
 * @returns The modified notebook
 */
export declare function appendCellToNotebook(immnb: ImmutableNotebook, immCell: ImmutableCell): ImmutableNotebook;
/**
 * Inserts a cell with cellID at a given index within the notebook.
 *
 * @param notebook The notebook the cell will be inserted into.
 * @param cell The cell that will be inserted
 * @param cellID The ID of the cell.
 * @param index The position we would like to insert the cell at
 *
 * @returns The modified notebook.
 */
export declare function insertCellAt(notebook: ImmutableNotebook, cell: ImmutableCell, cellId: string, index: number): ImmutableNotebook;
/**
 * Inserts a new cell with cellID before an existing cell with priorCellID
 * in the notebook.
 *
 * @param notebook The notebook the cell will be inserted into.
 * @param cell The cell that will be inserted
 * @param cellID The ID of the cell.
 * @param priorCellID The ID of the existing cell.
 */
export declare function insertCellAfter(notebook: ImmutableNotebook, cell: ImmutableCell, cellId: string, priorCellId: string): ImmutableNotebook;
/**
 * Deprecated: Delete a cell with CellID at a given location.
 *
 * Note that this function is deprecated in favor of `deleteCell`.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 *
 * @deprecated use `deleteCell()` instead
 */
export declare function removeCell(notebook: ImmutableNotebook, cellId: string): ImmutableNotebook;
/**
 * Delete a cell with CellID at a given location.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 */
export declare function deleteCell(notebook: ImmutableNotebook, cellId: string): ImmutableNotebook;
/**
 * Mark a cell as deleting; can be undone.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 */
export declare function markCellDeleting(notebook: ImmutableNotebook, cellId: string): ImmutableNotebook;
/**
 * Undo marking a cell as deleting.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will not be deleted.
 *
 * @returns The modified notebook
 */
export declare function markCellNotDeleting(notebook: ImmutableNotebook, cellId: string): ImmutableNotebook;
/**
 * A new 'monocell' notebook with a single empty code cell. This function is useful
 * if you are looking to initialize a fresh, new notebook.
 */
export declare const monocellNotebook: ImmutableRecord<NotebookRecordParams> & Readonly<NotebookRecordParams>;
