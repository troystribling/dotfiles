import { CellId } from "./primitives";
import { ImmutableNotebook } from "./notebook";
import { ImmutableCell } from "./cells";
import { List as ImmutableList, Map as ImmutableMap } from "immutable";
export declare const createCodeCell: import("immutable").Record.Factory<import("./cells").CodeCellParams>;
export declare const createMarkdownCell: import("immutable").Record.Factory<import("./cells").MarkdownCellParams>;
export declare const emptyCodeCell: import("immutable").RecordOf<import("./cells").CodeCellParams>;
export declare const emptyMarkdownCell: import("immutable").RecordOf<import("./cells").MarkdownCellParams>;
export declare const defaultNotebook: import("immutable").Record<import("./notebook").NotebookRecordParams> & Readonly<import("./notebook").NotebookRecordParams>;
export declare const createNotebook: import("immutable").Record.Factory<import("./notebook").NotebookRecordParams>;
export declare const emptyNotebook: import("immutable").Record<import("./notebook").NotebookRecordParams> & Readonly<import("./notebook").NotebookRecordParams>;
export interface CellStructure {
    cellOrder: ImmutableList<CellId>;
    cellMap: ImmutableMap<CellId, ImmutableCell>;
}
/**
 * A function that appends a new cell to a CellStructure object.
 *
 * @param cellStructure The cellOrder and cellMap of the current notebook
 * @param immutableCell The cell that will be inserted into the cellStructure
 * @param id The id of the new cell, defaults to a new UUID
 *
 * @returns Cell structure with the new cell appended at the end
 */
export declare function appendCell(cellStructure: CellStructure, immutableCell: ImmutableCell, id?: CellId): CellStructure;
/**
 * A function that appends a cell to an immutable notebook.
 *
 * @param immnb An immutable data structure representing the notebook that will be modified
 * @param immCell The new cell that will be inserted into the notebook
 *
 * @returns The modified notebook
 */
export declare function appendCellToNotebook(immnb: ImmutableNotebook, immCell: ImmutableCell): ImmutableNotebook;
/**
 * Inserts a cell with cellID at a given index within the notebook.
 *
 * @param notebook The notebook the cell will be inserted into.
 * @param cell The cell that will be inserted
 * @param cellID The ID of the cell.
 * @param index The position we would like to insert the cell at
 *
 * @returns The modified notebook.
 */
export declare function insertCellAt(notebook: ImmutableNotebook, cell: ImmutableCell, cellId: string, index: number): ImmutableNotebook;
/**
 * Inserts a new cell with cellID before an existing cell with priorCellID
 * in the notebook.
 *
 * @param notebook The notebook the cell will be inserted into.
 * @param cell The cell that will be inserted
 * @param cellID The ID of the cell.
 * @param priorCellID The ID of the existing cell.
 */
export declare function insertCellAfter(notebook: ImmutableNotebook, cell: ImmutableCell, cellId: string, priorCellId: string): ImmutableNotebook;
/**
 * Deprecated: Delete a cell with CellID at a given location.
 *
 * Note that this function is deprecated in favor of `deleteCell`.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 *
 * @deprecated use `deleteCell()` instead
 */
export declare function removeCell(notebook: ImmutableNotebook, cellId: string): ImmutableNotebook;
/**
 * Delete a cell with CellID at a given location.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 */
export declare function deleteCell(notebook: ImmutableNotebook, cellId: string): ImmutableNotebook;
/**
 * A new 'monocell' notebook with a single empty code cell. This function is useful
 * if you are looking to initialize a fresh, new notebook.
 */
export declare const monocellNotebook: import("immutable").Record<import("./notebook").NotebookRecordParams> & Readonly<import("./notebook").NotebookRecordParams>;
