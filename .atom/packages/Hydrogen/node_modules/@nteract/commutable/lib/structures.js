"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.monocellNotebook = exports.markCellNotDeleting = exports.markCellDeleting = exports.deleteCell = exports.removeCell = exports.insertCellAfter = exports.insertCellAt = exports.appendCellToNotebook = exports.appendCell = exports.emptyNotebook = exports.createNotebook = exports.defaultNotebook = exports.makeNotebookRecord = exports.emptyMarkdownCell = exports.emptyCodeCell = exports.createMarkdownCell = exports.createCodeCell = void 0;
const primitives_1 = require("./primitives");
const cells_1 = require("./cells");
const immutable_1 = require("immutable");
// The cell creators here are a bit duplicative
exports.createCodeCell = cells_1.makeCodeCell;
exports.createMarkdownCell = cells_1.makeMarkdownCell;
exports.emptyCodeCell = exports.createCodeCell();
exports.emptyMarkdownCell = exports.createMarkdownCell();
exports.makeNotebookRecord = immutable_1.Record({
    cellOrder: immutable_1.List(),
    cellMap: immutable_1.Map(),
    nbformat_minor: 0,
    nbformat: 4,
    metadata: immutable_1.Map()
});
// These are all kind of duplicative now that we're on records.
// Since we export these though, they're left for
// backwards compatiblity
exports.defaultNotebook = exports.makeNotebookRecord();
exports.createNotebook = exports.makeNotebookRecord;
exports.emptyNotebook = exports.makeNotebookRecord();
/**
 * A function that appends a new cell to a CellStructure object.
 *
 * @param cellStructure The cellOrder and cellMap of the current notebook
 * @param immutableCell The cell that will be inserted into the cellStructure
 * @param id The id of the new cell, defaults to a new UUID
 *
 * @returns Cell structure with the new cell appended at the end
 */
function appendCell(cellStructure, immutableCell, id = primitives_1.createCellId()) {
    return {
        cellOrder: cellStructure.cellOrder.push(id),
        cellMap: cellStructure.cellMap.set(id, immutableCell)
    };
}
exports.appendCell = appendCell;
/**
 * A function that appends a cell to an immutable notebook.
 *
 * @param immnb An immutable data structure representing the notebook that will be modified
 * @param immCell The new cell that will be inserted into the notebook
 *
 * @returns The modified notebook
 */
function appendCellToNotebook(immnb, immCell) {
    return immnb.withMutations(nb => {
        const cellStructure = {
            cellOrder: nb.get("cellOrder"),
            cellMap: nb.get("cellMap")
        };
        const { cellOrder, cellMap } = appendCell(cellStructure, immCell);
        return nb.set("cellOrder", cellOrder).set("cellMap", cellMap);
    });
}
exports.appendCellToNotebook = appendCellToNotebook;
/**
 * Inserts a cell with cellID at a given index within the notebook.
 *
 * @param notebook The notebook the cell will be inserted into.
 * @param cell The cell that will be inserted
 * @param cellID The ID of the cell.
 * @param index The position we would like to insert the cell at
 *
 * @returns The modified notebook.
 */
function insertCellAt(notebook, cell, cellId, index) {
    return notebook.withMutations(nb => nb
        .setIn(["cellMap", cellId], cell)
        .set("cellOrder", nb.get("cellOrder").insert(index, cellId)));
}
exports.insertCellAt = insertCellAt;
/**
 * Inserts a new cell with cellID before an existing cell with priorCellID
 * in the notebook.
 *
 * @param notebook The notebook the cell will be inserted into.
 * @param cell The cell that will be inserted
 * @param cellID The ID of the cell.
 * @param priorCellID The ID of the existing cell.
 */
function insertCellAfter(notebook, cell, cellId, priorCellId) {
    return insertCellAt(notebook, cell, cellId, notebook.get("cellOrder").indexOf(priorCellId) + 1);
}
exports.insertCellAfter = insertCellAfter;
/**
 * Deprecated: Delete a cell with CellID at a given location.
 *
 * Note that this function is deprecated in favor of `deleteCell`.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 *
 * @deprecated use `deleteCell()` instead
 */
function removeCell(notebook, cellId) {
    console.log("Deprecation Warning: removeCell() is being deprecated. Please use deleteCell() instead");
    return deleteCell(notebook, cellId);
}
exports.removeCell = removeCell;
/**
 * Delete a cell with CellID at a given location.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 */
function deleteCell(notebook, cellId) {
    return notebook
        .removeIn(["cellMap", cellId])
        .update("cellOrder", cellOrder => cellOrder.filterNot(id => id === cellId));
}
exports.deleteCell = deleteCell;
/**
 * Mark a cell as deleting; can be undone.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will be deleted.
 *
 * @returns The modified notebook
 */
function markCellDeleting(notebook, cellId) {
    return notebook.withMutations(nb => nb.setIn(["cellMap", cellId], nb
        .getIn(["cellMap", cellId])
        .setIn(["metadata", "nteract", "transient", "deleting"], true)));
}
exports.markCellDeleting = markCellDeleting;
/**
 * Undo marking a cell as deleting.
 *
 * @param notebook The notebook containing the cell.
 * @param cellID The ID of the cell that will not be deleted.
 *
 * @returns The modified notebook
 */
function markCellNotDeleting(notebook, cellId) {
    return notebook.withMutations(nb => nb.setIn(["cellMap", cellId], nb
        .getIn(["cellMap", cellId])
        .setIn(["metadata", "nteract", "transient", "deleting"], false)));
}
exports.markCellNotDeleting = markCellNotDeleting;
/**
 * A new 'monocell' notebook with a single empty code cell. This function is useful
 * if you are looking to initialize a fresh, new notebook.
 */
exports.monocellNotebook = appendCellToNotebook(exports.emptyNotebook, exports.emptyCodeCell);
//# sourceMappingURL=structures.js.map