"use strict";

var uuidv4 = require("uuid").v4;

var Immutable = require("immutable");

// We're hardset to nbformat v4.4 for what we use in-memory


var defaultCodeCell = Object.freeze({
  cell_type: "code",
  execution_count: null,
  metadata: Immutable.Map({
    collapsed: false,
    outputHidden: false,
    inputHidden: false
  }),
  source: "",
  outputs: Immutable.List()
});

var defaultMarkdownCell = Object.freeze({
  cell_type: "markdown",
  metadata: Immutable.Map(),
  source: ""
});

function createCodeCell() {
  var cell = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultCodeCell;

  // $FlowFixMe: Immutable
  return Immutable.Map(cell);
}

function createMarkdownCell() {
  var cell = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMarkdownCell;

  // $FlowFixMe: Immutable
  return Immutable.Map(cell);
}

var emptyCodeCell = createCodeCell();
var emptyMarkdownCell = createMarkdownCell();

var defaultNotebook = Object.freeze({
  nbformat: 4,
  nbformat_minor: 4,
  metadata: new Immutable.Map(),
  cellOrder: new Immutable.List(),
  cellMap: new Immutable.Map()
});

function createNotebook() {
  var notebook = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultNotebook;

  // $FlowFixMe: Immutable
  return Immutable.Map(notebook);
}

var emptyNotebook = createNotebook();

// Intended to make it easy to use this with (temporary mutable cellOrder + cellMap)
function appendCell(cellStructure, immutableCell) {
  var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uuidv4();

  return {
    cellOrder: cellStructure.cellOrder.push(id),
    cellMap: cellStructure.cellMap.set(id, immutableCell)
  };
}

function appendCellToNotebook(immnb, immCell) {
  return immnb.withMutations(function (nb) {
    // $FlowFixMe: Fixed by making ImmutableNotebook a typed Record.
    var cellStructure = {
      cellOrder: nb.get("cellOrder"),
      // $FlowFixMe: Fixed by making ImmutableNotebook a typed Record.
      cellMap: nb.get("cellMap")
    };

    var _appendCell = appendCell(cellStructure, immCell),
        cellOrder = _appendCell.cellOrder,
        cellMap = _appendCell.cellMap;

    return nb.set("cellOrder", cellOrder).set("cellMap", cellMap);
  });
}

function insertCellAt(notebook, cell, cellID, index) {
  return notebook.withMutations(function (nb) {
    return nb.setIn(["cellMap", cellID], cell)
    // $FlowFixMe: Fixed by making ImmutableNotebook a typed record.
    .set("cellOrder", nb.get("cellOrder").insert(index, cellID));
  });
}

function insertCellAfter(notebook, cell, cellID, priorCellID) {
  return insertCellAt(notebook, cell, cellID,
  // $FlowFixMe: Fixed by making ImmutableNotebook a typed record.
  notebook.get("cellOrder").indexOf(priorCellID) + 1);
}

function removeCell(notebook, cellID) {
  return notebook.removeIn(["cellMap", cellID]).update("cellOrder", function (cellOrder) {
    return cellOrder.filterNot(function (id) {
      return id === cellID;
    });
  });
}

var monocellNotebook = appendCellToNotebook(emptyNotebook, emptyCodeCell);

module.exports = {
  emptyCodeCell: emptyCodeCell,
  emptyMarkdownCell: emptyMarkdownCell,
  emptyNotebook: emptyNotebook,
  monocellNotebook: monocellNotebook,

  createCodeCell: createCodeCell,
  createMarkdownCell: createMarkdownCell,
  createNotebook: createNotebook,

  removeCell: removeCell,
  insertCellAfter: insertCellAfter,
  insertCellAt: insertCellAt,
  appendCellToNotebook: appendCellToNotebook,
  appendCell: appendCell
};