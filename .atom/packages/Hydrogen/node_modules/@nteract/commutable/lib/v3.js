"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromJS = fromJS;

var _v = require("./v4");

/* eslint-disable array-callback-return, prefer-spread */
var Immutable = require("immutable");
var appendCell = require("./structures").appendCell;

function demultiline(s) {
  if (Array.isArray(s)) {
    return s.join("");
  }
  return s;
}

function createImmutableMarkdownCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: cell.cell_type,
    source: demultiline(cell.source),
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableMimeBundle(output) {
  var VALID_MIMETYPES = {
    text: "text/plain",
    latex: "text/latex",
    png: "image/png",
    jpeg: "image/jpeg",
    svg: "image/svg+xml",
    html: "text/html",
    javascript: "application/x-javascript",
    json: "application/javascript",
    pdf: "application/pdf",
    metadata: "",
    prompt_number: "",
    output_type: ""
  };
  var mimeBundle = {};
  Object.keys(output).map(function (key) {
    if (key !== "prompt_number" || key !== "metadata" || key !== "output_type") {
      mimeBundle[VALID_MIMETYPES[key]] = output[key];
    }
  });
  return Object.keys(mimeBundle).reduce(_v.cleanMimeAtKey.bind(null, mimeBundle), Immutable.Map());
}

function sanitize(o) {
  if (o.metadata) {
    return { metadata: Immutable.fromJS(o.metadata) };
  }
  return {};
}

function createImmutableOutput(output) {
  switch (output.output_type) {
    case "pyout":
      return Immutable.Map(Object.assign({}, {
        output_type: output.output_type,
        execution_count: output.prompt_number,
        data: createImmutableMimeBundle(output)
      }, sanitize(output)));
    case "display_data":
      return Immutable.Map(Object.assign({}, {
        output_type: output.output_type,
        data: createImmutableMimeBundle(output)
      }, sanitize(output)));
    case "stream":
      return Immutable.Map({
        output_type: output.output_type,
        name: output.stream,
        text: demultiline(output.text)
      });
    case "pyerr":
      return Immutable.Map({
        output_type: "error",
        ename: output.ename,
        evalue: output.evalue,
        traceback: Immutable.List(output.traceback)
      });
    default:
      throw new TypeError("Output type " + output.output_type + " not recognized");
  }
}

function createImmutableCodeCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: cell.cell_type,
    source: demultiline(cell.input),
    // $FlowFixMe: Immutable
    outputs: new Immutable.List(cell.outputs.map(createImmutableOutput)),
    execution_count: cell.prompt_number,
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableRawCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: cell.cell_type,
    source: demultiline(cell.source),
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableHeadingCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: "markdown",
    source: Array.isArray(cell.source) ? demultiline(cell.source.map(function (line) {
      return Array(cell.level).join("#").concat(" ").concat(line);
    })) : cell.source,
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableCell(cell) {
  switch (cell.cell_type) {
    case "markdown":
      return createImmutableMarkdownCell(cell);
    case "code":
      return createImmutableCodeCell(cell);
    case "raw":
      return createImmutableRawCell(cell);
    case "heading":
      return createImmutableHeadingCell(cell);
    default:
      throw new TypeError("Cell type " + cell.cell_type + " unknown");
  }
}

function fromJS(notebook) {
  if (notebook.nbformat !== 3 || notebook.nbformat_minor < 0) {
    throw new TypeError("Notebook is not a valid v3 notebook. v3 notebooks must be of form 3.x\n      It lists nbformat v" + notebook.nbformat + "." + notebook.nbformat_minor);
  }

  var starterCellStructure = {
    cellOrder: Immutable.List().asMutable(),
    cellMap: Immutable.Map().asMutable()
  };

  var cellStructure = [].concat.apply([], notebook.worksheets.map(function (worksheet) {
    return worksheet.cells.reduce(function (cellStruct, cell) {
      return appendCell(cellStruct, createImmutableCell(cell));
    }, starterCellStructure);
  }))[0];

  return Immutable.Map({
    cellOrder: cellStructure.cellOrder.asImmutable(),
    cellMap: cellStructure.cellMap.asImmutable(),
    nbformat_minor: notebook.nbformat_minor,
    nbformat: 4,
    metadata: Immutable.fromJS(notebook.metadata)
  });
}