"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cleanMimeData = cleanMimeData;
exports.cleanMimeAtKey = cleanMimeAtKey;
exports.createImmutableMimeBundle = createImmutableMimeBundle;
exports.createImmutableOutput = createImmutableOutput;
exports.fromJS = fromJS;
exports.toJS = toJS;


/*
 * Functions in this module are provided for converting from Jupyter Notebook
 * Format v4 to nteract's in-memory format, affectionately referred to as
 * commutable.
 *
 * See: https://github.com/jupyter/nbformat/blob/62d6eb8803616d198eaa2024604d1fe923f2a7b3/nbformat/v4/nbformat.v4.schema.json
 *
 * The main goal here is consistency and compliance with the v4 spec. The types
 * contained in here (non Immutable ones) are constrained to the disk based
 * notebook format.
 *
 * To assist in the developer experience, types are included through the use of
 * flow.
 *
 */

var Immutable = require("immutable");
var appendCell = require("./structures").appendCell;

//
// MimeBundle example (disk format)
//
// {
//   "application/json": {"a": 3, "b": 2},
//   "text/html": ["<p>\n", "Hey\n", "</p>"],
//   "text/plain": "Hey"
// }
//


// On disk multi-line strings are used to accomodate line-by-line diffs in tools
// like git and GitHub. They get converted to strings for the in-memory format.


/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                             Output Types
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


/** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                              Cell Types
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


function demultiline(s) {
  if (Array.isArray(s)) {
    return s.join("");
  }
  return s;
}

/**
 * Split string into a list of strings delimited by newlines
 */
function remultiline(s) {
  if (Array.isArray(s)) {
    // Assume
    return s;
  }
  // Use positive lookahead regex to split on newline and retain newline char
  return s.split(/(.+?(?:\r\n|\n))/g).filter(function (x) {
    return x !== "";
  });
}

function isJSONKey(key) {
  return (/^application\/(.*\+)?json$/.test(key)
  );
}

function cleanMimeData(key, data) {
  // See https://github.com/jupyter/nbformat/blob/62d6eb8803616d198eaa2024604d1fe923f2a7b3/nbformat/v4/nbformat.v4.schema.json#L368
  if (isJSONKey(key)) {
    // Data stays as is for JSON types
    return data;
  }

  if (typeof data === "string" || Array.isArray(data)) {
    return demultiline(data);
  }

  throw new TypeError("Data for " + key + " is expected to be a string or an Array of strings");
}

function cleanMimeAtKey(mimeBundle, previous, key) {
  return previous.set(key, cleanMimeData(key, mimeBundle[key]));
}

function createImmutableMimeBundle(mimeBundle) {
  // Map over all the mimetypes, turning them into our in-memory format
  //
  // {
  //   "application/json": {"a": 3, "b": 2},
  //   "text/html": ["<p>\n", "Hey\n", "</p>"],
  //   "text/plain": "Hey"
  // }
  //
  // to
  //
  // {
  //   "application/json": {"a": 3, "b": 2},
  //   "text/html": "<p>\nHey\n</p>",
  //   "text/plain": "Hey"
  // }
  //
  return Object.keys(mimeBundle).reduce(cleanMimeAtKey.bind(null, mimeBundle), Immutable.Map());
}

function sanitize(o) {
  if (o.metadata) {
    return { metadata: Immutable.fromJS(o.metadata) };
  }
  return {};
}

function createImmutableOutput(output) {
  switch (output.output_type) {
    case "execute_result":
      return Immutable.Map(Object.assign({}, {
        output_type: output.output_type,
        execution_count: output.execution_count,
        data: createImmutableMimeBundle(output.data)
      }, sanitize(output)));
    case "display_data":
      return Immutable.Map(Object.assign({}, {
        output_type: output.output_type,
        data: createImmutableMimeBundle(output.data)
      }, sanitize(output)));
    case "stream":
      return Immutable.Map({
        output_type: output.output_type,
        name: output.name,
        text: demultiline(output.text)
      });
    case "error":
      return Immutable.Map({
        output_type: "error",
        ename: output.ename,
        evalue: output.evalue,
        // Note: this is one of the cases where the Array of strings (for traceback)
        // is part of the format, not a multiline string
        traceback: Immutable.List(output.traceback)
      });
    default:
      throw new TypeError("Output type " + output.output_type + " not recognized");
  }
}

function createImmutableRawCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: cell.cell_type,
    source: demultiline(cell.source),
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableMarkdownCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: cell.cell_type,
    source: demultiline(cell.source),
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableCodeCell(cell) {
  // $FlowFixMe: Immutable
  return new Immutable.Map({
    cell_type: cell.cell_type,
    source: demultiline(cell.source),
    // $FlowFixMe: Immutable
    outputs: new Immutable.List(cell.outputs.map(createImmutableOutput)),
    execution_count: cell.execution_count,
    metadata: Immutable.fromJS(cell.metadata)
  });
}

function createImmutableCell(cell) {
  switch (cell.cell_type) {
    case "markdown":
      return createImmutableMarkdownCell(cell);
    case "code":
      return createImmutableCodeCell(cell);
    case "raw":
      return createImmutableRawCell(cell);
    default:
      throw new TypeError("Cell type " + cell.cell_type + " unknown");
  }
}

function fromJS(notebook) {
  if (notebook.nbformat !== 4 || notebook.nbformat_minor < 0) {
    throw new TypeError("Notebook is not a valid v4 notebook. v4 notebooks must be of form 4.x\n       It lists nbformat v" + notebook.nbformat + "." + notebook.nbformat_minor);
  }

  // Since we're doing N cell operations all at once, switch to mutable then
  // switch back after.
  var starterCellStructure = {
    cellOrder: Immutable.List().asMutable(),
    cellMap: Immutable.Map().asMutable()
  };

  var cellStructure = notebook.cells.reduce(function (cellStruct, cell) {
    return appendCell(cellStruct, createImmutableCell(cell));
  }, starterCellStructure);

  return Immutable.Map({
    cellOrder: cellStructure.cellOrder.asImmutable(),
    cellMap: cellStructure.cellMap.asImmutable(),
    nbformat_minor: notebook.nbformat_minor,
    nbformat: 4,
    metadata: Immutable.fromJS(notebook.metadata)
  });
}

function markdownCellToJS(immCell) {
  // $FlowFixMe: With Immutable we can not properly type this
  var cell = immCell.toObject();

  // $FlowFixMe: Fails now as a result of the above.
  return {
    cell_type: "markdown",
    source: remultiline(cell.source),
    metadata: Immutable.fromJS(cell.metadata)
  };
}

function mimeBundleToJS(immMimeBundle) {
  var bundle = immMimeBundle.toObject();

  Object.keys(bundle).map(function (key) {
    if (isJSONKey(key)) {
      if (Immutable.Map.isMap(bundle[key])) {
        bundle[key] = bundle[key].toJS();
      }
      return bundle;
    }

    var data = bundle[key];

    if (typeof data === "string" || Array.isArray(data)) {
      bundle[key] = remultiline(data);
      return bundle;
    }
    throw new TypeError("Data for " + key + " is expected to be a string or an Array of strings");
  });

  return bundle;
}

function outputToJS(immOutput) {
  // Technically this is an intermediate output with Immutables inside
  var output = immOutput.toObject();

  switch (output.output_type) {
    case "execute_result":
      return {
        output_type: output.output_type,
        execution_count: output.execution_count,
        data: mimeBundleToJS(output.data),
        metadata: output.metadata.toJS()
      };
    case "display_data":
      return {
        output_type: output.output_type,
        data: mimeBundleToJS(output.data),
        metadata: output.metadata.toJS()
      };
    case "stream":
      return {
        output_type: output.output_type,
        name: output.name,
        text: remultiline(output.text)
      };
    case "error":
      // Note: this is one of the cases where the Array of strings (for traceback)
      // is part of the format, not a multiline string
      // $FlowFixMe: Need to expand scope of Output type.
      return immOutput.toJS();
    default:
      throw new TypeError("Output type " + output.output_type + " not recognized");
  }
}

function codeCellToJS(immCell) {
  // $FlowFixMe: With Immutable we can not properly type this
  var cell = immCell.toObject();

  // $FlowFixMe: Ditto above.
  return {
    cell_type: "code",
    source: remultiline(cell.source),
    outputs: cell.outputs.map(outputToJS).toArray(),
    execution_count: cell.execution_count,
    metadata: Immutable.fromJS(cell.metadata)
  };
}

function rawCellToJS(immCell) {
  // $FlowFixMe: With Immutable we can not properly type this
  var cell = immCell.toObject();

  // $FlowFixMe: Ditto above. Cells should be Records.
  return {
    cell_type: "raw",
    source: remultiline(cell.source),
    metadata: Immutable.fromJS(cell.metadata)
  };
}

function cellToJS(immCell) {
  // $FlowFixMe: Cell needs to be a typed record.
  var cellType = immCell.get("cell_type");
  switch (cellType) {
    case "markdown":
      return markdownCellToJS(immCell);
    case "code":
      return codeCellToJS(immCell);
    case "raw":
      return rawCellToJS(immCell);
    default:
      throw new TypeError("Cell type " + cellType + " unknown");
  }
}

function toJS(immnb) {
  // $FlowFixMe: With Immutable we can not properly type this
  var plainNotebook = immnb.toObject();

  var plainCellOrder = plainNotebook.cellOrder.toArray();
  var plainCellMap = plainNotebook.cellMap.toObject();

  var cells = plainCellOrder.map(function (cellID) {
    return cellToJS(plainCellMap[cellID]);
  });

  return {
    cells: cells,
    metadata: plainNotebook.metadata.toJS(),
    nbformat: plainNotebook.nbformat,
    nbformat_minor: plainNotebook.nbformat_minor
  };
}