"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.displayOrder = exports.transforms = exports.standardDisplayOrder = exports.standardTransforms = undefined;
exports.registerTransform = registerTransform;
exports.richestMimetype = richestMimetype;

var _immutable = require("immutable");

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _text = require("./text");

var _text2 = _interopRequireDefault(_text);

var _json = require("./json");

var _json2 = _interopRequireDefault(_json);

var _javascript = require("./javascript");

var _javascript2 = _interopRequireDefault(_javascript);

var _html = require("./html");

var _html2 = _interopRequireDefault(_html);

var _markdown = require("./markdown");

var _markdown2 = _interopRequireDefault(_markdown);

var _latex = require("./latex");

var _latex2 = _interopRequireDefault(_latex);

var _svg = require("./svg");

var _svg2 = _interopRequireDefault(_svg);

var _image = require("./image");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-enable no-unused-vars */

var standardTransforms = exports.standardTransforms = new _immutable.Map({
  "text/plain": _text2.default,
  "image/png": _image.PNGDisplay,
  "image/jpeg": _image.JPEGDisplay,
  "image/gif": _image.GIFDisplay,
  "image/svg+xml": _svg2.default,
  "text/html": _html2.default,
  "text/markdown": _markdown2.default,
  "text/latex": _latex2.default,
  "application/json": _json2.default,
  "application/javascript": _javascript2.default
});

// Needed for flow
/* eslint-disable no-unused-vars */
var standardDisplayOrder = exports.standardDisplayOrder = new _immutable.List(["application/json", "application/javascript", "text/html", "image/svg+xml", "text/markdown", "text/latex", "image/svg+xml", "image/gif", "image/png", "image/jpeg", "application/pdf", "text/plain"]);

function registerTransform(_ref, transform) {
  var transforms = _ref.transforms,
      displayOrder = _ref.displayOrder;

  return {
    transforms: transforms.set(transform.MIMETYPE, transform),
    displayOrder: displayOrder.insert(0, transform.MIMETYPE)
  };
}

/**
 * Choose the richest mimetype available based on the displayOrder and transforms
 * @param  {ImmutableMap}   bundle - Map({mimetype1: data1, mimetype2: data2, ...})
 * @param  {ImmutableList}  ordered list of mimetypes - List(['text/html', 'text/plain'])
 * @param  {ImmutableMap}   mimetype -> React Component - Map({'text/plain': TextTransform})
 * @return {string}          Richest mimetype
 */

function richestMimetype(bundle) {
  var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : standardDisplayOrder;
  var tf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : standardTransforms;

  return bundle.keySeq()
  // we can only use those we have a transform for
  .filter(function (mimetype) {
    return tf.has(mimetype) && order.includes(mimetype);
  })
  // the richest is based on the order in displayOrder
  .sortBy(function (mimetype) {
    return order.indexOf(mimetype);
  }).first();
}
var transforms = exports.transforms = standardTransforms;
var displayOrder = exports.displayOrder = standardDisplayOrder;