"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.displayOrder = exports.transforms = exports.standardDisplayOrder = exports.standardTransforms = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.registerTransform = registerTransform;
exports.richestMimetype = richestMimetype;

var _text = require("./text");

var _text2 = _interopRequireDefault(_text);

var _json = require("./json");

var _json2 = _interopRequireDefault(_json);

var _javascript = require("./javascript");

var _javascript2 = _interopRequireDefault(_javascript);

var _html = require("./html");

var _html2 = _interopRequireDefault(_html);

var _markdown = require("./markdown");

var _markdown2 = _interopRequireDefault(_markdown);

var _latex = require("./latex");

var _latex2 = _interopRequireDefault(_latex);

var _svg = require("./svg");

var _svg2 = _interopRequireDefault(_svg);

var _image = require("./image");

var _transformVdom = require("@nteract/transform-vdom");

var _transformVdom2 = _interopRequireDefault(_transformVdom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var tfs = [_transformVdom2.default, _json2.default, _javascript2.default, _html2.default, _markdown2.default, _latex2.default, _svg2.default, _image.GIFDisplay, _image.PNGDisplay, _image.JPEGDisplay, _text2.default];

var standardTransforms = exports.standardTransforms = {};

tfs.forEach(function (transform) {
  standardTransforms[transform.MIMETYPE] = transform;
});

var standardDisplayOrder = exports.standardDisplayOrder = tfs.map(function (transform) {
  return transform.MIMETYPE;
});

function registerTransform(_ref, transform) {
  var transforms = _ref.transforms,
      displayOrder = _ref.displayOrder;

  return {
    transforms: _extends({}, transforms, _defineProperty({}, transform.MIMETYPE, transform)),
    displayOrder: [transform.MIMETYPE].concat(_toConsumableArray(displayOrder))
  };
}

/**
 * Choose the richest mimetype available based on the displayOrder and transforms
 * @param  {Map}   bundle - Map({mimetype1: data1, mimetype2: data2, ...})
 * @param  {Array} ordered list of mimetypes - ['text/html', 'text/plain']
 * @param  {Map}   mimetype -> React Component - Map({'text/plain': TextTransform})
 * @return {string}          Richest mimetype
 */

function richestMimetype(bundle) {
  var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : standardDisplayOrder;
  var tf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : standardTransforms;

  return [].concat(_toConsumableArray(Object.keys(bundle)))
  // we can only use those we have a transform for
  .filter(function (mimetype) {
    return tf[mimetype] && order.includes(mimetype);
  })
  // the richest is based on the order in displayOrder
  .sort(function (a, b) {
    return order.indexOf(a) - order.indexOf(b);
  })[0];
}
var transforms = exports.transforms = standardTransforms;
var displayOrder = exports.displayOrder = standardDisplayOrder;