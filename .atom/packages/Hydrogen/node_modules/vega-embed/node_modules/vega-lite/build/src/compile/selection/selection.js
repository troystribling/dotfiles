"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var vega_event_selector_1 = require("vega-event-selector");
var channel_1 = require("../../channel");
var log_1 = require("../../log");
var selection_1 = require("../../selection");
var util_1 = require("../../util");
var model_1 = require("../model");
var interval_1 = require("./interval");
var multi_1 = require("./multi");
var single_1 = require("./single");
var transforms_1 = require("./transforms/transforms");
exports.STORE = '_store';
exports.TUPLE = '_tuple';
exports.MODIFY = '_modify';
exports.SELECTION_DOMAIN = '_selection_domain_';
function parseUnitSelection(model, selDefs) {
    var selCmpts = {};
    var selectionConfig = model.config.selection;
    var _loop_1 = function (name_1) {
        if (!selDefs.hasOwnProperty(name_1)) {
            return "continue";
        }
        var selDef = selDefs[name_1];
        var cfg = selectionConfig[selDef.type];
        // Set default values from config if a property hasn't been specified,
        // or if it is true. E.g., "translate": true should use the default
        // event handlers for translate. However, true may be a valid value for
        // a property (e.g., "nearest": true).
        for (var key in cfg) {
            // A selection should contain either `encodings` or `fields`, only use
            // default values for these two values if neither of them is specified.
            if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {
                continue;
            }
            if (key === 'mark') {
                selDef[key] = __assign({}, cfg[key], selDef[key]);
            }
            if (selDef[key] === undefined || selDef[key] === true) {
                selDef[key] = cfg[key] || selDef[key];
            }
        }
        name_1 = util_1.varName(name_1);
        var selCmpt = selCmpts[name_1] = __assign({}, selDef, { name: name_1, events: util_1.isString(selDef.on) ? vega_event_selector_1.selector(selDef.on, 'scope') : selDef.on });
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.parse) {
                txCompiler.parse(model, selDef, selCmpt);
            }
        });
    };
    for (var name_1 in selDefs) {
        _loop_1(name_1);
    }
    return selCmpts;
}
exports.parseUnitSelection = parseUnitSelection;
function assembleUnitSelectionSignals(model, signals) {
    forEachSelection(model, function (selCmpt, selCompiler) {
        var name = selCmpt.name;
        var modifyExpr = selCompiler.modifyExpr(model, selCmpt);
        signals.push.apply(signals, selCompiler.signals(model, selCmpt));
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.signals) {
                signals = txCompiler.signals(model, selCmpt, signals);
            }
            if (txCompiler.modifyExpr) {
                modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);
            }
        });
        signals.push({
            name: name + exports.MODIFY,
            on: [{
                    events: { signal: name + exports.TUPLE },
                    update: "modify(" + util_1.stringValue(selCmpt.name + exports.STORE) + ", " + modifyExpr + ")"
                }]
        });
    });
    var facetModel = getFacetModel(model);
    if (signals.length && facetModel) {
        var name_2 = util_1.stringValue(facetModel.getName('cell'));
        signals.unshift({
            name: 'facet',
            value: {},
            on: [{
                    events: vega_event_selector_1.selector('mousemove', 'scope'),
                    update: "isTuple(facet) ? facet : group(" + name_2 + ").datum"
                }]
        });
    }
    return signals;
}
exports.assembleUnitSelectionSignals = assembleUnitSelectionSignals;
function assembleTopLevelSignals(model, signals) {
    var needsUnit = false;
    forEachSelection(model, function (selCmpt, selCompiler) {
        if (selCompiler.topLevelSignals) {
            signals = selCompiler.topLevelSignals(model, selCmpt, signals);
        }
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.topLevelSignals) {
                signals = txCompiler.topLevelSignals(model, selCmpt, signals);
            }
        });
        needsUnit = true;
    });
    if (needsUnit) {
        var hasUnit = signals.filter(function (s) { return s.name === 'unit'; });
        if (!(hasUnit.length)) {
            signals.unshift({
                name: 'unit',
                value: {},
                on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }]
            });
        }
    }
    return signals;
}
exports.assembleTopLevelSignals = assembleTopLevelSignals;
function assembleUnitSelectionData(model, data) {
    forEachSelection(model, function (selCmpt) {
        var contains = data.filter(function (d) { return d.name === selCmpt.name + exports.STORE; });
        if (!contains.length) {
            data.push({ name: selCmpt.name + exports.STORE });
        }
    });
    return data;
}
exports.assembleUnitSelectionData = assembleUnitSelectionData;
function assembleUnitSelectionMarks(model, marks) {
    forEachSelection(model, function (selCmpt, selCompiler) {
        marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;
        transforms_1.forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.marks) {
                marks = txCompiler.marks(model, selCmpt, marks);
            }
        });
    });
    return marks;
}
exports.assembleUnitSelectionMarks = assembleUnitSelectionMarks;
function assembleLayerSelectionMarks(model, marks) {
    model.children.forEach(function (child) {
        if (model_1.isUnitModel(child)) {
            marks = assembleUnitSelectionMarks(child, marks);
        }
    });
    return marks;
}
exports.assembleLayerSelectionMarks = assembleLayerSelectionMarks;
function selectionPredicate(model, selections, dfnode) {
    var stores = [];
    function expr(name) {
        var vname = util_1.varName(name);
        var selCmpt = model.getSelectionComponent(vname, name);
        var store = util_1.stringValue(vname + exports.STORE);
        if (selCmpt.timeUnit) {
            var child = dfnode || model.component.data.raw;
            var tunode = selCmpt.timeUnit.clone();
            if (child.parent) {
                tunode.insertAsParentOf(child);
            }
            else {
                child.parent = tunode;
            }
        }
        if (selCmpt.empty !== 'none') {
            stores.push(store);
        }
        return compiler(selCmpt.type).predicate + ("(" + store + ", datum") +
            (selCmpt.resolve === 'global' ? ')' : ", " + util_1.stringValue(selCmpt.resolve) + ")");
    }
    var predicateStr = util_1.logicalExpr(selections, expr);
    return (stores.length
        ? '!(' + stores.map(function (s) { return "length(data(" + s + "))"; }).join(' || ') + ') || '
        : '') + ("(" + predicateStr + ")");
}
exports.selectionPredicate = selectionPredicate;
// Selections are parsed _after_ scales. If a scale domain is set to
// use a selection, the SELECTION_DOMAIN constant is used as the
// domainRaw.signal during scale.parse and then replaced with the necessary
// selection expression function during scale.assemble. To not pollute the
// type signatures to account for this setup, the selection domain definition
// is coerced to a string and appended to SELECTION_DOMAIN.
function isRawSelectionDomain(domainRaw) {
    return domainRaw.signal.indexOf(exports.SELECTION_DOMAIN) >= 0;
}
exports.isRawSelectionDomain = isRawSelectionDomain;
function selectionScaleDomain(model, domainRaw) {
    var selDomain = JSON.parse(domainRaw.signal.replace(exports.SELECTION_DOMAIN, ''));
    var name = util_1.varName(selDomain.selection);
    var selCmpt = model.component.selection && model.component.selection[name];
    if (selCmpt) {
        log_1.warn('Use "bind": "scales" to setup a binding for scales and selections within the same view.');
    }
    else {
        selCmpt = model.getSelectionComponent(name, selDomain.selection);
        if (!selDomain.encoding && !selDomain.field) {
            selDomain.field = selCmpt.project[0].field;
            if (selCmpt.project.length > 1) {
                log_1.warn('A "field" or "encoding" must be specified when using a selection as a scale domain. ' +
                    ("Using \"field\": " + util_1.stringValue(selDomain.field) + "."));
            }
        }
        return {
            signal: compiler(selCmpt.type).scaleDomain +
                ("(" + util_1.stringValue(name + exports.STORE) + ", " + util_1.stringValue(selDomain.encoding || null) + ", ") +
                util_1.stringValue(selDomain.field || null) +
                (selCmpt.resolve === 'global' ? ')' : ", " + util_1.stringValue(selCmpt.resolve) + ")")
        };
    }
    return { signal: 'null' };
}
exports.selectionScaleDomain = selectionScaleDomain;
// Utility functions
function forEachSelection(model, cb) {
    var selections = model.component.selection;
    for (var name_3 in selections) {
        if (selections.hasOwnProperty(name_3)) {
            var sel = selections[name_3];
            cb(sel, compiler(sel.type));
        }
    }
}
function compiler(type) {
    switch (type) {
        case 'single':
            return single_1.default;
        case 'multi':
            return multi_1.default;
        case 'interval':
            return interval_1.default;
    }
    return null;
}
function getFacetModel(model) {
    var parent = model.parent;
    while (parent) {
        if (model_1.isFacetModel(parent)) {
            break;
        }
        parent = parent.parent;
    }
    return parent;
}
function unitName(model) {
    var name = util_1.stringValue(model.name);
    var facet = getFacetModel(model);
    if (facet) {
        name += (facet.facet.row ? " + '_' + facet" + util_1.accessPath(facet.vgField('row')) : '')
            + (facet.facet.column ? " + '_' + facet" + util_1.accessPath(facet.vgField('column')) : '');
    }
    return name;
}
exports.unitName = unitName;
function requiresSelectionId(model) {
    var identifier = false;
    forEachSelection(model, function (selCmpt) {
        identifier = identifier || selCmpt.project.some(function (proj) { return proj.field === selection_1.SELECTION_ID; });
    });
    return identifier;
}
exports.requiresSelectionId = requiresSelectionId;
function channelSignalName(selCmpt, channel, range) {
    return util_1.varName(selCmpt.name + '_' + (range === 'visual' ? channel : selCmpt.fields[channel]));
}
exports.channelSignalName = channelSignalName;
function positionalProjections(selCmpt) {
    var x = null;
    var xi = null;
    var y = null;
    var yi = null;
    selCmpt.project.forEach(function (p, i) {
        if (p.channel === channel_1.X) {
            x = p;
            xi = i;
        }
        else if (p.channel === channel_1.Y) {
            y = p;
            yi = i;
        }
    });
    return { x: x, xi: xi, y: y, yi: yi };
}
exports.positionalProjections = positionalProjections;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3NlbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsMkRBQThEO0FBQzlELHlDQUEwRDtBQUMxRCxpQ0FBK0I7QUFFL0IsNkNBQTRHO0FBQzVHLG1DQUF5RjtBQU16RixrQ0FBMEQ7QUFFMUQsdUNBQTBDO0FBQzFDLGlDQUFvQztBQUVwQyxtQ0FBc0M7QUFDdEMsc0RBQXlEO0FBRzVDLFFBQUEsS0FBSyxHQUFHLFFBQVEsQ0FBQztBQUNqQixRQUFBLEtBQUssR0FBRyxRQUFRLENBQUM7QUFDakIsUUFBQSxNQUFNLEdBQUcsU0FBUyxDQUFDO0FBQ25CLFFBQUEsZ0JBQWdCLEdBQUcsb0JBQW9CLENBQUM7QUFxQ3JELDRCQUFtQyxLQUFnQixFQUFFLE9BQTJCO0lBQzlFLElBQU0sUUFBUSxHQUE2QixFQUFFLENBQUM7SUFDOUMsSUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7NEJBRXRDLE1BQUk7UUFDWCxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDOztRQUVwQyxDQUFDO1FBRUQsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQUksQ0FBQyxDQUFDO1FBQzdCLElBQU0sR0FBRyxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFekMsc0VBQXNFO1FBQ3RFLG1FQUFtRTtRQUNuRSx1RUFBdUU7UUFDdkUsc0NBQXNDO1FBQ3RDLEdBQUcsQ0FBQyxDQUFDLElBQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDdEIsc0VBQXNFO1lBQ3RFLHVFQUF1RTtZQUN2RSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxXQUFXLElBQUksTUFBTSxDQUFD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Q0FBQyxVQUFDLENBQUMsRUFBRSxDQUFDO1FBQzNCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEtBQUssV0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ04sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNULENBQUM7UUFBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sS0FBSyxXQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzNCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDTixFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ1QsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxDQUFDLEVBQUMsQ0FBQyxHQUFBLEVBQUUsRUFBRSxJQUFBLEVBQUUsQ0FBQyxHQUFBLEVBQUUsRUFBRSxJQUFBLEVBQUMsQ0FBQztBQUN4QixDQUFDO0FBaEJELHNEQWdCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c2VsZWN0b3IgYXMgcGFyc2VTZWxlY3Rvcn0gZnJvbSAndmVnYS1ldmVudC1zZWxlY3Rvcic7XG5pbXBvcnQge0NoYW5uZWwsIFNjYWxlQ2hhbm5lbCwgWCwgWX0gZnJvbSAnLi4vLi4vY2hhbm5lbCc7XG5pbXBvcnQge3dhcm59IGZyb20gJy4uLy4uL2xvZyc7XG5pbXBvcnQge0xvZ2ljYWxPcGVyYW5kfSBmcm9tICcuLi8uLi9sb2dpY2FsJztcbmltcG9ydCB7QnJ1c2hDb25maWcsIFNFTEVDVElPTl9JRCwgU2VsZWN0aW9uRGVmLCBTZWxlY3Rpb25SZXNvbHV0aW9uLCBTZWxlY3Rpb25UeXBlfSBmcm9tICcuLi8uLi9zZWxlY3Rpb24nO1xuaW1wb3J0IHthY2Nlc3NQYXRoLCBEaWN0LCBpc1N0cmluZywgbG9naWNhbEV4cHIsIHN0cmluZ1ZhbHVlLCB2YXJOYW1lfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7VmdCaW5kaW5nLCBWZ0RhdGEsIFZnRXZlbnRTdHJlYW0sIFZnU2lnbmFsUmVmfSBmcm9tICcuLi8uLi92ZWdhLnNjaGVtYSc7XG5pbXBvcnQge0RhdGFGbG93Tm9kZX0gZnJvbSAnLi4vZGF0YS9kYXRhZmxvdyc7XG5pbXBvcnQge1RpbWVVbml0Tm9kZX0gZnJvbSAnLi4vZGF0YS90aW1ldW5pdCc7XG5pbXBvcnQge0ZhY2V0TW9kZWx9IGZyb20gJy4uL2ZhY2V0JztcbmltcG9ydCB7TGF5ZXJNb2RlbH0gZnJvbSAnLi4vbGF5ZXInO1xuaW1wb3J0IHtpc0ZhY2V0TW9kZWwsIGlzVW5pdE1vZGVsLCBNb2RlbH0gZnJvbSAnLi4vbW9kZWwnO1xuaW1wb3J0IHtVbml0TW9kZWx9IGZyb20gJy4uL3VuaXQnO1xuaW1wb3J0IGludGVydmFsQ29tcGlsZXIgZnJvbSAnLi9pbnRlcnZhbCc7XG5pbXBvcnQgbXVsdGlDb21waWxlciBmcm9tICcuL211bHRpJztcbmltcG9ydCB7U2VsZWN0aW9uQ29tcG9uZW50fSBmcm9tICcuL3NlbGVjdGlvbic7XG5pbXBvcnQgc2luZ2xlQ29tcGlsZXIgZnJvbSAnLi9zaW5nbGUnO1xuaW1wb3J0IHtmb3JFYWNoVHJhbnNmb3JtfSBmcm9tICcuL3RyYW5zZm9ybXMvdHJhbnNmb3Jtcyc7XG5cblxuZXhwb3J0IGNvbnN0IFNUT1JFID0gJ19zdG9yZSc7XG5leHBvcnQgY29uc3QgVFVQTEUgPSAnX3R1cGxlJztcbmV4cG9ydCBjb25zdCBNT0RJRlkgPSAnX21vZGlmeSc7XG5leHBvcnQgY29uc3QgU0VMRUNUSU9OX0RPTUFJTiA9ICdfc2VsZWN0aW9uX2RvbWFpbl8nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvbkNvbXBvbmVudCB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogU2VsZWN0aW9uVHlwZTtcbiAgZXZlbnRzOiBWZ0V2ZW50U3RyZWFtO1xuICAvLyBwcmVkaWNhdGU/OiBzdHJpbmc7XG4gIGJpbmQ/OiAnc2NhbGVzJyB8IFZnQmluZGluZyB8IHtba2V5OiBzdHJpbmddOiBWZ0JpbmRpbmd9O1xuICByZXNvbHZlOiBTZWxlY3Rpb25SZXNvbHV0aW9uO1xuICBlbXB0eTogJ2FsbCcgfCAnbm9uZSc7XG4gIG1hcms/OiBCcnVzaENvbmZpZztcblxuICAvLyBUcmFuc2Zvcm1zXG4gIHByb2plY3Q/OiBQcm9qZWN0Q29tcG9uZW50W107XG4gIGZpZWxkcz86IGFueTtcbiAgdGltZVVuaXQ/OiBUaW1lVW5pdE5vZGU7XG4gIHNjYWxlcz86IENoYW5uZWxbXTtcbiAgdG9nZ2xlPzogYW55O1xuICB0cmFuc2xhdGU/OiBhbnk7XG4gIHpvb20/OiBhbnk7XG4gIG5lYXJlc3Q/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdENvbXBvbmVudCB7XG4gIGZpZWxkPzogc3RyaW5nO1xuICBjaGFubmVsPzogU2NhbGVDaGFubmVsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvbkNvbXBpbGVyIHtcbiAgc2lnbmFsczogKG1vZGVsOiBVbml0TW9kZWwsIHNlbENtcHQ6IFNlbGVjdGlvbkNvbXBvbmVudCkgPT4gYW55W107XG4gIHRvcExldmVsU2lnbmFscz86IChtb2RlbDogTW9kZWwsIHNlbENtcHQ6IFNlbGVjdGlvbkNvbXBvbmVudCwgc2lnbmFsczogYW55W10pID0+IGFueVtdO1xuICBtb2RpZnlFeHByOiAobW9kZWw6IFVuaXRNb2RlbCwgc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50KSA9PiBzdHJpbmc7XG4gIG1hcmtzPzogKG1vZGVsOiBVbml0TW9kZWwsIHNlbENtcHQ6U2VsZWN0aW9uQ29tcG9uZW50LCBtYXJrczogYW55W10pID0+IGFueVtdO1xuICBwcmVkaWNhdGU6IHN0cmluZzsgIC8vIFZlZ2EgZXhwciBzdHJpbmcgdG8gZGV0ZXJtaW5lIGluY2x1c2lvbiBpbiBzZWxlY3Rpb24uXG4gIHNjYWxlRG9tYWluOiBzdHJpbmc7ICAvLyBWZWdhIGV4cHIgc3RyaW5nIHRvIG1hdGVyaWFsaXplIGEgc2NhbGUgZG9tYWluLlxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0U2VsZWN0aW9uKG1vZGVsOiBVbml0TW9kZWwsIHNlbERlZnM6IERpY3Q8U2VsZWN0aW9uRGVmPikge1xuICBjb25zdCBzZWxDbXB0czogRGljdDxTZWxlY3Rpb25Db21wb25lbnQ+ID0ge307XG4gIGNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IG1vZGVsLmNvbmZpZy5zZWxlY3Rpb247XG5cbiAgZm9yIChsZXQgbmFtZSBpbiBzZWxEZWZzKSB7XG4gICAgaWYgKCFzZWxEZWZzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxEZWYgPSBzZWxEZWZzW25hbWVdO1xuICAgIGNvbnN0IGNmZyA9IHNlbGVjdGlvbkNvbmZpZ1tzZWxEZWYudHlwZV07XG5cbiAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgZnJvbSBjb25maWcgaWYgYSBwcm9wZXJ0eSBoYXNuJ3QgYmVlbiBzcGVjaWZpZWQsXG4gICAgLy8gb3IgaWYgaXQgaXMgdHJ1ZS4gRS5nLiwgXCJ0cmFuc2xhdGVcIjogdHJ1ZSBzaG91bGQgdXNlIHRoZSBkZWZhdWx0XG4gICAgLy8gZXZlbnQgaGFuZGxlcnMgZm9yIHRyYW5zbGF0ZS4gSG93ZXZlciwgdHJ1ZSBtYXkgYmUgYSB2YWxpZCB2YWx1ZSBmb3JcbiAgICAvLyBhIHByb3BlcnR5IChlLmcuLCBcIm5lYXJlc3RcIjogdHJ1ZSkuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2ZnKSB7XG4gICAgICAvLyBBIHNlbGVjdGlvbiBzaG91bGQgY29udGFpbiBlaXRoZXIgYGVuY29kaW5nc2Agb3IgYGZpZWxkc2AsIG9ubHkgdXNlXG4gICAgICAvLyBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlc2UgdHdvIHZhbHVlcyBpZiBuZWl0aGVyIG9mIHRoZW0gaXMgc3BlY2lmaWVkLlxuICAgICAgaWYgKChrZXkgPT09ICdlbmNvZGluZ3MnICYmIHNlbERlZi5maWVsZHMpIHx8IChrZXkgPT09ICdmaWVsZHMnICYmIHNlbERlZi5lbmNvZGluZ3MpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnbWFyaycpIHtcbiAgICAgICAgc2VsRGVmW2tleV0gPSB7Li4uY2ZnW2tleV0sIC4uLnNlbERlZltrZXldfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbERlZltrZXldID09PSB1bmRlZmluZWQgfHwgc2VsRGVmW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgc2VsRGVmW2tleV0gPSBjZmdba2V5XSB8fCBzZWxEZWZba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lID0gdmFyTmFtZShuYW1lKTtcbiAgICBjb25zdCBzZWxDbXB0ID0gc2VsQ21wdHNbbmFtZV0gPSB7XG4gICAgICAuLi5zZWxEZWYsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZXZlbnRzOiBpc1N0cmluZyhzZWxEZWYub24pID8gcGFyc2VTZWxlY3RvcihzZWxEZWYub24sICdzY29wZScpIDogc2VsRGVmLm9uLFxuICAgIH0gYXMgU2VsZWN0aW9uQ29tcG9uZW50O1xuXG4gICAgZm9yRWFjaFRyYW5zZm9ybShzZWxDbXB0LCB0eENvbXBpbGVyID0+IHtcbiAgICAgIGlmICh0eENvbXBpbGVyLnBhcnNlKSB7XG4gICAgICAgIHR4Q29tcGlsZXIucGFyc2UobW9kZWwsIHNlbERlZiwgc2VsQ21wdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2VsQ21wdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlbWJsZVVuaXRTZWxlY3Rpb25TaWduYWxzKG1vZGVsOiBVbml0TW9kZWwsIHNpZ25hbHM6IGFueVtdKSB7XG4gIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIChzZWxDbXB0LCBzZWxDb21waWxlcikgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBzZWxDbXB0Lm5hbWU7XG4gICAgbGV0IG1vZGlmeUV4cHIgPSBzZWxDb21waWxlci5tb2RpZnlFeHByKG1vZGVsLCBzZWxDbXB0KTtcblxuICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBzZWxDb21waWxlci5zaWduYWxzKG1vZGVsLCBzZWxDbXB0KSk7XG5cbiAgICBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIHR4Q29tcGlsZXIgPT4ge1xuICAgICAgaWYgKHR4Q29tcGlsZXIuc2lnbmFscykge1xuICAgICAgICBzaWduYWxzID0gdHhDb21waWxlci5zaWduYWxzKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eENvbXBpbGVyLm1vZGlmeUV4cHIpIHtcbiAgICAgICAgbW9kaWZ5RXhwciA9IHR4Q29tcGlsZXIubW9kaWZ5RXhwcihtb2RlbCwgc2VsQ21wdCwgbW9kaWZ5RXhwcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzaWduYWxzLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSArIE1PRElGWSxcbiAgICAgIG9uOiBbe1xuICAgICAgICBldmVudHM6IHtzaWduYWw6IG5hbWUgKyBUVVBMRX0sXG4gICAgICAgIHVwZGF0ZTogYG1vZGlmeSgke3N0cmluZ1ZhbHVlKHNlbENtcHQubmFtZSArIFNUT1JFKX0sICR7bW9kaWZ5RXhwcn0pYFxuICAgICAgfV1cbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgZmFjZXRNb2RlbCA9IGdldEZhY2V0TW9kZWwobW9kZWwpO1xuICBpZiAoc2lnbmFscy5sZW5ndGggJiYgZmFjZXRNb2RlbCkge1xuICAgIGNvbnN0IG5hbWUgPSBzdHJpbmdWYWx1ZShmYWNldE1vZGVsLmdldE5hbWUoJ2NlbGwnKSk7XG4gICAgc2lnbmFscy51bnNoaWZ0KHtcbiAgICAgIG5hbWU6ICdmYWNldCcsXG4gICAgICB2YWx1ZToge30sXG4gICAgICBvbjogW3tcbiAgICAgICAgZXZlbnRzOiBwYXJzZVNlbGVjdG9yKCdtb3VzZW1vdmUnLCAnc2NvcGUnKSxcbiAgICAgICAgdXBkYXRlOiBgaXNUdXBsZShmYWNldCkgPyBmYWNldCA6IGdyb3VwKCR7bmFtZX0pLmRhdHVtYFxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzaWduYWxzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVUb3BMZXZlbFNpZ25hbHMobW9kZWw6IFVuaXRNb2RlbCwgc2lnbmFsczogYW55W10pIHtcbiAgbGV0IG5lZWRzVW5pdCA9IGZhbHNlO1xuICBmb3JFYWNoU2VsZWN0aW9uKG1vZGVsLCAoc2VsQ21wdCwgc2VsQ29tcGlsZXIpID0+IHtcbiAgICBpZiAoc2VsQ29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKSB7XG4gICAgICBzaWduYWxzID0gc2VsQ29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIHR4Q29tcGlsZXIgPT4ge1xuICAgICAgaWYgKHR4Q29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKSB7XG4gICAgICAgIHNpZ25hbHMgPSB0eENvbXBpbGVyLnRvcExldmVsU2lnbmFscyhtb2RlbCwgc2VsQ21wdCwgc2lnbmFscyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBuZWVkc1VuaXQgPSB0cnVlO1xuICB9KTtcblxuICBpZiAobmVlZHNVbml0KSB7XG4gICAgY29uc3QgaGFzVW5pdCA9IHNpZ25hbHMuZmlsdGVyKChzKSA9PiBzLm5hbWUgPT09ICd1bml0Jyk7XG4gICAgaWYgKCEoaGFzVW5pdC5sZW5ndGgpKSB7XG4gICAgICBzaWduYWxzLnVuc2hpZnQoe1xuICAgICAgICBuYW1lOiAndW5pdCcsXG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgb246IFt7ZXZlbnRzOiAnbW91c2Vtb3ZlJywgdXBkYXRlOiAnaXNUdXBsZShncm91cCgpKSA/IGdyb3VwKCkgOiB1bml0J31dXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2lnbmFscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlVW5pdFNlbGVjdGlvbkRhdGEobW9kZWw6IFVuaXRNb2RlbCwgZGF0YTogVmdEYXRhW10pOiBWZ0RhdGFbXSB7XG4gIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIHNlbENtcHQgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5zID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubmFtZSA9PT0gc2VsQ21wdC5uYW1lICsgU1RPUkUpO1xuICAgIGlmICghY29udGFpbnMubGVuZ3RoKSB7XG4gICAgICBkYXRhLnB1c2goe25hbWU6IHNlbENtcHQubmFtZSArIFNUT1JFfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlVW5pdFNlbGVjdGlvbk1hcmtzKG1vZGVsOiBVbml0TW9kZWwsIG1hcmtzOiBhbnlbXSk6IGFueVtdIHtcbiAgZm9yRWFjaFNlbGVjdGlvbihtb2RlbCwgKHNlbENtcHQsIHNlbENvbXBpbGVyKSA9PiB7XG4gICAgbWFya3MgPSBzZWxDb21waWxlci5tYXJrcyA/IHNlbENvbXBpbGVyLm1hcmtzKG1vZGVsLCBzZWxDbXB0LCBtYXJrcykgOiBtYXJrcztcbiAgICBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsICh0eENvbXBpbGVyKSA9PiB7XG4gICAgICBpZiAodHhDb21waWxlci5tYXJrcykge1xuICAgICAgICBtYXJrcyA9IHR4Q29tcGlsZXIubWFya3MobW9kZWwsIHNlbENtcHQsIG1hcmtzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1hcmtzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVMYXllclNlbGVjdGlvbk1hcmtzKG1vZGVsOiBMYXllck1vZGVsLCBtYXJrczogYW55W10pOiBhbnlbXSB7XG4gIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGlmIChpc1VuaXRNb2RlbChjaGlsZCkpIHtcbiAgICAgIG1hcmtzID0gYXNzZW1ibGVVbml0U2VsZWN0aW9uTWFya3MoY2hpbGQsIG1hcmtzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBtYXJrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdGlvblByZWRpY2F0ZShtb2RlbDogTW9kZWwsIHNlbGVjdGlvbnM6IExvZ2ljYWxPcGVyYW5kPHN0cmluZz4sIGRmbm9kZT86IERhdGFGbG93Tm9kZSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0b3Jlczogc3RyaW5nW10gPSBbXTtcbiAgZnVuY3Rpb24gZXhwcihuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZuYW1lID0gdmFyTmFtZShuYW1lKTtcbiAgICBjb25zdCBzZWxDbXB0ID0gbW9kZWwuZ2V0U2VsZWN0aW9uQ29tcG9uZW50KHZuYW1lLCBuYW1lKTtcbiAgICBjb25zdCBzdG9yZSA9IHN0cmluZ1ZhbHVlKHZuYW1lICsgU1RPUkUpO1xuXG4gICAgaWYgKHNlbENtcHQudGltZVVuaXQpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGZub2RlIHx8IG1vZGVsLmNvbXBvbmVudC5kYXRhLnJhdztcbiAgICAgIGNvbnN0IHR1bm9kZSA9IHNlbENtcHQudGltZVVuaXQuY2xvbmUoKTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgdHVub2RlLmluc2VydEFzUGFyZW50T2YoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdHVub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxDbXB0LmVtcHR5ICE9PSAnbm9uZScpIHtcbiAgICAgIHN0b3Jlcy5wdXNoKHN0b3JlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGlsZXIoc2VsQ21wdC50eXBlKS5wcmVkaWNhdGUgKyBgKCR7c3RvcmV9LCBkYXR1bWAgK1xuICAgICAgKHNlbENtcHQucmVzb2x2ZSA9PT0gJ2dsb2JhbCcgPyAnKScgOiBgLCAke3N0cmluZ1ZhbHVlKHNlbENtcHQucmVzb2x2ZSl9KWApO1xuICB9XG5cbiAgY29uc3QgcHJlZGljYXRlU3RyID0gbG9naWNhbEV4cHIoc2VsZWN0aW9ucywgZXhwcik7XG4gIHJldHVybiAoc3RvcmVzLmxlbmd0aFxuICAgID8gJyEoJyArIHN0b3Jlcy5tYXAoKHMpID0+IGBsZW5ndGgoZGF0YSgke3N9KSlgKS5qb2luKCcgfHwgJykgKyAnKSB8fCAnXG4gICAgOiAnJ1xuICApICsgYCgke3ByZWRpY2F0ZVN0cn0pYDtcbn1cblxuLy8gU2VsZWN0aW9ucyBhcmUgcGFyc2VkIF9hZnRlcl8gc2NhbGVzLiBJZiBhIHNjYWxlIGRvbWFpbiBpcyBzZXQgdG9cbi8vIHVzZSBhIHNlbGVjdGlvbiwgdGhlIFNFTEVDVElPTl9ET01BSU4gY29uc3RhbnQgaXMgdXNlZCBhcyB0aGVcbi8vIGRvbWFpblJhdy5zaWduYWwgZHVyaW5nIHNjYWxlLnBhcnNlIGFuZCB0aGVuIHJlcGxhY2VkIHdpdGggdGhlIG5lY2Vzc2FyeVxuLy8gc2VsZWN0aW9uIGV4cHJlc3Npb24gZnVuY3Rpb24gZHVyaW5nIHNjYWxlLmFzc2VtYmxlLiBUbyBub3QgcG9sbHV0ZSB0aGVcbi8vIHR5cGUgc2lnbmF0dXJlcyB0byBhY2NvdW50IGZvciB0aGlzIHNldHVwLCB0aGUgc2VsZWN0aW9uIGRvbWFpbiBkZWZpbml0aW9uXG4vLyBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nIGFuZCBhcHBlbmRlZCB0byBTRUxFQ1RJT05fRE9NQUlOLlxuZXhwb3J0IGZ1bmN0aW9uIGlzUmF3U2VsZWN0aW9uRG9tYWluKGRvbWFpblJhdzogVmdTaWduYWxSZWYpIHtcbiAgcmV0dXJuIGRvbWFpblJhdy5zaWduYWwuaW5kZXhPZihTRUxFQ1RJT05fRE9NQUlOKSA+PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdGlvblNjYWxlRG9tYWluKG1vZGVsOiBNb2RlbCwgZG9tYWluUmF3OiBWZ1NpZ25hbFJlZik6IFZnU2lnbmFsUmVmIHtcbiAgY29uc3Qgc2VsRG9tYWluID0gSlNPTi5wYXJzZShkb21haW5SYXcuc2lnbmFsLnJlcGxhY2UoU0VMRUNUSU9OX0RPTUFJTiwgJycpKTtcbiAgY29uc3QgbmFtZSA9IHZhck5hbWUoc2VsRG9tYWluLnNlbGVjdGlvbik7XG5cbiAgbGV0IHNlbENtcHQgPSBtb2RlbC5jb21wb25lbnQuc2VsZWN0aW9uICYmIG1vZGVsLmNvbXBvbmVudC5zZWxlY3Rpb25bbmFtZV07XG4gIGlmIChzZWxDbXB0KSB7XG4gICAgd2FybignVXNlIFwiYmluZFwiOiBcInNjYWxlc1wiIHRvIHNldHVwIGEgYmluZGluZyBmb3Igc2NhbGVzIGFuZCBzZWxlY3Rpb25zIHdpdGhpbiB0aGUgc2FtZSB2aWV3LicpO1xuICB9IGVsc2Uge1xuICAgIHNlbENtcHQgPSBtb2RlbC5nZXRTZWxlY3Rpb25Db21wb25lbnQobmFtZSwgc2VsRG9tYWluLnNlbGVjdGlvbik7XG4gICAgaWYgKCFzZWxEb21haW4uZW5jb2RpbmcgJiYgIXNlbERvbWFpbi5maWVsZCkge1xuICAgICAgc2VsRG9tYWluLmZpZWxkID0gc2VsQ21wdC5wcm9qZWN0WzBdLmZpZWxkO1xuICAgICAgaWYgKHNlbENtcHQucHJvamVjdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHdhcm4oJ0EgXCJmaWVsZFwiIG9yIFwiZW5jb2RpbmdcIiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIHVzaW5nIGEgc2VsZWN0aW9uIGFzIGEgc2NhbGUgZG9tYWluLiAnICtcbiAgICAgICAgYFVzaW5nIFwiZmllbGRcIjogJHtzdHJpbmdWYWx1ZShzZWxEb21haW4uZmllbGQpfS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hbDogY29tcGlsZXIoc2VsQ21wdC50eXBlKS5zY2FsZURvbWFpbiArXG4gICAgICAgIGAoJHtzdHJpbmdWYWx1ZShuYW1lICsgU1RPUkUpfSwgJHtzdHJpbmdWYWx1ZShzZWxEb21haW4uZW5jb2RpbmcgfHwgbnVsbCl9LCBgICtcbiAgICAgICAgICBzdHJpbmdWYWx1ZShzZWxEb21haW4uZmllbGQgfHwgbnVsbCkgK1xuICAgICAgICAgIChzZWxDbXB0LnJlc29sdmUgPT09ICdnbG9iYWwnID8gJyknIDogYCwgJHtzdHJpbmdWYWx1ZShzZWxDbXB0LnJlc29sdmUpfSlgKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge3NpZ25hbDogJ251bGwnfTtcbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZm9yRWFjaFNlbGVjdGlvbihtb2RlbDogTW9kZWwsIGNiOiAoc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50LCBzZWxDb21waWxlcjogU2VsZWN0aW9uQ29tcGlsZXIpID0+IHZvaWQpIHtcbiAgY29uc3Qgc2VsZWN0aW9ucyA9IG1vZGVsLmNvbXBvbmVudC5zZWxlY3Rpb247XG4gIGZvciAoY29uc3QgbmFtZSBpbiBzZWxlY3Rpb25zKSB7XG4gICAgaWYgKHNlbGVjdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbnNbbmFtZV07XG4gICAgICBjYihzZWwsIGNvbXBpbGVyKHNlbC50eXBlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVyKHR5cGU6IFNlbGVjdGlvblR5cGUpOiBTZWxlY3Rpb25Db21waWxlciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICByZXR1cm4gc2luZ2xlQ29tcGlsZXI7XG4gICAgY2FzZSAnbXVsdGknOlxuICAgICAgcmV0dXJuIG11bHRpQ29tcGlsZXI7XG4gICAgY2FzZSAnaW50ZXJ2YWwnOlxuICAgICAgcmV0dXJuIGludGVydmFsQ29tcGlsZXI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0TW9kZWwobW9kZWw6IE1vZGVsKTogRmFjZXRNb2RlbCB7XG4gIGxldCBwYXJlbnQgPSBtb2RlbC5wYXJlbnQ7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoaXNGYWNldE1vZGVsKHBhcmVudCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudCBhcyBGYWNldE1vZGVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pdE5hbWUobW9kZWw6IE1vZGVsKSB7XG4gIGxldCBuYW1lID0gc3RyaW5nVmFsdWUobW9kZWwubmFtZSk7XG4gIGNvbnN0IGZhY2V0ID0gZ2V0RmFjZXRNb2RlbChtb2RlbCk7XG4gIGlmIChmYWNldCkge1xuICAgIG5hbWUgKz0gKGZhY2V0LmZhY2V0LnJvdyA/IGAgKyAnXycgKyBmYWNldCR7YWNjZXNzUGF0aChmYWNldC52Z0ZpZWxkKCdyb3cnKSl9YCA6ICcnKVxuICAgICAgKyAoZmFjZXQuZmFjZXQuY29sdW1uID8gYCArICdfJyArIGZhY2V0JHthY2Nlc3NQYXRoKGZhY2V0LnZnRmllbGQoJ2NvbHVtbicpKX1gIDogJycpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZXNTZWxlY3Rpb25JZChtb2RlbDogTW9kZWwpIHtcbiAgbGV0IGlkZW50aWZpZXIgPSBmYWxzZTtcbiAgZm9yRWFjaFNlbGVjdGlvbihtb2RlbCwgKHNlbENtcHQpID0+IHtcbiAgICBpZGVudGlmaWVyID0gaWRlbnRpZmllciB8fCBzZWxDbXB0LnByb2plY3Quc29tZSgocHJvaikgPT4gcHJvai5maWVsZCA9PT0gU0VMRUNUSU9OX0lEKTtcbiAgfSk7XG4gIHJldHVybiBpZGVudGlmaWVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhbm5lbFNpZ25hbE5hbWUoc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50LCBjaGFubmVsOiBDaGFubmVsLCByYW5nZTogJ3Zpc3VhbCcgfCAnZGF0YScpIHtcbiAgcmV0dXJuIHZhck5hbWUoc2VsQ21wdC5uYW1lICsgJ18nICsgKHJhbmdlID09PSAndmlzdWFsJyA/IGNoYW5uZWwgOiBzZWxDbXB0LmZpZWxkc1tjaGFubmVsXSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zaXRpb25hbFByb2plY3Rpb25zKHNlbENtcHQ6IFNlbGVjdGlvbkNvbXBvbmVudCkge1xuICBsZXQgeDpQcm9qZWN0Q29tcG9uZW50ID0gbnVsbDtcbiAgbGV0IHhpOm51bWJlciA9IG51bGw7XG4gIGxldCB5OlByb2plY3RDb21wb25lbnQgPSBudWxsO1xuICBsZXQgeWk6IG51bWJlciA9IG51bGw7XG5cbiAgc2VsQ21wdC5wcm9qZWN0LmZvckVhY2goKHAsIGkpID0+IHtcbiAgICBpZiAocC5jaGFubmVsID09PSBYKSB7XG4gICAgICB4ID0gcDtcbiAgICAgIHhpID0gaTtcbiAgICB9IGVsc2UgaWYgKHAuY2hhbm5lbCA9PT0gWSkge1xuICAgICAgeSA9IHA7XG4gICAgICB5aSA9IGk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHt4LCB4aSwgeSwgeWl9O1xufVxuIl19