{"version":3,"file":"channel.js","sourceRoot":"","sources":["../../src/channel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {Mark} from './mark';\nimport {EncodingFacetMapping, EncodingFacetMapping as ExtendedFacetMapping} from './spec/facet';\nimport {Flag, keys} from './util';\n\nexport type Channel = keyof Encoding<any> | keyof ExtendedFacetMapping<any>;\n\n// Facet\nexport const ROW: 'row' = 'row';\nexport const COLUMN: 'column' = 'column';\n\nexport const FACET: 'facet' = 'facet';\n\n// Position\nexport const X: 'x' = 'x';\nexport const Y: 'y' = 'y';\nexport const X2: 'x2' = 'x2';\nexport const Y2: 'y2' = 'y2';\n\n// Geo Position\nexport const LATITUDE: 'latitude' = 'latitude';\nexport const LONGITUDE: 'longitude' = 'longitude';\nexport const LATITUDE2: 'latitude2' = 'latitude2';\nexport const LONGITUDE2: 'longitude2' = 'longitude2';\n\n// Mark property with scale\nexport const COLOR: 'color' = 'color';\n\nexport const FILL: 'fill' = 'fill';\n\nexport const STROKE: 'stroke' = 'stroke';\n\nexport const SHAPE: 'shape' = 'shape';\nexport const SIZE: 'size' = 'size';\nexport const OPACITY: 'opacity' = 'opacity';\nexport const FILLOPACITY: 'fillOpacity' = 'fillOpacity';\n\nexport const STROKEOPACITY: 'strokeOpacity' = 'strokeOpacity';\n\nexport const STROKEWIDTH: 'strokeWidth' = 'strokeWidth';\n\n// Non-scale channel\nexport const TEXT: 'text' = 'text';\nexport const ORDER: 'order' = 'order';\nexport const DETAIL: 'detail' = 'detail';\nexport const KEY: 'key' = 'key';\n\nexport const TOOLTIP: 'tooltip' = 'tooltip';\nexport const HREF: 'href' = 'href';\n\nexport type PositionChannel = 'x' | 'y' | 'x2' | 'y2';\n\nconst POSITION_CHANNEL_INDEX: Flag<PositionChannel> = {\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1\n};\nexport function isPositionChannel(c: Channel): c is PositionChannel {\n  return c in POSITION_CHANNEL_INDEX;\n}\n\nexport type GeoPositionChannel = 'longitude' | 'latitude' | 'longitude2' | 'latitude2';\n\nexport function getPositionChannelFromLatLong(channel: GeoPositionChannel): PositionChannel {\n  switch (channel) {\n    case LATITUDE:\n      return 'y';\n    case LATITUDE2:\n      return 'y2';\n    case LONGITUDE:\n      return 'x';\n    case LONGITUDE2:\n      return 'x2';\n  }\n}\n\nconst GEOPOSITION_CHANNEL_INDEX: Flag<GeoPositionChannel> = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\n\nexport function isGeoPositionChannel(c: Channel): c is GeoPositionChannel {\n  return c in GEOPOSITION_CHANNEL_INDEX;\n}\n\nexport const GEOPOSITION_CHANNELS = keys(GEOPOSITION_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<keyof Encoding<any>> = {\n  ...POSITION_CHANNEL_INDEX,\n\n  ...GEOPOSITION_CHANNEL_INDEX,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  fillOpacity: 1,\n  strokeOpacity: 1,\n\n  strokeWidth: 1,\n  size: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\n\nexport type FacetChannel = keyof EncodingFacetMapping<any>;\n\nconst FACET_CHANNEL_INDEX: Flag<keyof EncodingFacetMapping<any>> = {\n  row: 1,\n  column: 1,\n  facet: 1\n};\n\nexport const FACET_CHANNELS = keys(FACET_CHANNEL_INDEX);\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = keys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\nconst {order: _o1, detail: _d1, row: _r, column: _c, facet: _f, ...SINGLE_DEF_UNIT_CHANNEL_INDEX} = CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS = keys(SINGLE_DEF_CHANNEL_INDEX);\n\nexport type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[number];\n\nexport const SINGLE_DEF_UNIT_CHANNELS = keys(SINGLE_DEF_UNIT_CHANNEL_INDEX);\n\nexport type SingleDefUnitChannel = typeof SINGLE_DEF_UNIT_CHANNELS[number];\n\n// export type SingleDefChannel = SingleDefUnitChannel | 'row' | 'column' | 'facet';\n\nexport function isSingleDefUnitChannel(str: string): str is SingleDefUnitChannel {\n  return !!SINGLE_DEF_UNIT_CHANNEL_INDEX[str];\n}\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\nexport type SecondaryRangeChannel = 'x2' | 'y2' | 'latitude2' | 'longitude2';\n\nexport const SECONDARY_RANGE_CHANNEL: SecondaryRangeChannel[] = ['x2', 'y2', 'latitude2', 'longitude2'];\n\nexport function isSecondaryRangeChannel(c: Channel): c is SecondaryRangeChannel {\n  const main = getMainRangeChannel(c);\n  return main !== c;\n}\n\n/**\n * Get the main channel for a range channel. E.g. `x` for `x2`.\n */\nexport function getMainRangeChannel(channel: Channel): Channel {\n  switch (channel) {\n    case 'x2':\n      return 'x';\n    case 'y2':\n      return 'y';\n    case 'latitude2':\n      return 'latitude';\n    case 'longitude2':\n      return 'longitude';\n  }\n  return channel;\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = keys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = keys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[0];\n\n// POSITION_SCALE_CHANNELS = X and Y;\nconst POSITION_SCALE_CHANNEL_INDEX: {x: 1; y: 1} = {x: 1, y: 1};\nexport const POSITION_SCALE_CHANNELS = keys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = typeof POSITION_SCALE_CHANNELS[0];\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = keys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[0];\n\nexport function isNonPositionScaleChannel(channel: Channel): channel is NonPositionScaleChannel {\n  return !!NONPOSITION_CHANNEL_INDEX[channel];\n}\n\n/**\n * @returns whether Vega supports legends for a particular channel\n */\nexport function supportLegend(channel: NonPositionScaleChannel) {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n    case STROKEWIDTH:\n      return true;\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      return false;\n  }\n}\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = keys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[0];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = {[mark in Mark]?: 'always' | 'binned'};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return getSupportedMark(channel)[mark];\n}\n\nconst ALL_MARKS: {[m in Mark]: 'always'} = {\n  // all marks\n  area: 'always',\n  bar: 'always',\n  circle: 'always',\n  geoshape: 'always',\n  line: 'always',\n  rule: 'always',\n  point: 'always',\n  rect: 'always',\n  square: 'always',\n  trail: 'always',\n  text: 'always',\n  tick: 'always'\n};\n\nconst {geoshape: _g, ...ALL_MARKS_EXCEPT_GEOSHAPE} = ALL_MARKS;\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to 'always', 'binned', or undefined\n */\nfunction getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n    // falls through\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n    case STROKEWIDTH:\n    // falls through\n\n    case FACET:\n    case ROW: // falls through\n    case COLUMN:\n      return ALL_MARKS;\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n      return ALL_MARKS_EXCEPT_GEOSHAPE;\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        rule: 'always',\n        bar: 'always',\n        rect: 'always',\n        area: 'always',\n        circle: 'binned',\n        point: 'binned',\n        square: 'binned',\n        tick: 'binned',\n        line: 'binned',\n        trail: 'binned'\n      };\n    case SIZE:\n      return {\n        point: 'always',\n        tick: 'always',\n        rule: 'always',\n        circle: 'always',\n        square: 'always',\n        bar: 'always',\n        text: 'always',\n        line: 'always',\n        trail: 'always'\n      };\n    case SHAPE:\n      return {point: 'always', geoshape: 'always'};\n    case TEXT:\n      return {text: 'always'};\n  }\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case STROKEWIDTH:\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range. [falls through]\n    case X2:\n    case Y2:\n      return undefined;\n\n    case FACET:\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    // TEXT, TOOLTIP, and HREF have no scale but have discrete output [falls through]\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('rangeType not implemented for ' + channel);\n}\n"]}