{"version":3,"file":"filterinvalid.js","sourceRoot":"","sources":["../../../../src/compile/data/filterinvalid.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,cAAc,EAAC,MAAM,eAAe,CAAC;AAC7C,OAAO,EAAW,OAAO,IAAI,QAAQ,EAAC,MAAM,kBAAkB,CAAC;AAC/D,OAAO,EAAC,UAAU,EAAC,MAAM,YAAY,CAAC;AACtC,OAAO,EAAC,mBAAmB,EAAC,MAAM,aAAa,CAAC;AAChD,OAAO,EAAO,IAAI,EAAC,MAAM,YAAY,CAAC;AAGtC,OAAO,EAAC,YAAY,EAAC,MAAM,YAAY,CAAC;AAExC,MAAM,OAAO,iBAAkB,SAAQ,YAAY;IAKjD,YAAY,MAAoB,EAAkB,MAA8B;QAC9E,KAAK,CAAC,MAAM,CAAC,CAAC;QADkC,WAAM,GAAN,MAAM,CAAwB;IAEhF,CAAC;IANM,KAAK;QACV,OAAO,IAAI,iBAAiB,CAAC,IAAI,oBAAM,IAAI,CAAC,MAAM,EAAE,CAAC;IACvD,CAAC;IAMM,MAAM,CAAC,IAAI,CAAC,MAAoB,EAAE,KAAgB;QACvD,MAAM,EAAC,MAAM,EAAE,IAAI,EAAC,GAAG,KAAK,CAAC;QAC7B,IAAI,MAAM,CAAC,aAAa,KAAK,QAAQ,EAAE;YACrC,OAAO,IAAI,CAAC;SACb;QAED,MAAM,MAAM,GAAG,KAAK,CAAC,cAAc,CACjC,CAAC,UAAkC,EAAE,QAAQ,EAAE,OAAO,EAAE,EAAE;YACxD,MAAM,cAAc,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;YACnF,IAAI,cAAc,EAAE;gBAClB,MAAM,SAAS,GAAG,cAAc,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;gBAE7C,mFAAmF;gBACnF,uFAAuF;gBACvF,kFAAkF;gBAClF,IAAI,mBAAmB,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE;oBAC9E,UAAU,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;iBACvC;aACF;YACD,OAAO,UAAU,CAAC;QACpB,CAAC,EACD,EAA4B,CAC7B,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE;YACxB,OAAO,IAAI,CAAC;SACb;QAED,OAAO,IAAI,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC/C,CAAC;IAEM,eAAe;QACpB,OAAO,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IACpC,CAAC;IAED,0DAA0D;IACnD,QAAQ;QACb,MAAM,OAAO,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE;YAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACpC,MAAM,GAAG,GAAG,QAAQ,CAAC,QAAQ,EAAE,EAAC,IAAI,EAAE,OAAO,EAAC,CAAC,CAAC;YAEhD,IAAI,QAAQ,KAAK,IAAI,EAAE;gBACrB,WAAW,CAAC,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC,CAAC;gBACpC,WAAW,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC;aACpC;YACD,OAAO,WAAW,CAAC;QACrB,CAAC,EAAE,EAAE,CAAC,CAAC;QAEP,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC;YACvB,CAAC,CAAC;gBACE,IAAI,EAAE,QAAQ;gBACd,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC;aAC3B;YACH,CAAC,CAAC,IAAI,CAAC;IACX,CAAC;CACF","sourcesContent":["import {isScaleChannel} from '../../channel';\nimport {FieldDef, vgField as fieldRef} from '../../channeldef';\nimport {isPathMark} from '../../mark';\nimport {hasContinuousDomain} from '../../scale';\nimport {Dict, keys} from '../../util';\nimport {VgFilterTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class FilterInvalidNode extends DataFlowNode {\n  public clone() {\n    return new FilterInvalidNode(null, {...this.filter});\n  }\n\n  constructor(parent: DataFlowNode, public readonly filter: Dict<FieldDef<string>>) {\n    super(parent);\n  }\n\n  public static make(parent: DataFlowNode, model: UnitModel): FilterInvalidNode {\n    const {config, mark} = model;\n    if (config.invalidValues !== 'filter') {\n      return null;\n    }\n\n    const filter = model.reduceFieldDef(\n      (aggregator: Dict<FieldDef<string>>, fieldDef, channel) => {\n        const scaleComponent = isScaleChannel(channel) && model.getScaleComponent(channel);\n        if (scaleComponent) {\n          const scaleType = scaleComponent.get('type');\n\n          // While discrete domain scales can handle invalid values, continuous scales can't.\n          // Thus, for non-path marks, we have to filter null for scales with continuous domains.\n          // (For path marks, we will use \"defined\" property and skip these values instead.)\n          if (hasContinuousDomain(scaleType) && !fieldDef.aggregate && !isPathMark(mark)) {\n            aggregator[fieldDef.field] = fieldDef;\n          }\n        }\n        return aggregator;\n      },\n      {} as Dict<FieldDef<string>>\n    );\n\n    if (!keys(filter).length) {\n      return null;\n    }\n\n    return new FilterInvalidNode(parent, filter);\n  }\n\n  public dependentFields() {\n    return new Set(keys(this.filter));\n  }\n\n  // create the VgTransforms for each of the filtered fields\n  public assemble(): VgFilterTransform {\n    const filters = keys(this.filter).reduce((vegaFilters, field) => {\n      const fieldDef = this.filter[field];\n      const ref = fieldRef(fieldDef, {expr: 'datum'});\n\n      if (fieldDef !== null) {\n        vegaFilters.push(`${ref} !== null`);\n        vegaFilters.push(`!isNaN(${ref})`);\n      }\n      return vegaFilters;\n    }, []);\n\n    return filters.length > 0\n      ? {\n          type: 'filter',\n          expr: filters.join(' && ')\n        }\n      : null;\n  }\n}\n"]}