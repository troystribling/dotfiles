{"version":3,"file":"optimizers.js","sourceRoot":"","sources":["../../../../src/compile/data/optimizers.ts"],"names":[],"mappings":"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","sourcesContent":["import {MAIN, Parse} from '../../data';\nimport {Dict, fieldIntersection, flatten, hash, hasIntersection, keys, some} from '../../util';\nimport {Model} from '../model';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {ParseNode} from './formatparse';\nimport {JoinAggregateTransformNode} from './joinaggregate';\nimport {FACET_SCALE_PREFIX} from './optimize';\nimport {BottomUpOptimizer, isDataSourceNode, TopDownOptimizer} from './optimizer';\nimport * as optimizers from './optimizers';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nexport interface OptimizerFlags {\n  /**\n   * If true, iteration continues.\n   */\n  continueFlag: boolean;\n  /**\n   * If true, the tree has been mutated by the function.\n   */\n  mutatedFlag: boolean;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport class MoveParseUp extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    const parent = node.parent;\n    // Move parse up by merging or swapping.\n    if (node instanceof ParseNode) {\n      if (isDataSourceNode(parent)) {\n        return this.flags;\n      }\n\n      if (parent.numChildren() > 1) {\n        // Don't move parse further up but continue with parent.\n        this.setContinue();\n        return this.flags;\n      }\n\n      if (parent instanceof ParseNode) {\n        this.setMutated();\n        parent.merge(node);\n      } else {\n        // Don't swap with nodes that produce something that the parse node depends on (e.g. lookup).\n        if (fieldIntersection(parent.producedFields(), node.dependentFields())) {\n          this.setContinue();\n          return this.flags;\n        }\n        this.setMutated();\n        node.swapWithParent();\n      }\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * Merge identical nodes at forks by comparing hashes.\n *\n * Does not need to iterate from leaves so we implement this with recursion as it's a bit simpler.\n */\nexport class MergeIdenticalNodes extends TopDownOptimizer {\n  public mergeNodes(parent: DataFlowNode, nodes: DataFlowNode[]) {\n    const mergedNode = nodes.shift();\n    for (const node of nodes) {\n      parent.removeChild(node);\n      node.parent = mergedNode;\n      node.remove();\n    }\n  }\n\n  public run(node: DataFlowNode): boolean {\n    const hashes = node.children.map(x => x.hash());\n    const buckets: {hash?: DataFlowNode[]} = {};\n\n    for (let i = 0; i < hashes.length; i++) {\n      if (buckets[hashes[i]] === undefined) {\n        buckets[hashes[i]] = [node.children[i]];\n      } else {\n        buckets[hashes[i]].push(node.children[i]);\n      }\n    }\n\n    for (const k of keys(buckets)) {\n      if (buckets[k].length > 1) {\n        this.setMutated();\n        this.mergeNodes(node, buckets[k]);\n      }\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport class RemoveUnusedSubtrees extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n      // no need to continue with parent because it is output node or will have children (there was a fork)\n      return this.flags;\n    } else {\n      this.setMutated();\n      node.remove();\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\n\nexport class RemoveDuplicateTimeUnits extends BottomUpOptimizer {\n  private fields = new Set<string>();\n  public run(node: DataFlowNode): OptimizerFlags {\n    this.setContinue();\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      if (hasIntersection(pfields, this.fields)) {\n        this.setMutated();\n        node.remove();\n      } else {\n        this.fields = new Set([...this.fields, ...pfields]);\n      }\n    }\n    return this.flags;\n  }\n\n  public reset(): void {\n    this.fields.clear();\n  }\n}\n\n/**\n * Merge adjacent time unit nodes.\n */\nexport class MergeTimeUnits extends BottomUpOptimizer {\n  public run(node: DataFlowNode): OptimizerFlags {\n    this.setContinue();\n    const parent = node.parent;\n    const timeUnitChildren = parent.children.filter(x => x instanceof TimeUnitNode) as TimeUnitNode[];\n    const combination = timeUnitChildren.pop();\n    for (const timeUnit of timeUnitChildren) {\n      this.setMutated();\n      combination.merge(timeUnit);\n    }\n    return this.flags;\n  }\n}\n\n/**\n * Clones the subtree and ignores output nodes except for the leaves, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (\n        copy instanceof AggregateNode ||\n        copy instanceof StackNode ||\n        copy instanceof WindowTransformNode ||\n        copy instanceof JoinAggregateTransformNode\n      ) {\n        copy.addDimensions(facet.fields);\n      }\n      flatten(node.children.map(clone)).forEach((n: DataFlowNode) => (n.parent = copy));\n\n      return [copy];\n    }\n\n    return flatten(node.children.map(clone));\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nexport function moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n      const child = node.children[0];\n\n      if (\n        child instanceof AggregateNode ||\n        child instanceof StackNode ||\n        child instanceof WindowTransformNode ||\n        child instanceof JoinAggregateTransformNode\n      ) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n\n      const facetMain = node.model.component.data.main;\n      moveMainDownToFacet(facetMain);\n\n      // replicate the subtree and place it before the facet's main node\n      const cloner = cloneSubtree(node);\n      const copy: DataFlowNode[] = flatten(node.children.map(cloner));\n      for (const c of copy) {\n        c.parent = facetMain;\n      }\n    }\n  } else {\n    node.children.map(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n/**\n * Remove nodes that are not required starting from a root.\n */\nexport class RemoveUnnecessaryNodes extends TopDownOptimizer {\n  public run(node: DataFlowNode): boolean {\n    // remove output nodes that are not required\n    if (node instanceof OutputNode && !node.isRequired()) {\n      this.setMutated();\n      node.remove();\n    }\n    for (const child of node.children) {\n      this.run(child);\n    }\n\n    return this.mutatedFlag;\n  }\n}\n\n/**\n * Inserts an intermediate ParseNode containing all non-conflicting parse fields and removes the empty ParseNodes.\n *\n * We assume that dependent paths that do not have a parse node can be just merged.\n */\nexport class MergeParse extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const originalChildren = [...parent.children];\n    const parseChildren = parent.children.filter((child): child is ParseNode => child instanceof ParseNode);\n\n    if (parent.numChildren() > 1 && parseChildren.length >= 1) {\n      const commonParse: Parse = {};\n      const conflictingParse = new Set<string>();\n      for (const parseNode of parseChildren) {\n        const parse = parseNode.parse;\n        for (const k of keys(parse)) {\n          if (!(k in commonParse)) {\n            commonParse[k] = parse[k];\n          } else if (commonParse[k] !== parse[k]) {\n            conflictingParse.add(k);\n          }\n        }\n      }\n\n      for (const field of conflictingParse) {\n        delete commonParse[field];\n      }\n\n      if (keys(commonParse).length !== 0) {\n        this.setMutated();\n        const mergedParseNode = new ParseNode(parent, commonParse);\n        for (const childNode of originalChildren) {\n          if (childNode instanceof ParseNode) {\n            for (const key of keys(commonParse)) {\n              delete childNode.parse[key];\n            }\n          }\n\n          parent.removeChild(childNode);\n          childNode.parent = mergedParseNode;\n\n          // remove empty parse nodes\n          if (childNode instanceof ParseNode && keys(childNode.parse).length === 0) {\n            childNode.remove();\n          }\n        }\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n}\n\nexport class MergeAggregates extends BottomUpOptimizer {\n  public run(node: DataFlowNode): optimizers.OptimizerFlags {\n    const parent = node.parent;\n    const aggChildren = parent.children.filter((child): child is AggregateNode => child instanceof AggregateNode);\n\n    // Object which we'll use to map the fields which an aggregate is grouped by to\n    // the set of aggregates with that grouping. This is useful as only aggregates\n    // with the same group by can be merged\n    const groupedAggregates: Dict<AggregateNode[]> = {};\n\n    // Build groupedAggregates\n    for (const agg of aggChildren) {\n      const groupBys = hash(agg.groupBy);\n      if (!(groupBys in groupedAggregates)) {\n        groupedAggregates[groupBys] = [];\n      }\n      groupedAggregates[groupBys].push(agg);\n    }\n\n    // Merge aggregateNodes with same key in groupedAggregates\n    for (const group of keys(groupedAggregates)) {\n      const mergeableAggs = groupedAggregates[group];\n      if (mergeableAggs.length > 1) {\n        const mergedAggs = mergeableAggs.pop();\n        for (const agg of mergeableAggs) {\n          if (mergedAggs.merge(agg)) {\n            parent.removeChild(agg);\n            agg.parent = mergedAggs;\n            agg.remove();\n\n            this.setMutated();\n          }\n        }\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * Merge bin nodes and move them up through forks. Stop at filters and parse as we want them to stay before the bin node.\n */\nexport class MergeBins extends BottomUpOptimizer {\n  constructor(private model: Model) {\n    super();\n  }\n  public run(node: DataFlowNode): OptimizerFlags {\n    const parent = node.parent;\n    const moveBinsUp = !(isDataSourceNode(parent) || parent instanceof FilterNode || parent instanceof ParseNode);\n\n    const promotableBins: BinNode[] = [];\n    const remainingBins: BinNode[] = [];\n\n    for (const child of parent.children) {\n      if (child instanceof BinNode) {\n        if (moveBinsUp && !fieldIntersection(parent.producedFields(), child.dependentFields())) {\n          promotableBins.push(child);\n        } else {\n          remainingBins.push(child);\n        }\n      }\n    }\n\n    if (promotableBins.length > 0) {\n      const promotedBin = promotableBins.pop();\n      for (const bin of promotableBins) {\n        promotedBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setMutated();\n      if (parent instanceof BinNode) {\n        parent.merge(promotedBin, this.model.renameSignal.bind(this.model));\n      } else {\n        promotedBin.swapWithParent();\n      }\n    }\n    if (remainingBins.length > 1) {\n      const remainingBin = remainingBins.pop();\n      for (const bin of remainingBins) {\n        remainingBin.merge(bin, this.model.renameSignal.bind(this.model));\n      }\n      this.setMutated();\n    }\n    this.setContinue();\n    return this.flags;\n  }\n}\n\n/**\n * This optimizer takes output nodes that are at a fork and moves them before the fork.\n *\n * The algorithm iterates over the children and tries to find the last output node in a cahin of output nodes.\n * It then moves all output nodes before that main output node. All other children (and the children of the output nodes)\n * are inserted after the main output node.\n */\nexport class MergeOutputs extends BottomUpOptimizer {\n  public run(node: DataFlowNode) {\n    const parent = node.parent;\n    const children = [...parent.children];\n    const hasOutputChild = some(children, child => child instanceof OutputNode);\n\n    if (!hasOutputChild || parent.numChildren() <= 1) {\n      this.setContinue();\n      return this.flags;\n    }\n\n    const otherChildren: DataFlowNode[] = [];\n\n    // The output node we will connect all other nodes to\n    // output nodes will be added before, other nodes after\n    let mainOutput: OutputNode;\n\n    for (const child of children) {\n      if (child instanceof OutputNode) {\n        let lastOutput = child;\n\n        while (lastOutput.numChildren() === 1) {\n          const theChild = lastOutput.children[0];\n          if (theChild instanceof OutputNode) {\n            lastOutput = theChild;\n          } else {\n            break;\n          }\n        }\n\n        otherChildren.push(...lastOutput.children);\n\n        if (mainOutput) {\n          // Move the output nodes before the mainOutput. We do this by setting\n          // the parent of the first not to the parent of the main output and\n          // the main output's parent to the last output.\n\n          // note: the child is the first output\n          parent.removeChild(child);\n          child.parent = mainOutput.parent;\n\n          mainOutput.parent.removeChild(mainOutput);\n          mainOutput.parent = lastOutput;\n\n          this.setMutated();\n        } else {\n          mainOutput = lastOutput;\n        }\n      } else {\n        otherChildren.push(child);\n      }\n    }\n\n    if (otherChildren.length) {\n      this.setMutated();\n      for (const child of otherChildren) {\n        child.parent.removeChild(child);\n        child.parent = mainOutput;\n      }\n    }\n\n    this.setContinue();\n    return this.flags;\n  }\n}\n"]}