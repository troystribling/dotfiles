{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/header/parse.ts"],"names":[],"mappings":"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","sourcesContent":["import {AxisOrient} from 'vega';\nimport {FacetChannel, FACET_CHANNELS} from '../../channel';\nimport {title as fieldDefTitle} from '../../channeldef';\nimport {contains, getFirstDefined} from '../../util';\nimport {assembleAxis} from '../axis/assemble';\nimport {FacetModel} from '../facet';\nimport {parseGuideResolve} from '../resolve';\nimport {getHeaderProperty} from './common';\nimport {HeaderChannel, HeaderComponent} from './component';\n\nexport function getHeaderType(orient: AxisOrient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function parseFacetHeaders(model: FacetModel) {\n  for (const channel of FACET_CHANNELS) {\n    parseFacetHeader(model, channel);\n  }\n\n  mergeChildAxis(model, 'x');\n  mergeChildAxis(model, 'y');\n}\n\nfunction parseFacetHeader(model: FacetModel, channel: FacetChannel) {\n  if (model.channelHasField(channel)) {\n    const fieldDef = model.facet[channel];\n    const titleConfig = getHeaderProperty('title', null, model.config, channel);\n    let title = fieldDefTitle(fieldDef, model.config, {\n      allowDisabling: true,\n      includeDefault: titleConfig === undefined || !!titleConfig\n    });\n\n    if (model.child.component.layoutHeaders[channel].title) {\n      // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n      title += ' / ' + model.child.component.layoutHeaders[channel].title;\n      model.child.component.layoutHeaders[channel].title = null;\n    }\n\n    const labelOrient = getHeaderProperty('labelOrient', fieldDef, model.config, channel);\n\n    const header = fieldDef.header || {};\n    const labels = getFirstDefined(header.labels, true);\n    const headerType = contains(['bottom', 'right'], labelOrient) ? 'footer' : 'header';\n\n    model.component.layoutHeaders[channel] = {\n      title,\n      facetFieldDef: fieldDef,\n      [headerType]: channel === 'facet' ? [] : [makeHeaderComponent(model, channel, labels)]\n    };\n  }\n}\n\nfunction makeHeaderComponent(model: FacetModel, channel: HeaderChannel, labels: boolean): HeaderComponent {\n  const sizeType = channel === 'row' ? 'height' : 'width';\n\n  return {\n    labels,\n    sizeSignal: model.child.component.layoutSize.get(sizeType) ? model.child.getSizeSignalRef(sizeType) : undefined,\n    axes: []\n  };\n}\n\nfunction mergeChildAxis(model: FacetModel, channel: 'x' | 'y') {\n  const {child} = model;\n  if (child.component.axes[channel]) {\n    const {layoutHeaders, resolve} = model.component;\n    resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n    if (resolve.axis[channel] === 'shared') {\n      // For shared axis, move the axes to facet's header or footer\n      const headerChannel = channel === 'x' ? 'column' : 'row';\n\n      const layoutHeader = layoutHeaders[headerChannel];\n      for (const axisComponent of child.component.axes[channel]) {\n        const headerType = getHeaderType(axisComponent.get('orient'));\n        layoutHeader[headerType] = layoutHeader[headerType] || [makeHeaderComponent(model, headerChannel, false)];\n\n        // FIXME: assemble shouldn't be called here, but we do it this way so we only extract the main part of the axes\n        const mainAxis = assembleAxis(axisComponent, 'main', model.config, {header: true});\n        // LayoutHeader no longer keep track of property precedence, thus let's combine.\n        layoutHeader[headerType][0].axes.push(mainAxis);\n        axisComponent.mainExtracted = true;\n      }\n    } else {\n      // Otherwise do nothing for independent axes\n    }\n  }\n}\n"]}