{"version":3,"file":"encode.js","sourceRoot":"","sources":["../../../../src/compile/legend/encode.ts"],"names":[],"mappings":"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","sourcesContent":["import {SymbolEncodeEntry} from 'vega';\nimport {isArray} from 'vega-util';\nimport {COLOR, NonPositionScaleChannel, OPACITY} from '../../channel';\nimport {\n  Conditional,\n  FieldDefWithCondition,\n  hasConditionalValueDef,\n  isTimeFormatFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  TypedFieldDef,\n  Value,\n  ValueDef,\n  ValueDefWithCondition\n} from '../../channeldef';\nimport {FILL_STROKE_CONFIG} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {getFirstDefined, keys} from '../../util';\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport * as mixins from '../mark/mixins';\nimport {UnitModel} from '../unit';\nimport {ScaleChannel} from './../../channel';\nimport {LegendComponent} from './component';\nimport {defaultType} from './properties';\n\nfunction type(legendCmp: LegendComponent, model: UnitModel, channel: ScaleChannel) {\n  const scaleType = model.getScaleComponent(channel).get('type');\n  return getFirstDefined(legendCmp.get('type'), defaultType({channel, scaleType, alwaysReturn: true}));\n}\n\nexport function symbols(\n  fieldDef: TypedFieldDef<string>,\n  symbolsSpec: any,\n  model: UnitModel,\n  channel: ScaleChannel,\n  legendCmp: LegendComponent\n): SymbolEncodeEntry {\n  if (type(legendCmp, model, channel) !== 'symbol') {\n    return undefined;\n  }\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model)\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  const {markDef, encoding, config} = model;\n  const filled = markDef.filled;\n\n  const opacity = getMaxValue(encoding.opacity) || markDef.opacity;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {value: config.legend.symbolBaseFillColor || 'black'};\n          out.fillOpacity = {value: opacity || 1};\n        }\n      } else if (isArray(out.fill)) {\n        const fill =\n          (getFirstConditionValue(encoding.fill || encoding.color) as string) ||\n          markDef.fill ||\n          (filled && markDef.color);\n        if (fill) {\n          out.fill = {value: fill};\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(\n          getFirstConditionValue(encoding.stroke || encoding.color) as string,\n          markDef.stroke,\n          filled ? markDef.color : undefined\n        );\n        if (stroke) {\n          out.stroke = {value: stroke};\n        }\n      }\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (opacity) {\n      // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function gradient(\n  fieldDef: TypedFieldDef<string>,\n  gradientSpec: any,\n  model: UnitModel,\n  channel: ScaleChannel,\n  legendCmp: LegendComponent\n) {\n  if (type(legendCmp, model, channel) !== 'gradient') {\n    return undefined;\n  }\n\n  let out: SymbolEncodeEntry = {};\n\n  const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n  if (opacity) {\n    // only apply opacity if it is neither zero or undefined\n    out.opacity = {value: opacity};\n  }\n\n  out = {...out, ...gradientSpec};\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function labels(\n  fieldDef: TypedFieldDef<string>,\n  labelsSpec: any,\n  model: UnitModel,\n  channel: NonPositionScaleChannel\n) {\n  const legend = model.legend(channel);\n  const config = model.config;\n\n  let out: SymbolEncodeEntry = {};\n\n  if (isTimeFormatFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression(\n      'datum.value',\n      fieldDef.timeUnit,\n      legend.format,\n      config.legend.shortTimeLabels,\n      config.timeFormat,\n      isUTCScale\n    );\n    labelsSpec = {\n      ...(expr ? {text: {signal: expr}} : {}),\n      ...labelsSpec\n    };\n  }\n\n  out = {...out, ...labelsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nfunction getMaxValue(\n  channelDef:\n    | FieldDefWithCondition<MarkPropFieldDef<string>, number>\n    | ValueDefWithCondition<MarkPropFieldDef<string>, number>\n) {\n  return getConditionValue<number>(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nexport function getFirstConditionValue<V extends Value>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>, V> | ValueDefWithCondition<MarkPropFieldDef<string>, V>\n): V {\n  return getConditionValue(channelDef, (v: V, conditionalDef: Conditional<ValueDef<V>>) => {\n    return getFirstDefined<V>(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<V extends Value>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>, V> | ValueDefWithCondition<MarkPropFieldDef<string>, V>,\n  reducer: (val: V, conditionalDef: Conditional<ValueDef>) => V\n): V {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(\n      reducer,\n      channelDef.value as any\n    );\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n"]}