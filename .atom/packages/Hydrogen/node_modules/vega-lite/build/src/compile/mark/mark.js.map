{"version":3,"file":"mark.js","sourceRoot":"","sources":["../../../../src/compile/mark/mark.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {isFieldDef, isValueDef, vgField} from '../../channeldef';\nimport {MAIN} from '../../data';\nimport {isAggregate, pathGroupingFields} from '../../encoding';\nimport {AREA, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortField} from '../../sort';\nimport {contains, getFirstDefined, isNullOrFalse} from '../../util';\nimport {VgCompare} from '../../vega.schema';\nimport {getMarkConfig, getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroups(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [\n      {\n        name: model.getName('pathgroup'),\n        type: 'group',\n        from: {\n          facet: {\n            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n            data: model.requestDataName(MAIN),\n            groupby: details\n          }\n        },\n        encode: {\n          update: {\n            width: {field: {group: 'width'}},\n            height: {field: {group: 'height'}}\n          }\n        },\n        marks: pathMarks\n      }\n    ];\n  } else {\n    return pathMarks;\n  }\n}\n\nexport function getSort(model: UnitModel): VgCompare {\n  const {encoding, stack, mark, markDef, config} = model;\n  const order = encoding.order;\n  if (\n    (!isArray(order) && isValueDef(order) && isNullOrFalse(order.value)) ||\n    ((!order && isNullOrFalse(markDef.order)) || isNullOrFalse(getMarkConfig('order', markDef, config)))\n  ) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannel = markDef.orient === 'horizontal' ? 'y' : 'x';\n    const dimensionChannelDef = encoding[dimensionChannel];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n\n      if (isArray(s)) {\n        return {\n          field: vgField(dimensionChannelDef, {prefix: dimensionChannel, suffix: 'sort_index', expr: 'datum'})\n        };\n      } else if (isSortField(s)) {\n        return {\n          field: vgField(\n            {\n              // FIXME: this op might not already exist?\n              // FIXME: what if dimensionChannel (x or y) contains custom domain?\n              aggregate: isAggregate(model.encoding) ? s.op : undefined,\n              field: s.field\n            },\n            {expr: 'datum'}\n          )\n        };\n      } else {\n        return {\n          field: vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          })\n        };\n      }\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(\n  model: UnitModel,\n  opt: {\n    fromPrefix: string;\n  } = {fromPrefix: ''}\n) {\n  const mark = model.mark;\n\n  const clip = getFirstDefined(model.markDef.clip, scaleClip(model), projectionClip(model));\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip: true} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: {field: key.field}} : {}),\n      ...(sort ? {sort} : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the domainRaw property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('domainRaw')) || (yScale && yScale.get('domainRaw')) ? true : undefined;\n}\n\n/**\n * If we use a custom projection with auto-fitting to the geodata extent,\n * we need to clip to ensure the chart size doesn't explode.\n */\nfunction projectionClip(model: UnitModel) {\n  const projection = model.component.projection;\n  return projection && !projection.isFit ? true : undefined;\n}\n"]}