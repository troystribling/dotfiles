{"version":3,"file":"mixins.js","sourceRoot":"","sources":["../../../../src/compile/mark/mixins.ts"],"names":[],"mappings":"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","sourcesContent":["import {array, isArray, isObject, isString} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, NonPositionScaleChannel, ScaleChannel, SCALE_CHANNELS, X, X2, Y2} from '../../channel';\nimport {\n  ChannelDef,\n  getTypedFieldDef,\n  isConditionalSelection,\n  isFieldDef,\n  isValueDef,\n  SecondaryFieldDef,\n  TypedFieldDef,\n  ValueDef\n} from '../../channeldef';\nimport * as log from '../../log';\nimport {isPathMark, Mark, MarkConfig, MarkDef} from '../../mark';\nimport {hasContinuousDomain} from '../../scale';\nimport {contains, Dict, getFirstDefined, keys} from '../../util';\nimport {VgEncodeChannel, VgEncodeEntry, VgValueRef, VG_MARK_CONFIGS} from '../../vega.schema';\nimport {getMarkConfig, getStyleConfig} from '../common';\nimport {expression} from '../predicate';\nimport {assembleSelectionPredicate} from '../selection/assemble';\nimport {UnitModel} from '../unit';\nimport * as ref from './valueref';\nimport {fieldInvalidPredicate} from './valueref';\n\nfunction isVisible(c: string) {\n  return c !== 'transparent' && c !== null && c !== undefined;\n}\n\nexport function color(model: UnitModel): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {filled, type: markType} = markDef;\n\n  const configValue = {\n    fill: getMarkConfig('fill', markDef, config),\n    stroke: getMarkConfig('stroke', markDef, config),\n    color: getMarkConfig('color', markDef, config)\n  };\n\n  const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType)\n    ? 'transparent'\n    : undefined;\n\n  const defaultFill = getFirstDefined(\n    markDef.fill,\n    configValue.fill,\n    // If there is no fill, always fill symbols, bar, geoshape\n    // with transparent fills https://github.com/vega/vega-lite/issues/1316\n    transparentIfNeeded\n  );\n\n  const defaultStroke = getFirstDefined(markDef.stroke, configValue.stroke);\n\n  const colorVgChannel = filled ? 'fill' : 'stroke';\n\n  const fillStrokeMarkDefAndConfig: VgEncodeEntry = {\n    ...(defaultFill ? {fill: {value: defaultFill}} : {}),\n    ...(defaultStroke ? {stroke: {value: defaultStroke}} : {})\n  };\n\n  if (encoding.fill || encoding.stroke) {\n    // ignore encoding.color, markDef.color, config.color\n    if (markDef.color) {\n      // warn for markDef.color  (no need to warn encoding.color as it will be dropped in normalized already)\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n    }\n\n    return {\n      ...nonPosition('fill', model, {defaultValue: getFirstDefined(defaultFill, transparentIfNeeded)}),\n      ...nonPosition('stroke', model, {defaultValue: defaultStroke})\n    };\n  } else if (encoding.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig,\n      // override them with encoded color field\n      ...nonPosition('color', model, {\n        vgChannel: colorVgChannel,\n        // apply default fill/stroke first, then color config, then transparent if needed.\n        defaultValue: getFirstDefined(\n          markDef[colorVgChannel],\n          markDef.color,\n          configValue[colorVgChannel],\n          configValue.color,\n          filled ? transparentIfNeeded : undefined\n        )\n      })\n    };\n  } else if (isVisible(markDef.fill) || isVisible(markDef.stroke)) {\n    // Ignore markDef.color\n    if (markDef.color) {\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in markDef, stroke: 'stroke' in markDef}));\n    }\n    return fillStrokeMarkDefAndConfig;\n  } else if (markDef.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig, // in this case, fillStrokeMarkDefAndConfig only include config\n\n      // override config with markDef.color\n      [colorVgChannel]: {value: markDef.color}\n    };\n  } else if (isVisible(configValue.fill) || isVisible(configValue.stroke)) {\n    // ignore config.color\n    return fillStrokeMarkDefAndConfig;\n  } else if (configValue.color) {\n    return {\n      ...(transparentIfNeeded ? {fill: {value: 'transparent'}} : {}),\n      [colorVgChannel]: {value: configValue.color}\n    };\n  }\n  return {};\n}\n\nexport type Ignore = Record<'size' | 'orient', 'ignore' | 'include'>;\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  const {fill, stroke} = color(model);\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapAllFieldsInvalid(model, 'fill', fill),\n    ...wrapAllFieldsInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...nonPosition('fillOpacity', model),\n    ...nonPosition('strokeOpacity', model),\n    ...nonPosition('strokeWidth', model),\n    ...tooltip(model),\n    ...text(model, 'href')\n  };\n}\n\nfunction wrapAllFieldsInvalid(model: UnitModel, channel: Channel, valueRef: VgValueRef | VgValueRef[]): VgEncodeEntry {\n  const {config, mark} = model;\n\n  if (config.invalidValues === 'hide' && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = allFieldsInvalidPredicate(model, {invalid: true, channels: SCALE_CHANNELS});\n    if (test) {\n      return {\n        [channel]: [\n          // prepend the invalid case\n          // TODO: support custom value\n          {test, value: null},\n          ...array(valueRef)\n        ]\n      };\n    }\n  }\n  return valueRef ? {[channel]: valueRef} : {};\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop: string, value: string | number | boolean): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n\nfunction allFieldsInvalidPredicate(\n  model: UnitModel,\n  {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}\n) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields.map(field => fieldInvalidPredicate(field, invalid)).join(` ${op} `);\n  }\n  return undefined;\n}\nexport function defined(model: UnitModel): VgEncodeEntry {\n  if (model.config.invalidValues) {\n    const signal = allFieldsInvalidPredicate(model, {channels: ['x', 'y']});\n\n    if (signal) {\n      return {defined: {signal}};\n    }\n  }\n  return {};\n}\n\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {\n    defaultValue?: number | string | boolean;\n    vgChannel?: VgEncodeChannel;\n    defaultRef?: VgValueRef;\n  } = {}\n): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {vgChannel = channel} = opt;\n  let {defaultRef, defaultValue} = opt;\n\n  if (defaultRef === undefined) {\n    // prettier-ignore\n    defaultValue = defaultValue ||\n      (vgChannel === channel\n        ? // When vl channel is the same as Vega's, no need to read from config as Vega will apply them correctly\n        markDef[channel]\n        : // However, when they are different (e.g, vl's text size is vg fontSize), need to read \"size\" from configs\n        getFirstDefined(markDef[channel], markDef[vgChannel], getMarkConfig(channel, markDef, config, {vgChannel})));\n\n    defaultRef = defaultValue ? {value: defaultValue} : undefined;\n  }\n\n  const channelDef = encoding[channel];\n\n  return wrapCondition(model, channelDef, vgChannel, cDef => {\n    return ref.midPoint({\n      channel,\n      channelDef: cDef,\n      scaleName: model.scaleName(channel),\n      scale: model.getScaleComponent(channel),\n      stack: null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    });\n  });\n}\n\n/**\n * Return a mixin that includes a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(\n  model: UnitModel,\n  channelDef: ChannelDef,\n  vgChannel: string,\n  refFn: (cDef: ChannelDef) => VgValueRef\n): VgEncodeEntry {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = isArray(condition) ? condition : [condition];\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c)\n        ? assembleSelectionPredicate(model, c.selection)\n        : expression(model, c.test);\n      return {\n        test,\n        ...conditionValueRef\n      };\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n\nexport function tooltip(model: UnitModel, opt: {reactiveGeom?: boolean} = {}) {\n  const {encoding, markDef, config} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: ref.tooltipForEncoding({tooltip: channelDef}, config, opt)};\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = ref.text(cDef, model.config, opt.reactiveGeom ? 'datum.datum' : 'datum');\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      if (cDef === null) {\n        // Allow using encoding.tooltip = null to disable tooltip\n        return undefined;\n      }\n\n      // If tooltipDef does not exist, then use value from markDef or config\n      const markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return ref.tooltipForEncoding(encoding, config, opt);\n        } else {\n          return {signal: 'datum'};\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\n\nexport function text(model: UnitModel, channel: 'text' | 'href' = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition(model, channelDef, channel, cDef => ref.text(cDef, model.config));\n}\n\nexport function bandPosition(\n  fieldDef: TypedFieldDef<string>,\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultSizeRef?: VgValueRef\n) {\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  if (\n    model.encoding.size ||\n    model.markDef.size !== undefined ||\n    (defaultSizeRef && defaultSizeRef.value !== undefined)\n  ) {\n    const orient = model.markDef.orient;\n    if (orient) {\n      const centeredBandPositionMixins = {\n        // Use xc/yc and place the mark at the middle of the band\n        // This way we never have to deal with size's condition for x/y position.\n        [channel + 'c']: ref.fieldRef(fieldDef, scaleName, {}, {band: 0.5})\n      };\n\n      if (getTypedFieldDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (isValueDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (model.markDef.size !== undefined) {\n        return {\n          ...centeredBandPositionMixins,\n          [sizeChannel]: {value: model.markDef.size}\n        };\n      } else if (defaultSizeRef && defaultSizeRef.value !== undefined) {\n        return {\n          ...centeredBandPositionMixins,\n          [sizeChannel]: defaultSizeRef\n        };\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(model.markDef.type));\n    }\n  }\n\n  return {\n    // FIXME: make offset works correctly here when we support group bar (https://github.com/vega/vega-lite/issues/396)\n    [channel]: ref.fieldRef(fieldDef, scaleName, {binSuffix: 'range'}, {}),\n    [sizeChannel]: defaultSizeRef || ref.bandRef(scaleName)\n  };\n}\n\nexport function centeredPointPositionWithSize(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultPosRef: VgValueRef,\n  defaultSizeRef: VgValueRef\n) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, defaultPosRef, centerChannel),\n    ...nonPosition('size', model, {defaultRef: defaultSizeRef, vgChannel: sizeChannel})\n  };\n}\n\nexport function binPosition({\n  fieldDef,\n  fieldDef2,\n  channel,\n  scaleName,\n  mark,\n  spacing = 0,\n  reverse\n}: {\n  fieldDef: TypedFieldDef<string>;\n  fieldDef2?: ValueDef | SecondaryFieldDef<string>;\n  channel: 'x' | 'y';\n  scaleName: string;\n  mark: Mark;\n  spacing?: number;\n  reverse: boolean;\n}) {\n  const binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  const channel2 = channel === X ? X2 : Y2;\n  if (isBinning(fieldDef.bin)) {\n    return {\n      [channel2]: ref.bin({\n        channel,\n        fieldDef,\n        scaleName,\n        mark,\n        side: 'start',\n        offset: binSpacing[`${channel}2`]\n      }),\n      [channel]: ref.bin({channel, fieldDef, scaleName, mark, side: 'end', offset: binSpacing[channel]})\n    };\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    return {\n      [channel2]: ref.fieldRef(fieldDef, scaleName, {}, {offset: binSpacing[`${channel}2`]}),\n      [channel]: ref.fieldRef(fieldDef2, scaleName, {}, {offset: binSpacing[channel]})\n    };\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n\n/**\n * Return mixins for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  vgChannel?: 'x' | 'y' | 'xc' | 'yc'\n) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, mark, markDef, config, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : ref.position({\n          channel,\n          channelDef,\n          channel2Def,\n          scaleName,\n          scale,\n          stack,\n          mark,\n          offset,\n          defaultRef: ref.positionDefault({\n            markDef,\n            config,\n            defaultRef,\n            channel,\n            scaleName,\n            scale,\n            mark,\n            checkBarAreaWithoutZero: !channel2Def // only check for non-ranged marks\n          })\n        });\n\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\n\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nexport function pointPosition2(model: UnitModel, defaultRef: 'zeroOrMin' | 'zeroOrMax', channel: 'x2' | 'y2') {\n  const {encoding, mark, markDef, stack, config} = model;\n\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  if (!channelDef && (encoding.latitude || encoding.longitude)) {\n    // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n    return {[channel]: {field: model.getName(channel)}};\n  }\n\n  const valueRef = ref.position2({\n    channel,\n    channelDef,\n    channel2Def: encoding[channel],\n    scaleName,\n    scale,\n    stack,\n    mark,\n    offset,\n    defaultRef: undefined\n  });\n\n  if (valueRef !== undefined) {\n    return {[channel]: valueRef};\n  }\n\n  // TODO: check width/height encoding here once we add them\n\n  // no x2/y2 encoding, then try to read x2/y2 or width/height based on precedence:\n  // markDef > config.style > mark-specific config (config[mark]) > general mark config (config.mark)\n\n  return getFirstDefined<VgEncodeEntry>(\n    position2orSize(channel, markDef),\n    position2orSize(channel, {\n      [channel]: getStyleConfig(channel, markDef, config.style),\n      [sizeChannel]: getStyleConfig(sizeChannel, markDef, config.style)\n    }),\n    position2orSize(channel, config[mark]),\n    position2orSize(channel, config.mark),\n    {\n      [channel]: ref.positionDefault({\n        markDef,\n        config,\n        defaultRef,\n        channel,\n        scaleName,\n        scale,\n        mark,\n        checkBarAreaWithoutZero: !encoding[channel] // only check for non-ranged marks\n      })()\n    }\n  );\n}\n\nfunction position2orSize(channel: 'x2' | 'y2', markDef: MarkConfig) {\n  const sizeChannel = channel === 'x2' ? 'width' : 'height';\n  if (markDef[channel]) {\n    return {[channel]: ref.vgValueRef(channel, markDef[channel])};\n  } else if (markDef[sizeChannel]) {\n    return {[sizeChannel]: {value: markDef[sizeChannel]}};\n  }\n  return undefined;\n}\n"]}