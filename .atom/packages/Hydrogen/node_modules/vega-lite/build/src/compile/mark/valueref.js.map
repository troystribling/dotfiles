{"version":3,"file":"valueref.js","sourceRoot":"","sources":["../../../../src/compile/mark/valueref.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport {SignalRef} from 'vega';\nimport {isFunction, isString, stringValue} from 'vega-util';\nimport {isCountingAggregateOp} from '../../aggregate';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, getMainRangeChannel, PositionChannel, X, X2, Y, Y2} from '../../channel';\nimport {\n  binRequiresRange,\n  ChannelDef,\n  ChannelDefWithCondition,\n  FieldDef,\n  FieldDefBase,\n  FieldName,\n  FieldRefOption,\n  format,\n  getFieldDef,\n  hasConditionalFieldDef,\n  isFieldDef,\n  isTypedFieldDef,\n  isValueDef,\n  SecondaryFieldDef,\n  title,\n  TypedFieldDef,\n  Value,\n  vgField\n} from '../../channeldef';\nimport {Config} from '../../config';\nimport {Encoding, forEach} from '../../encoding';\nimport * as log from '../../log';\nimport {isPathMark, Mark, MarkDef} from '../../mark';\nimport {hasDiscreteDomain, isContinuousToContinuous, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {QUANTITATIVE} from '../../type';\nimport {contains, getFirstDefined} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\nimport {binFormatExpression, formatSignalRef, getMarkConfig} from '../common';\nimport {ScaleComponent} from '../scale/component';\n\nfunction midPointWithPositionInvalidTest(\n  params: MidPointParams & {\n    channel: PositionChannel;\n    mark: Mark;\n  }\n) {\n  const {channel, channelDef, mark, scale} = params;\n  const ref = midPoint(params);\n\n  // Wrap to check if the positional value is invalid, if so, plot the point on the min value\n  if (\n    // Only this for field def without counting aggregate (as count wouldn't be null)\n    isFieldDef(channelDef) &&\n    !isCountingAggregateOp(channelDef.aggregate) &&\n    // and only for continuous scale without zero (otherwise, null / invalid will be interpreted as zero, which doesn't cause layout problem)\n    scale &&\n    isContinuousToContinuous(scale.get('type')) &&\n    scale.get('zero') === false\n  ) {\n    return wrapPositionInvalidTest({\n      fieldDef: channelDef,\n      channel,\n      mark,\n      ref\n    });\n  }\n  return ref;\n}\n\nfunction wrapPositionInvalidTest({\n  fieldDef,\n  channel,\n  mark,\n  ref\n}: {\n  fieldDef: FieldDef<string>;\n  channel: PositionChannel;\n  mark: Mark;\n  ref: VgValueRef;\n}): VgValueRef | VgValueRef[] {\n  if (!isPathMark(mark)) {\n    // Only do this for non-path mark (as path marks will already use \"defined\" to skip points)\n\n    return [fieldInvalidTestValueRef(fieldDef, channel), ref];\n  }\n  return ref;\n}\n\nexport function fieldInvalidTestValueRef(fieldDef: FieldDef<string>, channel: PositionChannel) {\n  const test = fieldInvalidPredicate(fieldDef, true);\n  const mainChannel = getMainRangeChannel(channel) as 'x' | 'y';\n  const zeroValueRef = mainChannel === 'x' ? {value: 0} : {field: {group: 'height'}};\n\n  return {test, ...zeroValueRef};\n}\n\nexport function fieldInvalidPredicate(field: FieldName | FieldDef<string>, invalid = true) {\n  field = isString(field) ? field : vgField(field, {expr: 'datum'});\n  const op = invalid ? '||' : '&&';\n  const eq = invalid ? '===' : '!==';\n  return `${field} ${eq} null ${op} ${invalid ? '' : '!'}isNaN(${field})`;\n}\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function position(\n  params: MidPointParams & {\n    channel: 'x' | 'y';\n    mark: Mark;\n  }\n): VgValueRef | VgValueRef[] {\n  const {channel, channelDef, scaleName, stack, offset} = params;\n\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'}, {offset});\n  }\n\n  return midPointWithPositionInvalidTest(params);\n}\n\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\nexport function position2({\n  channel,\n  channelDef,\n  channel2Def,\n  scaleName,\n  scale,\n  stack,\n  mark,\n  offset,\n  defaultRef\n}: MidPointParams & {\n  channel: 'x2' | 'y2';\n  mark: Mark;\n}): VgValueRef | VgValueRef[] {\n  if (\n    isFieldDef(channelDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return fieldRef(channelDef, scaleName, {suffix: 'start'}, {offset});\n  }\n  return midPointWithPositionInvalidTest({\n    channel,\n    channelDef: channel2Def,\n    scaleName,\n    scale,\n    stack,\n    mark,\n    offset,\n    defaultRef\n  });\n}\n\nexport function getOffset(channel: PositionChannel, markDef: MarkDef) {\n  const offsetChannel = (channel + 'Offset') as 'xOffset' | 'yOffset' | 'x2Offset' | 'y2Offset'; // Need to cast as the type can't be inferred automatically\n\n  // TODO: in the future read from encoding channel too\n  const markDefOffsetValue = markDef[offsetChannel];\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin({\n  channel,\n  fieldDef,\n  scaleName,\n  mark,\n  side,\n  offset\n}: {\n  channel: PositionChannel;\n  fieldDef: TypedFieldDef<string>;\n  scaleName: string;\n  mark: Mark;\n  side: 'start' | 'end';\n  offset?: number;\n}) {\n  const binSuffix = side === 'start' ? undefined : 'end';\n  const ref = fieldRef(fieldDef, scaleName, {binSuffix}, offset ? {offset} : {});\n\n  return wrapPositionInvalidTest({\n    fieldDef,\n    channel,\n    mark,\n    ref\n  });\n}\n\nexport function fieldRef(\n  fieldDef: FieldDefBase<string>,\n  scaleName: string,\n  opt: FieldRefOption,\n  mixins: {offset?: number | VgValueRef; band?: number | boolean}\n): VgValueRef {\n  const ref: VgValueRef = {\n    ...(scaleName ? {scale: scaleName} : {}),\n    field: vgField(fieldDef, opt)\n  };\n\n  if (mixins) {\n    const {offset, band} = mixins;\n    return {\n      ...ref,\n      ...(offset ? {offset} : {}),\n      ...(band ? {band} : {})\n    };\n  }\n  return ref;\n}\n\nexport function bandRef(scaleName: string, band: number | boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nfunction binMidSignal({\n  scaleName,\n  fieldDef,\n  fieldDef2,\n  offset,\n  band\n}: {\n  scaleName: string;\n  fieldDef: TypedFieldDef<string>;\n  fieldDef2?: SecondaryFieldDef<string>;\n  offset: number;\n  band?: number;\n}) {\n  band = getFirstDefined(band, 0.5);\n\n  const start = vgField(fieldDef, {expr: 'datum'});\n  const end =\n    fieldDef2 !== undefined\n      ? vgField(fieldDef2, {expr: 'datum'})\n      : vgField(fieldDef, {binSuffix: 'end', expr: 'datum'});\n\n  return {\n    signal: `scale(\"${scaleName}\", ${band} * ${start} + ${1 - band} * ${end})`,\n    ...(offset ? {offset} : {})\n  };\n}\n\nexport interface MidPointParams {\n  channel: Channel;\n  channelDef: ChannelDef;\n  channel2Def?: ChannelDef<SecondaryFieldDef<string>>;\n  scaleName: string;\n  scale: ScaleComponent;\n  stack?: StackProperties;\n  offset?: number;\n  defaultRef: VgValueRef | (() => VgValueRef);\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint({\n  channel,\n  channelDef,\n  channel2Def,\n  scaleName,\n  scale,\n  stack,\n  offset,\n  defaultRef\n}: MidPointParams): VgValueRef {\n  // TODO: datum support\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldDef(channelDef)) {\n      if (isTypedFieldDef(channelDef)) {\n        if (isBinning(channelDef.bin)) {\n          // Use middle only for x an y to place marks in the center between start and end of the bin range.\n          // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n          if (contains([X, Y], channel) && channelDef.type === QUANTITATIVE) {\n            if (stack && stack.impute) {\n              // For stack, we computed bin_mid so we can impute.\n              return fieldRef(channelDef, scaleName, {binSuffix: 'mid'}, {offset});\n            }\n            // For non-stack, we can just calculate bin mid on the fly using signal.\n            return binMidSignal({scaleName, fieldDef: channelDef, offset});\n          }\n          return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {}, {\n            offset\n          });\n        } else if (isBinned(channelDef.bin)) {\n          if (isFieldDef(channel2Def)) {\n            return binMidSignal({scaleName, fieldDef: channelDef, fieldDef2: channel2Def, offset});\n          } else {\n            const channel2 = channel === X ? X2 : Y2;\n            log.warn(log.message.channelRequiredForBinned(channel2));\n          }\n        }\n      }\n\n      if (scale) {\n        const scaleType = scale.get('type');\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, {band: 0.5, offset});\n          }\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, {offset});\n        }\n      }\n      return fieldRef(channelDef, scaleName, {}, {offset}); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n      const offsetMixins = offset ? {offset} : {};\n\n      return {...vgValueRef(channel, value), ...offsetMixins};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n\n/**\n * Convert special \"width\" and \"height\" values in Vega-Lite into Vega value ref.\n */\nexport function vgValueRef(channel: Channel, value: Value) {\n  if (contains(['x', 'x2'], channel) && value === 'width') {\n    return {field: {group: 'width'}};\n  } else if (contains(['y', 'y2'], channel) && value === 'height') {\n    return {field: {group: 'height'}};\n  }\n  return {value};\n}\n\nexport function tooltipForEncoding(\n  encoding: Encoding<string>,\n  config: Config,\n  {reactiveGeom}: {reactiveGeom?: boolean} = {}\n) {\n  const keyValues: string[] = [];\n  const usedKey = {};\n  const toSkip = {};\n  const expr = reactiveGeom ? 'datum.datum' : 'datum';\n  const tooltipTuples: {channel: Channel; key: string; value: string}[] = [];\n\n  function add(fDef: TypedFieldDef<string> | SecondaryFieldDef<string>, channel: Channel) {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const fieldDef: TypedFieldDef<string> = isTypedFieldDef(fDef)\n      ? fDef\n      : {\n          ...fDef,\n          type: encoding[mainChannel].type // for secondary field def, copy type from main channel\n        };\n\n    const key = title(fieldDef, config, {allowDisabling: false});\n\n    let value = text(fieldDef, config, expr).signal;\n\n    if (channel === 'x' || channel === 'y') {\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = getFieldDef(encoding[channel2]);\n\n      if (isBinned(fieldDef.bin) && fieldDef2) {\n        const startField = vgField(fieldDef, {expr});\n        const endField = vgField(fieldDef2, {expr});\n        value = binFormatExpression(startField, endField, format(fieldDef), config);\n        toSkip[channel2] = true;\n      }\n    }\n\n    tooltipTuples.push({channel, key, value});\n  }\n\n  forEach(encoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      add(channelDef, channel);\n    } else if (hasConditionalFieldDef(channelDef)) {\n      add(channelDef.condition, channel);\n    }\n  });\n\n  for (const {channel, key, value} of tooltipTuples) {\n    if (!toSkip[channel] && !usedKey[key]) {\n      keyValues.push(`${stringValue(key)}: ${value}`);\n      usedKey[key] = true;\n    }\n  }\n\n  return keyValues.length ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n\nexport function text(\n  channelDef: ChannelDefWithCondition<FieldDef<string>, string | number | boolean>,\n  config: Config,\n  expr: 'datum' | 'datum.datum' = 'datum'\n): VgValueRef {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return {value: channelDef.value};\n    }\n    if (isTypedFieldDef(channelDef)) {\n      return formatSignalRef(channelDef, format(channelDef), expr, config);\n    }\n  }\n  return undefined;\n}\n\nexport function mid(sizeRef: SignalRef): VgValueRef {\n  return {...sizeRef, mult: 0.5};\n}\n\nexport function positionDefault({\n  markDef,\n  config,\n  defaultRef,\n  channel,\n  scaleName,\n  scale,\n  mark,\n  checkBarAreaWithoutZero: checkBarAreaWithZero\n}: {\n  markDef: MarkDef;\n  config: Config;\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax';\n  channel: PositionChannel;\n  scaleName: string;\n  scale: ScaleComponent;\n  mark: Mark;\n  checkBarAreaWithoutZero: boolean;\n}) {\n  return () => {\n    const mainChannel = getMainRangeChannel(channel);\n\n    const definedValueOrConfig = getFirstDefined(markDef[channel], getMarkConfig(channel, markDef, config));\n    if (definedValueOrConfig !== undefined) {\n      return vgValueRef(channel, definedValueOrConfig);\n    }\n\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {scaleType}));\n          }\n        } else {\n          if (scale.domainDefinitelyIncludesZero()) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (checkBarAreaWithZero && (mark === 'bar' || mark === 'area')) {\n            log.warn(\n              log.message.nonZeroScaleUsedWithLengthMark(mark, mainChannel, {zeroFalse: scale.explicit.zero === false})\n            );\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return mainChannel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else {\n        // zeroOrMax\n        return mainChannel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    }\n    return defaultRef;\n  };\n}\n"]}