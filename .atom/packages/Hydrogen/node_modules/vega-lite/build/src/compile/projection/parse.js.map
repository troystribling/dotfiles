{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/projection/parse.ts"],"names":[],"mappings":"AACA,OAAO,EAAC,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,KAAK,EAAC,MAAM,eAAe,CAAC;AAChF,OAAO,EAAC,IAAI,EAAC,MAAM,YAAY,CAAC;AAChC,OAAO,EAAC,qBAAqB,EAAC,MAAM,kBAAkB,CAAC;AACvD,OAAO,EAAC,OAAO,EAAC,MAAM,YAAY,CAAC;AACnC,OAAO,EAAC,SAAS,EAAE,KAAK,EAAE,SAAS,EAAC,MAAM,YAAY,CAAC;AACvD,OAAO,EAAC,WAAW,EAAQ,MAAM,UAAU,CAAC;AAE5C,OAAO,EAAC,mBAAmB,EAAC,MAAM,aAAa,CAAC;AAEhD,MAAM,UAAU,eAAe,CAAC,KAAY;IAC1C,KAAK,CAAC,SAAS,CAAC,UAAU,GAAG,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;AAChH,CAAC;AAED,SAAS,mBAAmB,CAAC,KAAgB;IAC3C,IAAI,KAAK,CAAC,aAAa,EAAE;QACvB,MAAM,IAAI,GAAG,KAAK,CAAC,mBAAmB,CAAC;QACvC,MAAM,GAAG,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,CAAC,CAAC;QACtE,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACnG,MAAM,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAEpD,OAAO,IAAI,mBAAmB,CAC5B,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,oBAErB,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,EAC/B,CAAC,IAAI,IAAI,EAAE,CAAC,GAEjB,IAAI,EACJ,IAAI,CACL,CAAC;KACH;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAED,SAAS,aAAa,CAAC,KAAgB;IACrC,MAAM,IAAI,GAA2B,EAAE,CAAC;IAExC,CAAC,CAAC,SAAS,EAAE,QAAQ,CAAC,EAAE,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,EAAE;QACvE,IAAI,KAAK,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,EAAE;YACtF,IAAI,CAAC,IAAI,CAAC;gBACR,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,MAAM,EAAE,CAAC;aAChD,CAAC,CAAC;SACJ;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,KAAK,CAAC,eAAe,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,OAAO,EAAE;QAC1E,IAAI,CAAC,IAAI,CAAC;YACR,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,WAAW,IAAI,CAAC,MAAM,EAAE,CAAC;SAChD,CAAC,CAAC;KACJ;IAED,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,kDAAkD;QAClD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC;KACxC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,iBAAiB,CAAC,KAA0B,EAAE,MAA2B;IAChF,MAAM,mBAAmB,GAAG,KAAK,CAAC,qBAAqB,EAAE,IAAI,CAAC,EAAE;QAC9D,2BAA2B;QAC3B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;YACjF,OAAO,IAAI,CAAC;SACb;QACD,qDAAqD;QACrD,IACE,KAAK,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC;YACnC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC;YACpC,iFAAiF;YACjF,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAC1D;YACA,OAAO,IAAI,CAAC;SACb;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,MAAM,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9D,IAAI,IAAI,EAAE;QACR,IAAI,mBAAmB,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;aAAM,IAAI,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC,EAAE,CAAC,EAAE;YACtD,OAAO,MAAM,CAAC;SACf;aAAM,IAAI,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,SAAS,CAAC,EAAE,CAAC,EAAE;YACvD,OAAO,KAAK,CAAC;SACd;KACF;IAED,4EAA4E;IAC5E,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,uBAAuB,CAAC,KAAY;IAC3C,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QAC/B,OAAO,SAAS,CAAC;KAClB;IAED,IAAI,iBAAsC,CAAC;IAE3C,2BAA2B;IAC3B,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC;IAExD,+CAA+C;IAC/C,MAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;QAC7C,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC;QAC9C,IAAI,CAAC,UAAU,EAAE;YACf,wCAAwC;YACxC,OAAO,IAAI,CAAC;SACb;aAAM,IAAI,CAAC,iBAAiB,EAAE;YAC7B,8CAA8C;YAC9C,iBAAiB,GAAG,UAAU,CAAC;YAC/B,OAAO,IAAI,CAAC;SACb;aAAM;YACL,MAAM,KAAK,GAAG,iBAAiB,CAAC,iBAAiB,EAAE,UAAU,CAAC,CAAC;YAC/D,IAAI,KAAK,EAAE;gBACT,iBAAiB,GAAG,KAAK,CAAC;aAC3B;YACD,OAAO,CAAC,CAAC,KAAK,CAAC;SAChB;IACH,CAAC,CAAC,CAAC;IAEH,kEAAkE;IAClE,IAAI,iBAAiB,IAAI,QAAQ,EAAE;QACjC,0CAA0C;QAC1C,MAAM,IAAI,GAAG,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;QACxC,MAAM,eAAe,GAAG,IAAI,mBAAmB,CAC7C,IAAI,EACJ,iBAAiB,CAAC,mBAAmB,EACrC,iBAAiB,CAAC,IAAI,EACtB,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAClC,CAAC;QAEF,yCAAyC;QACzC,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC7B,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC;YAC9C,IAAI,UAAU,EAAE;gBACd,IAAI,UAAU,CAAC,KAAK,EAAE;oBACpB,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;iBAC/D;gBACD,KAAK,CAAC,gBAAgB,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC;gBACrD,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC;aAC1B;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,eAAe,CAAC;KACxB;IAED,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["import {SignalRef} from 'vega';\nimport {LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {MAIN} from '../../data';\nimport {PROJECTION_PROPERTIES} from '../../projection';\nimport {GEOJSON} from '../../type';\nimport {duplicate, every, stringify} from '../../util';\nimport {isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {ProjectionComponent} from './component';\n\nexport function parseProjection(model: Model) {\n  model.component.projection = isUnitModel(model) ? parseUnitProjection(model) : parseNonUnitProjections(model);\n}\n\nfunction parseUnitProjection(model: UnitModel): ProjectionComponent {\n  if (model.hasProjection) {\n    const proj = model.specifiedProjection;\n    const fit = !(proj && (proj.scale != null || proj.translate != null));\n    const size = fit ? [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')] : undefined;\n    const data = fit ? gatherFitData(model) : undefined;\n\n    return new ProjectionComponent(\n      model.projectionName(true),\n      {\n        ...(model.config.projection || {}),\n        ...(proj || {})\n      },\n      size,\n      data\n    );\n  }\n\n  return undefined;\n}\n\nfunction gatherFitData(model: UnitModel) {\n  const data: (SignalRef | string)[] = [];\n\n  [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach(posssiblePair => {\n    if (model.channelHasField(posssiblePair[0]) || model.channelHasField(posssiblePair[1])) {\n      data.push({\n        signal: model.getName(`geojson_${data.length}`)\n      });\n    }\n  });\n\n  if (model.channelHasField(SHAPE) && model.fieldDef(SHAPE).type === GEOJSON) {\n    data.push({\n      signal: model.getName(`geojson_${data.length}`)\n    });\n  }\n\n  if (data.length === 0) {\n    // main source is geojson, so we can just use that\n    data.push(model.requestDataName(MAIN));\n  }\n\n  return data;\n}\n\nfunction mergeIfNoConflict(first: ProjectionComponent, second: ProjectionComponent): ProjectionComponent {\n  const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => {\n    // neither has the property\n    if (!first.explicit.hasOwnProperty(prop) && !second.explicit.hasOwnProperty(prop)) {\n      return true;\n    }\n    // both have property and an equal value for property\n    if (\n      first.explicit.hasOwnProperty(prop) &&\n      second.explicit.hasOwnProperty(prop) &&\n      // some properties might be signals or objects and require hashing for comparison\n      stringify(first.get(prop)) === stringify(second.get(prop))\n    ) {\n      return true;\n    }\n    return false;\n  });\n\n  const size = stringify(first.size) === stringify(second.size);\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (stringify(first.explicit) === stringify({})) {\n      return second;\n    } else if (stringify(second.explicit) === stringify({})) {\n      return first;\n    }\n  }\n\n  // if all properties don't match, let each unit spec have its own projection\n  return null;\n}\n\nfunction parseNonUnitProjections(model: Model): ProjectionComponent {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  let nonUnitProjection: ProjectionComponent;\n\n  // parse all children first\n  model.children.forEach(child => parseProjection(child));\n\n  // analyze parsed projections, attempt to merge\n  const mergable = every(model.children, child => {\n    const projection = child.component.projection;\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      const merge = mergeIfNoConflict(nonUnitProjection, projection);\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n      return !!merge;\n    }\n  });\n\n  // if cached one and all other children share the same projection,\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    const name = model.projectionName(true);\n    const modelProjection = new ProjectionComponent(\n      name,\n      nonUnitProjection.specifiedProjection,\n      nonUnitProjection.size,\n      duplicate(nonUnitProjection.data)\n    );\n\n    // rename and assign all others as merged\n    model.children.forEach(child => {\n      const projection = child.component.projection;\n      if (projection) {\n        if (projection.isFit) {\n          modelProjection.data.push(...child.component.projection.data);\n        }\n        child.renameProjection(projection.get('name'), name);\n        projection.merged = true;\n      }\n    });\n\n    return modelProjection;\n  }\n\n  return undefined;\n}\n"]}