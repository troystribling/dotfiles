{"version":3,"file":"domain.js","sourceRoot":"","sources":["../../../../src/compile/scale/domain.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isObject, isString} from 'vega-util';\nimport {SHARED_DOMAIN_OP_INDEX} from '../../aggregate';\nimport {isBinning} from '../../bin';\nimport {isScaleChannel, ScaleChannel} from '../../channel';\nimport {binRequiresRange, ScaleFieldDef, TypedFieldDef, valueExpr, vgField} from '../../channeldef';\nimport {MAIN, RAW} from '../../data';\nimport {DateTime} from '../../datetime';\nimport * as log from '../../log';\nimport {Domain, hasDiscreteDomain, isSelectionDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {DEFAULT_SORT_OP, EncodingSortField, isSortArray, isSortByEncoding, isSortField} from '../../sort';\nimport {TimeUnit} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  VgDataRef,\n  VgDomain,\n  VgFieldRefUnionDomain,\n  VgNonUnionDomain,\n  VgSortField,\n  VgUnionSortField\n} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SELECTION_DOMAIN} from '../selection';\nimport {SignalRefWrapper} from '../signal';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\nimport {Explicit, mergeValuesWithExplicit, makeExplicit, makeImplicit} from '../split';\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const scales = model.specifiedScales;\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = scales[channel];\n    const specifiedDomain = specifiedScale ? specifiedScale.domain : undefined;\n\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.setWithExplicit('domains', domains);\n\n    if (isSelectionDomain(specifiedDomain)) {\n      // As scale parsing occurs before selection parsing, we use a temporary\n      // signal here and append the scale.domain definition. This is replaced\n      // with the correct domainRaw signal during scale assembly.\n      // For more information, see isRawSelectionDomain in selection.ts.\n\n      // FIXME: replace this with a special property in the scaleComponent\n      localScaleCmpt.set(\n        'domainRaw',\n        {\n          signal: SELECTION_DOMAIN + util.hash(specifiedDomain)\n        },\n        true\n      );\n    }\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains.value) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let domains: Explicit<VgNonUnionDomain[]>;\n    let domainRaw = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.getWithExplicit('domains');\n        } else {\n          domains = mergeValuesWithExplicit(\n            domains,\n            childComponent.getWithExplicit('domains'),\n            'domains',\n            'scale',\n            domainsTieBreaker\n          );\n        }\n\n        const dr = childComponent.get('domainRaw');\n        if (domainRaw && dr && domainRaw.signal !== dr.signal) {\n          log.warn('The same selection must be used to override scale domains in a layered view.');\n        }\n        domainRaw = dr;\n      }\n    }\n\n    localScaleComponents[channel].setWithExplicit('domains', domains);\n\n    if (domainRaw) {\n      localScaleComponents[channel].set('domainRaw', domainRaw, true);\n    }\n  });\n}\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(\n  domain: Domain,\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig\n) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): Explicit<VgNonUnionDomain[]> {\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  const domain = normalizeUnaggregatedDomain(\n    model.scaleDomain(channel),\n    model.fieldDef(channel),\n    scaleType,\n    model.config.scale\n  );\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'x'),\n        parseSingleChannelDomain(scaleType, domain, model, 'x2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return mergeValuesWithExplicit(\n        parseSingleChannelDomain(scaleType, domain, model, 'y'),\n        parseSingleChannelDomain(scaleType, domain, model, 'y2'),\n        'domain',\n        'scale',\n        domainsTieBreaker\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal<T>(domain: T[], type: Type, timeUnit: TimeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction parseSingleChannelDomain(\n  scaleType: ScaleType,\n  domain: Domain,\n  model: UnitModel,\n  channel: ScaleChannel | 'x2' | 'y2'\n): Explicit<VgNonUnionDomain[]> {\n  const fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n    // explicit value\n    const {type, timeUnit} = fieldDef;\n    if (type === 'temporal' || timeUnit) {\n      return makeExplicit(mapDomainToDataSignal<number | string | boolean | DateTime>(domain, type, timeUnit));\n    }\n\n    return makeExplicit([domain]);\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return makeImplicit([[0, 1]]);\n    }\n\n    const data = model.requestDataName(MAIN);\n    return makeImplicit([\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'start'})\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ]);\n  }\n\n  const sort: undefined | true | VgSortField = isScaleChannel(channel)\n    ? domainSort(model, channel, scaleType)\n    : undefined;\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(MAIN);\n    const {field} = fieldDef;\n    return makeImplicit([\n      {\n        data,\n        field: vgField({field, aggregate: 'min'})\n      },\n      {\n        data,\n        field: vgField({field, aggregate: 'max'})\n      }\n    ]);\n  } else if (isBinning(fieldDef.bin)) {\n    if (hasDiscreteDomain(scaleType)) {\n      if (scaleType === 'bin-ordinal') {\n        // we can omit the domain as it is inferred from the `bins` property\n        return makeImplicit([]);\n      }\n\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return makeImplicit([\n        {\n          // If sort by aggregation of a specified sort field, we need to use RAW table,\n          // so we can aggregate values for the scale independently from the main aggregation.\n          data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n          // Use range if we added it and the scale does not support computing a range as a signal.\n          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n          // we have to use a sort object if sort = true to make the sort correct by bin start\n          sort:\n            sort === true || !isObject(sort)\n              ? {\n                  field: model.vgField(channel, {}),\n                  op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                }\n              : sort\n        }\n      ]);\n    } else {\n      // continuous scales\n      const {bin} = fieldDef;\n      if (isBinning(bin)) {\n        const binSignal = getBinSignalName(model, fieldDef.field, bin);\n        return makeImplicit([\n          new SignalRefWrapper(() => {\n            const signal = model.getSignalName(binSignal);\n            return `[${signal}.start, ${signal}.stop]`;\n          })\n        ]);\n      } else {\n        return makeImplicit([\n          {\n            data: model.requestDataName(MAIN),\n            field: model.vgField(channel, {})\n          }\n        ]);\n      }\n    }\n  } else if (sort) {\n    return makeImplicit([\n      {\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        field: model.vgField(channel),\n        sort: sort\n      }\n    ]);\n  } else {\n    return makeImplicit([\n      {\n        data: model.requestDataName(MAIN),\n        field: model.vgField(channel)\n      }\n    ]);\n  }\n}\n\nfunction normalizeSortField(sort: EncodingSortField<string>, isStacked: boolean) {\n  const {op, field, order} = sort;\n  return {\n    // Apply default op\n    op: op || (isStacked ? 'sum' : DEFAULT_SORT_OP),\n    // flatten nested fields\n    ...(field ? {field: util.replacePathInField(field)} : {}),\n\n    ...(order ? {order} : {})\n  };\n}\n\nexport function domainSort(\n  model: UnitModel,\n  channel: ScaleChannel,\n  scaleType: ScaleType\n): undefined | true | VgSortField {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  // save to cast as the only exception is the geojson type for shape, which would not generate a scale\n  const fieldDef = model.fieldDef(channel) as ScaleFieldDef<string>;\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  const isStacked = model.stack !== null;\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    return normalizeSortField(sort, isStacked);\n  } else if (isSortByEncoding(sort)) {\n    const {encoding, order} = sort;\n    const {aggregate, field} = model.fieldDef(encoding);\n    const sortField: EncodingSortField<string> = {\n      op: aggregate as AggregateOp, // Once we decouple aggregate from aggregate op we won't have to cast here\n      field,\n      order\n    };\n    return normalizeSortField(sortField, isStacked);\n  } else if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  } else if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditions apply:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(\n  fieldDef: TypedFieldDef<string>,\n  scaleType: ScaleType\n): {valid: boolean; reason?: string} {\n  const {aggregate, type} = fieldDef;\n\n  if (!aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (isString(aggregate) && !SHARED_DOMAIN_OP_INDEX[aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(aggregate)\n    };\n  }\n\n  if (type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Tie breaker for mergeValuesWithExplicit for domains. We concat the specified values.\n */\nfunction domainsTieBreaker(\n  v1: Explicit<VgNonUnionDomain[]>,\n  v2: Explicit<VgNonUnionDomain[]>,\n  property: 'domains',\n  propertyOf: 'scale'\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingDomainProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, concat the domains so that we union them later.\n  return {explicit: v1.explicit, value: [...v1.value, ...v2.value]};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(\n    domains.map(domain => {\n      // ignore sort property when computing the unique domains\n      if (isDataRefDomain(domain)) {\n        const {sort: _s, ...domainWithoutSort} = domain;\n        return domainWithoutSort;\n      }\n      return domain;\n    }),\n    util.hash\n  );\n\n  const sorts: VgSortField[] = util.unique(\n    domains\n      .map(d => {\n        if (isDataRefDomain(d)) {\n          const s = d.sort;\n          if (s !== undefined && !util.isBoolean(s)) {\n            if (s.op === 'count') {\n              // let's make sure that if op is count, we don't use a field\n              delete s.field;\n            }\n            if (s.order === 'ascending') {\n              // drop order: ascending as it is the default\n              delete s.order;\n            }\n          }\n          return s;\n        }\n        return undefined;\n      })\n      .filter(s => s !== undefined),\n    util.hash\n  );\n\n  if (uniqueDomains.length === 0) {\n    return undefined;\n  } else if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep simple sort properties that work with unioned domains\n  const simpleSorts = util.unique(\n    sorts.map(s => {\n      if (util.isBoolean(s) || s.op === 'count') {\n        return s;\n      }\n      log.warn(log.message.domainSortDropped(s));\n      return true;\n    }),\n    util.hash\n  ) as VgUnionSortField[];\n\n  let sort: VgUnionSortField;\n\n  if (simpleSorts.length === 1) {\n    sort = simpleSorts[0];\n  } else if (simpleSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(\n    domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    }),\n    x => x\n  );\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgFieldRefUnionDomain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgDataRef).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(\n            'Detected faceted independent scales that union domain of multiple fields from different data sources.  We will use the first field.  The result view size may be incorrect.'\n          );\n          return field;\n        }\n      }\n    }\n    log.warn(\n      'Detected faceted independent scales that union domain of identical fields from different source detected.  We will assume that this is the same field from a different fork of the same data source.  However, if this is not case, the result view size maybe incorrect.'\n    );\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(\n      'Detected faceted independent scales that union domain of multiple fields from the same data source.  We will use the first field.  The result view size may be incorrect.'\n    );\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent = model.component.scales[channel];\n\n  const domains = scaleComponent.get('domains').map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n"]}