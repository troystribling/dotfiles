{"version":3,"file":"properties.js","sourceRoot":"","sources":["../../../../src/compile/scale/properties.ts"],"names":[],"mappings":"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","sourcesContent":["import {isArray} from 'vega-util';\nimport {isBinned, isBinning, isBinParams} from '../../bin';\nimport {Channel, COLOR, FILL, ScaleChannel, STROKE, X, Y} from '../../channel';\nimport {ScaleFieldDef, TypedFieldDef} from '../../channeldef';\nimport {Config} from '../../config';\nimport * as log from '../../log';\nimport {Mark, MarkDef, RectConfig} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  NiceTime,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty\n} from '../../scale';\nimport {Sort} from '../../sort';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {SignalRefWrapper} from './../signal';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseUnitScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = model.specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldDef = model.fieldDef(channel);\n    const config = model.config;\n\n    const specifiedValue = specifiedScale[property];\n    const sType = mergedScaleCmpt.get('type');\n\n    const supportedByScaleType = scaleTypeSupportProperty(sType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(sType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        // copyKeyFromObject ensures type safety\n        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n      } else {\n        const value = getDefaultValue(\n          property,\n          model,\n          channel,\n          fieldDef,\n          mergedScaleCmpt.get('type'),\n          mergedScaleCmpt.get('padding'),\n          mergedScaleCmpt.get('paddingInner'),\n          specifiedScale.domain,\n          model.markDef,\n          config\n        );\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  });\n}\n\n// Note: This method is used in Voyager.\nexport function getDefaultValue(\n  property: keyof Scale,\n  model: Model,\n  channel: Channel,\n  fieldDef: ScaleFieldDef<string, Type>,\n  scaleType: ScaleType,\n  scalePadding: number,\n  scalePaddingInner: number,\n  specifiedDomain: Scale['domain'],\n  markDef: MarkDef,\n  config: Config\n) {\n  const scaleConfig = config.scale;\n  const {type, sort} = fieldDef;\n\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'bins':\n      return bins(model, fieldDef);\n    case 'interpolate':\n      return interpolate(channel, type);\n    case 'nice':\n      return nice(scaleType, channel, fieldDef);\n    case 'padding':\n      return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);\n    case 'paddingInner':\n      return paddingInner(scalePadding, channel, markDef.type, scaleConfig);\n    case 'paddingOuter':\n      return paddingOuter(scalePadding, channel, scaleType, markDef.type, scalePaddingInner, scaleConfig);\n    case 'reverse':\n      return reverse(scaleType, sort);\n    case 'zero':\n      return zero(channel, fieldDef, specifiedDomain, markDef, scaleType);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n\n// This method is here rather than in range.ts to avoid circular dependency.\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit,\n          childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For range step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  });\n}\n\nexport function bins(model: Model, fieldDef: TypedFieldDef<string>) {\n  const bin = fieldDef.bin;\n  if (isBinning(bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, bin);\n    return new SignalRefWrapper(() => {\n      return model.getSignalName(binSignal);\n    });\n  } else if (isBinned(bin) && isBinParams(bin) && bin.step !== undefined) {\n    // start and stop will be determined from the scale domain\n    return {\n      step: bin.step\n    };\n  }\n  return undefined;\n}\n\nexport function interpolate(channel: Channel, type: Type) {\n  if (contains([COLOR, FILL, STROKE], channel) && type !== 'nominal') {\n    return 'hcl';\n  }\n  return undefined;\n}\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: TypedFieldDef<string>): boolean | NiceTime {\n  if (fieldDef.bin || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return util.contains([X, Y], channel) ? true : undefined;\n}\n\nexport function padding(\n  channel: Channel,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig,\n  fieldDef: TypedFieldDef<string>,\n  markDef: MarkDef,\n  barConfig: RectConfig\n) {\n  if (util.contains([X, Y], channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !fieldDef.bin) {\n        if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(paddingValue: number, channel: Channel, mark: Mark, scaleConfig: ScaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n\n    const {bandPaddingInner, barBandPaddingInner, rectBandPaddingInner} = scaleConfig;\n\n    return getFirstDefined(bandPaddingInner, mark === 'bar' ? barBandPaddingInner : rectBandPaddingInner);\n  }\n  return undefined;\n}\n\nexport function paddingOuter(\n  paddingValue: number,\n  channel: Channel,\n  scaleType: ScaleType,\n  mark: Mark,\n  paddingInnerValue: number,\n  scaleConfig: ScaleConfig\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      const {bandPaddingOuter, barBandPaddingOuter, rectBandPaddingOuter} = scaleConfig;\n\n      return getFirstDefined(\n        bandPaddingOuter,\n        mark === 'bar' ? barBandPaddingOuter : rectBandPaddingOuter,\n        /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n        paddingInnerValue / 2\n      );\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(scaleType: ScaleType, sort: Sort<string>) {\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(\n  channel: Channel,\n  fieldDef: TypedFieldDef<string>,\n  specifiedDomain: Domain,\n  markDef: MarkDef,\n  scaleType: ScaleType\n) {\n  // If users explicitly provide a domain range, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedDomain && specifiedDomain !== 'unaggregated';\n  if (hasCustomDomain) {\n    if (hasContinuousDomain(scaleType)) {\n      if (isArray(specifiedDomain)) {\n        const first = specifiedDomain[0];\n        const last = specifiedDomain[specifiedDomain.length - 1];\n\n        if (first <= 0 && last >= 0) {\n          // if the domain includes zero, make zero remains true\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  // If there is no custom domain, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  if (!fieldDef.bin && util.contains([X, Y], channel)) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n"]}