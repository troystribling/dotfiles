{"version":3,"file":"range.js","sourceRoot":"","sources":["../../../../src/compile/scale/range.ts"],"names":[],"mappings":"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","sourcesContent":["import {SignalRef} from 'vega';\nimport {isArray, isNumber} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {\n  Channel,\n  COLOR,\n  FILL,\n  FILLOPACITY,\n  OPACITY,\n  POSITION_SCALE_CHANNELS,\n  ScaleChannel,\n  SCALE_CHANNELS,\n  SHAPE,\n  SIZE,\n  STROKE,\n  STROKEOPACITY,\n  STROKEWIDTH,\n  X,\n  Y\n} from '../../channel';\nimport {Config} from '../../config';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  hasDiscreteDomain,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {isSignalRef, isVgRangeStep, SchemeConfig, VgRange} from '../../vega.schema';\nimport {getBinSignalName} from '../data/bin';\nimport {Rename, SignalRefWrapper} from '../signal';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'rangeStep', 'scheme'];\n\nfunction getSizeType(channel: ScaleChannel) {\n  return channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n}\n\nexport function parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  SCALE_CHANNELS.forEach((channel: ScaleChannel) => {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      return;\n    }\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n\n    const specifiedScale = model.specifiedScales[channel];\n    const fieldDef = model.fieldDef(channel);\n\n    // Read if there is a specified width/height\n    const sizeType = getSizeType(channel);\n    let sizeSpecified = sizeType ? !!model.component.layoutSize.get(sizeType) : undefined;\n\n    const scaleType = mergedScaleCmpt.get('type');\n\n    // if autosize is fit, size cannot be data driven\n    const rangeStep = util.contains(['point', 'band'], scaleType) || !!specifiedScale.rangeStep;\n    if (sizeType && model.fit && !sizeSpecified && rangeStep) {\n      log.warn(log.message.CANNOT_FIX_RANGE_STEP_WITH_FIT);\n      sizeSpecified = true;\n    }\n\n    const xyRangeSteps = getXYRangeStep(model);\n\n    const rangeWithExplicit = parseRangeForChannel(\n      channel,\n      model.getSignalName.bind(model),\n      scaleType,\n      fieldDef.type,\n      specifiedScale,\n      model.config,\n      localScaleCmpt.get('zero'),\n      model.mark,\n      sizeSpecified,\n      model.getName(sizeType),\n      xyRangeSteps\n    );\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getRangeStep(model: UnitModel, channel: 'x' | 'y'): number | SignalRef {\n  const scaleCmpt = model.getScaleComponent(channel);\n  if (!scaleCmpt) {\n    return undefined;\n  }\n\n  const scaleType = scaleCmpt.get('type');\n  const fieldDef = model.fieldDef(channel);\n\n  if (hasDiscreteDomain(scaleType)) {\n    const range = scaleCmpt && scaleCmpt.get('range');\n    if (range && isVgRangeStep(range) && isNumber(range.step)) {\n      return range.step;\n      // TODO: support the case without range step\n    }\n  } else if (fieldDef && fieldDef.bin && isBinning(fieldDef.bin)) {\n    const binSignal = getBinSignalName(model, fieldDef.field, fieldDef.bin);\n\n    // TODO: extract this to be range step signal\n    const sizeType = getSizeType(channel);\n    const sizeSignal = model.getName(sizeType);\n    return new SignalRefWrapper(() => {\n      const updatedName = model.getSignalName(binSignal);\n      const binCount = `(${updatedName}.stop - ${updatedName}.start) / ${updatedName}.step`;\n      return `${model.getSignalName(sizeSignal)} / (${binCount})`;\n    });\n  }\n  return undefined;\n}\n\nfunction getXYRangeStep(model: UnitModel) {\n  const steps: (number | SignalRef)[] = [];\n  for (const channel of POSITION_SCALE_CHANNELS) {\n    const step = getRangeStep(model, channel);\n    if (step !== undefined) {\n      steps.push(step);\n    }\n  }\n  return steps;\n}\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport function parseRangeForChannel(\n  channel: Channel,\n  getSignalName: Rename,\n  scaleType: ScaleType,\n  type: Type,\n  specifiedScale: Scale,\n  config: Config,\n  zero: boolean,\n  mark: Mark,\n  sizeSpecified: boolean,\n  sizeSignal: string,\n  xyRangeSteps: (number | SignalRef)[]\n): Explicit<VgRange> {\n  const noRangeStep = sizeSpecified || specifiedScale.rangeStep === null;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n          case 'rangeStep': {\n            const rangeStep = specifiedScale[property];\n            if (rangeStep !== null) {\n              if (!sizeSpecified) {\n                return makeExplicit({step: rangeStep});\n              } else {\n                // If top-level size is specified, we ignore specified rangeStep.\n                log.warn(log.message.rangeStepDropped(channel));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return makeImplicit(\n    defaultRange(\n      channel,\n      getSignalName,\n      scaleType,\n      type,\n      config,\n      zero,\n      mark,\n      sizeSignal,\n      xyRangeSteps,\n      noRangeStep,\n      specifiedScale.domain\n    )\n  );\n}\n\nfunction parseScheme(scheme: Scheme): SchemeConfig {\n  if (isExtendedScheme(scheme)) {\n    return {\n      scheme: scheme.name,\n      ...util.omit(scheme, ['name'])\n    };\n  }\n  return {scheme: scheme};\n}\n\nfunction defaultRange(\n  channel: Channel,\n  getSignalName: Rename,\n  scaleType: ScaleType,\n  type: Type,\n  config: Config,\n  zero: boolean,\n  mark: Mark,\n  sizeSignal: string,\n  xyRangeSteps: (number | SignalRef)[],\n  noRangeStep: boolean,\n  domain: Domain\n): VgRange {\n  switch (channel) {\n    case X:\n    case Y:\n      if (util.contains(['point', 'band'], scaleType) && !noRangeStep) {\n        if (channel === X && mark === 'text') {\n          if (config.scale.textXRangeStep) {\n            return {step: config.scale.textXRangeStep};\n          }\n        } else {\n          if (config.scale.rangeStep) {\n            return {step: config.scale.rangeStep};\n          }\n        }\n      }\n\n      // If range step is null, use zero to width or height.\n      // Note that these range signals are temporary\n      // as they can be merged and renamed.\n      // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n      // We will later replace these temporary names with\n      // the final name in assembleScaleRange()\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [SignalRefWrapper.fromName(getSignalName, sizeSignal), 0];\n      } else {\n        return [0, SignalRefWrapper.fromName(getSignalName, sizeSignal)];\n      }\n    case SIZE: {\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    }\n    case STROKEWIDTH:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minStrokeWidth, config.scale.maxStrokeWidth];\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n    case OPACITY:\n    case FILLOPACITY:\n    case STROKEOPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: Channel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin: number, rangeMax: number | SignalRef, cardinality: number): SignalRef {\n  // always return a signal since it's better to compute the sequence in Vega later\n  const f = () => {\n    const rMax = isSignalRef(rangeMax) ? rangeMax.signal : rangeMax;\n    const step = `(${rMax} - ${rangeMin}) / (${cardinality} - 1)`;\n    return `sequence(${rangeMin}, ${rangeMax} + ${step}, ${step})`;\n  };\n  if (isSignalRef(rangeMax)) {\n    return new SignalRefWrapper(f);\n  } else {\n    return {signal: f()};\n  }\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nexport const MAX_SIZE_RANGE_STEP_RATIO = 0.95;\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: (number | SignalRef)[], config: Config): number | SignalRef {\n  const scaleConfig = config.scale;\n  switch (mark) {\n    case 'bar':\n    case 'tick': {\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      const min = minXYRangeStep(xyRangeSteps, config.scale);\n\n      if (isNumber(min)) {\n        return min - 1;\n      } else {\n        return new SignalRefWrapper(() => `${min.signal} - 1`);\n      }\n    }\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle': {\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      if (isNumber(pointStep)) {\n        return Math.pow(MAX_SIZE_RANGE_STEP_RATIO * pointStep, 2);\n      } else {\n        return new SignalRefWrapper(() => `pow(${MAX_SIZE_RANGE_STEP_RATIO} * ${pointStep.signal}, 2)`);\n      }\n    }\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: (number | SignalRef)[], scaleConfig: ScaleConfig): number | SignalRef {\n  if (xyRangeSteps.length > 0) {\n    let min = Infinity;\n\n    for (const step of xyRangeSteps) {\n      if (isSignalRef(step)) {\n        min = undefined;\n      } else {\n        if (min !== undefined && step < min) {\n          min = step;\n        }\n      }\n    }\n\n    return min !== undefined\n      ? min\n      : new SignalRefWrapper(() => {\n          const exprs = xyRangeSteps.map(e => (isSignalRef(e) ? e.signal : e));\n          return `min(${exprs.join(', ')})`;\n        });\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n"]}