{"version":3,"file":"parse.js","sourceRoot":"","sources":["../../../../src/compile/selection/parse.ts"],"names":[],"mappings":";AAAA,OAAO,EAAC,QAAQ,IAAI,aAAa,EAAC,MAAM,qBAAqB,CAAC;AAC9D,OAAO,EAAC,QAAQ,EAAC,MAAM,WAAW,CAAC;AAGnC,OAAO,EAAO,SAAS,EAAE,OAAO,EAAC,MAAM,YAAY,CAAC;AAEpD,OAAO,EAAC,gBAAgB,EAAC,MAAM,yBAAyB,CAAC;AAEzD,MAAM,UAAU,kBAAkB,CAAC,KAAgB,EAAE,OAA2B;IAC9E,MAAM,QAAQ,GAA+F,EAAE,CAAC;IAChH,MAAM,eAAe,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC;IAE/C,IAAI,OAAO,EAAE;QACX,OAAO,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,mDAAmD;KAClF;IAED,KAAK,IAAI,IAAI,IAAI,OAAO,EAAE;QACxB,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;YACjC,SAAS;SACV;QAED,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7B,MAAM,iCAA0D,EAA1D,EAAC,MAAM,EAAE,SAAS,OAAwC,EAAtC,iDAAsC,CAAC,CAAC,0CAA0C;QAE5G,sEAAsE;QACtE,mEAAmE;QACnE,uEAAuE;QACvE,sCAAsC;QACtC,KAAK,MAAM,GAAG,IAAI,GAAG,EAAE;YACrB,sEAAsE;YACtE,uEAAuE;YACvE,IAAI,CAAC,GAAG,KAAK,WAAW,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,KAAK,QAAQ,IAAI,MAAM,CAAC,SAAS,CAAC,EAAE;gBACpF,SAAS;aACV;YAED,IAAI,GAAG,KAAK,MAAM,EAAE;gBAClB,MAAM,CAAC,GAAG,CAAC,qBAAO,GAAG,CAAC,GAAG,CAAC,EAAK,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;aAC7C;YAED,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,SAAS,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,IAAI,EAAE;gBACrD,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,GAAG,CAAC,CAAC;aACvC;SACF;QAED,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;QACrB,MAAM,OAAO,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,kBAC7B,MAAM,IACT,IAAI,EAAE,IAAI,EACV,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,GACrE,CAAC,CAAC;QAEV,gBAAgB,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE;YACrC,IAAI,UAAU,CAAC,KAAK,EAAE;gBACpB,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;aAC1C;QACH,CAAC,CAAC,CAAC;KACJ;IAED,OAAO,QAAQ,CAAC;AAClB,CAAC","sourcesContent":["import {selector as parseSelector} from 'vega-event-selector';\nimport {isString} from 'vega-util';\nimport {SelectionComponent} from '.';\nimport {SelectionDef} from '../../selection';\nimport {Dict, duplicate, varName} from '../../util';\nimport {UnitModel} from '../unit';\nimport {forEachTransform} from './transforms/transforms';\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent<any /* this has to be \"any\" so typing won't fail in test files*/>> = {};\n  const selectionConfig = model.config.selection;\n\n  if (selDefs) {\n    selDefs = duplicate(selDefs); // duplicate to avoid side effects to original spec\n  }\n\n  for (let name in selDefs) {\n    if (!selDefs.hasOwnProperty(name)) {\n      continue;\n    }\n\n    const selDef = selDefs[name];\n    const {fields, encodings, ...cfg} = selectionConfig[selDef.type]; // Project transform applies its defaults.\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = {...cfg[key], ...selDef[key]};\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    name = varName(name);\n    const selCmpt = (selCmpts[name] = {\n      ...selDef,\n      name: name,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on\n    } as any);\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selDef, selCmpt);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n"]}