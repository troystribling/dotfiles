{"version":3,"file":"project.js","sourceRoot":"","sources":["../../../../../src/compile/selection/transforms/project.ts"],"names":[],"mappings":";AAAA,OAAO,EAAC,KAAK,EAAE,OAAO,EAAC,MAAM,WAAW,CAAC;AACzC,OAAO,EAAC,sBAAsB,EAAqC,MAAM,kBAAkB,CAAC;AAC5F,OAAO,KAAK,GAAG,MAAM,cAAc,CAAC;AACpC,OAAO,EAAC,mBAAmB,EAAC,MAAM,gBAAgB,CAAC;AACnD,OAAO,EAAC,mBAAmB,EAAqD,MAAM,oBAAoB,CAAC;AAC3G,OAAO,EAAO,IAAI,EAAE,IAAI,EAAE,OAAO,EAAC,MAAM,eAAe,CAAC;AACxD,OAAO,EAAoB,YAAY,EAAC,MAAM,qBAAqB,CAAC;AACpE,OAAO,MAAM,MAAM,UAAU,CAAC;AAG9B,MAAM,CAAC,MAAM,YAAY,GAAG,eAAe,CAAC;AAe5C,MAAM,OAAO,4BAA4B;IAKvC,YAAY,GAAG,KAA4B;QACzC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;IAChB,CAAC;CACF;AAED,MAAM,OAAO,GAAsB;IACjC,GAAG,EAAE,GAAG,EAAE;QACR,OAAO,IAAI,CAAC,CAAC,gEAAgE;IAC/E,CAAC;IAED,KAAK,EAAE,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE;QAChC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC;QAC1B,MAAM,IAAI,GAAG,OAAO,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI,4BAA4B,EAAE,CAAC,CAAC;QACvF,MAAM,MAAM,GAA8B,EAAE,CAAC;QAC7C,MAAM,SAAS,GAA4B,EAAE,CAAC;QAE9C,MAAM,OAAO,GAAG,IAAI,GAAG,EAAU,CAAC;QAClC,MAAM,UAAU,GAAG,CAAC,CAAsB,EAAE,KAAwB,EAAE,EAAE;YACtE,MAAM,MAAM,GAAG,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YACxD,IAAI,EAAE,GAAG,OAAO,CAAC,GAAG,IAAI,IAAI,MAAM,EAAE,CAAC,CAAC;YACtC,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,OAAO,EAAE,EAAE;gBAChD,EAAE,GAAG,OAAO,CAAC,GAAG,IAAI,IAAI,MAAM,IAAI,OAAO,EAAE,CAAC,CAAC;aAC9C;YACD,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YAChB,OAAO,EAAC,CAAC,KAAK,CAAC,EAAE,EAAE,EAAC,CAAC;QACvB,CAAC,CAAC;QAEF,0FAA0F;QAC1F,wDAAwD;QACxD,4CAA4C;QAC5C,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;YACvC,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;YAEhD,IAAI,MAAM,CAAC,IAAI,EAAE;gBACf,KAAK,MAAM,IAAI,IAAI,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE;oBACrC,KAAK,MAAM,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE;wBAC5B,IAAI,sBAAsB,CAAC,GAAG,CAAC,EAAE;4BAC/B,CAAC,MAAM,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC,SAAS,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAA2B,CAAC,CAAC;yBACjF;6BAAM;4BACL,IAAI,mBAAmB,CAAC,MAAM,CAAC,EAAE;gCAC/B,GAAG,CAAC,IAAI,CAAC,sEAAsE,CAAC,CAAC;gCACjF,MAAM,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;6BAClC;iCAAM;gCACL,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;6BACnD;yBACF;qBACF;iBACF;aACF;iBAAM;gBACL,MAAM,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS,CAAC;gBACjC,MAAM,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aAC5B;SACF;QAED,0DAA0D;QAC1D,KAAK,MAAM,KAAK,IAAI,MAAM,CAAC,MAAM,IAAI,EAAE,EAAE;YACvC,MAAM,CAAC,GAAwB,EAAC,IAAI,EAAE,GAAG,EAAE,KAAK,EAAC,CAAC;YAClD,CAAC,CAAC,OAAO,qBAAO,UAAU,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC;YACvC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;SACpB;QAED,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,SAAS,IAAI,EAAE,EAAE;YAC5C,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;YACzC,IAAI,QAAQ,EAAE;gBACZ,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;gBAC3B,IAAI,QAAQ,CAAC,QAAQ,EAAE;oBACrB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;oBAE/B,6DAA6D;oBAC7D,2DAA2D;oBAC3D,6DAA6D;oBAC7D,iCAAiC;oBACjC,MAAM,SAAS,GAAG;wBAChB,EAAE,EAAE,KAAK;wBACT,KAAK,EAAE,QAAQ,CAAC,KAAK;wBACrB,QAAQ,EAAE,QAAQ,CAAC,QAAQ;qBAC5B,CAAC;oBACF,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,SAAS,CAAC;iBACxC;gBAED,mDAAmD;gBACnD,iFAAiF;gBACjF,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;oBAClB,sEAAsE;oBACtE,sFAAsF;oBACtF,sFAAsF;oBACtF,IAAI,IAAI,GAAmB,GAAG,CAAC;oBAC/B,IAAI,OAAO,CAAC,IAAI,KAAK,UAAU,EAAE;wBAC/B,MAAM,SAAS,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAuB,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;wBAC/E,IAAI,mBAAmB,CAAC,SAAS,CAAC,EAAE;4BAClC,IAAI,GAAG,GAAG,CAAC;yBACZ;qBACF;yBAAM,IAAI,QAAQ,CAAC,GAAG,EAAE;wBACvB,IAAI,GAAG,MAAM,CAAC;qBACf;oBAED,MAAM,CAAC,GAAwB,EAAC,KAAK,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC;oBACtD,CAAC,CAAC,OAAO,qBAAO,UAAU,CAAC,CAAC,EAAE,MAAM,CAAC,EAAK,UAAU,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;oBACnE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;oBACrC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;iBACnC;aACF;iBAAM;gBACL,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,kCAAkC,CAAC,OAAO,CAAC,CAAC,CAAC;aACnE;SACF;QAED,IAAI,MAAM,CAAC,IAAI,EAAE;YACf,IAAI,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;gBACvB,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,sBAAsB,CAAC,CAAC;aAC9C;iBAAM;gBACL,MAAM,SAAS,GAAG,CAAgE,CAAI,EAAY,EAAE;oBAClG,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACvF,CAAC,CAAC;gBAEF,IAAI,mBAAmB,CAAC,MAAM,CAAC,EAAE;oBAC/B,OAAO,CAAC,IAAI,GAAG,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;iBACvC;qBAAM;oBACL,MAAM,IAAI,GAAG,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;oBAChE,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;iBACpC;aACF;SACF;QAED,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,EAAE;YAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SACnD;IACH,CAAC;IAED,OAAO,EAAE,CAAC,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE,EAAE;QACtC,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,GAAG,YAAY,CAAC;QACzC,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;QAC1D,OAAO,SAAS,CAAC,MAAM;YACrB,CAAC,CAAC,UAAU;YACZ,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC;gBAChB,IAAI;gBACJ,KAAK,EAAE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;oBACtC,MAAM,EAAC,OAAO,KAAa,IAAI,EAAf,wCAAe,CAAC;oBAChC,OAAO,IAAI,CAAC;gBACd,CAAC,CAAC;aACH,CAAC,CAAC;IACT,CAAC;CACF,CAAC;AAEF,eAAe,OAAO,CAAC","sourcesContent":["import {array, isArray} from 'vega-util';\nimport {isSingleDefUnitChannel, ScaleChannel, SingleDefUnitChannel} from '../../../channel';\nimport * as log from '../../../log';\nimport {hasContinuousDomain} from '../../../scale';\nimport {isIntervalSelection, SelectionInitIntervalMapping, SelectionInitMapping} from '../../../selection';\nimport {Dict, hash, keys, varName} from '../../../util';\nimport {TimeUnitComponent, TimeUnitNode} from '../../data/timeunit';\nimport scales from './scales';\nimport {TransformCompiler} from './transforms';\n\nexport const TUPLE_FIELDS = '_tuple_fields';\n\n/**\n * Do the selection tuples hold enumerated or ranged values for a field?\n * Ranged values can be left-right inclusive (R) or left-inclusive, right-exclusive (R-LE).\n */\nexport type TupleStoreType = 'E' | 'R' | 'R-RE';\n\nexport interface SelectionProjection {\n  type: TupleStoreType;\n  field: string;\n  channel?: SingleDefUnitChannel;\n  signals?: {data?: string; visual?: string};\n}\n\nexport class SelectionProjectionComponent {\n  public has: {[key in SingleDefUnitChannel]?: SelectionProjection};\n  public timeUnit?: TimeUnitNode;\n  public items: SelectionProjection[];\n\n  constructor(...items: SelectionProjection[]) {\n    this.items = items;\n    this.has = {};\n  }\n}\n\nconst project: TransformCompiler = {\n  has: () => {\n    return true; // This transform handles its own defaults, so always run parse.\n  },\n\n  parse: (model, selDef, selCmpt) => {\n    const name = selCmpt.name;\n    const proj = selCmpt.project || (selCmpt.project = new SelectionProjectionComponent());\n    const parsed: Dict<SelectionProjection> = {};\n    const timeUnits: Dict<TimeUnitComponent> = {};\n\n    const signals = new Set<string>();\n    const signalName = (p: SelectionProjection, range: 'data' | 'visual') => {\n      const suffix = range === 'visual' ? p.channel : p.field;\n      let sg = varName(`${name}_${suffix}`);\n      for (let counter = 1; signals.has(sg); counter++) {\n        sg = varName(`${name}_${suffix}_${counter}`);\n      }\n      signals.add(sg);\n      return {[range]: sg};\n    };\n\n    // If no explicit projection (either fields or encodings) is specified, set some defaults.\n    // If an initial value is set, try to infer projections.\n    // Otherwise, use the default configuration.\n    if (!selDef.fields && !selDef.encodings) {\n      const cfg = model.config.selection[selDef.type];\n\n      if (selDef.init) {\n        for (const init of array(selDef.init)) {\n          for (const key of keys(init)) {\n            if (isSingleDefUnitChannel(key)) {\n              (selDef.encodings || (selDef.encodings = [])).push(key as SingleDefUnitChannel);\n            } else {\n              if (isIntervalSelection(selDef)) {\n                log.warn('Interval selections should be initialized using \"x\" and/or \"y\" keys.');\n                selDef.encodings = cfg.encodings;\n              } else {\n                (selDef.fields || (selDef.fields = [])).push(key);\n              }\n            }\n          }\n        }\n      } else {\n        selDef.encodings = cfg.encodings;\n        selDef.fields = cfg.fields;\n      }\n    }\n\n    // TODO: find a possible channel mapping for these fields.\n    for (const field of selDef.fields || []) {\n      const p: SelectionProjection = {type: 'E', field};\n      p.signals = {...signalName(p, 'data')};\n      proj.items.push(p);\n    }\n\n    for (const channel of selDef.encodings || []) {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        let field = fieldDef.field;\n        if (fieldDef.timeUnit) {\n          field = model.vgField(channel);\n\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          const component = {\n            as: field,\n            field: fieldDef.field,\n            timeUnit: fieldDef.timeUnit\n          };\n          timeUnits[hash(component)] = component;\n        }\n\n        // Prevent duplicate projections on the same field.\n        // TODO: what if the same field is bound to multiple channels (e.g., SPLOM diag).\n        if (!parsed[field]) {\n          // Determine whether the tuple will store enumerated or ranged values.\n          // Interval selections store ranges for continuous scales, and enumerations otherwise.\n          // Single/multi selections store ranges for binned fields, and enumerations otherwise.\n          let type: TupleStoreType = 'E';\n          if (selCmpt.type === 'interval') {\n            const scaleType = model.getScaleComponent(channel as ScaleChannel).get('type');\n            if (hasContinuousDomain(scaleType)) {\n              type = 'R';\n            }\n          } else if (fieldDef.bin) {\n            type = 'R-RE';\n          }\n\n          const p: SelectionProjection = {field, channel, type};\n          p.signals = {...signalName(p, 'data'), ...signalName(p, 'visual')};\n          proj.items.push((parsed[field] = p));\n          proj.has[channel] = parsed[field];\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    }\n\n    if (selDef.init) {\n      if (scales.has(selCmpt)) {\n        log.warn(log.message.NO_INIT_SCALE_BINDINGS);\n      } else {\n        const parseInit = <T extends SelectionInitMapping | SelectionInitIntervalMapping>(i: T): T['a'][] => {\n          return proj.items.map(p => (i[p.channel] !== undefined ? i[p.channel] : i[p.field]));\n        };\n\n        if (isIntervalSelection(selDef)) {\n          selCmpt.init = parseInit(selDef.init);\n        } else {\n          const init = isArray(selDef.init) ? selDef.init : [selDef.init];\n          selCmpt.init = init.map(parseInit);\n        }\n      }\n    }\n\n    if (keys(timeUnits).length) {\n      proj.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  },\n\n  signals: (model, selCmpt, allSignals) => {\n    const name = selCmpt.name + TUPLE_FIELDS;\n    const hasSignal = allSignals.filter(s => s.name === name);\n    return hasSignal.length\n      ? allSignals\n      : allSignals.concat({\n          name,\n          value: selCmpt.project.items.map(proj => {\n            const {signals, ...rest} = proj;\n            return rest;\n          })\n        });\n  }\n};\n\nexport default project;\n"]}