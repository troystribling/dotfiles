{"version":3,"file":"encoding.js","sourceRoot":"","sources":["../../src/encoding.ts"],"names":[],"mappings":"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","sourcesContent":["import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isArgmaxDef, isArgminDef} from './aggregate';\nimport {isBinned, isBinning} from './bin';\nimport {Channel, CHANNELS, isChannel, isNonPositionScaleChannel, isSecondaryRangeChannel, supportMark} from './channel';\nimport {\n  binRequiresRange,\n  ChannelDef,\n  Field,\n  FieldDef,\n  FieldDefWithoutScale,\n  getFieldDef,\n  getGuide,\n  getTypedFieldDef,\n  hasConditionalFieldDef,\n  isConditionalDef,\n  isFieldDef,\n  isTypedFieldDef,\n  isValueDef,\n  LatLongFieldDef,\n  normalize,\n  normalizeFieldDef,\n  NumericFieldDefWithCondition,\n  NumericValueDefWithCondition,\n  OrderFieldDef,\n  PositionFieldDef,\n  SecondaryFieldDef,\n  ShapeFieldDefWithCondition,\n  ShapeValueDefWithCondition,\n  StringFieldDefWithCondition,\n  StringValueDefWithCondition,\n  TextFieldDef,\n  TextFieldDefWithCondition,\n  TextValueDefWithCondition,\n  title,\n  TypedFieldDef,\n  ValueDef,\n  vgField\n} from './channeldef';\nimport {Config} from './config';\nimport * as log from './log';\nimport {Mark} from './mark';\nimport {EncodingFacetMapping} from './spec/facet';\nimport {getDateTimeComponents} from './timeunit';\nimport {AggregatedFieldDef, BinTransform, TimeUnitTransform} from './transform';\nimport {TEMPORAL} from './type';\nimport {keys, some} from './util';\n\nexport interface Encoding<F extends Field> {\n  /**\n   * X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"` without specified `x2` or `width`.\n   *\n   * The `value` of this channel can be a number or a string `\"width\"` for the width of the plot.\n   */\n  x?: PositionFieldDef<F> | ValueDef<number | 'width'>;\n\n  /**\n   * Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"` without specified `y2` or `height`.\n   *\n   * The `value` of this channel can be a number or a string `\"height\"` for the height of the plot.\n   */\n  y?: PositionFieldDef<F> | ValueDef<number | 'height'>;\n\n  /**\n   * X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   *\n   * The `value` of this channel can be a number or a string `\"width\"` for the width of the plot.\n   */\n  // TODO: Ham need to add default behavior\n  // `x2` cannot have type as it should have the same type as `x`\n  x2?: SecondaryFieldDef<F> | ValueDef<number | 'width'>;\n\n  /**\n   * Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   *\n   * The `value` of this channel can be a number or a string `\"height\"` for the height of the plot.\n   */\n  // TODO: Ham need to add default behavior\n  // `y2` cannot have type as it should have the same type as `y`\n  y2?: SecondaryFieldDef<F> | ValueDef<number | 'height'>;\n\n  /**\n   * Longitude position of geographically projected marks.\n   */\n  longitude?: LatLongFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Latitude position of geographically projected marks.\n   */\n  latitude?: LatLongFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // `longitude2` cannot have type as it should have the same type as `longitude`\n  longitude2?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // `latitude2` cannot have type as it should have the same type as `latitude`\n  latitude2?: SecondaryFieldDef<F> | ValueDef<number>;\n\n  /**\n   * Color of the marks – either fill or stroke color based on  the `filled` property of mark definition.\n   * By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n   * `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n   *\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_\n   * 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels.  If either `fill` or `stroke` channel is specified, `color` channel will be ignored.\n   * 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).\n   */\n  color?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * Fill color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ When using `fill` channel, `color ` channel will be ignored. To customize both fill and stroke, please use `fill` and `stroke` channels (not `fill` and `color`).\n   */\n  fill?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * Stroke color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ When using `stroke` channel, `color ` channel will be ignored. To customize both stroke and fill, please use `stroke` and `fill` channels (not `stroke` and `color`).\n   */\n\n  stroke?: StringFieldDefWithCondition<F> | StringValueDefWithCondition<F>;\n\n  /**\n   * Opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.\n   */\n  opacity?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Fill opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `fillOpacity` property.\n   */\n  fillOpacity?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Stroke opacity of the marks.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeOpacity` property.\n   */\n  strokeOpacity?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Stroke width of the marks.\n   *\n   * __Default value:__ If undefined, the default stroke width depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `strokeWidth` property.\n   */\n  strokeWidth?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Size of the mark.\n   * - For `\"point\"`, `\"square\"` and `\"circle\"`, – the symbol size, or pixel area of the mark.\n   * - For `\"bar\"` and `\"tick\"` – the bar and tick's size.\n   * - For `\"text\"` – the text's font size.\n   * - Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)\n   */\n  size?: NumericFieldDefWithCondition<F> | NumericValueDefWithCondition<F>;\n\n  /**\n   * Shape of the mark.\n   *\n   * 1. For `point` marks the supported values include:\n   *   - plotting shapes: `\"circle\"`, `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, `\"triangle-down\"`, `\"triangle-right\"`, or `\"triangle-left\"`.\n   *   - the line symbol `\"stroke\"`\n   *   - centered directional shapes `\"arrow\"`, `\"wedge\"`, or `\"triangle\"`\n   *   - a custom [SVG path string](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths) (For correct sizing, custom shape paths should be defined within a square bounding box with coordinates ranging from -1 to 1 along both the x and y dimensions.)\n   *\n   * 2. For `geoshape` marks it should be a field definition of the geojson data\n   *\n   * __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property. (`\"circle\"` if unset.)\n   */\n  shape?: ShapeFieldDefWithCondition<F> | ShapeValueDefWithCondition<F>;\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line, trail, and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDefWithoutScale<F> | FieldDefWithoutScale<F>[];\n\n  /**\n   * A data field to use as a unique key for data binding. When a visualization’s data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.\n   */\n  key?: FieldDefWithoutScale<F>;\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: TextFieldDefWithCondition<F> | TextValueDefWithCondition<F>;\n\n  /**\n   * The tooltip text to show upon mouse hover.\n   */\n  tooltip?: TextFieldDefWithCondition<F> | TextValueDefWithCondition<F> | TextFieldDef<F>[] | null;\n\n  /**\n   * A URL to load upon mouse click.\n   */\n  href?: TextFieldDefWithCondition<F> | TextValueDefWithCondition<F>;\n\n  /**\n   * Order of the marks.\n   * - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n   * - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).  Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n   * - Otherwise, this `order` channel encodes layer order of the marks.\n   *\n   * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.\n   */\n  order?: OrderFieldDef<F> | OrderFieldDef<F>[] | ValueDef<number>;\n}\n\nexport interface EncodingWithFacet<F extends Field> extends Encoding<F>, EncodingFacetMapping<F> {}\n\nexport function channelHasField<F extends Field>(encoding: EncodingWithFacet<F>, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: EncodingWithFacet<Field>) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function extractTransformsFromEncoding(oldEncoding: Encoding<Field>, config: Config) {\n  const groupby: string[] = [];\n  const bins: BinTransform[] = [];\n  const timeUnits: TimeUnitTransform[] = [];\n  const aggregate: AggregatedFieldDef[] = [];\n  const encoding: Encoding<string> = {};\n\n  forEach(oldEncoding, (channelDef, channel) => {\n    // Extract potential embedded transformations along with remaining properties\n    if (isFieldDef(channelDef)) {\n      const {field, aggregate: aggOp, timeUnit, bin, ...remaining} = channelDef;\n      if (aggOp || timeUnit || bin) {\n        const guide = getGuide(channelDef);\n        const isTitleDefined = guide && guide.title;\n        let newField = vgField(channelDef, {forAs: true});\n        const newFieldDef: FieldDef<string> = {\n          // Only add title if it doesn't exist\n          ...(isTitleDefined ? [] : {title: title(channelDef, config, {allowDisabling: true})}),\n          ...remaining,\n          // Always overwrite field\n          field: newField\n        };\n        const isPositionChannel: boolean = channel === 'x' || channel === 'y';\n\n        if (aggOp) {\n          let op: AggregateOp;\n\n          if (isArgmaxDef(aggOp)) {\n            op = 'argmax';\n            newField = vgField({aggregate: 'argmax', field: aggOp.argmax}, {forAs: true});\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (isArgminDef(aggOp)) {\n            op = 'argmin';\n            newField = vgField({aggregate: 'argmin', field: aggOp.argmin}, {forAs: true});\n            newFieldDef.field = `${newField}.${field}`;\n          } else if (aggOp !== 'boxplot' && aggOp !== 'errorbar' && aggOp !== 'errorband') {\n            op = aggOp;\n          }\n\n          if (op) {\n            const aggregateEntry: AggregatedFieldDef = {\n              op,\n              as: newField\n            };\n            if (field) {\n              aggregateEntry.field = field;\n            }\n            aggregate.push(aggregateEntry);\n          }\n        } else {\n          groupby.push(newField);\n          if (isTypedFieldDef(channelDef) && isBinning(bin)) {\n            bins.push({bin, field, as: newField});\n            // Add additional groupbys for range and end of bins\n            groupby.push(vgField(channelDef, {binSuffix: 'end'}));\n            if (binRequiresRange(channelDef, channel)) {\n              groupby.push(vgField(channelDef, {binSuffix: 'range'}));\n            }\n            // Create accompanying 'x2' or 'y2' field if channel is 'x' or 'y' respectively\n            if (isPositionChannel) {\n              const secondaryChannel: SecondaryFieldDef<string> = {\n                field: newField + '_end'\n              };\n              encoding[channel + '2'] = secondaryChannel;\n            }\n            newFieldDef.bin = 'binned';\n            if (!isSecondaryRangeChannel(channel)) {\n              newFieldDef['type'] = 'quantitative';\n            }\n          } else if (timeUnit) {\n            timeUnits.push({timeUnit, field, as: newField});\n\n            // Add formatting to appropriate property based on the type of channel we're processing\n            const format = getDateTimeComponents(timeUnit, config.axis.shortTimeLabels).join(' ');\n            const formatType = isTypedFieldDef(channelDef) && channelDef.type !== TEMPORAL && 'time';\n            if (channel === 'text' || channel === 'tooltip') {\n              newFieldDef['format'] = newFieldDef['format'] || format;\n              if (formatType) {\n                newFieldDef['formatType'] = formatType;\n              }\n            } else if (isNonPositionScaleChannel(channel)) {\n              newFieldDef['legend'] = {format, ...(formatType ? {formatType} : {}), ...newFieldDef['legend']};\n            } else if (isPositionChannel) {\n              newFieldDef['axis'] = {format, ...(formatType ? {formatType} : {}), ...newFieldDef['axis']};\n            }\n          }\n        }\n        // now the field should refer to post-transformed field instead\n        encoding[channel] = newFieldDef;\n      } else {\n        groupby.push(field);\n        encoding[channel] = oldEncoding[channel];\n      }\n    } else {\n      // For value def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\n\nexport function markChannelCompatible(encoding: Encoding<string>, channel: Channel, mark: Mark) {\n  const markSupported = supportMark(channel, mark);\n  if (!markSupported) {\n    return false;\n  } else if (markSupported === 'binned') {\n    const primaryFieldDef = encoding[channel === 'x2' ? 'x' : 'y'];\n\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function normalizeEncoding(encoding: Encoding<string>, mark: Mark): Encoding<string> {\n  return keys(encoding).reduce((normalizedEncoding: Encoding<string>, channel: Channel | string) => {\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!markChannelCompatible(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === 'size' && mark === 'line') {\n      const fieldDef = getTypedFieldDef(encoding[channel]);\n      if (fieldDef && fieldDef.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    }\n\n    // Drop color if either fill or stroke is specified\n    if (channel === 'color' && ('fill' in encoding || 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n      return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n    if (\n      channel === 'detail' ||\n      (channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef)) ||\n      (channel === 'tooltip' && isArray(channelDef))\n    ) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = (isArray(channelDef) ? channelDef : [channelDef]).reduce(\n          (defs: FieldDef<string>[], fieldDef: FieldDef<string>) => {\n            if (!isFieldDef(fieldDef)) {\n              log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            } else {\n              defs.push(normalizeFieldDef(fieldDef, channel));\n            }\n            return defs;\n          },\n          []\n        );\n      }\n    } else {\n      if (channel === 'tooltip' && channelDef === null) {\n        // Preserve null so we can use it to disable tooltip\n        normalizedEncoding[channel] = null;\n      } else if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n      normalizedEncoding[channel] = normalize(channelDef as ChannelDef, channel);\n    }\n    return normalizedEncoding;\n  }, {});\n}\n\nexport function fieldDefs<F extends Field>(encoding: EncodingWithFacet<F>): FieldDef<F>[] {\n  const arr: FieldDef<F>[] = [];\n  for (const channel of keys(encoding)) {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach(def => {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      });\n    }\n  }\n  return arr;\n}\n\nexport function forEach<U extends {[k in Channel]?: any}>(\n  mapping: U,\n  f: (cd: ChannelDef, c: Channel) => void,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    const el = mapping[channel];\n    if (isArray(el)) {\n      el.forEach((channelDef: ChannelDef) => {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, el, channel);\n    }\n  }\n}\n\nexport function reduce<T, U extends {[k in Channel]?: any}>(\n  mapping: U,\n  f: (acc: any, fd: TypedFieldDef<string>, c: Channel) => U,\n  init: T,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce((r1: T, channelDef: ChannelDef) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n\n/**\n * Returns list of path grouping fields for the given encoding\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'href':\n      case 'x2':\n      case 'y2':\n      // falls through\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2':\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area [falls through]\n      case 'text':\n      case 'shape':\n      // falls through\n\n      // tooltip fields should not be added to group by [falls through]\n      case 'tooltip':\n        return details;\n\n      case 'order':\n        // order should not group line / trail\n        if (mark === 'line' || mark === 'trail') {\n          return details;\n        }\n      // but order should group area for stacking (falls through)\n\n      case 'detail':\n      case 'key': {\n        const channelDef = encoding[channel];\n        if (isArray(channelDef) || isFieldDef(channelDef)) {\n          (isArray(channelDef) ? channelDef : [channelDef]).forEach(fieldDef => {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          });\n        }\n        return details;\n      }\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, size should group lines.\n\n      // falls through\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n      case 'fillOpacity':\n      case 'strokeOpacity':\n      case 'strokeWidth': {\n        // TODO strokeDashOffset:\n        // falls through\n\n        const fieldDef = getTypedFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      }\n    }\n  }, []);\n}\n"]}