'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.any = any;
exports.annotateFields = annotateFields;
exports.annotateField = annotateField;
exports.annotatePairs = annotatePairs;
exports.default = annotate;

var _ast = require('./ast');

// Taken from https://github.com/nvie/itertools.js#any and inlined here to
// avoid a dependency on itertools just for this function
function any(iterable, keyFn) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            if (keyFn(item)) {
                return true;
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return false;
}

function annotateFields(object, fields) {
    // Convert the object to a list of pairs
    var pairs = Object.entries(object);

    // If we want to annotate keys that are missing in the object, add an
    // explicit "undefined" value for those now, so we have a place in the
    // object to annotate
    var existingKeys = new Set(Object.keys(object));
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = fields[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _ref = _step2.value;

            var _ref2 = _slicedToArray(_ref, 1);

            var field = _ref2[0];

            if (!existingKeys.has(field)) {
                pairs.push([field, undefined]);
            }
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    var _loop = function _loop(ann, _field) {
        // prettier-ignore
        pairs = pairs.map(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                k = _ref6[0],
                v = _ref6[1];

            return _field === k ? [k, typeof ann === 'string' ? annotate(v, ann) : ann] : [k, v];
        });
    };

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = fields[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _ref3 = _step3.value;

            var _ref4 = _slicedToArray(_ref3, 2);

            var _field = _ref4[0];
            var ann = _ref4[1];

            _loop(ann, _field);
        }
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    return annotatePairs(pairs);
}

function annotateField(object, field, ann) {
    return annotateFields(object, [[field, ann]]);
}

function annotatePairs(value, annotation) {
    var pairs = value.map(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            key = _ref8[0],
            v = _ref8[1];

        return { key: key, value: annotate(v) };
    });
    var hasAnnotation = any(pairs, function (pair) {
        return pair.value.hasAnnotation;
    });
    return { type: 'ObjectAnnotation', pairs: pairs, hasAnnotation: hasAnnotation, annotation: annotation };
}

function annotate(value, annotation) {
    var hasAnnotation = annotation !== undefined;

    if (value === null || value === undefined || typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value.getMonth === 'function') {
        return { type: 'ScalarAnnotation', value: value, hasAnnotation: hasAnnotation, annotation: annotation };
    } else {
        var ann = (0, _ast.asAnnotation)(value);
        if (ann) {
            if (annotation === undefined) {
                return ann;
            } else if (ann.type === 'ObjectAnnotation') {
                return { type: 'ObjectAnnotation', pairs: ann.pairs, annotation: annotation, hasAnnotation: hasAnnotation };
            } else if (ann.type === 'ArrayAnnotation') {
                return { type: 'ArrayAnnotation', items: ann.items, annotation: annotation, hasAnnotation: hasAnnotation };
            } else {
                return { type: 'ScalarAnnotation', value: ann.value, annotation: annotation, hasAnnotation: hasAnnotation };
            }
        } else if (Array.isArray(value)) {
            var items = value.map(function (v) {
                return annotate(v);
            });
            hasAnnotation = any(items, function (ann) {
                return ann.hasAnnotation;
            });
            return { type: 'ArrayAnnotation', items: items, hasAnnotation: hasAnnotation, annotation: annotation };
        } else {
            /* typeof value === 'object' */
            return annotatePairs(Object.entries(value), annotation);
        }
    }
}