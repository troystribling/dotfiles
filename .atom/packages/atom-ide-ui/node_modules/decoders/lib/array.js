'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.poja = undefined;
exports.array = array;

var _debrief = require('debrief');

var _lemons = require('lemons');

var _utils = require('./utils');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Like a "Plain Old JavaScript Object", but for arrays: "Plain Old JavaScript
 * Array" ^_^
 */
var poja = exports.poja = function poja(blob) {
    if (!Array.isArray(blob)) {
        return (0, _lemons.Err)((0, _debrief.annotate)(blob, 'Must be an array'));
    }
    return (0, _lemons.Ok)(blob);
};

/**
 * Given an iterable of Result instances, exhaust them all and return:
 * - An [index, err] tuple, indicating the (index of the) first Err instance
 *   encountered; or
 * - a new Ok with an array of all unwrapped Ok'ed values
 */
function all(iterable, blobs) {
    var results = [];
    var index = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var result = _step.value;

            try {
                var value = result.unwrap();
                results.push(value);
            } catch (ann) {
                // Rewrite the annotation to include the index information, and inject it into the original blob
                var clone = [].concat(_toConsumableArray(blobs));
                clone.splice(index, 1, (0, _debrief.annotate)(ann, ann.annotation !== undefined ? ann.annotation + ' (at index ' + index + ')' : 'index ' + index));

                // const errValue = [];
                // if (index > 0) {
                //     errValue.push('...'); // TODO: make special mark, not string!
                // }
                // errValue.push(
                // );
                // if (index < iterable.length - 1) {
                //     errValue.push('...'); // TODO: make special mark, not string!
                // }
                return (0, _lemons.Err)((0, _debrief.annotate)(clone));
            }
            index++;
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return (0, _lemons.Ok)(results);
}

/**
 * Given a T, builds a decoder that assumes an array input and returns an
 * Array<T>.
 */
function members(decoder) {
    return function (blobs) {
        var results = blobs.map(decoder);
        var result = all(results, blobs);
        return result;
    };
}

/**
 * Builds a Decoder that returns Ok for values of `Array<T>`, given a Decoder
 * for `T`.  Err otherwise.
 */
function array(decoder) {
    return (0, _utils.compose)(poja, members(decoder));
}