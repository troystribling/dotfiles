'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pojo = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.object = object;
exports.exact = exact;
exports.field = field;

var _debrief = require('debrief');

var _lemons = require('lemons');

var _utils = require('./utils');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Helper to indicate we're deliberately using "any", telling Flow we know what
// we're doing
function isObject(o) {
    return o !== null && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && !Array.isArray(o) && !(0, _utils.isDate)(o);
}

function subtract(xs, ys) {
    var result = new Set();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = xs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var x = _step.value;

            if (!ys.has(x)) {
                result.add(x);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return result;
}

var pojo = exports.pojo = function pojo(blob) {
    return isObject(blob) ? (0, _lemons.Ok)(blob) : (0, _lemons.Err)((0, _debrief.annotate)(blob, 'Must be an object'));
};

/**
 * A "type function" which informs Flow about how a type will be modified at runtime.
 * Read this as "given a Guard of type T, I can produce a value of type T".  This
 * definition helps construct $ObjMap types.
 */


/**
 * Given a mapping of fields-to-decoders, builds a decoder for an object type.
 *
 * For example, given decoders for a number and a string, we can construct an
 * "object description" like so:
 *
 *   { id: decodeNumber(), name: decodeString() }
 *
 * Which is of type:
 *
 *   { id: Guard<number>, name: Guard<string> }
 *
 * Passing this to decodeObject() will produce the following return type:
 *
 *   Guard<{ id: number, name: string }>
 *
 * Put simply: it'll "peel off" all of the nested Decoders, puts them together
 * in an object, and wraps it in a Guard<...>.
 */
function object(mapping) {
    var known = new Set(Object.keys(mapping));
    return (0, _utils.compose)(pojo, function (blob) {
        var actual = new Set(Object.keys(blob));

        // At this point, "missing" will also include all fields that may
        // validly be optional.  We'll let the underlying decoder decide and
        // remove the key from this missing set if the decoder accepts the
        // value.
        var missing = subtract(known, actual);

        var record = {};
        var fieldErrors = {};

        // NOTE: We're using .keys() here over .entries(), since .entries()
        // will type the value part as "mixed"
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
            for (var _iterator2 = Object.keys(mapping)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _key = _step2.value;

                var decoder = mapping[_key];
                var value = blob[_key];
                var result = decoder(value);
                try {
                    record[_key] = result.unwrap();

                    // If this succeeded, remove the key from the missing keys
                    // tracker
                    missing.delete(_key);
                } catch (ann) {
                    /* istanbul ignore next */
                    if (!(0, _debrief.isAnnotation)(ann)) {
                        throw ann;
                    }

                    // Keep track of the annotation, but don't return just yet. We
                    // want to collect more error information.
                    if (value === undefined) {
                        // Explicitly add it to the missing set if the value is
                        // undefined.  This covers explicit undefineds to be
                        // treated the same as implicit undefineds (aka missing
                        // keys).
                        missing.add(_key);
                    } else {
                        fieldErrors[_key] = ann;
                    }
                }
            }

            // Deal with errors now. There are two classes of errors we want to
            // report.  First of all, we want to report any inline errors in this
            // object.  Lastly, any fields that are missing should be annotated on
            // the outer object itself.
        } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                }
            } finally {
                if (_didIteratorError2) {
                    throw _iteratorError2;
                }
            }
        }

        var fieldsWithErrors = Object.keys(fieldErrors);
        if (fieldsWithErrors.length > 0 || missing.size > 0) {
            var err = blob;

            if (fieldsWithErrors.length > 0) {
                var errorlist = fieldsWithErrors.map(function (k) {
                    return [k, fieldErrors[k]];
                });
                err = (0, _debrief.annotateFields)(err, errorlist);
            }

            if (missing.size > 0) {
                var errMsg = [].concat(_toConsumableArray(missing)).map(function (key) {
                    return '"' + key + '"';
                }).join(', ');
                var pluralized = missing.size > 1 ? 'keys' : 'key';
                err = (0, _debrief.annotate)(err, 'Missing ' + pluralized + ': ' + errMsg);
            }

            return (0, _lemons.Err)(err);
        }

        return (0, _lemons.Ok)(record);
    });
}

function exact(mapping) {
    // Check the inputted object for any superfluous keys
    var allowed = new Set(Object.keys(mapping));
    var checked = (0, _utils.compose)(pojo, function (blob) {
        var actual = new Set(Object.keys(blob));
        var superfluous = subtract(actual, allowed);
        if (superfluous.size > 0) {
            return (0, _lemons.Err)((0, _debrief.annotate)(blob, 'Superfluous keys: ' + [].concat(_toConsumableArray(superfluous)).join(', ')));
        }
        return (0, _lemons.Ok)(blob);
    });

    // Defer to the "object" decoder for doing the real decoding work.  Since
    // we made sure there are no superfluous keys in this structure, it's now
    // safe to force-case it to an $Exact<> type.
    var decoder = object(mapping);
    return (0, _utils.compose)(checked, decoder);
}

function field(field, decoder) {
    // TODO: Optimize away the many calls to pojo() (one made for each field
    // like this, not efficient -- pull it out of this function)
    return (0, _utils.compose)(pojo, function (blob) {
        var value = blob[field];
        var result = decoder(value);
        try {
            return (0, _lemons.Ok)(result.unwrap());
        } catch (e) {
            var errText = value === undefined ? 'Missing key: "' + field + '"' : 'Unexpected value for field "' + field + '"';
            return (0, _lemons.Err)((0, _debrief.annotate)(blob, errText));
        }
    });
}