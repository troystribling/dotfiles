'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Err = exports.Ok = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //  strict

var _Maybe = require('./Maybe');

var _Maybe2 = _interopRequireDefault(_Maybe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Result error value
 *     = Ok value
 *     | Err error
 */

var Ok = 'Ok';
var Err = 'Err';

// prettier-ignore

/**
 * Represents a union type that's either a legit value or an error:
 *
 *     Result error value
 *         = Ok value
 *         | Err error
 *
 */
var Result = function () {

    /**
     * **Do not call this constructor directly!**  Use either `Result.ok()` or
     * `Result.err()` to construct a new Result instance.
     */
    function Result(r) {
        _classCallCheck(this, Result);

        this._r = r;
    }

    /**
     * Create a new Result instance representing a successful computation.
     */


    _createClass(Result, [{
        key: 'toString',
        value: function toString() {
            var r = this._r;
            return r.type === Ok ? 'Ok(' + String(r.value) + ')' : 'Err(' + String(r.error) + ')';
        }
    }, {
        key: 'isOk',
        value: function isOk() {
            return this._r.type === Ok;
        }
    }, {
        key: 'isErr',
        value: function isErr() {
            return this._r.type === Err;
        }
    }, {
        key: 'withDefault',
        value: function withDefault(defaultValue) {
            var r = this._r;
            return r.type === Ok ? r.value : defaultValue;
        }
    }, {
        key: 'toMaybe',
        value: function toMaybe() {
            var r = this._r;
            return r.type === Ok ? _Maybe2.default.just(r.value) : _Maybe2.default.nothing();
        }
    }, {
        key: 'value',
        value: function value() {
            var r = this._r;
            return r.type === Ok ? r.value : undefined;
        }
    }, {
        key: 'errValue',
        value: function errValue() {
            var r = this._r;
            return r.type === Err ? r.error : undefined;
        }

        /**
         * Unwrap the value from this Result instance if this is an "Ok" result.
         * Otherwise, will throw the "Err" error via a runtime exception.
         */

    }, {
        key: 'unwrap',
        value: function unwrap() {
            var r = this._r;
            if (r.type === Ok) {
                return r.value;
            } else {
                throw r.error;
            }
        }
    }, {
        key: 'dispatch',
        value: function dispatch(okCallback, errCallback) {
            var r = this._r;
            return r.type === Ok ? okCallback(r.value) : errCallback(r.error);
        }

        /**
         * Chain together a sequence of computations that may fail.
         */

    }, {
        key: 'andThen',
        value: function andThen(callback) {
            var r = this._r;
            return r.type === Ok ? callback(r.value) : Result.err(r.error);
        }

        /**
         * Transform an Ok result.  If the result is an Err, the same error value
         * will propagate through.
         */

    }, {
        key: 'map',
        value: function map(mapper) {
            var r = this._r;
            return r.type === Ok ? Result.ok(mapper(r.value)) : Result.err(r.error);
        }

        /**
         * Transform an Err value.  If the result is an Ok, this is a no-op.
         * Useful when for example the errors has too much information.
         */

    }, {
        key: 'mapError',
        value: function mapError(mapper) {
            var r = this._r;
            return r.type === Ok ? Result.ok(r.value) : Result.err(mapper(r.error));
        }
    }], [{
        key: 'ok',
        value: function ok(value) {
            return new Result({ type: Ok, value: value });
        }

        /**
         * Create a new Result instance representing a failed computation.
         */

    }, {
        key: 'err',
        value: function err(error) {
            return new Result({ type: Err, error: error });
        }
    }]);

    return Result;
}();

exports.default = Result;


var _Ok = function _Ok(value) {
    return Result.ok(value);
};
var _Err = function _Err(error) {
    return Result.err(error);
};

// prettier-ignore
exports.Ok = _Ok;
exports.Err = _Err;