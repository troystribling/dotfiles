Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts workspace/applyEdit commands to editors.
class ApplyEditAdapter {
  // Public: Attach to a {LanguageClientConnection} to receive edit events.
  static attach(connection) {
    connection.onApplyEdit(m => ApplyEditAdapter.onApplyEdit(m));
  }

  static async onApplyEdit(params) {

    let changes = params.edit.changes || {};

    if (params.edit.documentChanges) {
      changes = {};
      params.edit.documentChanges.forEach(change => {
        if (change && change.textDocument) {
          changes[change.textDocument.uri] = change.edits;
        }
      });
    }

    const uris = Object.keys(changes);
    const paths = uris.map(_convert2.default.uriToPath);
    const editors = await Promise.all(paths.map(path => {
      return atom.workspace.open(path, {
        searchAllPanes: true,
        // Open new editors in the background.
        activatePane: false,
        activateItem: false
      });
    }));

    const checkpoints = [];
    try {
      for (let i = 0; i < editors.length; i++) {
        const editor = editors[i];
        const uri = uris[i];
        // Get an existing editor for the file, or open a new one if it doesn't exist.
        const edits = _convert2.default.convertLsTextEdits(changes[uri]);
        // Sort edits in reverse order to prevent edit conflicts.
        edits.sort((edit1, edit2) => -edit1.oldRange.compare(edit2.oldRange));
        const buffer = editor.getBuffer();
        const checkpoint = buffer.createCheckpoint();
        checkpoints.push({ buffer, checkpoint });
        let prevEdit = null;
        for (const edit of edits) {
          ApplyEditAdapter.validateEdit(buffer, edit, prevEdit);
          buffer.setTextInRange(edit.oldRange, edit.newText);
          prevEdit = edit;
        }
        buffer.groupChangesSinceCheckpoint(checkpoint);
      }
      return { applied: true };
    } catch (e) {
      atom.notifications.addError('workspace/applyEdits failed', {
        description: 'Failed to apply edits.',
        detail: e.message
      });
      checkpoints.forEach(({ buffer, checkpoint }) => {
        buffer.revertToCheckpoint(checkpoint);
      });
      return { applied: false };
    }
  }

  // Private: Do some basic sanity checking on the edit ranges.
  static validateEdit(buffer, edit, prevEdit) {
    const path = buffer.getPath() || '';
    if (prevEdit != null && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
      throw Error(`Found overlapping edit ranges in ${path}`);
    }
    const startRow = edit.oldRange.start.row;
    const startCol = edit.oldRange.start.column;
    const lineLength = buffer.lineLengthForRow(startRow);
    if (lineLength == null || startCol > lineLength) {
      throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
    }
  }
}
exports.default = ApplyEditAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9hcHBseS1lZGl0LWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiQXBwbHlFZGl0QWRhcHRlciIsImF0dGFjaCIsImNvbm5lY3Rpb24iLCJvbkFwcGx5RWRpdCIsIm0iLCJwYXJhbXMiLCJjaGFuZ2VzIiwiZWRpdCIsImRvY3VtZW50Q2hhbmdlcyIsImZvckVhY2giLCJjaGFuZ2UiLCJ0ZXh0RG9jdW1lbnQiLCJ1cmkiLCJlZGl0cyIsInVyaXMiLCJPYmplY3QiLCJrZXlzIiwicGF0aHMiLCJtYXAiLCJ1cmlUb1BhdGgiLCJlZGl0b3JzIiwiUHJvbWlzZSIsImFsbCIsInBhdGgiLCJhdG9tIiwid29ya3NwYWNlIiwib3BlbiIsInNlYXJjaEFsbFBhbmVzIiwiYWN0aXZhdGVQYW5lIiwiYWN0aXZhdGVJdGVtIiwiY2hlY2twb2ludHMiLCJpIiwibGVuZ3RoIiwiZWRpdG9yIiwiY29udmVydExzVGV4dEVkaXRzIiwic29ydCIsImVkaXQxIiwiZWRpdDIiLCJvbGRSYW5nZSIsImNvbXBhcmUiLCJidWZmZXIiLCJnZXRCdWZmZXIiLCJjaGVja3BvaW50IiwiY3JlYXRlQ2hlY2twb2ludCIsInB1c2giLCJwcmV2RWRpdCIsInZhbGlkYXRlRWRpdCIsInNldFRleHRJblJhbmdlIiwibmV3VGV4dCIsImdyb3VwQ2hhbmdlc1NpbmNlQ2hlY2twb2ludCIsImFwcGxpZWQiLCJlIiwibm90aWZpY2F0aW9ucyIsImFkZEVycm9yIiwiZGVzY3JpcHRpb24iLCJkZXRhaWwiLCJtZXNzYWdlIiwicmV2ZXJ0VG9DaGVja3BvaW50IiwiZ2V0UGF0aCIsImVuZCIsInN0YXJ0IiwiRXJyb3IiLCJzdGFydFJvdyIsInJvdyIsInN0YXJ0Q29sIiwiY29sdW1uIiwibGluZUxlbmd0aCIsImxpbmVMZW5ndGhGb3JSb3ciXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFLQTs7Ozs7O0FBRUE7QUFDZSxNQUFNQSxnQkFBTixDQUF1QjtBQUNwQztBQUNBLFNB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LFFBQXJFLEVBQXdHO0FBQ3RHLFVBQU10QixPQUFPaUIsT0FBT2tCLE9BQVAsTUFBb0IsRUFBakM7QUFDQSxRQUFJYixZQUFZLElBQVosSUFBb0J0QyxLQUFLK0IsUUFBTCxDQUFjcUIsR0FBZCxDQUFrQnBCLE9BQWxCLENBQTBCTSxTQUFTUCxRQUFULENBQWtCc0IsS0FBNUMsSUFBcUQsQ0FBN0UsRUFBZ0Y7QUFDOUUsWUFBTUMsTUFBTyxvQ0FBbUN0QyxJQUFLLEVBQS9DLENBQU47QUFDRDtBQUNELFVBQU11QyxXQUFXdkQsS0FBSytCLFFBQUwsQ0FBY3NCLEtBQWQsQ0FBb0JHLEdBQXJDO0FBQ0EsVUFBTUMsV0FBV3pELEtBQUsrQixRQUFMLENBQWNzQixLQUFkLENBQW9CSyxNQUFyQztBQUNBLFVBQU1DLGFBQWExQixPQUFPMkIsZ0JBQVAsQ0FBd0JMLFFBQXhCLENBQW5CO0FBQ0EsUUFBSUksY0FBYyxJQUFkLElBQXNCRixXQUFXRSxVQUFyQyxFQUFpRDtBQUMvQyxZQUFNTCxNQUFPLHdCQUF1QnRDLElBQUssSUFBR3VDLFdBQVcsQ0FBRSxJQUFHRSxXQUFXLENBQUUsRUFBbkUsQ0FBTjtBQUNEO0FBQ0Y7QUE3RW1DO2tCQUFqQmhFLGdCIiwiZmlsZSI6ImFwcGx5LWVkaXQtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICB0eXBlIEFwcGx5V29ya3NwYWNlRWRpdFBhcmFtcyxcclxuICB0eXBlIEFwcGx5V29ya3NwYWNlRWRpdFJlc3BvbnNlLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB3b3Jrc3BhY2UvYXBwbHlFZGl0IGNvbW1hbmRzIHRvIGVkaXRvcnMuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFwcGx5RWRpdEFkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogQXR0YWNoIHRvIGEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gcmVjZWl2ZSBlZGl0IGV2ZW50cy5cclxuICBzdGF0aWMgYXR0YWNoKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbikge1xyXG4gICAgY29ubmVjdGlvbi5vbkFwcGx5RWRpdChtID0+IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQobSkpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIG9uQXBwbHlFZGl0KHBhcmFtczogQXBwbHlXb3Jrc3BhY2VFZGl0UGFyYW1zKTogUHJvbWlzZTxBcHBseVdvcmtzcGFjZUVkaXRSZXNwb25zZT4ge1xyXG5cclxuICAgIGxldCBjaGFuZ2VzID0gcGFyYW1zLmVkaXQuY2hhbmdlcyB8fCB7fTtcclxuXHJcbiAgICBpZiAocGFyYW1zLmVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XHJcbiAgICAgIGNoYW5nZXMgPSB7fTtcclxuICAgICAgcGFyYW1zLmVkaXQuZG9jdW1lbnRDaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcclxuICAgICAgICBpZiAoY2hhbmdlICYmIGNoYW5nZS50ZXh0RG9jdW1lbnQpIHtcclxuICAgICAgICAgIGNoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gY2hhbmdlLmVkaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXJpcyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpO1xyXG4gICAgY29uc3QgcGF0aHMgPSB1cmlzLm1hcChDb252ZXJ0LnVyaVRvUGF0aCk7XHJcbiAgICBjb25zdCBlZGl0b3JzID0gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIHBhdGhzLm1hcChwYXRoID0+IHtcclxuICAgICAgICByZXR1cm4gYXRvbS53b3Jrc3BhY2Uub3BlbihwYXRoLCB7XHJcbiAgICAgICAgICBzZWFyY2hBbGxQYW5lczogdHJ1ZSxcclxuICAgICAgICAgIC8vIE9wZW4gbmV3IGVkaXRvcnMgaW4gdGhlIGJhY2tncm91bmQuXHJcbiAgICAgICAgICBhY3RpdmF0ZVBhbmU6IGZhbHNlLFxyXG4gICAgICAgICAgYWN0aXZhdGVJdGVtOiBmYWxzZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IGNoZWNrcG9pbnRzID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkaXRvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlZGl0b3IgPSBlZGl0b3JzW2ldO1xyXG4gICAgICAgIGNvbnN0IHVyaSA9IHVyaXNbaV07XHJcbiAgICAgICAgLy8gR2V0IGFuIGV4aXN0aW5nIGVkaXRvciBmb3IgdGhlIGZpbGUsIG9yIG9wZW4gYSBuZXcgb25lIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgICAgY29uc3QgZWRpdHMgPSBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhjaGFuZ2VzW3VyaV0pO1xyXG4gICAgICAgIC8vIFNvcnQgZWRpdHMgaW4gcmV2ZXJzZSBvcmRlciB0byBwcmV2ZW50IGVkaXQgY29uZmxpY3RzLlxyXG4gICAgICAgIGVkaXRzLnNvcnQoKGVkaXQxLCBlZGl0MikgPT4gLWVkaXQxLm9sZFJhbmdlLmNvbXBhcmUoZWRpdDIub2xkUmFuZ2UpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKCk7XHJcbiAgICAgICAgY29uc3QgY2hlY2twb2ludCA9IGJ1ZmZlci5jcmVhdGVDaGVja3BvaW50KCk7XHJcbiAgICAgICAgY2hlY2twb2ludHMucHVzaCh7YnVmZmVyLCBjaGVja3BvaW50fSk7XHJcbiAgICAgICAgbGV0IHByZXZFZGl0ID0gbnVsbDtcclxuICAgICAgICBmb3IgKGNvbnN0IGVkaXQgb2YgZWRpdHMpIHtcclxuICAgICAgICAgIEFwcGx5RWRpdEFkYXB0ZXIudmFsaWRhdGVFZGl0KGJ1ZmZlciwgZWRpdCwgcHJldkVkaXQpO1xyXG4gICAgICAgICAgYnVmZmVyLnNldFRleHRJblJhbmdlKGVkaXQub2xkUmFuZ2UsIGVkaXQubmV3VGV4dCk7XHJcbiAgICAgICAgICBwcmV2RWRpdCA9IGVkaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1ZmZlci5ncm91cENoYW5nZXNTaW5jZUNoZWNrcG9pbnQoY2hlY2twb2ludCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHthcHBsaWVkOiB0cnVlfTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZEVycm9yKCd3b3Jrc3BhY2UvYXBwbHlFZGl0cyBmYWlsZWQnLCB7XHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdGYWlsZWQgdG8gYXBwbHkgZWRpdHMuJyxcclxuICAgICAgICBkZXRhaWw6IGUubWVzc2FnZSxcclxuICAgICAgfSk7XHJcbiAgICAgIGNoZWNrcG9pbnRzLmZvckVhY2goKHtidWZmZXIsIGNoZWNrcG9pbnR9KSA9PiB7XHJcbiAgICAgICAgYnVmZmVyLnJldmVydFRvQ2hlY2twb2ludChjaGVja3BvaW50KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB7YXBwbGllZDogZmFsc2V9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHJpdmF0ZTogRG8gc29tZSBiYXNpYyBzYW5pdHkgY2hlY2tpbmcgb24gdGhlIGVkaXQgcmFuZ2VzLlxyXG4gIHN0YXRpYyB2YWxpZGF0ZUVkaXQoYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIsIGVkaXQ6IGF0b21JZGUkVGV4dEVkaXQsIHByZXZFZGl0OiA/YXRvbUlkZSRUZXh0RWRpdCk6IHZvaWQge1xyXG4gICAgY29uc3QgcGF0aCA9IGJ1ZmZlci5nZXRQYXRoKCkgfHwgJyc7XHJcbiAgICBpZiAocHJldkVkaXQgIT0gbnVsbCAmJiBlZGl0Lm9sZFJhbmdlLmVuZC5jb21wYXJlKHByZXZFZGl0Lm9sZFJhbmdlLnN0YXJ0KSA+IDApIHtcclxuICAgICAgdGhyb3cgRXJyb3IoYEZvdW5kIG92ZXJsYXBwaW5nIGVkaXQgcmFuZ2VzIGluICR7cGF0aH1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0Um93ID0gZWRpdC5vbGRSYW5nZS5zdGFydC5yb3c7XHJcbiAgICBjb25zdCBzdGFydENvbCA9IGVkaXQub2xkUmFuZ2Uuc3RhcnQuY29sdW1uO1xyXG4gICAgY29uc3QgbGluZUxlbmd0aCA9IGJ1ZmZlci5saW5lTGVuZ3RoRm9yUm93KHN0YXJ0Um93KTtcclxuICAgIGlmIChsaW5lTGVuZ3RoID09IG51bGwgfHwgc3RhcnRDb2wgPiBsaW5lTGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGBPdXQgb2YgcmFuZ2UgZWRpdCBvbiAke3BhdGh9OiR7c3RhcnRSb3cgKyAxfToke3N0YXJ0Q29sICsgMX1gKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19