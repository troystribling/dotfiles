Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
let DefinitionAdapter = class DefinitionAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a definitionProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.definitionProvider === true;
  }

  // Public: Get the definitions for a symbol at a given {Point} within a
  // {TextEditor} including optionally highlighting all other references
  // within the document if the langauge server also supports highlighting.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `languageName` The name of the programming language.
  // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
  // * `point` The Atom {Point} containing the position of the text that represents the symbol
  //           for which the definition and highlights should be provided.
  //
  // Returns a {Promise} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  getDefinition(connection, serverCapabilities, languageName, editor, point) {
    return _asyncToGenerator(function* () {
      const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);
      const definitionLocations = DefinitionAdapter.normalizeLocations((yield connection.gotoDefinition(documentPositionParams)));
      if (definitionLocations == null || definitionLocations.length === 0) {
        return null;
      }

      let queryRange;
      if (serverCapabilities.documentHighlightProvider) {
        const highlights = yield connection.documentHighlight(documentPositionParams);
        if (highlights != null && highlights.length > 0) {
          queryRange = highlights.map(function (h) {
            return _convert2.default.lsRangeToAtomRange(h.range);
          });
        }
      }

      return {
        queryRange: queryRange || [_utils2.default.getWordAtPosition(editor, point)],
        definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName)
      };
    })();
  }

  // Public: Normalize the locations so a single {Location} becomes an {Array} of just
  // one. The language server protocol return either as the protocol evolved between v1 and v2.
  //
  // * `locationResult` either a single {Location} object or an {Array} of {Locations}
  //
  // Returns an {Array} of {Location}s or {null} if the locationResult was null.
  static normalizeLocations(locationResult) {
    if (locationResult == null) {
      return null;
    }
    return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter(d => d.range.start != null);
  }

  // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
  //
  // * `locations` An {Array} of {Location} objects to be converted.
  // * `languageName` The name of the language these objects are written in.
  //
  // Returns an {Array} of {Definition}s that represented the converted {Location}s.
  static convertLocationsToDefinitions(locations, languageName) {
    return locations.map(d => ({
      path: _convert2.default.uriToPath(d.uri),
      position: _convert2.default.positionToPoint(d.range.start),
      range: _atom.Range.fromObject(_convert2.default.lsRangeToAtomRange(d.range)),
      language: languageName
    }));
  }
};
exports.default = DefinitionAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kZWZpbml0aW9uLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGVmaW5pdGlvbkFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRlZmluaXRpb25Qcm92aWRlciIsImdldERlZmluaXRpb24iLCJjb25uZWN0aW9uIiwibGFuZ3VhZ2VOYW1lIiwiZWRpdG9yIiwicG9pbnQiLCJkb2N1bWVudFBvc2l0aW9uUGFyYW1zIiwiZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImRlZmluaXRpb25Mb2NhdGlvbnMiLCJub3JtYWxpemVMb2NhdGlvbnMiLCJnb3RvRGVmaW5pdGlvbiIsImxlbmd0aCIsInF1ZXJ5UmFuZ2UiLCJkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIiwiaGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0IiwibWFwIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwiaCIsInJhbmdlIiwiZ2V0V29yZEF0UG9zaXRpb24iLCJkZWZpbml0aW9ucyIsImNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zIiwibG9jYXRpb25SZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJkIiwic3RhcnQiLCJsb2NhdGlvbnMiLCJwYXRoIiwidXJpVG9QYXRoIiwidXJpIiwicG9zaXRpb24iLCJwb3NpdGlvblRvUG9pbnQiLCJmcm9tT2JqZWN0IiwibGFuZ3VhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBO0lBQ3FCQSxpQixHQUFOLE1BQU1BLGlCQUFOLENBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsUUFBUCxDQUFnQkMsa0JBQWhCLEVBQWlFO0FBQy9ELFdBQU9BLG1CQUFtQkMsa0JBQW5CLEtBQTBDLElBQWpEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTUMsZUFBTixDQUNFQyxVQURGLEVBRUVILGtCQUZGLEVBR0VJLFlBSEYsRUFJRUMsTUFKRixFQUtFQyxLQUxGLEVBTTJDO0FBQUE7QUFDekMsWUFBTUMseUJBQXlCLGtCQUFRQyxrQ0FBUixDQUEyQ0gsTUFBM0MsRUFBbURDLEtBQW5ELENBQS9CO0FBQ0EsWUFBTUcsc0JBQXNCWCxrQkFBa0JZLGtCQUFsQixFQUMxQixNQUFNUCxXQUFXUSxjQUFYLENBQTBCSixzQkFBMUIsQ0FEb0IsRUFBNUI7QUFHQSxVQUFJRSx1QkFBdUIsSUFBdkIsSUFBK0JBLG9CQUFvQkcsTUFBcEIsS0FBK0IsQ0FBbEUsRUFBcUU7QUFDbkUsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBSUMsVUFBSjtBQUNBLFVBQUliLG1CQUFtQmMseUJBQXZCLEVBQWtEO0FBQ2hELGNBQU1DLGFBQWEsTUFBTVosV0FBV2EsaUJBQVgsQ0FBNkJULHNCQUE3QixDQUF6QjtBQUNBLFlBQUlRLGNBQWMsSUFBZCxJQUFzQkEsV0FBV0gsTUFBWCxHQUFvQixDQUE5QyxFQUFpRDtBQUMvQ0MsdUJBQWFFLFdBQVdFLEdBQVgsQ0FBZTtBQUFBLG1CQUFLLGtCQUFRQyxrQkFBUixDQUEyQkMsRUFBRUMsS0FBN0IsQ0FBTDtBQUFBLFdBQWYsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsYUFBTztBQUNMUCxvQkFBWUEsY0FBYyxDQUFDLGdCQUFNUSxpQkFBTixDQUF3QmhCLE1BQXhCLEVBQWdDQyxLQUFoQyxDQUFELENBRHJCO0FBRUxnQixxQkFBYXhCLGtCQUFrQnlCLDZCQUFsQixDQUFnRGQsbUJBQWhELEVBQXFFTCxZQUFyRTtBQUZSLE9BQVA7QUFqQnlDO0FBcUIxQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPTSxrQkFBUCxDQUEwQmMsY0FBMUIsRUFBd0Y7QUFDdEYsUUFBSUEsa0JBQWtCLElBQXRCLEVBQTRCO0FBQzFCLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBTyxDQUFDQyxNQUFNQyxPQUFOLENBQWNGLGNBQWQsSUFBZ0NBLGNBQWhDLEdBQWlELENBQUNBLGNBQUQsQ0FBbEQsRUFBb0VHLE1BQXBFLENBQTJFQyxLQUFLQSxFQUFFUixLQUFGLENBQVFTLEtBQVIsSUFBaUIsSUFBakcsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9OLDZCQUFQLENBQXFDTyxTQUFyQyxFQUFpRTFCLFlBQWpFLEVBQWtIO0FBQ2hILFdBQU8wQixVQUFVYixHQUFWLENBQWNXLE1BQU07QUFDekJHLFlBQU0sa0JBQVFDLFNBQVIsQ0FBa0JKLEVBQUVLLEdBQXBCLENBRG1CO0FBRXpCQyxnQkFBVSxrQkFBUUMsZUFBUixDQUF3QlAsRUFBRVIsS0FBRixDQUFRUyxLQUFoQyxDQUZlO0FBR3pCVCxhQUFPLFlBQU1nQixVQUFOLENBQWlCLGtCQUFRbEIsa0JBQVIsQ0FBMkJVLEVBQUVSLEtBQTdCLENBQWpCLENBSGtCO0FBSXpCaUIsZ0JBQVVqQztBQUplLEtBQU4sQ0FBZCxDQUFQO0FBTUQ7QUFoRm9DLEM7a0JBQWxCTixpQiIsImZpbGUiOiJkZWZpbml0aW9uLWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIHR5cGUgTG9jYXRpb24sIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzfSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQge1JhbmdlfSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgZGVmaW5pdGlvbiBwcm92aWRlciB0byB0aGVcclxuLy8gQXRvbSBJREUgVUkgRGVmaW5pdGlvbnMgcGFja2FnZSBmb3IgJ0dvIFRvIERlZmluaXRpb24nIGZ1bmN0aW9uYWxpdHkuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25BZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSBkZWZpbml0aW9uUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kZWZpbml0aW9uUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCB0aGUgZGVmaW5pdGlvbnMgZm9yIGEgc3ltYm9sIGF0IGEgZ2l2ZW4ge1BvaW50fSB3aXRoaW4gYVxyXG4gIC8vIHtUZXh0RWRpdG9yfSBpbmNsdWRpbmcgb3B0aW9uYWxseSBoaWdobGlnaHRpbmcgYWxsIG90aGVyIHJlZmVyZW5jZXNcclxuICAvLyB3aXRoaW4gdGhlIGRvY3VtZW50IGlmIHRoZSBsYW5nYXVnZSBzZXJ2ZXIgYWxzbyBzdXBwb3J0cyBoaWdobGlnaHRpbmcuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIHByb3ZpZGUgZGVmaW5pdGlvbnMgYW5kIGhpZ2hsaWdodHMuXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cclxuICAvLyAqIGBsYW5ndWFnZU5hbWVgIFRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZS5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBzeW1ib2wgYW5kIHBvdGVudGlhbCBoaWdobGlnaHRzLlxyXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3ltYm9sXHJcbiAgLy8gICAgICAgICAgIGZvciB3aGljaCB0aGUgZGVmaW5pdGlvbiBhbmQgaGlnaGxpZ2h0cyBzaG91bGQgYmUgcHJvdmlkZWQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgYXN5bmMgZ2V0RGVmaW5pdGlvbihcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG4gICAgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcsXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogYXRvbSRQb2ludCxcclxuICApOiBQcm9taXNlPD9hdG9tSWRlJERlZmluaXRpb25RdWVyeVJlc3VsdD4ge1xyXG4gICAgY29uc3QgZG9jdW1lbnRQb3NpdGlvblBhcmFtcyA9IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvaW50KTtcclxuICAgIGNvbnN0IGRlZmluaXRpb25Mb2NhdGlvbnMgPSBEZWZpbml0aW9uQWRhcHRlci5ub3JtYWxpemVMb2NhdGlvbnMoXHJcbiAgICAgIGF3YWl0IGNvbm5lY3Rpb24uZ290b0RlZmluaXRpb24oZG9jdW1lbnRQb3NpdGlvblBhcmFtcyksXHJcbiAgICApO1xyXG4gICAgaWYgKGRlZmluaXRpb25Mb2NhdGlvbnMgPT0gbnVsbCB8fCBkZWZpbml0aW9uTG9jYXRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcXVlcnlSYW5nZTtcclxuICAgIGlmIChzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRIaWdobGlnaHRQcm92aWRlcikge1xyXG4gICAgICBjb25zdCBoaWdobGlnaHRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudEhpZ2hsaWdodChkb2N1bWVudFBvc2l0aW9uUGFyYW1zKTtcclxuICAgICAgaWYgKGhpZ2hsaWdodHMgIT0gbnVsbCAmJiBoaWdobGlnaHRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBxdWVyeVJhbmdlID0gaGlnaGxpZ2h0cy5tYXAoaCA9PiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShoLnJhbmdlKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBxdWVyeVJhbmdlOiBxdWVyeVJhbmdlIHx8IFtVdGlscy5nZXRXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KV0sXHJcbiAgICAgIGRlZmluaXRpb25zOiBEZWZpbml0aW9uQWRhcHRlci5jb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhkZWZpbml0aW9uTG9jYXRpb25zLCBsYW5ndWFnZU5hbWUpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogTm9ybWFsaXplIHRoZSBsb2NhdGlvbnMgc28gYSBzaW5nbGUge0xvY2F0aW9ufSBiZWNvbWVzIGFuIHtBcnJheX0gb2YganVzdFxyXG4gIC8vIG9uZS4gVGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCByZXR1cm4gZWl0aGVyIGFzIHRoZSBwcm90b2NvbCBldm9sdmVkIGJldHdlZW4gdjEgYW5kIHYyLlxyXG4gIC8vXHJcbiAgLy8gKiBgbG9jYXRpb25SZXN1bHRgIGVpdGhlciBhIHNpbmdsZSB7TG9jYXRpb259IG9iamVjdCBvciBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbnN9XHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufXMgb3Ige251bGx9IGlmIHRoZSBsb2NhdGlvblJlc3VsdCB3YXMgbnVsbC5cclxuICBzdGF0aWMgbm9ybWFsaXplTG9jYXRpb25zKGxvY2F0aW9uUmVzdWx0OiBMb2NhdGlvbiB8IEFycmF5PExvY2F0aW9uPik6ID9BcnJheTxMb2NhdGlvbj4ge1xyXG4gICAgaWYgKGxvY2F0aW9uUmVzdWx0ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobG9jYXRpb25SZXN1bHQpID8gbG9jYXRpb25SZXN1bHQgOiBbbG9jYXRpb25SZXN1bHRdKS5maWx0ZXIoZCA9PiBkLnJhbmdlLnN0YXJ0ICE9IG51bGwpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufSBvYmplY3RzIGludG8gYW4gQXJyYXkgb2Yge0RlZmluaXRpb259cy5cclxuICAvL1xyXG4gIC8vICogYGxvY2F0aW9uc2AgQW4ge0FycmF5fSBvZiB7TG9jYXRpb259IG9iamVjdHMgdG8gYmUgY29udmVydGVkLlxyXG4gIC8vICogYGxhbmd1YWdlTmFtZWAgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIHRoZXNlIG9iamVjdHMgYXJlIHdyaXR0ZW4gaW4uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtBcnJheX0gb2Yge0RlZmluaXRpb259cyB0aGF0IHJlcHJlc2VudGVkIHRoZSBjb252ZXJ0ZWQge0xvY2F0aW9ufXMuXHJcbiAgc3RhdGljIGNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zKGxvY2F0aW9uczogQXJyYXk8TG9jYXRpb24+LCBsYW5ndWFnZU5hbWU6IHN0cmluZyk6IEFycmF5PGF0b21JZGUkRGVmaW5pdGlvbj4ge1xyXG4gICAgcmV0dXJuIGxvY2F0aW9ucy5tYXAoZCA9PiAoe1xyXG4gICAgICBwYXRoOiBDb252ZXJ0LnVyaVRvUGF0aChkLnVyaSksXHJcbiAgICAgIHBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChkLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgcmFuZ2U6IFJhbmdlLmZyb21PYmplY3QoQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoZC5yYW5nZSkpLFxyXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxyXG4gICAgfSkpO1xyXG4gIH1cclxufVxyXG4iXX0=