Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class DefinitionAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a definitionProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.definitionProvider === true;
  }

  // Public: Get the definitions for a symbol at a given {Point} within a
  // {TextEditor} including optionally highlighting all other references
  // within the document if the langauge server also supports highlighting.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `languageName` The name of the programming language.
  // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
  // * `point` The Atom {Point} containing the position of the text that represents the symbol
  //           for which the definition and highlights should be provided.
  //
  // Returns a {Promise} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  async getDefinition(connection, serverCapabilities, languageName, editor, point) {
    const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);
    const definitionLocations = DefinitionAdapter.normalizeLocations((await connection.gotoDefinition(documentPositionParams)));
    if (definitionLocations == null || definitionLocations.length === 0) {
      return null;
    }

    let queryRange;
    if (serverCapabilities.documentHighlightProvider) {
      const highlights = await connection.documentHighlight(documentPositionParams);
      if (highlights != null && highlights.length > 0) {
        queryRange = highlights.map(h => _convert2.default.lsRangeToAtomRange(h.range));
      }
    }

    return {
      queryRange: queryRange || [_utils2.default.getWordAtPosition(editor, point)],
      definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName)
    };
  }

  // Public: Normalize the locations so a single {Location} becomes an {Array} of just
  // one. The language server protocol return either as the protocol evolved between v1 and v2.
  //
  // * `locationResult` either a single {Location} object or an {Array} of {Locations}
  //
  // Returns an {Array} of {Location}s or {null} if the locationResult was null.
  static normalizeLocations(locationResult) {
    if (locationResult == null) {
      return null;
    }
    return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter(d => d.range.start != null);
  }

  // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
  //
  // * `locations` An {Array} of {Location} objects to be converted.
  // * `languageName` The name of the language these objects are written in.
  //
  // Returns an {Array} of {Definition}s that represented the converted {Location}s.
  static convertLocationsToDefinitions(locations, languageName) {
    return locations.map(d => ({
      path: _convert2.default.uriToPath(d.uri),
      position: _convert2.default.positionToPoint(d.range.start),
      range: _atom.Range.fromObject(_convert2.default.lsRangeToAtomRange(d.range)),
      language: languageName
    }));
  }
}
exports.default = DefinitionAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kZWZpbml0aW9uLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGVmaW5pdGlvbkFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRlZmluaXRpb25Qcm92aWRlciIsImdldERlZmluaXRpb24iLCJjb25uZWN0aW9uIiwibGFuZ3VhZ2VOYW1lIiwiZWRpdG9yIiwicG9pbnQiLCJkb2N1bWVudFBvc2l0aW9uUGFyYW1zIiwiZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImRlZmluaXRpb25Mb2NhdGlvbnMiLCJub3JtYWxpemVMb2NhdGlvbnMiLCJnb3RvRGVmaW5pdGlvbiIsImxlbmd0aCIsInF1ZXJ5UmFuZ2UiLCJkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIiwiaGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0IiwibWFwIiwiaCIsImxzUmFuZ2VUb0F0b21SYW5nZSIsInJhbmdlIiwiZ2V0V29yZEF0UG9zaXRpb24iLCJkZWZpbml0aW9ucyIsImNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zIiwibG9jYXRpb25SZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJkIiwic3RhcnQiLCJsb2NhdGlvbnMiLCJwYXRoIiwidXJpVG9QYXRoIiwidXJpIiwicG9zaXRpb24iLCJwb3NpdGlvblRvUG9pbnQiLCJmcm9tT2JqZWN0IiwibGFuZ3VhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUEsaUJBQU4sQ0FBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxrQkFBbkIsS0FBMEMsSUFBakQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU1DLGFBQU4sQ0FDRUMsVUFERixFQUVFSCxrQkFGRixFQUdFSSxZQUhGLEVBSUVDLE1BSkYsRUFLRUMsS0FMRixFQU0yQztBQUN6QyxVQUFNQyx5QkFBeUIsa0JBQVFDLGtDQUFSLENBQTJDSCxNQUEzQyxFQUFtREMsS0FBbkQsQ0FBL0I7QUFDQSxVQUFNRyxzQkFBc0JYLGtCQUFrQlksa0JBQWxCLEVBQzFCLE1BQU1QLFdBQVdRLGNBQVgsQ0FBMEJKLHNCQUExQixDQURvQixFQUE1QjtBQUdBLFFBQUlFLHVCQUF1QixJQUF2QixJQUErQkEsb0JBQW9CRyxNQUFwQixLQUErQixDQUFsRSxFQUFxRTtBQUNuRSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJQyxVQUFKO0FBQ0EsUUFBSWIsbUJBQW1CYyx5QkFBdkIsRUFBa0Q7QUFDaEQsWUFBTUMsYUFBYSxNQUFNWixXQUFXYSxpQkFBWCxDQUE2QlQsc0JBQTdCLENBQXpCO0FBQ0EsVUFBSVEsY0FBYyxJQUFkLElBQXNCQSxXQUFXSCxNQUFYLEdBQW9CLENBQTlDLEVBQWlEO0FBQy9DQyxxQkFBYUUsV0FBV0UsR0FBWCxDQUFlQyxLQUFLLGtCQUFRQyxrQkFBUixDQUEyQkQsRUFBRUUsS0FBN0IsQ0FBcEIsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTztBQUNMUCxrQkFBWUEsY0FBYyxDQUFDLGdCQUFNUSxpQkFBTixDQUF3QmhCLE1BQXhCLEVBQWdDQyxLQUFoQyxDQUFELENBRHJCO0FBRUxnQixtQkFBYXhCLGtCQUFrQnlCLDZCQUFsQixDQUFnRGQsbUJBQWhELEVBQXFFTCxZQUFyRTtBQUZSLEtBQVA7QUFJRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPTSxrQkFBUCxDQUEwQmMsY0FBMUIsRUFBd0Y7QUFDdEYsUUFBSUEsa0JBQWtCLElBQXRCLEVBQTRCO0FBQzFCLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBTyxDQUFDQyxNQUFNQyxPQUFOLENBQWNGLGNBQWQsSUFBZ0NBLGNBQWhDLEdBQWlELENBQUNBLGNBQUQsQ0FBbEQsRUFBb0VHLE1BQXBFLENBQTJFQyxLQUFLQSxFQUFFUixLQUFGLENBQVFTLEtBQVIsSUFBaUIsSUFBakcsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9OLDZCQUFQLENBQXFDTyxTQUFyQyxFQUFpRTFCLFlBQWpFLEVBQWtIO0FBQ2hILFdBQU8wQixVQUFVYixHQUFWLENBQWNXLE1BQU07QUFDekJHLFlBQU0sa0JBQVFDLFNBQVIsQ0FBa0JKLEVBQUVLLEdBQXBCLENBRG1CO0FBRXpCQyxnQkFBVSxrQkFBUUMsZUFBUixDQUF3QlAsRUFBRVIsS0FBRixDQUFRUyxLQUFoQyxDQUZlO0FBR3pCVCxhQUFPLFlBQU1nQixVQUFOLENBQWlCLGtCQUFRakIsa0JBQVIsQ0FBMkJTLEVBQUVSLEtBQTdCLENBQWpCLENBSGtCO0FBSXpCaUIsZ0JBQVVqQztBQUplLEtBQU4sQ0FBZCxDQUFQO0FBTUQ7QUFoRm9DO2tCQUFsQk4saUIiLCJmaWxlIjoiZGVmaW5pdGlvbi1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCB0eXBlIExvY2F0aW9uLCB0eXBlIFNlcnZlckNhcGFiaWxpdGllc30gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzJztcclxuaW1wb3J0IHtSYW5nZX0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXHJcbi8vIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJyBmdW5jdGlvbmFsaXR5LlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uQWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZGVmaW5pdGlvblByb3ZpZGVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuZGVmaW5pdGlvblByb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBHZXQgdGhlIGRlZmluaXRpb25zIGZvciBhIHN5bWJvbCBhdCBhIGdpdmVuIHtQb2ludH0gd2l0aGluIGFcclxuICAvLyB7VGV4dEVkaXRvcn0gaW5jbHVkaW5nIG9wdGlvbmFsbHkgaGlnaGxpZ2h0aW5nIGFsbCBvdGhlciByZWZlcmVuY2VzXHJcbiAgLy8gd2l0aGluIHRoZSBkb2N1bWVudCBpZiB0aGUgbGFuZ2F1Z2Ugc2VydmVyIGFsc28gc3VwcG9ydHMgaGlnaGxpZ2h0aW5nLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBwcm92aWRlIGRlZmluaXRpb25zIGFuZCBoaWdobGlnaHRzLlxyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHVzZWQuXHJcbiAgLy8gKiBgbGFuZ3VhZ2VOYW1lYCBUaGUgbmFtZSBvZiB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgc3ltYm9sIGFuZCBwb3RlbnRpYWwgaGlnaGxpZ2h0cy5cclxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGV4dCB0aGF0IHJlcHJlc2VudHMgdGhlIHN5bWJvbFxyXG4gIC8vICAgICAgICAgICBmb3Igd2hpY2ggdGhlIGRlZmluaXRpb24gYW5kIGhpZ2hsaWdodHMgc2hvdWxkIGJlIHByb3ZpZGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIGFzeW5jIGdldERlZmluaXRpb24oXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcclxuICAgIGxhbmd1YWdlTmFtZTogc3RyaW5nLFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IGF0b20kUG9pbnQsXHJcbiAgKTogUHJvbWlzZTw/YXRvbUlkZSREZWZpbml0aW9uUXVlcnlSZXN1bHQ+IHtcclxuICAgIGNvbnN0IGRvY3VtZW50UG9zaXRpb25QYXJhbXMgPSBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yLCBwb2ludCk7XHJcbiAgICBjb25zdCBkZWZpbml0aW9uTG9jYXRpb25zID0gRGVmaW5pdGlvbkFkYXB0ZXIubm9ybWFsaXplTG9jYXRpb25zKFxyXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmdvdG9EZWZpbml0aW9uKGRvY3VtZW50UG9zaXRpb25QYXJhbXMpLFxyXG4gICAgKTtcclxuICAgIGlmIChkZWZpbml0aW9uTG9jYXRpb25zID09IG51bGwgfHwgZGVmaW5pdGlvbkxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHF1ZXJ5UmFuZ2U7XHJcbiAgICBpZiAoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIpIHtcclxuICAgICAgY29uc3QgaGlnaGxpZ2h0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRIaWdobGlnaHQoZG9jdW1lbnRQb3NpdGlvblBhcmFtcyk7XHJcbiAgICAgIGlmIChoaWdobGlnaHRzICE9IG51bGwgJiYgaGlnaGxpZ2h0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcXVlcnlSYW5nZSA9IGhpZ2hsaWdodHMubWFwKGggPT4gQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoaC5yYW5nZSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcXVlcnlSYW5nZTogcXVlcnlSYW5nZSB8fCBbVXRpbHMuZ2V0V29yZEF0UG9zaXRpb24oZWRpdG9yLCBwb2ludCldLFxyXG4gICAgICBkZWZpbml0aW9uczogRGVmaW5pdGlvbkFkYXB0ZXIuY29udmVydExvY2F0aW9uc1RvRGVmaW5pdGlvbnMoZGVmaW5pdGlvbkxvY2F0aW9ucywgbGFuZ3VhZ2VOYW1lKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IE5vcm1hbGl6ZSB0aGUgbG9jYXRpb25zIHNvIGEgc2luZ2xlIHtMb2NhdGlvbn0gYmVjb21lcyBhbiB7QXJyYXl9IG9mIGp1c3RcclxuICAvLyBvbmUuIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgcmV0dXJuIGVpdGhlciBhcyB0aGUgcHJvdG9jb2wgZXZvbHZlZCBiZXR3ZWVuIHYxIGFuZCB2Mi5cclxuICAvL1xyXG4gIC8vICogYGxvY2F0aW9uUmVzdWx0YCBlaXRoZXIgYSBzaW5nbGUge0xvY2F0aW9ufSBvYmplY3Qgb3IgYW4ge0FycmF5fSBvZiB7TG9jYXRpb25zfVxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn1zIG9yIHtudWxsfSBpZiB0aGUgbG9jYXRpb25SZXN1bHQgd2FzIG51bGwuXHJcbiAgc3RhdGljIG5vcm1hbGl6ZUxvY2F0aW9ucyhsb2NhdGlvblJlc3VsdDogTG9jYXRpb24gfCBBcnJheTxMb2NhdGlvbj4pOiA/QXJyYXk8TG9jYXRpb24+IHtcclxuICAgIGlmIChsb2NhdGlvblJlc3VsdCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGxvY2F0aW9uUmVzdWx0KSA/IGxvY2F0aW9uUmVzdWx0IDogW2xvY2F0aW9uUmVzdWx0XSkuZmlsdGVyKGQgPT4gZC5yYW5nZS5zdGFydCAhPSBudWxsKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn0gb2JqZWN0cyBpbnRvIGFuIEFycmF5IG9mIHtEZWZpbml0aW9ufXMuXHJcbiAgLy9cclxuICAvLyAqIGBsb2NhdGlvbnNgIEFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufSBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZC5cclxuICAvLyAqIGBsYW5ndWFnZU5hbWVgIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0aGVzZSBvYmplY3RzIGFyZSB3cml0dGVuIGluLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtEZWZpbml0aW9ufXMgdGhhdCByZXByZXNlbnRlZCB0aGUgY29udmVydGVkIHtMb2NhdGlvbn1zLlxyXG4gIHN0YXRpYyBjb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhsb2NhdGlvbnM6IEFycmF5PExvY2F0aW9uPiwgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcpOiBBcnJheTxhdG9tSWRlJERlZmluaXRpb24+IHtcclxuICAgIHJldHVybiBsb2NhdGlvbnMubWFwKGQgPT4gKHtcclxuICAgICAgcGF0aDogQ29udmVydC51cmlUb1BhdGgoZC51cmkpLFxyXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoZC5yYW5nZS5zdGFydCksXHJcbiAgICAgIHJhbmdlOiBSYW5nZS5mcm9tT2JqZWN0KENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGQucmFuZ2UpKSxcclxuICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcclxuICAgIH0pKTtcclxuICB9XHJcbn1cclxuIl19