Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Synchronizes the documents between Atom and the language server by notifying
// each end of changes, opening, closing and other events as well as sending and applying
// changes either in whole or in part depending on what the language server supports.
let DocumentSyncAdapter = class DocumentSyncAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix textDocumentSync capability either being Full or
  // Incremental.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return this.canAdaptV2(serverCapabilities) || this.canAdaptV3(serverCapabilities);
  }

  static canAdaptV2(serverCapabilities) {
    return serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Incremental || serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Full;
  }

  static canAdaptV3(serverCapabilities) {
    const options = serverCapabilities.textDocumentSync;
    return options !== null && typeof options === 'object' && (options.change === _languageclient.TextDocumentSyncKind.Incremental || options.change === _languageclient.TextDocumentSyncKind.Full);
  }

  // Public: Create a new {DocumentSyncAdapter} for the given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server to be kept in sync.
  // * `documentSyncKind` The type of document syncing supported - Full or Incremental.
  // * `editorSelector` A predicate function that takes a {TextEditor} and returns a {boolean}
  //                    indicating whether this adapter should care about the contents of the editor.
  constructor(connection, documentSyncKind, editorSelector) {
    this._disposable = new _atom.CompositeDisposable();
    this._editors = new WeakMap();

    this._connection = connection;
    if (typeof documentSyncKind === 'number') {
      this._documentSyncKind = documentSyncKind;
    } else if (documentSyncKind != null && documentSyncKind.change != null) {
      this._documentSyncKind = documentSyncKind.change;
    } else {
      this._documentSyncKind = _languageclient.TextDocumentSyncKind.Full;
    }
    this._editorSelector = editorSelector;
    this._disposable.add(atom.textEditors.observe(this.observeTextEditor.bind(this)));
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Examine a {TextEditor} and decide if we wish to observe it. If so ensure that we stop observing it
  // when it is closed or otherwise destroyed.
  //
  // * `editor` A {TextEditor} to consider for observation.
  observeTextEditor(editor) {
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => {
      this._disposable.remove(listener);
      listener.dispose();
    }));
    this._disposable.add(listener);
    if (!this._editors.has(editor) && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleGrammarChange(editor) {
    const sync = this._editors.get(editor);
    if (sync != null && !this._editorSelector(editor)) {
      this._editors.delete(editor);
      this._disposable.remove(sync);
      sync.dispose();
    } else if (sync == null && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleNewEditor(editor) {
    const sync = new TextEditorSyncAdapter(editor, this._connection, this._documentSyncKind);
    this._editors.set(editor, sync);
    this._disposable.add(sync);
    this._disposable.add(editor.onDidDestroy(() => {
      const destroyedSync = this._editors.get(editor);
      if (destroyedSync) {
        this._editors.delete(editor);
        this._disposable.remove(destroyedSync);
        destroyedSync.dispose();
      }
    }));
  }

  getEditorSyncAdapter(editor) {
    return this._editors.get(editor);
  }
};

// Public: Keep a single {TextEditor} in sync with a given language server.

exports.default = DocumentSyncAdapter;
let TextEditorSyncAdapter = class TextEditorSyncAdapter {

  // Public: Create a {TextEditorSyncAdapter} in sync with a given language server.
  //
  // * `editor` A {TextEditor} to keep in sync.
  // * `connection` A {LanguageClientConnection} to a language server to keep in sync.
  // * `documentSyncKind` Whether to use Full (1) or Incremental (2) when sending changes.
  constructor(editor, connection, documentSyncKind) {
    this._disposable = new _atom.CompositeDisposable();
    this._version = 1;

    this._editor = editor;
    this._connection = connection;

    const changeTracking = this.setupChangeTracking(documentSyncKind);
    if (changeTracking != null) {
      this._disposable.add(changeTracking);
    }

    this._disposable.add(editor.onDidSave(this.didSave.bind(this)), editor.onDidDestroy(this.didDestroy.bind(this)), editor.onDidChangePath(this.didRename.bind(this)));

    this._lastFileUri = this.getEditorUri();
    this.didOpen();
  }

  // The change tracking disposable listener that will ensure that changes are sent to the
  // language server as appropriate.
  setupChangeTracking(documentSyncKind) {
    switch (documentSyncKind) {
      case _languageclient.TextDocumentSyncKind.Full:
        return this._editor.onDidChange(this.sendFullChanges.bind(this));
      case _languageclient.TextDocumentSyncKind.Incremental:
        return this._editor.getBuffer().onDidChangeText(this.sendIncrementalChanges.bind(this));
    }
    return null;
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Get the languageId field that will be sent to the language server by simply
  // using the grammar name.
  getLanguageId() {
    return this._editor.getGrammar().name;
  }

  // Public: Create a {VersionedTextDocumentIdentifier} for the document observed by
  // this adapter including both the Uri and the current Version.
  getVersionedTextDocumentIdentifier() {
    return {
      uri: this.getEditorUri(),
      version: this._version
    };
  }

  // Ensure when the document is opened we send notification to the language server
  // so it can load it in and keep track of diagnostics etc.
  didOpen() {
    if (this._editor.getURI() == null) {
      return;
    } // Not yet saved

    this._connection.didOpenTextDocument({
      textDocument: {
        uri: this.getEditorUri(),
        languageId: this.getLanguageId().toLowerCase(),
        version: this._version,
        text: this._editor.getText()
      }
    });
  }

  // Public: Send the entire document to the language server. This is used when
  // operating in Full (1) sync mode.
  sendFullChanges() {
    this._version++;
    this._connection.didChangeTextDocument({
      textDocument: this.getVersionedTextDocumentIdentifier(),
      contentChanges: [{ text: this._editor.getText() }]
    });
  }

  // Public: Send the incremental text changes to the language server. This is used
  // when operating in Incremental (2) sync mode.
  //
  // * `event` The event fired by Atom to indicate the document has stopped changing
  //           including a list of changes since the last time this event fired for this
  //           text editor.
  // Note: The order of changes in the event is guaranteed top to bottom.  Language server
  // expects this in reverse.
  sendIncrementalChanges(event) {
    if (event.changes.length > 0) {
      this._version++;
      this._connection.didChangeTextDocument({
        textDocument: this.getVersionedTextDocumentIdentifier(),
        contentChanges: event.changes.map(TextEditorSyncAdapter.textEditToContentChange).reverse()
      });
    }
  }

  // Public: Convert an Atom {TextEditEvent} to a language server {TextDocumentContentChangeEvent}
  // object.
  //
  // * `change` The Atom {TextEditEvent} to convert.
  //
  // Returns a {TextDocumentContentChangeEvent} that represents the converted {TextEditEvent}.
  static textEditToContentChange(change) {
    return {
      range: _convert2.default.atomRangeToLSRange(change.oldRange),
      rangeLength: change.oldText.length,
      text: change.newText
    };
  }

  // Called when the {TextEditor} is closed and sends the 'didCloseTextDocument' notification to
  // the connected language server.
  didDestroy() {
    if (this._editor.getURI() == null) {
      return;
    } // Not yet saved
    this._connection.didCloseTextDocument({
      textDocument: { uri: this.getEditorUri() }
    });
  }

  // Called when the {TextEditor} saves and sends the 'didSaveTextDocument' notification to
  // the connected language server.
  // Note: Right now this also sends the `didChangeWatchedFiles` notification as well but that
  // will be sent from elsewhere soon.
  didSave() {
    this._connection.didSaveTextDocument({
      textDocument: { uri: this.getEditorUri() }
    });
    // TODO: Move this to a file watching event once Atom has API support.
    this._connection.didChangeWatchedFiles({
      changes: [{ uri: this.getEditorUri(), type: _languageclient.FileChangeType.Changed }]
    }); // Replace with file watch
  }

  didRename() {
    const lastFileUri = this._lastFileUri;
    if (!lastFileUri) {
      this._lastFileUri = this.getEditorUri();
      return;
    }

    this._connection.didCloseTextDocument({
      textDocument: { uri: lastFileUri }
    });
    this._connection.didChangeWatchedFiles({
      changes: [{ uri: lastFileUri, type: _languageclient.FileChangeType.Deleted }, { uri: this.getEditorUri(), type: _languageclient.FileChangeType.Created }]
    });
    this._lastFileUri = this.getEditorUri();

    // send an equivalent open event for this editor, which will now use the new
    // file path
    this.didOpen();
  }

  // Public: Obtain the current {TextEditor} path and convert it to a Uri.
  getEditorUri() {
    return _convert2.default.pathToUri(this._editor.getPath() || '');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRG9jdW1lbnRTeW5jQWRhcHRlciIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiY2FuQWRhcHRWMiIsImNhbkFkYXB0VjMiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwiSW5jcmVtZW50YWwiLCJGdWxsIiwib3B0aW9ucyIsImNoYW5nZSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsImRvY3VtZW50U3luY0tpbmQiLCJlZGl0b3JTZWxlY3RvciIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvcnMiLCJXZWFrTWFwIiwiX2Nvbm5lY3Rpb24iLCJfZG9jdW1lbnRTeW5jS2luZCIsIl9lZGl0b3JTZWxlY3RvciIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvciIsImJpbmQiLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsInJlbW92ZSIsImhhcyIsIl9oYW5kbGVOZXdFZGl0b3IiLCJzeW5jIiwiZ2V0IiwiZGVsZXRlIiwiVGV4dEVkaXRvclN5bmNBZGFwdGVyIiwic2V0IiwiZGVzdHJveWVkU3luYyIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwiX3ZlcnNpb24iLCJfZWRpdG9yIiwiY2hhbmdlVHJhY2tpbmciLCJzZXR1cENoYW5nZVRyYWNraW5nIiwib25EaWRTYXZlIiwiZGlkU2F2ZSIsImRpZERlc3Ryb3kiLCJvbkRpZENoYW5nZVBhdGgiLCJkaWRSZW5hbWUiLCJfbGFzdEZpbGVVcmkiLCJnZXRFZGl0b3JVcmkiLCJkaWRPcGVuIiwib25EaWRDaGFuZ2UiLCJzZW5kRnVsbENoYW5nZXMiLCJnZXRCdWZmZXIiLCJvbkRpZENoYW5nZVRleHQiLCJzZW5kSW5jcmVtZW50YWxDaGFuZ2VzIiwiZ2V0TGFuZ3VhZ2VJZCIsImdldEdyYW1tYXIiLCJuYW1lIiwiZ2V0VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciIsInVyaSIsInZlcnNpb24iLCJnZXRVUkkiLCJkaWRPcGVuVGV4dERvY3VtZW50IiwidGV4dERvY3VtZW50IiwibGFuZ3VhZ2VJZCIsInRvTG93ZXJDYXNlIiwidGV4dCIsImdldFRleHQiLCJkaWRDaGFuZ2VUZXh0RG9jdW1lbnQiLCJjb250ZW50Q2hhbmdlcyIsImV2ZW50IiwiY2hhbmdlcyIsImxlbmd0aCIsIm1hcCIsInRleHRFZGl0VG9Db250ZW50Q2hhbmdlIiwicmV2ZXJzZSIsInJhbmdlIiwiYXRvbVJhbmdlVG9MU1JhbmdlIiwib2xkUmFuZ2UiLCJyYW5nZUxlbmd0aCIsIm9sZFRleHQiLCJuZXdUZXh0IiwiZGlkQ2xvc2VUZXh0RG9jdW1lbnQiLCJkaWRTYXZlVGV4dERvY3VtZW50IiwiZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzIiwidHlwZSIsIkNoYW5nZWQiLCJsYXN0RmlsZVVyaSIsIkRlbGV0ZWQiLCJDcmVhdGVkIiwicGF0aFRvVXJpIiwiZ2V0UGF0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7QUFTQTs7OztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0lBQ3FCQSxtQixHQUFOLE1BQU1BLG1CQUFOLENBQTBCOztBQU92QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsUUFBUCxDQUFnQkMsa0JBQWhCLEVBQWlFO0FBQy9ELFdBQU8sS0FBS0MsVUFBTCxDQUFnQkQsa0JBQWhCLEtBQXVDLEtBQUtFLFVBQUwsQ0FBZ0JGLGtCQUFoQixDQUE5QztBQUNEOztBQUVELFNBQU9DLFVBQVAsQ0FBa0JELGtCQUFsQixFQUFtRTtBQUNqRSxXQUNFQSxtQkFBbUJHLGdCQUFuQixLQUF3QyxxQ0FBcUJDLFdBQTdELElBQ0FKLG1CQUFtQkcsZ0JBQW5CLEtBQXdDLHFDQUFxQkUsSUFGL0Q7QUFJRDs7QUFFRCxTQUFPSCxV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a0IsS0FBS25ELE9BQUwsQ0FBYW9ELE9BQWIsTUFBMEIsRUFBNUMsQ0FBUDtBQUNEO0FBN0t5QixDIiwiZmlsZSI6ImRvY3VtZW50LXN5bmMtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBGaWxlQ2hhbmdlVHlwZSxcclxuICBUZXh0RG9jdW1lbnRTeW5jS2luZCxcclxuICBUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyxcclxuICB0eXBlIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCxcclxuICB0eXBlIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIsXHJcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFB1YmxpYzogU3luY2hyb25pemVzIHRoZSBkb2N1bWVudHMgYmV0d2VlbiBBdG9tIGFuZCB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGJ5IG5vdGlmeWluZ1xyXG4vLyBlYWNoIGVuZCBvZiBjaGFuZ2VzLCBvcGVuaW5nLCBjbG9zaW5nIGFuZCBvdGhlciBldmVudHMgYXMgd2VsbCBhcyBzZW5kaW5nIGFuZCBhcHBseWluZ1xyXG4vLyBjaGFuZ2VzIGVpdGhlciBpbiB3aG9sZSBvciBpbiBwYXJ0IGRlcGVuZGluZyBvbiB3aGF0IHRoZSBsYW5ndWFnZSBzZXJ2ZXIgc3VwcG9ydHMuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50U3luY0FkYXB0ZXIge1xyXG4gIF9lZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW47XHJcbiAgX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIF9kb2N1bWVudFN5bmNLaW5kOiBudW1iZXI7XHJcbiAgX2VkaXRvcnM6IFdlYWtNYXA8YXRvbSRUZXh0RWRpdG9yLCBUZXh0RWRpdG9yU3luY0FkYXB0ZXI+ID0gbmV3IFdlYWtNYXAoKTtcclxuICBfY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uO1xyXG5cclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IHRleHREb2N1bWVudFN5bmMgY2FwYWJpbGl0eSBlaXRoZXIgYmVpbmcgRnVsbCBvclxyXG4gIC8vIEluY3JlbWVudGFsLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmNhbkFkYXB0VjIoc2VydmVyQ2FwYWJpbGl0aWVzKSB8fCB0aGlzLmNhbkFkYXB0VjMoc2VydmVyQ2FwYWJpbGl0aWVzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYW5BZGFwdFYyKHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYyA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgfHxcclxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FuQWRhcHRWMyhzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHNlcnZlckNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgKG9wdGlvbnMuY2hhbmdlID09PSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCB8fCBvcHRpb25zLmNoYW5nZSA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIG5ldyB7RG9jdW1lbnRTeW5jQWRhcHRlcn0gZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gYmUga2VwdCBpbiBzeW5jLlxyXG4gIC8vICogYGRvY3VtZW50U3luY0tpbmRgIFRoZSB0eXBlIG9mIGRvY3VtZW50IHN5bmNpbmcgc3VwcG9ydGVkIC0gRnVsbCBvciBJbmNyZW1lbnRhbC5cclxuICAvLyAqIGBlZGl0b3JTZWxlY3RvcmAgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtUZXh0RWRpdG9yfSBhbmQgcmV0dXJucyBhIHtib29sZWFufVxyXG4gIC8vICAgICAgICAgICAgICAgICAgICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBhZGFwdGVyIHNob3VsZCBjYXJlIGFib3V0IHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdG9yLlxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZG9jdW1lbnRTeW5jS2luZDogPyhUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyB8IG51bWJlciksXHJcbiAgICBlZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW4sXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRTeW5jS2luZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCA9IGRvY3VtZW50U3luY0tpbmQ7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50U3luY0tpbmQgIT0gbnVsbCAmJiBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZSAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZWRpdG9yU2VsZWN0b3IgPSBlZGl0b3JTZWxlY3RvcjtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20udGV4dEVkaXRvcnMub2JzZXJ2ZSh0aGlzLm9ic2VydmVUZXh0RWRpdG9yLmJpbmQodGhpcykpKTtcclxuICB9XHJcblxyXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gRXhhbWluZSBhIHtUZXh0RWRpdG9yfSBhbmQgZGVjaWRlIGlmIHdlIHdpc2ggdG8gb2JzZXJ2ZSBpdC4gSWYgc28gZW5zdXJlIHRoYXQgd2Ugc3RvcCBvYnNlcnZpbmcgaXRcclxuICAvLyB3aGVuIGl0IGlzIGNsb3NlZCBvciBvdGhlcndpc2UgZGVzdHJveWVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0byBjb25zaWRlciBmb3Igb2JzZXJ2YXRpb24uXHJcbiAgb2JzZXJ2ZVRleHRFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gZWRpdG9yLm9ic2VydmVHcmFtbWFyKGdyYW1tYXIgPT4gdGhpcy5faGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3IpKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShsaXN0ZW5lcik7XHJcbiAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChsaXN0ZW5lcik7XHJcbiAgICBpZiAoIXRoaXMuX2VkaXRvcnMuaGFzKGVkaXRvcikgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xyXG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICBjb25zdCBzeW5jID0gdGhpcy5fZWRpdG9ycy5nZXQoZWRpdG9yKTtcclxuICAgIGlmIChzeW5jICE9IG51bGwgJiYgIXRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcclxuICAgICAgdGhpcy5fZWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUoc3luYyk7XHJcbiAgICAgIHN5bmMuZGlzcG9zZSgpO1xyXG4gICAgfSBlbHNlIGlmIChzeW5jID09IG51bGwgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xyXG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IHN5bmMgPSBuZXcgVGV4dEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvciwgdGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCk7XHJcbiAgICB0aGlzLl9lZGl0b3JzLnNldChlZGl0b3IsIHN5bmMpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoc3luYyk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChcclxuICAgICAgZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGVzdHJveWVkU3luYyA9IHRoaXMuX2VkaXRvcnMuZ2V0KGVkaXRvcik7XHJcbiAgICAgICAgaWYgKGRlc3Ryb3llZFN5bmMpIHtcclxuICAgICAgICAgIHRoaXMuX2VkaXRvcnMuZGVsZXRlKGVkaXRvcik7XHJcbiAgICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShkZXN0cm95ZWRTeW5jKTtcclxuICAgICAgICAgIGRlc3Ryb3llZFN5bmMuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ2V0RWRpdG9yU3luY0FkYXB0ZXIoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiA/VGV4dEVkaXRvclN5bmNBZGFwdGVyIHtcclxuICAgIHJldHVybiB0aGlzLl9lZGl0b3JzLmdldChlZGl0b3IpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gUHVibGljOiBLZWVwIGEgc2luZ2xlIHtUZXh0RWRpdG9yfSBpbiBzeW5jIHdpdGggYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbmNsYXNzIFRleHRFZGl0b3JTeW5jQWRhcHRlciB7XHJcbiAgX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIF9lZGl0b3I6IGF0b20kVGV4dEVkaXRvcjtcclxuICBfbGFzdEZpbGVVcmk6ID9zdHJpbmc7XHJcbiAgX2Nvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbjtcclxuICBfdmVyc2lvbiA9IDE7XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1RleHRFZGl0b3JTeW5jQWRhcHRlcn0gaW4gc3luYyB3aXRoIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0byBrZWVwIGluIHN5bmMuXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byBhIGxhbmd1YWdlIHNlcnZlciB0byBrZWVwIGluIHN5bmMuXHJcbiAgLy8gKiBgZG9jdW1lbnRTeW5jS2luZGAgV2hldGhlciB0byB1c2UgRnVsbCAoMSkgb3IgSW5jcmVtZW50YWwgKDIpIHdoZW4gc2VuZGluZyBjaGFuZ2VzLlxyXG4gIGNvbnN0cnVjdG9yKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcikge1xyXG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcblxyXG4gICAgY29uc3QgY2hhbmdlVHJhY2tpbmcgPSB0aGlzLnNldHVwQ2hhbmdlVHJhY2tpbmcoZG9jdW1lbnRTeW5jS2luZCk7XHJcbiAgICBpZiAoY2hhbmdlVHJhY2tpbmcgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChjaGFuZ2VUcmFja2luZyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGVkaXRvci5vbkRpZFNhdmUodGhpcy5kaWRTYXZlLmJpbmQodGhpcykpLFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KHRoaXMuZGlkRGVzdHJveS5iaW5kKHRoaXMpKSxcclxuICAgICAgZWRpdG9yLm9uRGlkQ2hhbmdlUGF0aCh0aGlzLmRpZFJlbmFtZS5iaW5kKHRoaXMpKSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5fbGFzdEZpbGVVcmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xyXG4gICAgdGhpcy5kaWRPcGVuKCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgY2hhbmdlIHRyYWNraW5nIGRpc3Bvc2FibGUgbGlzdGVuZXIgdGhhdCB3aWxsIGVuc3VyZSB0aGF0IGNoYW5nZXMgYXJlIHNlbnQgdG8gdGhlXHJcbiAgLy8gbGFuZ3VhZ2Ugc2VydmVyIGFzIGFwcHJvcHJpYXRlLlxyXG4gIHNldHVwQ2hhbmdlVHJhY2tpbmcoZG9jdW1lbnRTeW5jS2luZDogbnVtYmVyKTogP0lEaXNwb3NhYmxlIHtcclxuICAgIHN3aXRjaCAoZG9jdW1lbnRTeW5jS2luZCkge1xyXG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRvci5vbkRpZENoYW5nZSh0aGlzLnNlbmRGdWxsQ2hhbmdlcy5iaW5kKHRoaXMpKTtcclxuICAgICAgY2FzZSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbDpcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpLm9uRGlkQ2hhbmdlVGV4dCh0aGlzLnNlbmRJbmNyZW1lbnRhbENoYW5nZXMuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBsYW5ndWFnZUlkIGZpZWxkIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYnkgc2ltcGx5XHJcbiAgLy8gdXNpbmcgdGhlIGdyYW1tYXIgbmFtZS5cclxuICBnZXRMYW5ndWFnZUlkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEdyYW1tYXIoKS5uYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gZm9yIHRoZSBkb2N1bWVudCBvYnNlcnZlZCBieVxyXG4gIC8vIHRoaXMgYWRhcHRlciBpbmNsdWRpbmcgYm90aCB0aGUgVXJpIGFuZCB0aGUgY3VycmVudCBWZXJzaW9uLlxyXG4gIGdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKTogVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCksXHJcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIHdoZW4gdGhlIGRvY3VtZW50IGlzIG9wZW5lZCB3ZSBzZW5kIG5vdGlmaWNhdGlvbiB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gc28gaXQgY2FuIGxvYWQgaXQgaW4gYW5kIGtlZXAgdHJhY2sgb2YgZGlhZ25vc3RpY3MgZXRjLlxyXG4gIGRpZE9wZW4oKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fZWRpdG9yLmdldFVSSSgpID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfSAvLyBOb3QgeWV0IHNhdmVkXHJcblxyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRPcGVuVGV4dERvY3VtZW50KHtcclxuICAgICAgdGV4dERvY3VtZW50OiB7XHJcbiAgICAgICAgdXJpOiB0aGlzLmdldEVkaXRvclVyaSgpLFxyXG4gICAgICAgIGxhbmd1YWdlSWQ6IHRoaXMuZ2V0TGFuZ3VhZ2VJZCgpLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcclxuICAgICAgICB0ZXh0OiB0aGlzLl9lZGl0b3IuZ2V0VGV4dCgpLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IFNlbmQgdGhlIGVudGlyZSBkb2N1bWVudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGlzIHVzZWQgd2hlblxyXG4gIC8vIG9wZXJhdGluZyBpbiBGdWxsICgxKSBzeW5jIG1vZGUuXHJcbiAgc2VuZEZ1bGxDaGFuZ2VzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fdmVyc2lvbisrO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VUZXh0RG9jdW1lbnQoe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IHRoaXMuZ2V0VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcigpLFxyXG4gICAgICBjb250ZW50Q2hhbmdlczogW3t0ZXh0OiB0aGlzLl9lZGl0b3IuZ2V0VGV4dCgpfV0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogU2VuZCB0aGUgaW5jcmVtZW50YWwgdGV4dCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaXMgdXNlZFxyXG4gIC8vIHdoZW4gb3BlcmF0aW5nIGluIEluY3JlbWVudGFsICgyKSBzeW5jIG1vZGUuXHJcbiAgLy9cclxuICAvLyAqIGBldmVudGAgVGhlIGV2ZW50IGZpcmVkIGJ5IEF0b20gdG8gaW5kaWNhdGUgdGhlIGRvY3VtZW50IGhhcyBzdG9wcGVkIGNoYW5naW5nXHJcbiAgLy8gICAgICAgICAgIGluY2x1ZGluZyBhIGxpc3Qgb2YgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoaXMgZXZlbnQgZmlyZWQgZm9yIHRoaXNcclxuICAvLyAgICAgICAgICAgdGV4dCBlZGl0b3IuXHJcbiAgLy8gTm90ZTogVGhlIG9yZGVyIG9mIGNoYW5nZXMgaW4gdGhlIGV2ZW50IGlzIGd1YXJhbnRlZWQgdG9wIHRvIGJvdHRvbS4gIExhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGV4cGVjdHMgdGhpcyBpbiByZXZlcnNlLlxyXG4gIHNlbmRJbmNyZW1lbnRhbENoYW5nZXMoZXZlbnQ6IGF0b20kRGlkU3RvcENoYW5naW5nRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmIChldmVudC5jaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5fdmVyc2lvbisrO1xyXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVRleHREb2N1bWVudCh7XHJcbiAgICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcclxuICAgICAgICBjb250ZW50Q2hhbmdlczogZXZlbnQuY2hhbmdlcy5tYXAoVGV4dEVkaXRvclN5bmNBZGFwdGVyLnRleHRFZGl0VG9Db250ZW50Q2hhbmdlKS5yZXZlcnNlKCksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIEF0b20ge1RleHRFZGl0RXZlbnR9IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHtUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnR9XHJcbiAgLy8gb2JqZWN0LlxyXG4gIC8vXHJcbiAgLy8gKiBgY2hhbmdlYCBUaGUgQXRvbSB7VGV4dEVkaXRFdmVudH0gdG8gY29udmVydC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7VGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50fSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnZlcnRlZCB7VGV4dEVkaXRFdmVudH0uXHJcbiAgc3RhdGljIHRleHRFZGl0VG9Db250ZW50Q2hhbmdlKGNoYW5nZTogYXRvbSRUZXh0RWRpdEV2ZW50KTogVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJhbmdlOiBDb252ZXJ0LmF0b21SYW5nZVRvTFNSYW5nZShjaGFuZ2Uub2xkUmFuZ2UpLFxyXG4gICAgICByYW5nZUxlbmd0aDogY2hhbmdlLm9sZFRleHQubGVuZ3RoLFxyXG4gICAgICB0ZXh0OiBjaGFuZ2UubmV3VGV4dCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBDYWxsZWQgd2hlbiB0aGUge1RleHRFZGl0b3J9IGlzIGNsb3NlZCBhbmQgc2VuZHMgdGhlICdkaWRDbG9zZVRleHREb2N1bWVudCcgbm90aWZpY2F0aW9uIHRvXHJcbiAgLy8gdGhlIGNvbm5lY3RlZCBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgZGlkRGVzdHJveSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9lZGl0b3IuZ2V0VVJJKCkgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIE5vdCB5ZXQgc2F2ZWRcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2xvc2VUZXh0RG9jdW1lbnQoe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IHt1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCl9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBDYWxsZWQgd2hlbiB0aGUge1RleHRFZGl0b3J9IHNhdmVzIGFuZCBzZW5kcyB0aGUgJ2RpZFNhdmVUZXh0RG9jdW1lbnQnIG5vdGlmaWNhdGlvbiB0b1xyXG4gIC8vIHRoZSBjb25uZWN0ZWQgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vIE5vdGU6IFJpZ2h0IG5vdyB0aGlzIGFsc28gc2VuZHMgdGhlIGBkaWRDaGFuZ2VXYXRjaGVkRmlsZXNgIG5vdGlmaWNhdGlvbiBhcyB3ZWxsIGJ1dCB0aGF0XHJcbiAgLy8gd2lsbCBiZSBzZW50IGZyb20gZWxzZXdoZXJlIHNvb24uXHJcbiAgZGlkU2F2ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkU2F2ZVRleHREb2N1bWVudCh7XHJcbiAgICAgIHRleHREb2N1bWVudDoge3VyaTogdGhpcy5nZXRFZGl0b3JVcmkoKX0sXHJcbiAgICB9KTtcclxuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhIGZpbGUgd2F0Y2hpbmcgZXZlbnQgb25jZSBBdG9tIGhhcyBBUEkgc3VwcG9ydC5cclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKHtcclxuICAgICAgY2hhbmdlczogW3t1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCksIHR5cGU6IEZpbGVDaGFuZ2VUeXBlLkNoYW5nZWR9XSxcclxuICAgIH0pOyAvLyBSZXBsYWNlIHdpdGggZmlsZSB3YXRjaFxyXG4gIH1cclxuXHJcbiAgZGlkUmVuYW1lKCkge1xyXG4gICAgY29uc3QgbGFzdEZpbGVVcmkgPSB0aGlzLl9sYXN0RmlsZVVyaTtcclxuICAgIGlmICghbGFzdEZpbGVVcmkpIHtcclxuICAgICAgdGhpcy5fbGFzdEZpbGVVcmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDbG9zZVRleHREb2N1bWVudCh7XHJcbiAgICAgIHRleHREb2N1bWVudDoge3VyaTogbGFzdEZpbGVVcml9LFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVdhdGNoZWRGaWxlcyh7XHJcbiAgICAgIGNoYW5nZXM6IFtcclxuICAgICAgICB7dXJpOiBsYXN0RmlsZVVyaSwgdHlwZTogRmlsZUNoYW5nZVR5cGUuRGVsZXRlZH0sXHJcbiAgICAgICAge3VyaTogdGhpcy5nZXRFZGl0b3JVcmkoKSwgdHlwZTogRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZH0sXHJcbiAgICAgIF0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2xhc3RGaWxlVXJpID0gdGhpcy5nZXRFZGl0b3JVcmkoKTtcclxuXHJcbiAgICAvLyBzZW5kIGFuIGVxdWl2YWxlbnQgb3BlbiBldmVudCBmb3IgdGhpcyBlZGl0b3IsIHdoaWNoIHdpbGwgbm93IHVzZSB0aGUgbmV3XHJcbiAgICAvLyBmaWxlIHBhdGhcclxuICAgIHRoaXMuZGlkT3BlbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIGN1cnJlbnQge1RleHRFZGl0b3J9IHBhdGggYW5kIGNvbnZlcnQgaXQgdG8gYSBVcmkuXHJcbiAgZ2V0RWRpdG9yVXJpKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gQ29udmVydC5wYXRoVG9VcmkodGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==