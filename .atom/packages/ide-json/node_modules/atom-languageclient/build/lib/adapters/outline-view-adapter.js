Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
let OutlineViewAdapter = class OutlineViewAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  getOutline(connection, editor) {
    return _asyncToGenerator(function* () {
      const results = yield connection.documentSymbol({
        textDocument: _convert2.default.editorToTextDocumentIdentifier(editor)
      });
      return {
        outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
      };
    })();
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    const byContainerName = OutlineViewAdapter.createContainerNamedOutline(symbols);
    const roots = new Map();
    byContainerName.forEach((v, k) => {
      const containerName = v.containerName;
      if (containerName === '' || containerName == null || k === containerName) {
        // No container name or contained within itself belong as top-level items
        roots.set(k, v.outline);
      } else {
        const container = byContainerName.get(containerName);
        if (container) {
          // Items with a container we know about get put in that container
          container.outline.children.push(v.outline);
        } else {
          // Items with a container we don't know about we dynamically create one for
          let rootContainer = roots.get(containerName);
          if (rootContainer == null) {
            rootContainer = {
              plainText: containerName,
              children: [],
              startPosition: new _atom.Point(0, 0)
            };
            roots.set(containerName, rootContainer);
          }
          rootContainer.children.push(v.outline);
        }
      }
    });
    return Array.from(roots.values());
  }

  // Public: Converts an {Array} of {SymbolInformation} received from a language server into a
  // {Map} of {ContainerNamedOutline} keyed by their symbol names. This allows us to find parents
  // quickly when assembling the tree through containerNames.
  //
  // * `symbols` An {Array} of {SymbolInformation}s to convert into the map.
  //
  // Returns a {Map} of {ContainerNamedOutline}s each converted from a {SymbolInformation}
  // and keyed by its containerName.
  static createContainerNamedOutline(symbols) {
    return symbols.reduce((map, symbol) => {
      map.set(symbol.name, {
        containerName: symbol.containerName,
        outline: OutlineViewAdapter.symbolToOutline(symbol)
      });
      return map;
    }, new Map());
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
};
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRvY3VtZW50U3ltYm9sUHJvdmlkZXIiLCJnZXRPdXRsaW5lIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInJlc3VsdHMiLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsIm91dGxpbmVUcmVlcyIsImNyZWF0ZU91dGxpbmVUcmVlcyIsInN5bWJvbHMiLCJieUNvbnRhaW5lck5hbWUiLCJjcmVhdGVDb250YWluZXJOYW1lZE91dGxpbmUiLCJyb290cyIsIk1hcCIsImZvckVhY2giLCJ2IiwiayIsImNvbnRhaW5lck5hbWUiLCJzZXQiLCJvdXRsaW5lIiwiY29udGFpbmVyIiwiZ2V0IiwiY2hpbGRyZW4iLCJwdXNoIiwicm9vdENvbnRhaW5lciIsInBsYWluVGV4dCIsInN0YXJ0UG9zaXRpb24iLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJtYXAiLCJzeW1ib2wiLCJuYW1lIiwic3ltYm9sVG9PdXRsaW5lIiwiaWNvbiIsInN5bWJvbEtpbmRUb0VudGl0eUtpbmQiLCJraW5kIiwidG9rZW5pemVkVGV4dCIsInN5bWJvbEtpbmRUb1Rva2VuS2luZCIsInZhbHVlIiwidW5kZWZpbmVkIiwicmVwcmVzZW50YXRpdmVOYW1lIiwicG9zaXRpb25Ub1BvaW50IiwibG9jYXRpb24iLCJyYW5nZSIsInN0YXJ0IiwiZW5kUG9zaXRpb24iLCJlbmQiLCJCb29sZWFuIiwiQ2xhc3MiLCJDb25zdGFudCIsIkNvbnN0cnVjdG9yIiwiRW51bSIsIkZpZWxkIiwiRmlsZSIsIkZ1bmN0aW9uIiwiSW50ZXJmYWNlIiwiTWV0aG9kIiwiTW9kdWxlIiwiTmFtZXNwYWNlIiwiTnVtYmVyIiwiUGFja2Fn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QkFBV0MsTUFBaEI7QUFDRSxlQUFPLGFBQVA7QUFDRixXQUFLLDJCQUFXQyxTQUFoQjtBQUNFLGVBQU8sZ0JBQVA7QUFDRixXQUFLLDJCQUFXQyxNQUFoQjtBQUNFLGVBQU8sYUFBUDtBQUNGLFdBQUssMkJBQVdDLE9BQWhCO0FBQ0UsZUFBTyxjQUFQO0FBQ0YsV0FBSywyQkFBV0MsUUFBaEI7QUFDRSxlQUFPLGVBQVA7QUFDRixXQUFLLDJCQUFXQyxNQUFoQjtBQUNFLGVBQU8sYUFBUDtBQUNGLFdBQUssMkJBQVdDLFFBQWhCO0FBQ0UsZUFBTyxlQUFQO0FBQ0Y7QUFDRSxlQUFPLElBQVA7QUF0Q0o7QUF3Q0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBTzFCLHFCQUFQLENBQTZCUCxNQUE3QixFQUFnRTtBQUM5RCxZQUFRQSxNQUFSO0FBQ0UsV0FBSywyQkFBV2tCLEtBQWhCO0FBQ0UsZUFBTyxNQUFQO0FBQ0YsV0FBSywyQkFBV0UsV0FBaEI7QUFDRSxlQUFPLGFBQVA7QUFDRixXQUFLLDJCQUFXTSxNQUFoQjtBQUNBLFdBQUssMkJBQVdGLFFBQWhCO0FBQ0UsZUFBTyxRQUFQO0FBQ0YsV0FBSywyQkFBV1EsTUFBaEI7QUFDRSxlQUFPLFFBQVA7QUFDRjtBQUNFLGVBQU8sT0FBUDtBQVhKO0FBYUQ7QUFsTHFDLEM7a0JBQW5CcEUsa0IiLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIFN5bWJvbEtpbmQsIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzLCB0eXBlIFN5bWJvbEluZm9ybWF0aW9ufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICdhdG9tJztcclxuXHJcbnR5cGUgQ29udGFpbmVyTmFtZWRPdXRsaW5lID0ge1xyXG4gIGNvbnRhaW5lck5hbWU6ID9zdHJpbmcsXHJcbiAgb3V0bGluZTogYXRvbUlkZSRPdXRsaW5lVHJlZSxcclxufTtcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBkb2N1bWVudFN5bWJvbFByb3ZpZGVyIG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gdGhlIE91dGxpbmUgVmlld1xyXG4vLyBzdXBwbGllZCBieSBBdG9tIElERSBVSS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0bGluZVZpZXdBZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSBkb2N1bWVudFN5bWJvbFByb3ZpZGVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRTeW1ib2xQcm92aWRlciA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSBPdXRsaW5lIGZvciBkb2N1bWVudCB2aWEgdGhlIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IGFzIGlkZW50aWZpZWRcclxuICAvLyBieSB0aGUge1RleHRFZGl0b3J9LlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXHJcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBvdXRsaW5lLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIE91dGxpbmUgc2hvdWxkIHJlcHJlc2VudC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge091dGxpbmV9IG9mIHRoaXMgZG9jdW1lbnQuXHJcbiAgYXN5bmMgZ2V0T3V0bGluZShjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogUHJvbWlzZTw/YXRvbUlkZSRPdXRsaW5lPiB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudFN5bWJvbCh7XHJcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3V0bGluZVRyZWVzOiBPdXRsaW5lVmlld0FkYXB0ZXIuY3JlYXRlT3V0bGluZVRyZWVzKHJlc3VsdHMpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGFuIHtBcnJheX0gb2Yge091dGxpbmVUcmVlfXMgZnJvbSB0aGUgQXJyYXkgb2Yge1N5bWJvbEluZm9ybWF0aW9ufSByZWNpZXZlZFxyXG4gIC8vIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpbmNsdWRlcyBkZXRlcm1pbmluZyB0aGUgYXBwcm9wcmlhdGUgY2hpbGQgYW5kIHBhcmVudFxyXG4gIC8vIHJlbGF0aW9uc2hpcHMgZm9yIHRoZSBoaWVyYXJjaHkuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xzYCBBbiB7QXJyYXl9IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn1zIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0XHJcbiAgLy8gICAgICAgICAgICAgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiB7T3V0bGluZVRyZWV9LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiB7T3V0bGluZVRyZWV9IGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN5bWJvbHMgdGhhdCB0aGUgT3V0bGluZSBWaWV3IGNhbiBkaXNwbGF5LlxyXG4gIHN0YXRpYyBjcmVhdGVPdXRsaW5lVHJlZXMoc3ltYm9sczogQXJyYXk8U3ltYm9sSW5mb3JtYXRpb24+KTogQXJyYXk8YXRvbUlkZSRPdXRsaW5lVHJlZT4ge1xyXG4gICAgY29uc3QgYnlDb250YWluZXJOYW1lID0gT3V0bGluZVZpZXdBZGFwdGVyLmNyZWF0ZUNvbnRhaW5lck5hbWVkT3V0bGluZShzeW1ib2xzKTtcclxuICAgIGNvbnN0IHJvb3RzOiBNYXA8c3RyaW5nLCBhdG9tSWRlJE91dGxpbmVUcmVlPiA9IG5ldyBNYXAoKTtcclxuICAgIGJ5Q29udGFpbmVyTmFtZS5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lck5hbWUgPSB2LmNvbnRhaW5lck5hbWU7XHJcbiAgICAgIGlmIChjb250YWluZXJOYW1lID09PSAnJyB8fCBjb250YWluZXJOYW1lID09IG51bGwgfHwgayA9PT0gY29udGFpbmVyTmFtZSkge1xyXG4gICAgICAgIC8vIE5vIGNvbnRhaW5lciBuYW1lIG9yIGNvbnRhaW5lZCB3aXRoaW4gaXRzZWxmIGJlbG9uZyBhcyB0b3AtbGV2ZWwgaXRlbXNcclxuICAgICAgICByb290cy5zZXQoaywgdi5vdXRsaW5lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBieUNvbnRhaW5lck5hbWUuZ2V0KGNvbnRhaW5lck5hbWUpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIpIHtcclxuICAgICAgICAgIC8vIEl0ZW1zIHdpdGggYSBjb250YWluZXIgd2Uga25vdyBhYm91dCBnZXQgcHV0IGluIHRoYXQgY29udGFpbmVyXHJcbiAgICAgICAgICBjb250YWluZXIub3V0bGluZS5jaGlsZHJlbi5wdXNoKHYub3V0bGluZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vIEl0ZW1zIHdpdGggYSBjb250YWluZXIgd2UgZG9uJ3Qga25vdyBhYm91dCB3ZSBkeW5hbWljYWxseSBjcmVhdGUgb25lIGZvclxyXG4gICAgICAgICAgbGV0IHJvb3RDb250YWluZXIgPSByb290cy5nZXQoY29udGFpbmVyTmFtZSk7XHJcbiAgICAgICAgICBpZiAocm9vdENvbnRhaW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJvb3RDb250YWluZXIgPSB7XHJcbiAgICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uOiBuZXcgUG9pbnQoMCwgMCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJvb3RzLnNldChjb250YWluZXJOYW1lLCByb290Q29udGFpbmVyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJvb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaCh2Lm91dGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290cy52YWx1ZXMoKSk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnRzIGFuIHtBcnJheX0gb2Yge1N5bWJvbEluZm9ybWF0aW9ufSByZWNlaXZlZCBmcm9tIGEgbGFuZ3VhZ2Ugc2VydmVyIGludG8gYVxyXG4gIC8vIHtNYXB9IG9mIHtDb250YWluZXJOYW1lZE91dGxpbmV9IGtleWVkIGJ5IHRoZWlyIHN5bWJvbCBuYW1lcy4gVGhpcyBhbGxvd3MgdXMgdG8gZmluZCBwYXJlbnRzXHJcbiAgLy8gcXVpY2tseSB3aGVuIGFzc2VtYmxpbmcgdGhlIHRyZWUgdGhyb3VnaCBjb250YWluZXJOYW1lcy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbHNgIEFuIHtBcnJheX0gb2Yge1N5bWJvbEluZm9ybWF0aW9ufXMgdG8gY29udmVydCBpbnRvIHRoZSBtYXAuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge01hcH0gb2Yge0NvbnRhaW5lck5hbWVkT3V0bGluZX1zIGVhY2ggY29udmVydGVkIGZyb20gYSB7U3ltYm9sSW5mb3JtYXRpb259XHJcbiAgLy8gYW5kIGtleWVkIGJ5IGl0cyBjb250YWluZXJOYW1lLlxyXG4gIHN0YXRpYyBjcmVhdGVDb250YWluZXJOYW1lZE91dGxpbmUoc3ltYm9sczogQXJyYXk8U3ltYm9sSW5mb3JtYXRpb24+KTogTWFwPHN0cmluZywgQ29udGFpbmVyTmFtZWRPdXRsaW5lPiB7XHJcbiAgICByZXR1cm4gc3ltYm9scy5yZWR1Y2UoKG1hcCwgc3ltYm9sKSA9PiB7XHJcbiAgICAgIG1hcC5zZXQoc3ltYm9sLm5hbWUsIHtcclxuICAgICAgICBjb250YWluZXJOYW1lOiBzeW1ib2wuY29udGFpbmVyTmFtZSxcclxuICAgICAgICBvdXRsaW5lOiBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sVG9PdXRsaW5lKHN5bWJvbCksXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBpbmRpdmlkdWFsIHtTeW1ib2xJbmZvcm1hdGlvbn0gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gdG8gYW4ge091dGxpbmVUcmVlfSBmb3IgdXNlIGJ5IHRoZSBPdXRsaW5lIFZpZXcuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xgIFRoZSB7U3ltYm9sSW5mb3JtYXRpb259IHRvIGNvbnZlcnQgdG8gYW4ge091dGxpbmVUcmVlfS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgdGhlIHtPdXRsaW5lVHJlZX0gZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4ge1N5bWJvbEluZm9ybWF0aW9ufS5cclxuICBzdGF0aWMgc3ltYm9sVG9PdXRsaW5lKHN5bWJvbDogU3ltYm9sSW5mb3JtYXRpb24pOiBhdG9tSWRlJE91dGxpbmVUcmVlIHtcclxuICAgIGNvbnN0IGljb24gPSBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2wua2luZCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b2tlbml6ZWRUZXh0OiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAga2luZDogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2wua2luZCksXHJcbiAgICAgICAgICB2YWx1ZTogc3ltYm9sLm5hbWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgaWNvbjogaWNvbiAhPSBudWxsID8gaWNvbiA6IHVuZGVmaW5lZCxcclxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcclxuICAgICAgc3RhcnRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgZW5kUG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5lbmQpLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgc3ltYm9sIGtpbmQgaW50byBhbiBvdXRsaW5lIGVudGl0eSBraW5kIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAgLy8gdGhlIHN0eWxpbmcgc3VjaCBhcyB0aGUgYXBwcm9wcmlhdGUgaWNvbiBpbiB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBPdXRsaW5lVmlldyBlbnRpdHkga2luZC5cclxuICBzdGF0aWMgc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2w6IG51bWJlcik6ID9zdHJpbmcge1xyXG4gICAgc3dpdGNoIChzeW1ib2wpIHtcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkFycmF5OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1hcnJheSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Cb29sZWFuOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1ib29sZWFuJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNsYXNzOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jbGFzcyc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdGFudDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY29uc3RhbnQnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0cnVjdG9yJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkVudW06XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWVudW0nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmllbGQ6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpZWxkJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpbGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpbGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZ1bmN0aW9uJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkludGVyZmFjZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtaW50ZXJmYWNlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbWV0aG9kJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1vZHVsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbW9kdWxlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk5hbWVzcGFjZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbmFtZXNwYWNlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk51bWJlcjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbnVtYmVyJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlBhY2thZ2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXBhY2thZ2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUHJvcGVydHk6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXByb3BlcnR5JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtc3RyaW5nJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlZhcmlhYmxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS12YXJpYWJsZSc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCB0byB0aGUgYXBwcm9wcmlhdGUgdG9rZW4ga2luZCB1c2VkIHRvIHN5bnRheFxyXG4gIC8vIGhpZ2hsaWdodCB0aGUgc3ltYm9sIG5hbWUgaW4gdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgc3ludGF4IHRva2VuIGtpbmQuXHJcbiAgc3RhdGljIHN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2w6IG51bWJlcik6IGF0b21JZGUkVG9rZW5LaW5kIHtcclxuICAgIHN3aXRjaCAoc3ltYm9sKSB7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcclxuICAgICAgICByZXR1cm4gJ3R5cGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XHJcbiAgICAgICAgcmV0dXJuICdjb25zdHJ1Y3Rvcic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5NZXRob2Q6XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcclxuICAgICAgICByZXR1cm4gJ21ldGhvZCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5TdHJpbmc6XHJcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAncGxhaW4nO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=