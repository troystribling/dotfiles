Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _atom = require('atom');

var _vscodeJsonrpc = require('vscode-jsonrpc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
  constructor() {
    this._cancellationTokens = new WeakMap();
  }

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  async getOutline(connection, editor) {
    const results = await _utils2.default.doWithCancellationToken(connection, this._cancellationTokens, cancellationToken => connection.documentSymbol({ textDocument: _convert2.default.editorToTextDocumentIdentifier(editor) }, cancellationToken));
    results.sort((a, b) => a.location.range.start.line === b.location.range.start.line ? a.location.range.start.character - b.location.range.start.character : a.location.range.start.line - b.location.range.start.line);
    return {
      outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
    };
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    // Temporarily keep containerName through the conversion process
    const allItems = symbols.map(symbol => ({
      containerName: symbol.containerName,
      outline: OutlineViewAdapter.symbolToOutline(symbol)
    }));

    // Create a map of containers by name with all items that have that name
    const containers = allItems.reduce((map, item) => {
      const name = item.outline.representativeName;
      if (name != null) {
        const container = map.get(name);
        if (container == null) {
          map.set(name, [item.outline]);
        } else {
          container.push(item.outline);
        }
      }
      return map;
    }, new Map());

    const roots = [];

    // Put each item within its parent and extract out the roots
    for (const item of allItems) {
      const containerName = item.containerName;
      const child = item.outline;
      if (containerName == null || containerName === '') {
        roots.push(item.outline);
      } else {
        const possibleParents = containers.get(containerName);
        let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
        if (closestParent == null) {
          closestParent = {
            plainText: containerName,
            representativeName: containerName,
            startPosition: new _atom.Point(0, 0),
            children: [child]
          };
          roots.push(closestParent);
          if (possibleParents == null) {
            containers.set(containerName, [closestParent]);
          } else {
            possibleParents.push(closestParent);
          }
        } else {
          closestParent.children.push(child);
        }
      }
    }

    return roots;
  }

  static _getClosestParent(candidates, child) {
    if (candidates == null || candidates.length === 0) {
      return null;
    }

    let parent = null;
    for (const candidate of candidates) {
      if (candidate !== child && candidate.startPosition.isLessThanOrEqual(child.startPosition) && (candidate.endPosition == null || candidate.endPosition.isGreaterThanOrEqual(child.endPosition))) {
        if (parent == null || parent.startPosition.isLessThanOrEqual(candidate.startPosition) || parent.endPosition != null && parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)) {
          parent = candidate;
        }
      }
    }

    return parent;
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
}
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJfY2FuY2VsbGF0aW9uVG9rZW5zIiwiV2Vha01hcCIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiZG9jdW1lbnRTeW1ib2xQcm92aWRlciIsImdldE91dGxpbmUiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicmVzdWx0cyIsImRvV2l0aENhbmNlbGxhdGlvblRva2VuIiwiY2FuY2VsbGF0aW9uVG9rZW4iLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInNvcnQiLCJhIiwiYiIsImxvY2F0aW9uIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJvdXRsaW5lVHJlZXMiLCJjcmVhdGVPdXRsaW5lVHJlZXMiLCJzeW1ib2xzIiwiYWxsSXRlbXMiLCJtYXAiLCJzeW1ib2wiLCJjb250YWluZXJOYW1lIiwib3V0bGluZSIsInN5bWJvbFRvT3V0bGluZSIsImNvbnRhaW5lcnMiLCJyZWR1Y2UiLCJpdGVtIiwibmFtZSIsInJlcHJlc2VudGF0aXZlTmFtZSIsImNvbnRhaW5lciIsImdldCIsInNldCIsInB1c2giLCJNYXAiLCJyb290cyIsImNoaWxkIiwicG9zc2libGVQYXJlbnRzIiwiY2xvc2VzdFBhcmVudCIsIl9nZXRDbG9zZXN0UGFyZW50IiwicGxhaW5UZXh0Iiwic3RhcnRQb3NpdGlvbiIsImNoaWxkcmVuIiwiY2FuZGlkYXRlcyIsImxlbmd0aCIsInBhcmVudCIsImNhbmRpZGF0ZSIsImlzTGVzc1RoYW5PckVxdWFsIiwiZW5kUG9zaXRpb24iLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbCIsImljb24iLCJzeW1ib2xLaW5kVG9FbnRpdHlLaW5kIiwia2luZCIsInRva2VuaXplZFRleHQiLCJzeW1ib2xLaW5kVG9Ub2tlbktpbmQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInBvc2l0aW9uVG9Qb2ludCIsImVuZCIsIkFycmF5IiwiQm9vbGVhbiIsIkNsYXNzIiwiQ29uc3RhbnQiLCJDb25zdHJ1Y3RvciIsIkVudW0iLCJGaWVsZCIsIkZpbGUiLCJGdW5jdGlvbiIsIkludGVyZmFjZSIsIk1ldGhvZCIsIk1vZHVsZSIsIk5hbWVzcGFjZSIsIk51bWJlciIsIlBhY2thZ2UiLCJQcm9wZXJ0eSIsIlN0cmluZyIsIlZhcmlhYmxlIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNlLE1BQU1BLGtCQUFOLENBQXlCO0FBQUE7QUFBQSxTQUV0Q0MsbUJBRnNDLEdBRTRDLElBQUlDLE9BQUosRUFGNUM7QUFBQTs7QUFJdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxzQkFBbkIsS0FBOEMsSUFBckQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsVUFBTixDQUFpQkMsVUFBakIsRUFBdURDLE1BQXZELEVBQTJHO0FBQ3pHLFVBQU1DLFVBQVUsTUFBTSxnQkFBTUMsdUJBQU4sQ0FBOEJILFVBQTlCLEVBQTBDLEtBQUtOLG1CQUEvQyxFQUFvRVUscUJBQ3hGSixXQUFXSyxjQUFYLENBQTBCLEVBQUNDLGNBQWMsa0JBQVFDLDhCQUFSLENBQXVDTixNQUF2QyxDQUFmLEVBQTFCLEVBQTBGRyxpQkFBMUYsQ0FEb0IsQ0FBdEI7QUFHQUYsWUFBUU0sSUFBUixDQUNFLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUNHRCxFQUFFRSxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCQyxJQUF2QixLQUFnQ0osRUFBRUMsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFBdkQsR0FD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QzlELFlBQVFBLE1BQVI7QUFDRSxXQUFLLDJCQUFXd0MsS0FBaEI7QUFDRSxlQUFPLE1BQVA7QUFDRixXQUFLLDJCQUFXRSxXQUFoQjtBQUNFLGVBQU8sYUFBUDtBQUNGLFdBQUssMkJBQVdNLE1BQWhCO0FBQ0EsV0FBSywyQkFBV0YsUUFBaEI7QUFDRSxlQUFPLFFBQVA7QUFDRixXQUFLLDJCQUFXUSxNQUFoQjtBQUNFLGVBQU8sUUFBUDtBQUNGO0FBQ0UsZUFBTyxPQUFQO0FBWEo7QUFhRDtBQXpOcUM7a0JBQW5CbEYsa0IiLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIFN5bWJvbEtpbmQsIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzLCB0eXBlIFN5bWJvbEluZm9ybWF0aW9ufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICdhdG9tJztcclxuaW1wb3J0IHtDYW5jZWxsYXRpb25Ub2tlblNvdXJjZX0gZnJvbSAndnNjb2RlLWpzb25ycGMnO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGRvY3VtZW50U3ltYm9sUHJvdmlkZXIgb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byB0aGUgT3V0bGluZSBWaWV3XHJcbi8vIHN1cHBsaWVkIGJ5IEF0b20gSURFIFVJLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRsaW5lVmlld0FkYXB0ZXIge1xyXG5cclxuICBfY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+ID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZG9jdW1lbnRTeW1ib2xQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50U3ltYm9sUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IE9idGFpbiB0aGUgT3V0bGluZSBmb3IgZG9jdW1lbnQgdmlhIHRoZSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSBhcyBpZGVudGlmaWVkXHJcbiAgLy8gYnkgdGhlIHtUZXh0RWRpdG9yfS5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZFxyXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgb3V0bGluZS5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGNvbnRhaW5pbmcgdGhlIHtPdXRsaW5lfSBvZiB0aGlzIGRvY3VtZW50LlxyXG4gIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P2F0b21JZGUkT3V0bGluZT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFV0aWxzLmRvV2l0aENhbmNlbGxhdGlvblRva2VuKGNvbm5lY3Rpb24sIHRoaXMuX2NhbmNlbGxhdGlvblRva2VucywgY2FuY2VsbGF0aW9uVG9rZW4gPT5cclxuICAgICAgY29ubmVjdGlvbi5kb2N1bWVudFN5bWJvbCh7dGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpfSwgY2FuY2VsbGF0aW9uVG9rZW4pLFxyXG4gICAgKTtcclxuICAgIHJlc3VsdHMuc29ydChcclxuICAgICAgKGEsIGIpID0+XHJcbiAgICAgICAgKGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZSA9PT0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lXHJcbiAgICAgICAgICA/IGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXJcclxuICAgICAgICAgIDogYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvdXRsaW5lVHJlZXM6IE91dGxpbmVWaWV3QWRhcHRlci5jcmVhdGVPdXRsaW5lVHJlZXMocmVzdWx0cyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9cyBmcm9tIHRoZSBBcnJheSBvZiB7U3ltYm9sSW5mb3JtYXRpb259IHJlY2lldmVkXHJcbiAgLy8gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGluY2x1ZGVzIGRldGVybWluaW5nIHRoZSBhcHByb3ByaWF0ZSBjaGlsZCBhbmQgcGFyZW50XHJcbiAgLy8gcmVsYXRpb25zaGlwcyBmb3IgdGhlIGhpZXJhcmNoeS5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbHNgIEFuIHtBcnJheX0gb2Yge1N5bWJvbEluZm9ybWF0aW9ufXMgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXRcclxuICAvLyAgICAgICAgICAgICBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIHtPdXRsaW5lVHJlZX0uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtPdXRsaW5lVHJlZX0gY29udGFpbmluZyB0aGUgZ2l2ZW4gc3ltYm9scyB0aGF0IHRoZSBPdXRsaW5lIFZpZXcgY2FuIGRpc3BsYXkuXHJcbiAgc3RhdGljIGNyZWF0ZU91dGxpbmVUcmVlcyhzeW1ib2xzOiBBcnJheTxTeW1ib2xJbmZvcm1hdGlvbj4pOiBBcnJheTxhdG9tSWRlJE91dGxpbmVUcmVlPiB7XHJcbiAgICAvLyBUZW1wb3JhcmlseSBrZWVwIGNvbnRhaW5lck5hbWUgdGhyb3VnaCB0aGUgY29udmVyc2lvbiBwcm9jZXNzXHJcbiAgICBjb25zdCBhbGxJdGVtcyA9IHN5bWJvbHMubWFwKHN5bWJvbCA9PiAoe1xyXG4gICAgICBjb250YWluZXJOYW1lOiBzeW1ib2wuY29udGFpbmVyTmFtZSxcclxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxyXG4gICAgY29uc3QgY29udGFpbmVycyA9IGFsbEl0ZW1zLnJlZHVjZSgobWFwLCBpdGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLm91dGxpbmUucmVwcmVzZW50YXRpdmVOYW1lO1xyXG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250YWluZXIucHVzaChpdGVtLm91dGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuXHJcbiAgICBjb25zdCByb290czogQXJyYXk8YXRvbUlkZSRPdXRsaW5lVHJlZT4gPSBbXTtcclxuXHJcbiAgICAvLyBQdXQgZWFjaCBpdGVtIHdpdGhpbiBpdHMgcGFyZW50IGFuZCBleHRyYWN0IG91dCB0aGUgcm9vdHNcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhbGxJdGVtcykge1xyXG4gICAgICBjb25zdCBjb250YWluZXJOYW1lID0gaXRlbS5jb250YWluZXJOYW1lO1xyXG4gICAgICBjb25zdCBjaGlsZCA9IGl0ZW0ub3V0bGluZTtcclxuICAgICAgaWYgKGNvbnRhaW5lck5hbWUgPT0gbnVsbCB8fCBjb250YWluZXJOYW1lID09PSAnJykge1xyXG4gICAgICAgIHJvb3RzLnB1c2goaXRlbS5vdXRsaW5lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBwb3NzaWJsZVBhcmVudHMgPSBjb250YWluZXJzLmdldChjb250YWluZXJOYW1lKTtcclxuICAgICAgICBsZXQgY2xvc2VzdFBhcmVudCA9IE91dGxpbmVWaWV3QWRhcHRlci5fZ2V0Q2xvc2VzdFBhcmVudChwb3NzaWJsZVBhcmVudHMsIGNoaWxkKTtcclxuICAgICAgICBpZiAoY2xvc2VzdFBhcmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICBjbG9zZXN0UGFyZW50ID0ge1xyXG4gICAgICAgICAgICBwbGFpblRleHQ6IGNvbnRhaW5lck5hbWUsXHJcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aXZlTmFtZTogY29udGFpbmVyTmFtZSxcclxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogbmV3IFBvaW50KDAsIDApLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogW2NoaWxkXSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICByb290cy5wdXNoKGNsb3Nlc3RQYXJlbnQpO1xyXG4gICAgICAgICAgaWYgKHBvc3NpYmxlUGFyZW50cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lcnMuc2V0KGNvbnRhaW5lck5hbWUsIFtjbG9zZXN0UGFyZW50XSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NzaWJsZVBhcmVudHMucHVzaChjbG9zZXN0UGFyZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2xvc2VzdFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdHM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2dldENsb3Nlc3RQYXJlbnQoY2FuZGlkYXRlczogP0FycmF5PGF0b21JZGUkT3V0bGluZVRyZWU+LCBjaGlsZDogYXRvbUlkZSRPdXRsaW5lVHJlZSk6ID9hdG9tSWRlJE91dGxpbmVUcmVlIHtcclxuICAgIGlmIChjYW5kaWRhdGVzID09IG51bGwgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBhcmVudCA9IG51bGw7XHJcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBjYW5kaWRhdGUgIT09IGNoaWxkICYmXHJcbiAgICAgICAgY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2hpbGQuc3RhcnRQb3NpdGlvbikgJiZcclxuICAgICAgICAoY2FuZGlkYXRlLmVuZFBvc2l0aW9uID09IG51bGwgfHwgY2FuZGlkYXRlLmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNoaWxkLmVuZFBvc2l0aW9uKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcGFyZW50ID09IG51bGwgfHxcclxuICAgICAgICAgIChwYXJlbnQuc3RhcnRQb3NpdGlvbi5pc0xlc3NUaGFuT3JFcXVhbChjYW5kaWRhdGUuc3RhcnRQb3NpdGlvbikgfHxcclxuICAgICAgICAgICAgKHBhcmVudC5lbmRQb3NpdGlvbiAhPSBudWxsICYmIHBhcmVudC5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjYW5kaWRhdGUuZW5kUG9zaXRpb24pKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHBhcmVudCA9IGNhbmRpZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIGluZGl2aWR1YWwge1N5bWJvbEluZm9ybWF0aW9ufSBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyB0byBhbiB7T3V0bGluZVRyZWV9IGZvciB1c2UgYnkgdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIHtTeW1ib2xJbmZvcm1hdGlvbn0gdG8gY29udmVydCB0byBhbiB7T3V0bGluZVRyZWV9LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUge091dGxpbmVUcmVlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7U3ltYm9sSW5mb3JtYXRpb259LlxyXG4gIHN0YXRpYyBzeW1ib2xUb091dGxpbmUoc3ltYm9sOiBTeW1ib2xJbmZvcm1hdGlvbik6IGF0b21JZGUkT3V0bGluZVRyZWUge1xyXG4gICAgY29uc3QgaWNvbiA9IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbC5raW5kKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRva2VuaXplZFRleHQ6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBraW5kOiBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbC5raW5kKSxcclxuICAgICAgICAgIHZhbHVlOiBzeW1ib2wubmFtZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBpY29uOiBpY29uICE9IG51bGwgPyBpY29uIDogdW5kZWZpbmVkLFxyXG4gICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IHN5bWJvbC5uYW1lLFxyXG4gICAgICBzdGFydFBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChzeW1ib2wubG9jYXRpb24ucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICBlbmRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLmVuZCksXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCBpbnRvIGFuIG91dGxpbmUgZW50aXR5IGtpbmQgdXNlZCB0byBkZXRlcm1pbmVcclxuICAvLyB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xgIFRoZSBudW1lcmljIHN5bWJvbCBraW5kIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcXVpdmFsZW50IE91dGxpbmVWaWV3IGVudGl0eSBraW5kLlxyXG4gIHN0YXRpYyBzeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbDogbnVtYmVyKTogP3N0cmluZyB7XHJcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQXJyYXk6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWFycmF5JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkJvb2xlYW46XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWJvb2xlYW4nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNsYXNzJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0YW50OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdGFudCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY29uc3RydWN0b3InO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRW51bTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZW51bSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GaWVsZDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZmllbGQnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmlsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZmlsZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZnVuY3Rpb24nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuSW50ZXJmYWNlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1pbnRlcmZhY2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1tZXRob2QnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTW9kdWxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1tb2R1bGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTmFtZXNwYWNlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1uYW1lc3BhY2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTnVtYmVyOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1udW1iZXInO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUGFja2FnZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtcGFja2FnZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Qcm9wZXJ0eTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtcHJvcGVydHknO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1zdHJpbmcnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuVmFyaWFibGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXZhcmlhYmxlJztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIHRvIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBraW5kIHVzZWQgdG8gc3ludGF4XHJcbiAgLy8gaGlnaGxpZ2h0IHRoZSBzeW1ib2wgbmFtZSBpbiB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBzeW50YXggdG9rZW4ga2luZC5cclxuICBzdGF0aWMgc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbDogbnVtYmVyKTogYXRvbUlkZSRUb2tlbktpbmQge1xyXG4gICAgc3dpdGNoIChzeW1ib2wpIHtcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNsYXNzOlxyXG4gICAgICAgIHJldHVybiAndHlwZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcclxuICAgICAgICByZXR1cm4gJ2NvbnN0cnVjdG9yJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxyXG4gICAgICAgIHJldHVybiAnbWV0aG9kJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdwbGFpbic7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==