Object.defineProperty(exports, "__esModule", {
  value: true
});

var _child_process = require('child_process');

var cp = _interopRequireWildcard(_child_process);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _vscodeJsonrpc = require('vscode-jsonrpc');

var rpc = _interopRequireWildcard(_vscodeJsonrpc);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _atom = require('atom');

var _logger = require('./logger');

var _serverManager = require('./server-manager.js');

var _convert = require('./convert.js');

var _convert2 = _interopRequireDefault(_convert);

var _applyEditAdapter = require('./adapters/apply-edit-adapter');

var _applyEditAdapter2 = _interopRequireDefault(_applyEditAdapter);

var _autocompleteAdapter = require('./adapters/autocomplete-adapter');

var _autocompleteAdapter2 = _interopRequireDefault(_autocompleteAdapter);

var _codeActionAdapter = require('./adapters/code-action-adapter');

var _codeActionAdapter2 = _interopRequireDefault(_codeActionAdapter);

var _codeFormatAdapter = require('./adapters/code-format-adapter');

var _codeFormatAdapter2 = _interopRequireDefault(_codeFormatAdapter);

var _codeHighlightAdapter = require('./adapters/code-highlight-adapter');

var _codeHighlightAdapter2 = _interopRequireDefault(_codeHighlightAdapter);

var _datatipAdapter = require('./adapters/datatip-adapter');

var _datatipAdapter2 = _interopRequireDefault(_datatipAdapter);

var _definitionAdapter = require('./adapters/definition-adapter');

var _definitionAdapter2 = _interopRequireDefault(_definitionAdapter);

var _documentSyncAdapter = require('./adapters/document-sync-adapter');

var _documentSyncAdapter2 = _interopRequireDefault(_documentSyncAdapter);

var _findReferencesAdapter = require('./adapters/find-references-adapter');

var _findReferencesAdapter2 = _interopRequireDefault(_findReferencesAdapter);

var _linterPushV2Adapter = require('./adapters/linter-push-v2-adapter');

var _linterPushV2Adapter2 = _interopRequireDefault(_linterPushV2Adapter);

var _notificationsAdapter = require('./adapters/notifications-adapter');

var _notificationsAdapter2 = _interopRequireDefault(_notificationsAdapter);

var _outlineViewAdapter = require('./adapters/outline-view-adapter');

var _outlineViewAdapter2 = _interopRequireDefault(_outlineViewAdapter);

var _signatureHelpAdapter = require('./adapters/signature-help-adapter');

var _signatureHelpAdapter2 = _interopRequireDefault(_signatureHelpAdapter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Public: AutoLanguageClient provides a simple way to have all the supported
// Atom-IDE services wired up entirely for you by just subclassing it and
// implementing startServerProcess/getGrammarScopes/getLanguageName and
// getServerName.
class AutoLanguageClient {
  constructor() {
    this._disposable = new _atom.CompositeDisposable();
    this.processStdErr = '';
  }

  // Available if consumeBusySignal is setup


  // Shared adapters that can take the RPC connection as required


  // You must implement these so we know how to deal with your language and server
  // -------------------------------------------------------------------------

  // Return an array of the grammar scopes you handle, e.g. [ 'source.js' ]
  getGrammarScopes() {
    throw Error('Must implement getGrammarScopes when extending AutoLanguageClient');
  }

  // Return the name of the language you support, e.g. 'JavaScript'
  getLanguageName() {
    throw Error('Must implement getLanguageName when extending AutoLanguageClient');
  }

  // Return the name of your server, e.g. 'Eclipse JDT'
  getServerName() {
    throw Error('Must implement getServerName when extending AutoLanguageClient');
  }

  // Start your server process
  startServerProcess(projectPath) {
    throw Error('Must override startServerProcess to start language server process when extending AutoLanguageClient');
  }

  // You might want to override these for different behavior
  // ---------------------------------------------------------------------------

  // Determine whether we should start a server for a given editor if we don't have one yet
  shouldStartForEditor(editor) {
    return this.getGrammarScopes().includes(editor.getGrammar().scopeName);
  }

  // Return the parameters used to initialize a client - you may want to extend capabilities
  getInitializeParams(projectPath, process) {
    return {
      processId: process.pid,
      rootPath: projectPath,
      rootUri: _convert2.default.pathToUri(projectPath),
      capabilities: {
        workspace: {
          applyEdit: true,
          workspaceEdit: {
            documentChanges: true
          },
          didChangeConfiguration: {
            dynamicRegistration: false
          },
          didChangeWatchedFiles: {
            dynamicRegistration: false
          },
          symbol: {
            dynamicRegistration: false
          },
          executeCommand: {
            dynamicRegistration: false
          }
        },
        textDocument: {
          synchronization: {
            dynamicRegistration: false,
            willSave: true,
            willSaveWaitUntil: false,
            didSave: true
          },
          completion: {
            dynamicRegistration: false,
            completionItem: {
              snippetSupport: true,
              commitCharactersSupport: false
            },
            contextSupport: true
          },
          hover: {
            dynamicRegistration: false
          },
          signatureHelp: {
            dynamicRegistration: false
          },
          references: {
            dynamicRegistration: false
          },
          documentHighlight: {
            dynamicRegistration: false
          },
          documentSymbol: {
            dynamicRegistration: false
          },
          formatting: {
            dynamicRegistration: false
          },
          rangeFormatting: {
            dynamicRegistration: false
          },
          onTypeFormatting: {
            dynamicRegistration: false
          },
          definition: {
            dynamicRegistration: false
          },
          codeAction: {
            dynamicRegistration: false
          },
          codeLens: {
            dynamicRegistration: false
          },
          documentLink: {
            dynamicRegistration: false
          },
          rename: {
            dynamicRegistration: false
          }
        },
        experimental: {}
      }
    };
  }

  // Early wire-up of listeners before initialize method is sent
  preInitialization(connection) {}

  // Late wire-up of listeners after initialize method has been sent
  postInitialization(server) {}

  // Determine whether to use ipc, stdio or socket to connect to the server
  getConnectionType() {
    return this.socket != null ? 'socket' : 'stdio';
  }

  // Return the name of your root configuration key
  getRootConfigurationKey() {
    return '';
  }

  // Optionally transform the configuration object before it is sent to the server
  mapConfigurationObject(configuration) {
    return configuration;
  }

  // Helper methods that are useful for implementors
  // ---------------------------------------------------------------------------

  // Gets a LanguageClientConnection for a given TextEditor
  async getConnectionForEditor(editor) {
    const server = await this._serverManager.getServer(editor);
    return server ? server.connection : null;
  }

  // Restart all active language servers for this language client in the workspace
  async restartAllServers() {
    await this._serverManager.restartAllServers();
  }

  // Default implementation of the rest of the AutoLanguageClient
  // ---------------------------------------------------------------------------

  // Activate does very little for perf reasons - hooks in via ServerManager for later 'activation'
  activate() {
    this.name = `${this.getLanguageName()} (${this.getServerName()})`;
    this.logger = this.getLogger();
    this._serverManager = new _serverManager.ServerManager(p => this.startServer(p), this.logger, e => this.shouldStartForEditor(e), filepath => this.filterChangeWatchedFiles(filepath), () => this.busySignalService, this.getServerName());
    this._serverManager.startListening();
    process.on('exit', () => this.exitCleanup.bind(this));
  }

  exitCleanup() {
    this._serverManager.terminate();
  }

  // Deactivate disposes the resources we're using
  async deactivate() {
    this._isDeactivating = true;
    this._disposable.dispose();
    this._serverManager.stopListening();
    await this._serverManager.stopAllServers();
  }

  spawnChildNode(args, options = {}) {
    this.logger.debug(`starting child Node "${args.join(' ')}"`);
    options.env = options.env || Object.create(process.env);
    options.env.ELECTRON_RUN_AS_NODE = '1';
    options.env.ELECTRON_NO_ATTACH_CONSOLE = '1';
    return cp.spawn(process.execPath, args, options);
  }

  // By default LSP logging is switched off but you can switch it on via the core.debugLSP setting
  getLogger() {
    return atom.config.get('core.debugLSP') ? new _logger.ConsoleLogger(this.name) : new _logger.NullLogger();
  }

  // Starts the server by starting the process, then initializing the language server and starting adapters
  async startServer(projectPath) {
    const startingSignal = this.busySignalService && this.busySignalService.reportBusy(`Starting ${this.getServerName()} for ${_path2.default.basename(projectPath)}`);
    let process;
    try {
      process = await this.startServerProcess(projectPath);
    } finally {
      startingSignal && startingSignal.dispose();
    }
    this.captureServerErrors(process, projectPath);
    const connection = new ls.LanguageClientConnection(this.createRpcConnection(process), this.logger);
    this.preInitialization(connection);
    const initializeParams = this.getInitializeParams(projectPath, process);
    const initialization = connection.initialize(initializeParams);
    this.busySignalService && this.busySignalService.reportBusyWhile(`${this.getServerName()} initializing for ${_path2.default.basename(projectPath)}`, () => initialization);
    const initializeResponse = await initialization;
    const newServer = {
      projectPath,
      process,
      connection,
      capabilities: initializeResponse.capabilities,
      disposable: new _atom.CompositeDisposable()
    };
    this.postInitialization(newServer);
    connection.initialized();
    connection.on('close', () => {
      if (!this.isDeactivating) {
        this._serverManager.stopServer(newServer);
        if (!this._serverManager.hasServerReachedRestartLimit(newServer)) {
          this.logger.debug(`Restarting language server for project '${newServer.projectPath}'`);
          this._serverManager.startServer(projectPath);
        } else {
          this.logger.warn(`Language server has exceeded auto-restart limit for project '${newServer.projectPath}'`);
          atom.notifications.addError(`The ${this.name} language server has exited and exceeded the restart limit for project '${newServer.projectPath}'`);
        }
      }
    });

    const configurationKey = this.getRootConfigurationKey();
    if (configurationKey) {
      this._disposable.add(atom.config.observe(configurationKey, config => {
        const mappedConfig = this.mapConfigurationObject(config || {});
        if (mappedConfig) {
          connection.didChangeConfiguration({
            settings: mappedConfig
          });
        }
      }));
    }

    this.startExclusiveAdapters(newServer);
    return newServer;
  }

  captureServerErrors(childProcess, projectPath) {
    childProcess.on('error', err => this.handleSpawnFailure(err));
    childProcess.on('exit', (code, signal) => this.logger.debug(`exit: code ${code} signal ${signal}`));
    childProcess.stderr.setEncoding('utf8');
    childProcess.stderr.on('data', chunk => {
      const errorString = chunk.toString();
      this.handleServerStderr(errorString, projectPath);
      // Keep the last 5 lines for packages to use in messages
      this.processStdErr = (this.processStdErr + errorString).split('\n').slice(-5).join('\n');
    });
  }

  handleSpawnFailure(err) {
    atom.notifications.addError(`${this.getServerName()} language server for ${this.getLanguageName()} unable to start`, {
      dismissable: true,
      description: err.toString()
    });
  }

  // Creates the RPC connection which can be ipc, socket or stdio
  createRpcConnection(process) {
    let reader, writer;
    const connectionType = this.getConnectionType();
    switch (connectionType) {
      case 'ipc':
        reader = new rpc.IPCMessageReader(process);
        writer = new rpc.IPCMessageWriter(process);
        break;
      case 'socket':
        reader = new rpc.SocketMessageReader(this.socket);
        writer = new rpc.SocketMessageWriter(this.socket);
        break;
      case 'stdio':
        reader = new rpc.StreamMessageReader(process.stdout);
        writer = new rpc.StreamMessageWriter(process.stdin);
        break;
    }

    return rpc.createMessageConnection(reader, writer, {
      error: m => {
        this.logger.error(m);
      }
    });
  }

  // Start adapters that are not shared between servers
  startExclusiveAdapters(server) {
    _applyEditAdapter2.default.attach(server.connection);
    _notificationsAdapter2.default.attach(server.connection, this.name);

    if (_documentSyncAdapter2.default.canAdapt(server.capabilities)) {
      server.docSyncAdapter = new _documentSyncAdapter2.default(server.connection, server.capabilities.textDocumentSync, editor => this.shouldSyncForEditor(editor, server.projectPath));
      server.disposable.add(server.docSyncAdapter);
    }

    server.linterPushV2 = new _linterPushV2Adapter2.default(server.connection);
    if (this._linterDelegate != null) {
      server.linterPushV2.attach(this._linterDelegate);
    }
    server.disposable.add(server.linterPushV2);

    if (_signatureHelpAdapter2.default.canAdapt(server.capabilities)) {
      server.signatureHelpAdapter = new _signatureHelpAdapter2.default(server, this.getGrammarScopes());
      if (this._signatureHelpRegistry != null) {
        server.signatureHelpAdapter.attach(this._signatureHelpRegistry);
      }
      server.disposable.add(server.signatureHelpAdapter);
    }
  }

  shouldSyncForEditor(editor, projectPath) {
    return this.isFileInProject(editor, projectPath) && this.shouldStartForEditor(editor);
  }

  isFileInProject(editor, projectPath) {
    return (editor.getURI() || '').startsWith(projectPath);
  }

  // Autocomplete+ via LS completion---------------------------------------
  provideAutocomplete() {
    return {
      selector: this.getGrammarScopes().map(g => '.' + g).join(', '),
      inclusionPriority: 1,
      suggestionPriority: 2,
      excludeLowerPriority: false,
      getSuggestions: this.getSuggestions.bind(this),
      onDidInsertSuggestion: this.onDidInsertSuggestion.bind(this),
      getSuggestionDetailsOnSelect: this.getSuggestionDetailsOnSelect.bind(this)
    };
  }

  async getSuggestions(request) {
    const server = await this._serverManager.getServer(request.editor);
    if (server == null || !_autocompleteAdapter2.default.canAdapt(server.capabilities)) {
      return [];
    }

    this.autoComplete = this.autoComplete || new _autocompleteAdapter2.default();
    this._lastAutocompleteRequest = request;
    return this.autoComplete.getSuggestions(server, request, this.onDidConvertAutocomplete);
  }

  async getSuggestionDetailsOnSelect(suggestion) {
    const request = this._lastAutocompleteRequest;
    if (request == null) {
      return null;
    }
    const server = await this._serverManager.getServer(request.editor);
    if (server == null || !_autocompleteAdapter2.default.canResolve(server.capabilities) || this.autoComplete == null) {
      return null;
    }

    return this.autoComplete.completeSuggestion(server, suggestion, request, this.onDidConvertAutocomplete);
  }

  onDidConvertAutocomplete(completionItem, suggestion, request) {}

  onDidInsertSuggestion(arg) {}

  // Definitions via LS documentHighlight and gotoDefinition------------
  provideDefinitions() {
    return {
      name: this.name,
      priority: 20,
      grammarScopes: this.getGrammarScopes(),
      getDefinition: this.getDefinition.bind(this)
    };
  }

  async getDefinition(editor, point) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_definitionAdapter2.default.canAdapt(server.capabilities)) {
      return null;
    }

    this.definitions = this.definitions || new _definitionAdapter2.default();
    return this.definitions.getDefinition(server.connection, server.capabilities, this.getLanguageName(), editor, point);
  }

  // Outline View via LS documentSymbol---------------------------------
  provideOutlines() {
    return {
      name: this.name,
      grammarScopes: this.getGrammarScopes(),
      priority: 1,
      getOutline: this.getOutline.bind(this)
    };
  }

  async getOutline(editor) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_outlineViewAdapter2.default.canAdapt(server.capabilities)) {
      return null;
    }

    this.outlineView = this.outlineView || new _outlineViewAdapter2.default();
    return this.outlineView.getOutline(server.connection, editor);
  }

  // Linter push v2 API via LS publishDiagnostics
  consumeLinterV2(registerIndie) {
    this._linterDelegate = registerIndie({ name: this.name });
    if (this._linterDelegate == null) {
      return;
    }

    for (const server of this._serverManager.getActiveServers()) {
      if (server.linterPushV2 != null) {
        server.linterPushV2.attach(this._linterDelegate);
      }
    }
  }

  // Find References via LS findReferences------------------------------
  provideFindReferences() {
    return {
      isEditorSupported: editor => this.getGrammarScopes().includes(editor.getGrammar().scopeName),
      findReferences: this.getReferences.bind(this)
    };
  }

  async getReferences(editor, point) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_findReferencesAdapter2.default.canAdapt(server.capabilities)) {
      return null;
    }

    this.findReferences = this.findReferences || new _findReferencesAdapter2.default();
    return this.findReferences.getReferences(server.connection, editor, point, server.projectPath);
  }

  // Datatip via LS textDocument/hover----------------------------------
  consumeDatatip(service) {
    this._disposable.add(service.addProvider({
      providerName: this.name,
      priority: 1,
      grammarScopes: this.getGrammarScopes(),
      validForScope: scopeName => {
        return this.getGrammarScopes().includes(scopeName);
      },
      datatip: this.getDatatip.bind(this)
    }));
  }

  async getDatatip(editor, point) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_datatipAdapter2.default.canAdapt(server.capabilities)) {
      return null;
    }

    this.datatip = this.datatip || new _datatipAdapter2.default();
    return this.datatip.getDatatip(server.connection, editor, point);
  }

  // Code Format via LS formatDocument & formatDocumentRange------------
  provideCodeFormat() {
    return {
      grammarScopes: this.getGrammarScopes(),
      priority: 1,
      formatCode: this.getCodeFormat.bind(this)
    };
  }

  async getCodeFormat(editor, range) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_codeFormatAdapter2.default.canAdapt(server.capabilities)) {
      return [];
    }

    return _codeFormatAdapter2.default.format(server.connection, server.capabilities, editor, range);
  }

  provideCodeHighlight() {
    return {
      grammarScopes: this.getGrammarScopes(),
      priority: 1,
      highlight: (editor, position) => {
        return this.getCodeHighlight(editor, position);
      }
    };
  }

  async getCodeHighlight(editor, position) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_codeHighlightAdapter2.default.canAdapt(server.capabilities)) {
      return null;
    }

    return _codeHighlightAdapter2.default.highlight(server.connection, server.capabilities, editor, position);
  }

  provideCodeActions() {
    return {
      grammarScopes: this.getGrammarScopes(),
      priority: 1,
      getCodeActions: (editor, range, diagnostics) => {
        return this.getCodeActions(editor, range, diagnostics);
      }
    };
  }

  async getCodeActions(editor, range, diagnostics) {
    const server = await this._serverManager.getServer(editor);
    if (server == null || !_codeActionAdapter2.default.canAdapt(server.capabilities)) {
      return null;
    }

    return _codeActionAdapter2.default.getCodeActions(server.connection, server.capabilities, server.linterPushV2, editor, range, diagnostics);
  }

  consumeSignatureHelp(registry) {
    this._signatureHelpRegistry = registry;
    for (const server of this._serverManager.getActiveServers()) {
      if (server.signatureHelpAdapter != null) {
        server.signatureHelpAdapter.attach(registry);
      }
    }
    return new _atom.Disposable(() => {
      this._signatureHelpRegistry = null;
    });
  }

  consumeBusySignal(service) {
    this.busySignalService = service;
    return new _atom.Disposable(() => delete this.busySignalService);
  }

  /**
   * `didChangeWatchedFiles` message filtering, override for custom logic.
   * @param filePath path of a file that has changed in the project path
   * @return false => message will not be sent to the language server
   */
  filterChangeWatchedFiles(filePath) {
    return true;
  }

  /**
   * Called on language server stderr output.
   * @param stderr a chunk of stderr from a language server instance
   */
  handleServerStderr(stderr, projectPath) {
    stderr.split('\n').filter(l => l).forEach(line => this.logger.warn(`stderr ${line}`));
  }
}
exports.default = AutoLanguageClient;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9hdXRvLWxhbmd1YWdlY2xpZW50LmpzIl0sIm5hbWVzIjpbImNwIiwibHMiLCJycGMiLCJBdXRvTGFuZ3VhZ2VDbGllbnQiLCJfZGlzcG9zYWJsZSIsInByb2Nlc3NTdGRFcnIiLCJnZXRHcmFtbWFyU2NvcGVzIiwiRXJyb3IiLCJnZXRMYW5ndWFnZU5hbWUiLCJnZXRTZXJ2ZXJOYW1lIiwic3RhcnRTZXJ2ZXJQcm9jZXNzIiwicHJvamVjdFBhdGgiLCJzaG91bGRTdGFydEZvckVkaXRvciIsImVkaXRvciIsImluY2x1ZGVzIiwiZ2V0R3JhbW1hciIsInNjb3BlTmFtZSIsImdldEluaXRpYWxpemVQYXJhbXMiLCJwcm9jZXNzIiwicHJvY2Vzc0lkIiwicGlkIiwicm9vdFBhdGgiLCJyb290VXJpIiwicGF0aFRvVXJpIiwiY2FwYWJpbGl0aWVzIiwid29ya3NwYWNlIiwiYXBwbHlFZGl0Iiwid29ya3NwYWNlRWRpdCIsImRvY3VtZW50Q2hhbmdlcyIsImRpZENoYW5nZUNvbmZpZ3VyYXRpb24iLCJkeW5hbWljUmVnaXN0cmF0aW9uIiwiZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzIiwic3ltYm9sIiwiZXhlY3V0ZUNvbW1hbmQiLCJ0ZXh0RG9jdW1lbnQiLCJzeW5jaHJvbml6YXRpb24iLCJ3aWxsU2F2ZSIsIndpbGxTYXZlV2FpdFVudGlsIiwiZGlkU2F2ZSIsImNvbXBsZXRpb24iLCJjb21wbGV0aW9uSXRlbSIsInNuaXBwZXRTdXBwb3J0IiwiY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQiLCJjb250ZXh0U3VwcG9ydCIsImhvdmVyIiwic2lnbmF0dXJlSGVscCIsInJlZmVyZW5jZXMiLCJkb2N1bWVudEhpZ2hsaWdodCIsImRvY3VtZW50U3ltYm9sIiwiZm9ybWF0dGluZyIsInJhbmdlRm9ybWF0dGluZyIsIm9uVHlwZUZvcm1hdHRpbmciLCJkZWZpbml0aW9uIiwiY29kZUFjdGlvbiIsImNvZGVMZW5zIiwiZG9jdW1lbnRMaW5rIiwicmVuYW1lIiwiZXhwZXJpbWVudGFsIiwicHJlSW5pdGlhbGl6YXRpb24iLCJjb25uZWN0aW9uIiwicG9zdEluaXRpYWxpemF0aW9uIiwic2VydmVyIiwiZ2V0Q29ubmVjdGlvblR5cGUiLCJzb2NrZXQiLCJnZXRSb290Q29uZmlndXJhdGlvbktleSIsIm1hcENvbmZpZ3VyYXRpb25PYmplY3QiLCJjb25maWd1cmF0aW9uIiwiZ2V0Q29ubmVjdGlvbkZvckVkaXRvciIsIl9zZXJ2ZXJNYW5hZ2VyIiwiZ2V0U2VydmVyIiwicmVzdGFydEFsbFNlcnZlcnMiLCJhY3RpdmF0ZSIsIm5hbWUiLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJwIiwic3RhcnRTZXJ2ZXIiLCJlIiwiZmlsZXBhdGgiLCJmaWx0ZXJDaGFuZ2VXYXRjaGVkRmlsZXMiLCJidXN5U2lnbmFsU2VydmljZSIsInN0YXJ0TGlzdGVuaW5nIiwib24iLCJleGl0Q2xlYW51cCIsImJpbmQiLCJ0ZXJtaW5hdGUiLCJkZWFjdGl2YXRlIiwiX2lzRGVhY3RpdmF0aW5nIiwiZGlzcG9zZSIsInN0b3BMaXN0ZW5pbmciLCJzdG9wQWxsU2VydmVycyIsInNwYXduQ2hpbGROb2RlIiwiYXJncyIsIm9wdGlvbnMiLCJkZWJ1ZyIsImpvaW4iLCJlbnYiLCJPYmplY3QiLCJjcmVhdGUiLCJFTEVDVFJPTl9SVU5fQVNfTk9ERSIsIkVMRUNUUk9OX05PX0FUVEFDSF9DT05TT0xFIiwic3Bhd24iLCJleGVjUGF0aCIsImF0b20iLCJjb25maWciLCJnZXQiLCJzdGFydGluZ1NpZ25hbCIsInJlcG9ydEJ1c3kiLCJiYXNlbmFtZSIsImNhcHR1cmVTZXJ2ZXJFcnJvcnMiLCJMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24iLCJjcmVhdGVScGNDb25uZWN0aW9uIiwiaW5pdGlhbGl6ZVBhcmFtcyIsImluaXRpYWxpemF0aW9uIiwiaW5pdGlhbGl6ZSIsInJlcG9ydEJ1c3lXaGlsZSIsImluaXRpYWxpemVSZXNwb25zZSIsIm5ld1NlcnZlciIsImRpc3Bvc2FibGUiLCJpbml0aWFsaXplZCIsImlzRGVhY3RpdmF0aW5nIiwic3RvcFNlcnZlciIsImhhc1NlcnZlclJlYWNoZWRSZXN0YXJ0TGltaXQiLCJ3YXJuIiwibm90aWZpY2F0aW9ucyIsImFkZEVycm9yIiwiY29uZmlndXJhdGlvbktleSIsImFkZCIsIm9ic2VydmUiLCJtYXBwZWRDb25maWciLCJzZXR0aW5ncyIsInN0YXJ0RXhjbHVzaXZlQWRhcHRlcnMiLCJjaGlsZFByb2Nlc3MiLCJlcnIiLCJoYW5kbGVTcGF3bkZhaWx1cmUiLCJjb2RlIiwic2lnbmFsIiwic3RkZXJyIiwic2V0RW5jb2RpbmciLCJjaHVuayIsImVycm9yU3RyaW5nIiwidG9TdHJpbmciLCJoYW5kbGVTZXJ2ZXJTdGRlcnIiLCJzcGxpdCIsInNsaWNlIiwiZGlzbWlzc2FibGUiLCJkZXNjcmlwdGlvbiIsInJlYWRlciIsIndyaXRlciIsImNvbm5lY3Rpb25UeXBlIiwiSVBDTWVzc2FnZVJlYWRlciIsIklQQ01lc3NhZ2VXcml0ZXIiLCJTb2NrZXRNZXNzYWdlUmVhZGVyIiwiU29ja2V0TWVzc2FnZVdyaXRlciIsIlN0cmVhbU1lc3NhZ2VSZWFkZXIiLCJzdGRvdXQiLCJTdHJlYW1NZXNzYWdlV3JpdGVyIiwic3RkaW4iLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsImVycm9yIiwibSIsImF0dGFjaCIsImNhbkFkYXB0IiwiZG9jU3luY0FkYXB0ZXIiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwic2hvdWxkU3luY0ZvckVkaXRvciIsImxpbnRlclB1c2hWMiIsIl9saW50ZXJEZWxlZ2F0ZSIsInNpZ25hdHVyZUhlbHBBZGFwdGVyIiwiX3NpZ25hdHVyZUhlbHBSZWdpc3RyeSIsImlzRmlsZUluUHJvamVjdCIsImdldFVSSSIsInN0YXJ0c1dpdGgiLCJwcm92aWRlQXV0b2NvbXBsZXRlIiwic2VsZWN0b3IiLCJtYXAiLCJnIiwiaW5jbHVzaW9uUHJpb3JpdHkiLCJzdWdnZXN0aW9uUHJpb3JpdHkiLCJleGNsdWRlTG93ZXJQcmlvcml0eSIsImdldFN1Z2dlc3Rpb25zIiwib25EaWRJbnNlcnRTdWdnZXN0aW9uIiwiZ2V0U3VnZ2VzdGlvbkRldGFpbHNPblNlbGVjdCIsInJlcXVlc3QiLCJhdXRvQ29tcGxldGUiLCJfbGFzdEF1dG9jb21wbGV0ZVJlcXVlc3QiLCJvbkRpZENvbnZlcnRBdXRvY29tcGxldGUiLCJzdWdnZXN0aW9uIiwiY2FuUmVzb2x2ZSIsImNvbXBsZXRlU3VnZ2VzdGlvbiIsImFyZyIsInByb3ZpZGVEZWZpbml0aW9ucyIsInByaW9yaXR5IiwiZ3JhbW1hclNjb3BlcyIsImdldERlZmluaXRpb24iLCJwb2ludCIsImRlZmluaXRpb25zIiwicHJvdmlkZU91dGxpbmVzIiwiZ2V0T3V0bGluZSIsIm91dGxpbmVWaWV3IiwiY29uc3VtZUxpbnRlclYyIiwicmVnaXN0ZXJJbmRpZSIsImdldEFjdGl2ZVNlcnZlcnMiLCJwcm92aWRlRmluZFJlZmVyZW5jZXMiLCJpc0VkaXRvclN1cHBvcnRlZCIsImZpbmRSZWZlcmVuY2VzIiwiZ2V0UmVmZXJlbmNlcyIsImNvbnN1bWVEYXRhdGlwIiwic2VydmljZSIsImFkZFByb3ZpZGVyIiwicHJvdmlkZXJOYW1lIiwidmFsaWRGb3JTY29wZSIsImRhdGF0aXAiLCJnZXREYXRhdGlwIiwicHJvdmlkZUNvZGVGb3JtYXQiLCJmb3JtYXRDb2RlIiwiZ2V0Q29kZUZvcm1hdCIsInJhbmdlIiwiZm9ybWF0IiwicHJvdmlkZUNvZGVIaWdobGlnaHQiLCJoaWdobGlnaHQiLCJwb3NpdGlvbiIsImdldENvZGVIaWdobGlnaHQiLCJwcm92aWRlQ29kZUFjdGlvbnMiLCJnZXRDb2RlQWN0aW9ucyIsImRpYWdub3N0aWNzIiwiY29uc3VtZVNpZ25hdHVyZUhlbHAiLCJyZWdpc3RyeSIsImNvbnN1bWVCdXN5U2lnbmFsIiwiZmlsZVBhdGgiLCJmaWx0ZXIiLCJsIiwiZm9yRWFjaCIsImxpbmUiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7SUFBWUEsRTs7QUFDWjs7SUFBWUMsRTs7QUFDWjs7SUFBWUMsRzs7QUFDWjs7OztBQUNBOztB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b0JBQWtCcEIsT0FBbEIsRUFBbUU7QUFDakUsU0FBS2hJLGlCQUFMLEdBQXlCZ0ksT0FBekI7QUFDQSxXQUFPLHFCQUFlLE1BQU0sT0FBTyxLQUFLaEksaUJBQWpDLENBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQUQsMkJBQXlCc0osUUFBekIsRUFBb0Q7QUFDbEQsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQXZGLHFCQUFtQkwsTUFBbkIsRUFBbUM5SCxXQUFuQyxFQUF3RDtBQUN0RDhILFdBQU9NLEtBQVAsQ0FBYSxJQUFiLEVBQW1CdUYsTUFBbkIsQ0FBMEJDLEtBQUtBLENBQS9CLEVBQWtDQyxPQUFsQyxDQUEwQ0MsUUFBUSxLQUFLaEssTUFBTCxDQUFZa0QsSUFBWixDQUFrQixVQUFTOEcsSUFBSyxFQUFoQyxDQUFsRDtBQUNEO0FBbG1CcUM7a0JBQW5CdE8sa0IiLCJmaWxlIjoiYXV0by1sYW5ndWFnZWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQgKiBhcyBjcCBmcm9tICdjaGlsZF9wcm9jZXNzJztcclxuaW1wb3J0ICogYXMgbHMgZnJvbSAnLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCAqIGFzIHJwYyBmcm9tICd2c2NvZGUtanNvbnJwYyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQge0NvbXBvc2l0ZURpc3Bvc2FibGUsIERpc3Bvc2FibGV9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQge0NvbnNvbGVMb2dnZXIsIE51bGxMb2dnZXIsIHR5cGUgTG9nZ2VyfSBmcm9tICcuL2xvZ2dlcic7XHJcbmltcG9ydCB7U2VydmVyTWFuYWdlciwgdHlwZSBBY3RpdmVTZXJ2ZXJ9IGZyb20gJy4vc2VydmVyLW1hbmFnZXIuanMnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuL2NvbnZlcnQuanMnO1xyXG5cclxuaW1wb3J0IEFwcGx5RWRpdEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9hcHBseS1lZGl0LWFkYXB0ZXInO1xyXG5pbXBvcnQgQXV0b2NvbXBsZXRlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2F1dG9jb21wbGV0ZS1hZGFwdGVyJztcclxuaW1wb3J0IENvZGVBY3Rpb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvY29kZS1hY3Rpb24tYWRhcHRlcic7XHJcbmltcG9ydCBDb2RlRm9ybWF0QWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2NvZGUtZm9ybWF0LWFkYXB0ZXInO1xyXG5pbXBvcnQgQ29kZUhpZ2hsaWdodEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9jb2RlLWhpZ2hsaWdodC1hZGFwdGVyJztcclxuaW1wb3J0IERhdGF0aXBBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvZGF0YXRpcC1hZGFwdGVyJztcclxuaW1wb3J0IERlZmluaXRpb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvZGVmaW5pdGlvbi1hZGFwdGVyJztcclxuaW1wb3J0IERvY3VtZW50U3luY0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXInO1xyXG5pbXBvcnQgRmluZFJlZmVyZW5jZXNBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXInO1xyXG5pbXBvcnQgTGludGVyUHVzaFYyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2xpbnRlci1wdXNoLXYyLWFkYXB0ZXInO1xyXG5pbXBvcnQgTm90aWZpY2F0aW9uc0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9ub3RpZmljYXRpb25zLWFkYXB0ZXInO1xyXG5pbXBvcnQgT3V0bGluZVZpZXdBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvb3V0bGluZS12aWV3LWFkYXB0ZXInO1xyXG5pbXBvcnQgU2lnbmF0dXJlSGVscEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9zaWduYXR1cmUtaGVscC1hZGFwdGVyJztcclxuXHJcbnR5cGUgQ29ubmVjdGlvblR5cGUgPSAnc3RkaW8nIHwgJ3NvY2tldCcgfCAnaXBjJztcclxuXHJcbi8vIFB1YmxpYzogQXV0b0xhbmd1YWdlQ2xpZW50IHByb3ZpZGVzIGEgc2ltcGxlIHdheSB0byBoYXZlIGFsbCB0aGUgc3VwcG9ydGVkXHJcbi8vIEF0b20tSURFIHNlcnZpY2VzIHdpcmVkIHVwIGVudGlyZWx5IGZvciB5b3UgYnkganVzdCBzdWJjbGFzc2luZyBpdCBhbmRcclxuLy8gaW1wbGVtZW50aW5nIHN0YXJ0U2VydmVyUHJvY2Vzcy9nZXRHcmFtbWFyU2NvcGVzL2dldExhbmd1YWdlTmFtZSBhbmRcclxuLy8gZ2V0U2VydmVyTmFtZS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b0xhbmd1YWdlQ2xpZW50IHtcclxuICBfZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgX3NlcnZlck1hbmFnZXI6IFNlcnZlck1hbmFnZXI7XHJcbiAgX2xpbnRlckRlbGVnYXRlOiBsaW50ZXIkVjJJbmRpZURlbGVnYXRlO1xyXG4gIF9zaWduYXR1cmVIZWxwUmVnaXN0cnk6ID9hdG9tSWRlJFNpZ25hdHVyZUhlbHBSZWdpc3RyeTtcclxuICBfbGFzdEF1dG9jb21wbGV0ZVJlcXVlc3Q6ID9hdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3Q7XHJcbiAgX2lzRGVhY3RpdmF0aW5nOiBib29sZWFuO1xyXG5cclxuICAvLyBBdmFpbGFibGUgaWYgY29uc3VtZUJ1c3lTaWduYWwgaXMgc2V0dXBcclxuICBidXN5U2lnbmFsU2VydmljZTogP2F0b21JZGUkQnVzeVNpZ25hbFNlcnZpY2U7XHJcblxyXG4gIHByb2Nlc3NTdGRFcnI6IHN0cmluZyA9ICcnO1xyXG4gIGxvZ2dlcjogTG9nZ2VyO1xyXG4gIG5hbWU6IHN0cmluZztcclxuICBzb2NrZXQ6IG5ldCRTb2NrZXQ7XHJcblxyXG4gIC8vIFNoYXJlZCBhZGFwdGVycyB0aGF0IGNhbiB0YWtlIHRoZSBSUEMgY29ubmVjdGlvbiBhcyByZXF1aXJlZFxyXG4gIGF1dG9Db21wbGV0ZTogP0F1dG9jb21wbGV0ZUFkYXB0ZXI7XHJcbiAgZGF0YXRpcDogP0RhdGF0aXBBZGFwdGVyO1xyXG4gIGRlZmluaXRpb25zOiA/RGVmaW5pdGlvbkFkYXB0ZXI7XHJcbiAgZmluZFJlZmVyZW5jZXM6ID9GaW5kUmVmZXJlbmNlc0FkYXB0ZXI7XHJcbiAgb3V0bGluZVZpZXc6ID9PdXRsaW5lVmlld0FkYXB0ZXI7XHJcblxyXG4gIC8vIFlvdSBtdXN0IGltcGxlbWVudCB0aGVzZSBzbyB3ZSBrbm93IGhvdyB0byBkZWFsIHdpdGggeW91ciBsYW5ndWFnZSBhbmQgc2VydmVyXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIGdyYW1tYXIgc2NvcGVzIHlvdSBoYW5kbGUsIGUuZy4gWyAnc291cmNlLmpzJyBdXHJcbiAgZ2V0R3JhbW1hclNjb3BlcygpOiBBcnJheTxzdHJpbmc+IHtcclxuICAgIHRocm93IEVycm9yKCdNdXN0IGltcGxlbWVudCBnZXRHcmFtbWFyU2NvcGVzIHdoZW4gZXh0ZW5kaW5nIEF1dG9MYW5ndWFnZUNsaWVudCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB5b3Ugc3VwcG9ydCwgZS5nLiAnSmF2YVNjcmlwdCdcclxuICBnZXRMYW5ndWFnZU5hbWUoKTogc3RyaW5nIHtcclxuICAgIHRocm93IEVycm9yKCdNdXN0IGltcGxlbWVudCBnZXRMYW5ndWFnZU5hbWUgd2hlbiBleHRlbmRpbmcgQXV0b0xhbmd1YWdlQ2xpZW50Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIG5hbWUgb2YgeW91ciBzZXJ2ZXIsIGUuZy4gJ0VjbGlwc2UgSkRUJ1xyXG4gIGdldFNlcnZlck5hbWUoKTogc3RyaW5nIHtcclxuICAgIHRocm93IEVycm9yKCdNdXN0IGltcGxlbWVudCBnZXRTZXJ2ZXJOYW1lIHdoZW4gZXh0ZW5kaW5nIEF1dG9MYW5ndWFnZUNsaWVudCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RhcnQgeW91ciBzZXJ2ZXIgcHJvY2Vzc1xyXG4gIHN0YXJ0U2VydmVyUHJvY2Vzcyhwcm9qZWN0UGF0aDogc3RyaW5nKTogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MgfCBQcm9taXNlPGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzPiB7XHJcbiAgICB0aHJvdyBFcnJvcignTXVzdCBvdmVycmlkZSBzdGFydFNlcnZlclByb2Nlc3MgdG8gc3RhcnQgbGFuZ3VhZ2Ugc2VydmVyIHByb2Nlc3Mgd2hlbiBleHRlbmRpbmcgQXV0b0xhbmd1YWdlQ2xpZW50Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBZb3UgbWlnaHQgd2FudCB0byBvdmVycmlkZSB0aGVzZSBmb3IgZGlmZmVyZW50IGJlaGF2aW9yXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIERldGVybWluZSB3aGV0aGVyIHdlIHNob3VsZCBzdGFydCBhIHNlcnZlciBmb3IgYSBnaXZlbiBlZGl0b3IgaWYgd2UgZG9uJ3QgaGF2ZSBvbmUgeWV0XHJcbiAgc2hvdWxkU3RhcnRGb3JFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmdldEdyYW1tYXJTY29wZXMoKS5pbmNsdWRlcyhlZGl0b3IuZ2V0R3JhbW1hcigpLnNjb3BlTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbml0aWFsaXplIGEgY2xpZW50IC0geW91IG1heSB3YW50IHRvIGV4dGVuZCBjYXBhYmlsaXRpZXNcclxuICBnZXRJbml0aWFsaXplUGFyYW1zKHByb2plY3RQYXRoOiBzdHJpbmcsIHByb2Nlc3M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzKTogbHMuSW5pdGlhbGl6ZVBhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm9jZXNzSWQ6IHByb2Nlc3MucGlkLFxyXG4gICAgICByb290UGF0aDogcHJvamVjdFBhdGgsXHJcbiAgICAgIHJvb3RVcmk6IENvbnZlcnQucGF0aFRvVXJpKHByb2plY3RQYXRoKSxcclxuICAgICAgY2FwYWJpbGl0aWVzOiB7XHJcbiAgICAgICAgd29ya3NwYWNlOiB7XHJcbiAgICAgICAgICBhcHBseUVkaXQ6IHRydWUsXHJcbiAgICAgICAgICB3b3Jrc3BhY2VFZGl0OiB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50Q2hhbmdlczogdHJ1ZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkaWRDaGFuZ2VDb25maWd1cmF0aW9uOiB7XHJcbiAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRpZENoYW5nZVdhdGNoZWRGaWxlczoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzeW1ib2w6IHtcclxuICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXhlY3V0ZUNvbW1hbmQ6IHtcclxuICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGV4dERvY3VtZW50OiB7XHJcbiAgICAgICAgICBzeW5jaHJvbml6YXRpb246IHtcclxuICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHdpbGxTYXZlOiB0cnVlLFxyXG4gICAgICAgICAgICB3aWxsU2F2ZVdhaXRVbnRpbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGRpZFNhdmU6IHRydWUsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY29tcGxldGlvbjoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcclxuICAgICAgICAgICAgICBzbmlwcGV0U3VwcG9ydDogdHJ1ZSxcclxuICAgICAgICAgICAgICBjb21taXRDaGFyYWN0ZXJzU3VwcG9ydDogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRleHRTdXBwb3J0OiB0cnVlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGhvdmVyOiB7XHJcbiAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHNpZ25hdHVyZUhlbHA6IHtcclxuICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcmVmZXJlbmNlczoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkb2N1bWVudEhpZ2hsaWdodDoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkb2N1bWVudFN5bWJvbDoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBmb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHJhbmdlRm9ybWF0dGluZzoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBvblR5cGVGb3JtYXR0aW5nOiB7XHJcbiAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRlZmluaXRpb246IHtcclxuICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY29kZUFjdGlvbjoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjb2RlTGVuczoge1xyXG4gICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkb2N1bWVudExpbms6IHtcclxuICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgcmVuYW1lOiB7XHJcbiAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGV4cGVyaW1lbnRhbDoge30sXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gRWFybHkgd2lyZS11cCBvZiBsaXN0ZW5lcnMgYmVmb3JlIGluaXRpYWxpemUgbWV0aG9kIGlzIHNlbnRcclxuICBwcmVJbml0aWFsaXphdGlvbihjb25uZWN0aW9uOiBscy5MYW5ndWFnZUNsaWVudENvbm5lY3Rpb24pOiB2b2lkIHt9XHJcblxyXG4gIC8vIExhdGUgd2lyZS11cCBvZiBsaXN0ZW5lcnMgYWZ0ZXIgaW5pdGlhbGl6ZSBtZXRob2QgaGFzIGJlZW4gc2VudFxyXG4gIHBvc3RJbml0aWFsaXphdGlvbihzZXJ2ZXI6IEFjdGl2ZVNlcnZlcik6IHZvaWQge31cclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIGlwYywgc3RkaW8gb3Igc29ja2V0IHRvIGNvbm5lY3QgdG8gdGhlIHNlcnZlclxyXG4gIGdldENvbm5lY3Rpb25UeXBlKCk6IENvbm5lY3Rpb25UeXBlIHtcclxuICAgIHJldHVybiB0aGlzLnNvY2tldCAhPSBudWxsID8gJ3NvY2tldCcgOiAnc3RkaW8nO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHlvdXIgcm9vdCBjb25maWd1cmF0aW9uIGtleVxyXG4gIGdldFJvb3RDb25maWd1cmF0aW9uS2V5KCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICAvLyBPcHRpb25hbGx5IHRyYW5zZm9ybSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgYmVmb3JlIGl0IGlzIHNlbnQgdG8gdGhlIHNlcnZlclxyXG4gIG1hcENvbmZpZ3VyYXRpb25PYmplY3QoY29uZmlndXJhdGlvbjogYW55KTogYW55IHtcclxuICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIG1ldGhvZHMgdGhhdCBhcmUgdXNlZnVsIGZvciBpbXBsZW1lbnRvcnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gR2V0cyBhIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiBmb3IgYSBnaXZlbiBUZXh0RWRpdG9yXHJcbiAgYXN5bmMgZ2V0Q29ubmVjdGlvbkZvckVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P2xzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbj4ge1xyXG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcclxuICAgIHJldHVybiBzZXJ2ZXIgPyBzZXJ2ZXIuY29ubmVjdGlvbiA6IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBSZXN0YXJ0IGFsbCBhY3RpdmUgbGFuZ3VhZ2Ugc2VydmVycyBmb3IgdGhpcyBsYW5ndWFnZSBjbGllbnQgaW4gdGhlIHdvcmtzcGFjZVxyXG4gIGFzeW5jIHJlc3RhcnRBbGxTZXJ2ZXJzKCkge1xyXG4gICAgYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5yZXN0YXJ0QWxsU2VydmVycygpO1xyXG4gIH1cclxuXHJcbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcmVzdCBvZiB0aGUgQXV0b0xhbmd1YWdlQ2xpZW50XHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEFjdGl2YXRlIGRvZXMgdmVyeSBsaXR0bGUgZm9yIHBlcmYgcmVhc29ucyAtIGhvb2tzIGluIHZpYSBTZXJ2ZXJNYW5hZ2VyIGZvciBsYXRlciAnYWN0aXZhdGlvbidcclxuICBhY3RpdmF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMubmFtZSA9IGAke3RoaXMuZ2V0TGFuZ3VhZ2VOYW1lKCl9ICgke3RoaXMuZ2V0U2VydmVyTmFtZSgpfSlgO1xyXG4gICAgdGhpcy5sb2dnZXIgPSB0aGlzLmdldExvZ2dlcigpO1xyXG4gICAgdGhpcy5fc2VydmVyTWFuYWdlciA9IG5ldyBTZXJ2ZXJNYW5hZ2VyKFxyXG4gICAgICBwID0+IHRoaXMuc3RhcnRTZXJ2ZXIocCksXHJcbiAgICAgIHRoaXMubG9nZ2VyLFxyXG4gICAgICBlID0+IHRoaXMuc2hvdWxkU3RhcnRGb3JFZGl0b3IoZSksXHJcbiAgICAgIGZpbGVwYXRoID0+IHRoaXMuZmlsdGVyQ2hhbmdlV2F0Y2hlZEZpbGVzKGZpbGVwYXRoKSxcclxuICAgICAgKCkgPT4gdGhpcy5idXN5U2lnbmFsU2VydmljZSxcclxuICAgICAgdGhpcy5nZXRTZXJ2ZXJOYW1lKCksXHJcbiAgICApO1xyXG4gICAgdGhpcy5fc2VydmVyTWFuYWdlci5zdGFydExpc3RlbmluZygpO1xyXG4gICAgcHJvY2Vzcy5vbignZXhpdCcsICgpID0+IHRoaXMuZXhpdENsZWFudXAuYmluZCh0aGlzKSk7XHJcbiAgfVxyXG5cclxuICBleGl0Q2xlYW51cCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3NlcnZlck1hbmFnZXIudGVybWluYXRlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBEZWFjdGl2YXRlIGRpc3Bvc2VzIHRoZSByZXNvdXJjZXMgd2UncmUgdXNpbmdcclxuICBhc3luYyBkZWFjdGl2YXRlKCk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0aGlzLl9pc0RlYWN0aXZhdGluZyA9IHRydWU7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgIHRoaXMuX3NlcnZlck1hbmFnZXIuc3RvcExpc3RlbmluZygpO1xyXG4gICAgYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5zdG9wQWxsU2VydmVycygpO1xyXG4gIH1cclxuXHJcbiAgc3Bhd25DaGlsZE5vZGUoYXJnczogQXJyYXk8c3RyaW5nPiwgb3B0aW9ucz86IGNoaWxkX3Byb2Nlc3Mkc3Bhd25PcHRzID0ge30pOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2VzcyB7XHJcbiAgICB0aGlzLmxvZ2dlci5kZWJ1Zyhgc3RhcnRpbmcgY2hpbGQgTm9kZSBcIiR7YXJncy5qb2luKCcgJyl9XCJgKTtcclxuICAgIG9wdGlvbnMuZW52ID0gb3B0aW9ucy5lbnYgfHwgT2JqZWN0LmNyZWF0ZShwcm9jZXNzLmVudik7XHJcbiAgICBvcHRpb25zLmVudi5FTEVDVFJPTl9SVU5fQVNfTk9ERSA9ICcxJztcclxuICAgIG9wdGlvbnMuZW52LkVMRUNUUk9OX05PX0FUVEFDSF9DT05TT0xFID0gJzEnO1xyXG4gICAgcmV0dXJuIGNwLnNwYXduKHByb2Nlc3MuZXhlY1BhdGgsIGFyZ3MsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLy8gQnkgZGVmYXVsdCBMU1AgbG9nZ2luZyBpcyBzd2l0Y2hlZCBvZmYgYnV0IHlvdSBjYW4gc3dpdGNoIGl0IG9uIHZpYSB0aGUgY29yZS5kZWJ1Z0xTUCBzZXR0aW5nXHJcbiAgZ2V0TG9nZ2VyKCk6IExvZ2dlciB7XHJcbiAgICByZXR1cm4gYXRvbS5jb25maWcuZ2V0KCdjb3JlLmRlYnVnTFNQJykgPyBuZXcgQ29uc29sZUxvZ2dlcih0aGlzLm5hbWUpIDogbmV3IE51bGxMb2dnZXIoKTtcclxuICB9XHJcblxyXG4gIC8vIFN0YXJ0cyB0aGUgc2VydmVyIGJ5IHN0YXJ0aW5nIHRoZSBwcm9jZXNzLCB0aGVuIGluaXRpYWxpemluZyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGFuZCBzdGFydGluZyBhZGFwdGVyc1xyXG4gIGFzeW5jIHN0YXJ0U2VydmVyKHByb2plY3RQYXRoOiBzdHJpbmcpOiBQcm9taXNlPEFjdGl2ZVNlcnZlcj4ge1xyXG4gICAgY29uc3Qgc3RhcnRpbmdTaWduYWwgPSB0aGlzLmJ1c3lTaWduYWxTZXJ2aWNlICYmIHRoaXMuYnVzeVNpZ25hbFNlcnZpY2UucmVwb3J0QnVzeShcclxuICAgICAgYFN0YXJ0aW5nICR7dGhpcy5nZXRTZXJ2ZXJOYW1lKCl9IGZvciAke3BhdGguYmFzZW5hbWUocHJvamVjdFBhdGgpfWAsXHJcbiAgICApO1xyXG4gICAgbGV0IHByb2Nlc3M7XHJcbiAgICB0cnkge1xyXG4gICAgICBwcm9jZXNzID0gYXdhaXQgdGhpcy5zdGFydFNlcnZlclByb2Nlc3MocHJvamVjdFBhdGgpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc3RhcnRpbmdTaWduYWwgJiYgc3RhcnRpbmdTaWduYWwuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jYXB0dXJlU2VydmVyRXJyb3JzKHByb2Nlc3MsIHByb2plY3RQYXRoKTtcclxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgbHMuTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uKHRoaXMuY3JlYXRlUnBjQ29ubmVjdGlvbihwcm9jZXNzKSwgdGhpcy5sb2dnZXIpO1xyXG4gICAgdGhpcy5wcmVJbml0aWFsaXphdGlvbihjb25uZWN0aW9uKTtcclxuICAgIGNvbnN0IGluaXRpYWxpemVQYXJhbXMgPSB0aGlzLmdldEluaXRpYWxpemVQYXJhbXMocHJvamVjdFBhdGgsIHByb2Nlc3MpO1xyXG4gICAgY29uc3QgaW5pdGlhbGl6YXRpb24gPSBjb25uZWN0aW9uLmluaXRpYWxpemUoaW5pdGlhbGl6ZVBhcmFtcyk7XHJcbiAgICB0aGlzLmJ1c3lTaWduYWxTZXJ2aWNlICYmIHRoaXMuYnVzeVNpZ25hbFNlcnZpY2UucmVwb3J0QnVzeVdoaWxlKFxyXG4gICAgICBgJHt0aGlzLmdldFNlcnZlck5hbWUoKX0gaW5pdGlhbGl6aW5nIGZvciAke3BhdGguYmFzZW5hbWUocHJvamVjdFBhdGgpfWAsXHJcbiAgICAgICgpID0+IGluaXRpYWxpemF0aW9uLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGluaXRpYWxpemVSZXNwb25zZSA9IGF3YWl0IGluaXRpYWxpemF0aW9uO1xyXG4gICAgY29uc3QgbmV3U2VydmVyID0ge1xyXG4gICAgICBwcm9qZWN0UGF0aCxcclxuICAgICAgcHJvY2VzcyxcclxuICAgICAgY29ubmVjdGlvbixcclxuICAgICAgY2FwYWJpbGl0aWVzOiBpbml0aWFsaXplUmVzcG9uc2UuY2FwYWJpbGl0aWVzLFxyXG4gICAgICBkaXNwb3NhYmxlOiBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpLFxyXG4gICAgfTtcclxuICAgIHRoaXMucG9zdEluaXRpYWxpemF0aW9uKG5ld1NlcnZlcik7XHJcbiAgICBjb25uZWN0aW9uLmluaXRpYWxpemVkKCk7XHJcbiAgICBjb25uZWN0aW9uLm9uKCdjbG9zZScsICgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmlzRGVhY3RpdmF0aW5nKSB7XHJcbiAgICAgICAgdGhpcy5fc2VydmVyTWFuYWdlci5zdG9wU2VydmVyKG5ld1NlcnZlcik7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmhhc1NlcnZlclJlYWNoZWRSZXN0YXJ0TGltaXQobmV3U2VydmVyKSkge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFJlc3RhcnRpbmcgbGFuZ3VhZ2Ugc2VydmVyIGZvciBwcm9qZWN0ICcke25ld1NlcnZlci5wcm9qZWN0UGF0aH0nYCk7XHJcbiAgICAgICAgICB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLnN0YXJ0U2VydmVyKHByb2plY3RQYXRoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgTGFuZ3VhZ2Ugc2VydmVyIGhhcyBleGNlZWRlZCBhdXRvLXJlc3RhcnQgbGltaXQgZm9yIHByb2plY3QgJyR7bmV3U2VydmVyLnByb2plY3RQYXRofSdgKTtcclxuICAgICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcihgVGhlICR7dGhpcy5uYW1lfSBsYW5ndWFnZSBzZXJ2ZXIgaGFzIGV4aXRlZCBhbmQgZXhjZWVkZWQgdGhlIHJlc3RhcnQgbGltaXQgZm9yIHByb2plY3QgJyR7bmV3U2VydmVyLnByb2plY3RQYXRofSdgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb25LZXkgPSB0aGlzLmdldFJvb3RDb25maWd1cmF0aW9uS2V5KCk7XHJcbiAgICBpZiAoY29uZmlndXJhdGlvbktleSkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChcclxuICAgICAgICBhdG9tLmNvbmZpZy5vYnNlcnZlKGNvbmZpZ3VyYXRpb25LZXksIGNvbmZpZyA9PiB7XHJcbiAgICAgICAgICBjb25zdCBtYXBwZWRDb25maWcgPSB0aGlzLm1hcENvbmZpZ3VyYXRpb25PYmplY3QoY29uZmlnIHx8IHt9KTtcclxuICAgICAgICAgIGlmIChtYXBwZWRDb25maWcpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi5kaWRDaGFuZ2VDb25maWd1cmF0aW9uKHtcclxuICAgICAgICAgICAgICBzZXR0aW5nczogbWFwcGVkQ29uZmlnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zdGFydEV4Y2x1c2l2ZUFkYXB0ZXJzKG5ld1NlcnZlcik7XHJcbiAgICByZXR1cm4gbmV3U2VydmVyO1xyXG4gIH1cclxuXHJcbiAgY2FwdHVyZVNlcnZlckVycm9ycyhjaGlsZFByb2Nlc3M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzLCBwcm9qZWN0UGF0aDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBjaGlsZFByb2Nlc3Mub24oJ2Vycm9yJywgZXJyID0+IHRoaXMuaGFuZGxlU3Bhd25GYWlsdXJlKGVycikpO1xyXG4gICAgY2hpbGRQcm9jZXNzLm9uKCdleGl0JywgKGNvZGUsIHNpZ25hbCkgPT4gdGhpcy5sb2dnZXIuZGVidWcoYGV4aXQ6IGNvZGUgJHtjb2RlfSBzaWduYWwgJHtzaWduYWx9YCkpO1xyXG4gICAgY2hpbGRQcm9jZXNzLnN0ZGVyci5zZXRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgY2hpbGRQcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChjaHVuazogQnVmZmVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gY2h1bmsudG9TdHJpbmcoKTtcclxuICAgICAgdGhpcy5oYW5kbGVTZXJ2ZXJTdGRlcnIoZXJyb3JTdHJpbmcsIHByb2plY3RQYXRoKTtcclxuICAgICAgLy8gS2VlcCB0aGUgbGFzdCA1IGxpbmVzIGZvciBwYWNrYWdlcyB0byB1c2UgaW4gbWVzc2FnZXNcclxuICAgICAgdGhpcy5wcm9jZXNzU3RkRXJyID0gKHRoaXMucHJvY2Vzc1N0ZEVyciArIGVycm9yU3RyaW5nKVxyXG4gICAgICAgIC5zcGxpdCgnXFxuJylcclxuICAgICAgICAuc2xpY2UoLTUpXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBoYW5kbGVTcGF3bkZhaWx1cmUoZXJyOiBhbnkpOiB2b2lkIHtcclxuICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcihcclxuICAgICAgYCR7dGhpcy5nZXRTZXJ2ZXJOYW1lKCl9IGxhbmd1YWdlIHNlcnZlciBmb3IgJHt0aGlzLmdldExhbmd1YWdlTmFtZSgpfSB1bmFibGUgdG8gc3RhcnRgLFxyXG4gICAgICB7XHJcbiAgICAgICAgZGlzbWlzc2FibGU6IHRydWUsXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGVyci50b1N0cmluZygpLFxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIENyZWF0ZXMgdGhlIFJQQyBjb25uZWN0aW9uIHdoaWNoIGNhbiBiZSBpcGMsIHNvY2tldCBvciBzdGRpb1xyXG4gIGNyZWF0ZVJwY0Nvbm5lY3Rpb24ocHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MpOiBycGMuQ29ubmVjdGlvbiB7XHJcbiAgICBsZXQgcmVhZGVyLCB3cml0ZXI7XHJcbiAgICBjb25zdCBjb25uZWN0aW9uVHlwZSA9IHRoaXMuZ2V0Q29ubmVjdGlvblR5cGUoKTtcclxuICAgIHN3aXRjaCAoY29ubmVjdGlvblR5cGUpIHtcclxuICAgICAgY2FzZSAnaXBjJzpcclxuICAgICAgICByZWFkZXIgPSBuZXcgcnBjLklQQ01lc3NhZ2VSZWFkZXIocHJvY2Vzcyk7XHJcbiAgICAgICAgd3JpdGVyID0gbmV3IHJwYy5JUENNZXNzYWdlV3JpdGVyKHByb2Nlc3MpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdzb2NrZXQnOlxyXG4gICAgICAgIHJlYWRlciA9IG5ldyBycGMuU29ja2V0TWVzc2FnZVJlYWRlcih0aGlzLnNvY2tldCk7XHJcbiAgICAgICAgd3JpdGVyID0gbmV3IHJwYy5Tb2NrZXRNZXNzYWdlV3JpdGVyKHRoaXMuc29ja2V0KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnc3RkaW8nOlxyXG4gICAgICAgIHJlYWRlciA9IG5ldyBycGMuU3RyZWFtTWVzc2FnZVJlYWRlcihwcm9jZXNzLnN0ZG91dCk7XHJcbiAgICAgICAgd3JpdGVyID0gbmV3IHJwYy5TdHJlYW1NZXNzYWdlV3JpdGVyKHByb2Nlc3Muc3RkaW4pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBycGMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24ocmVhZGVyLCB3cml0ZXIsIHtcclxuICAgICAgZXJyb3I6IG0gPT4ge1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG0pO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBTdGFydCBhZGFwdGVycyB0aGF0IGFyZSBub3Qgc2hhcmVkIGJldHdlZW4gc2VydmVyc1xyXG4gIHN0YXJ0RXhjbHVzaXZlQWRhcHRlcnMoc2VydmVyOiBBY3RpdmVTZXJ2ZXIpOiB2b2lkIHtcclxuICAgIEFwcGx5RWRpdEFkYXB0ZXIuYXR0YWNoKHNlcnZlci5jb25uZWN0aW9uKTtcclxuICAgIE5vdGlmaWNhdGlvbnNBZGFwdGVyLmF0dGFjaChzZXJ2ZXIuY29ubmVjdGlvbiwgdGhpcy5uYW1lKTtcclxuXHJcbiAgICBpZiAoRG9jdW1lbnRTeW5jQWRhcHRlci5jYW5BZGFwdChzZXJ2ZXIuY2FwYWJpbGl0aWVzKSkge1xyXG4gICAgICBzZXJ2ZXIuZG9jU3luY0FkYXB0ZXIgPSBuZXcgRG9jdW1lbnRTeW5jQWRhcHRlcihzZXJ2ZXIuY29ubmVjdGlvbiwgc2VydmVyLmNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jLCBlZGl0b3IgPT5cclxuICAgICAgICB0aGlzLnNob3VsZFN5bmNGb3JFZGl0b3IoZWRpdG9yLCBzZXJ2ZXIucHJvamVjdFBhdGgpLFxyXG4gICAgICApO1xyXG4gICAgICBzZXJ2ZXIuZGlzcG9zYWJsZS5hZGQoc2VydmVyLmRvY1N5bmNBZGFwdGVyKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXJ2ZXIubGludGVyUHVzaFYyID0gbmV3IExpbnRlclB1c2hWMkFkYXB0ZXIoc2VydmVyLmNvbm5lY3Rpb24pO1xyXG4gICAgaWYgKHRoaXMuX2xpbnRlckRlbGVnYXRlICE9IG51bGwpIHtcclxuICAgICAgc2VydmVyLmxpbnRlclB1c2hWMi5hdHRhY2godGhpcy5fbGludGVyRGVsZWdhdGUpO1xyXG4gICAgfVxyXG4gICAgc2VydmVyLmRpc3Bvc2FibGUuYWRkKHNlcnZlci5saW50ZXJQdXNoVjIpO1xyXG5cclxuICAgIGlmIChTaWduYXR1cmVIZWxwQWRhcHRlci5jYW5BZGFwdChzZXJ2ZXIuY2FwYWJpbGl0aWVzKSkge1xyXG4gICAgICBzZXJ2ZXIuc2lnbmF0dXJlSGVscEFkYXB0ZXIgPSBuZXcgU2lnbmF0dXJlSGVscEFkYXB0ZXIoc2VydmVyLCB0aGlzLmdldEdyYW1tYXJTY29wZXMoKSk7XHJcbiAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVIZWxwUmVnaXN0cnkgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlci5zaWduYXR1cmVIZWxwQWRhcHRlci5hdHRhY2godGhpcy5fc2lnbmF0dXJlSGVscFJlZ2lzdHJ5KTtcclxuICAgICAgfVxyXG4gICAgICBzZXJ2ZXIuZGlzcG9zYWJsZS5hZGQoc2VydmVyLnNpZ25hdHVyZUhlbHBBZGFwdGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHNob3VsZFN5bmNGb3JFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHByb2plY3RQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmlzRmlsZUluUHJvamVjdChlZGl0b3IsIHByb2plY3RQYXRoKSAmJiB0aGlzLnNob3VsZFN0YXJ0Rm9yRWRpdG9yKGVkaXRvcik7XHJcbiAgfVxyXG5cclxuICBpc0ZpbGVJblByb2plY3QoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHByb2plY3RQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAoZWRpdG9yLmdldFVSSSgpIHx8ICcnKS5zdGFydHNXaXRoKHByb2plY3RQYXRoKTtcclxuICB9XHJcblxyXG4gIC8vIEF1dG9jb21wbGV0ZSsgdmlhIExTIGNvbXBsZXRpb24tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBwcm92aWRlQXV0b2NvbXBsZXRlKCk6IGF0b20kQXV0b2NvbXBsZXRlUHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VsZWN0b3I6IHRoaXMuZ2V0R3JhbW1hclNjb3BlcygpXHJcbiAgICAgICAgLm1hcChnID0+ICcuJyArIGcpXHJcbiAgICAgICAgLmpvaW4oJywgJyksXHJcbiAgICAgIGluY2x1c2lvblByaW9yaXR5OiAxLFxyXG4gICAgICBzdWdnZXN0aW9uUHJpb3JpdHk6IDIsXHJcbiAgICAgIGV4Y2x1ZGVMb3dlclByaW9yaXR5OiBmYWxzZSxcclxuICAgICAgZ2V0U3VnZ2VzdGlvbnM6IHRoaXMuZ2V0U3VnZ2VzdGlvbnMuYmluZCh0aGlzKSxcclxuICAgICAgb25EaWRJbnNlcnRTdWdnZXN0aW9uOiB0aGlzLm9uRGlkSW5zZXJ0U3VnZ2VzdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICBnZXRTdWdnZXN0aW9uRGV0YWlsc09uU2VsZWN0OiB0aGlzLmdldFN1Z2dlc3Rpb25EZXRhaWxzT25TZWxlY3QuYmluZCh0aGlzKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRTdWdnZXN0aW9ucyhcclxuICAgIHJlcXVlc3Q6IGF0b20kQXV0b2NvbXBsZXRlUmVxdWVzdCxcclxuICApOiBQcm9taXNlPEFycmF5PGF0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbj4+IHtcclxuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuX3NlcnZlck1hbmFnZXIuZ2V0U2VydmVyKHJlcXVlc3QuZWRpdG9yKTtcclxuICAgIGlmIChzZXJ2ZXIgPT0gbnVsbCB8fCAhQXV0b2NvbXBsZXRlQWRhcHRlci5jYW5BZGFwdChzZXJ2ZXIuY2FwYWJpbGl0aWVzKSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hdXRvQ29tcGxldGUgPSB0aGlzLmF1dG9Db21wbGV0ZSB8fCBuZXcgQXV0b2NvbXBsZXRlQWRhcHRlcigpO1xyXG4gICAgdGhpcy5fbGFzdEF1dG9jb21wbGV0ZVJlcXVlc3QgPSByZXF1ZXN0O1xyXG4gICAgcmV0dXJuIHRoaXMuYXV0b0NvbXBsZXRlLmdldFN1Z2dlc3Rpb25zKHNlcnZlciwgcmVxdWVzdCwgdGhpcy5vbkRpZENvbnZlcnRBdXRvY29tcGxldGUpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U3VnZ2VzdGlvbkRldGFpbHNPblNlbGVjdChzdWdnZXN0aW9uOiBhdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24pOiBQcm9taXNlPD9hdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb24+IHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9sYXN0QXV0b2NvbXBsZXRlUmVxdWVzdDtcclxuICAgIGlmIChyZXF1ZXN0ID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cclxuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuX3NlcnZlck1hbmFnZXIuZ2V0U2VydmVyKHJlcXVlc3QuZWRpdG9yKTtcclxuICAgIGlmIChzZXJ2ZXIgPT0gbnVsbCB8fCAhQXV0b2NvbXBsZXRlQWRhcHRlci5jYW5SZXNvbHZlKHNlcnZlci5jYXBhYmlsaXRpZXMpIHx8IHRoaXMuYXV0b0NvbXBsZXRlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuYXV0b0NvbXBsZXRlLmNvbXBsZXRlU3VnZ2VzdGlvbihzZXJ2ZXIsIHN1Z2dlc3Rpb24sIHJlcXVlc3QsIHRoaXMub25EaWRDb252ZXJ0QXV0b2NvbXBsZXRlKTtcclxuICB9XHJcblxyXG4gIG9uRGlkQ29udmVydEF1dG9jb21wbGV0ZShcclxuICAgIGNvbXBsZXRpb25JdGVtOiBscy5Db21wbGV0aW9uSXRlbSxcclxuICAgIHN1Z2dlc3Rpb246IGF0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbixcclxuICAgIHJlcXVlc3Q6IGF0b20kQXV0b2NvbXBsZXRlUmVxdWVzdCxcclxuICApOiB2b2lkIHtcclxuICB9XHJcblxyXG4gIG9uRGlkSW5zZXJ0U3VnZ2VzdGlvbihhcmc6IGF0b20kQXV0b2NvbXBsZXRlRGlkSW5zZXJ0KTogdm9pZCB7fVxyXG5cclxuICAvLyBEZWZpbml0aW9ucyB2aWEgTFMgZG9jdW1lbnRIaWdobGlnaHQgYW5kIGdvdG9EZWZpbml0aW9uLS0tLS0tLS0tLS0tXHJcbiAgcHJvdmlkZURlZmluaXRpb25zKCk6IGF0b21JZGUkRGVmaW5pdGlvblByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgcHJpb3JpdHk6IDIwLFxyXG4gICAgICBncmFtbWFyU2NvcGVzOiB0aGlzLmdldEdyYW1tYXJTY29wZXMoKSxcclxuICAgICAgZ2V0RGVmaW5pdGlvbjogdGhpcy5nZXREZWZpbml0aW9uLmJpbmQodGhpcyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0RGVmaW5pdGlvbihlZGl0b3I6IFRleHRFZGl0b3IsIHBvaW50OiBhdG9tJFBvaW50KTogUHJvbWlzZTw/YXRvbUlkZSREZWZpbml0aW9uUXVlcnlSZXN1bHQ+IHtcclxuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuX3NlcnZlck1hbmFnZXIuZ2V0U2VydmVyKGVkaXRvcik7XHJcbiAgICBpZiAoc2VydmVyID09IG51bGwgfHwgIURlZmluaXRpb25BZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGVmaW5pdGlvbnMgPSB0aGlzLmRlZmluaXRpb25zIHx8IG5ldyBEZWZpbml0aW9uQWRhcHRlcigpO1xyXG4gICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbnMuZ2V0RGVmaW5pdGlvbihcclxuICAgICAgc2VydmVyLmNvbm5lY3Rpb24sXHJcbiAgICAgIHNlcnZlci5jYXBhYmlsaXRpZXMsXHJcbiAgICAgIHRoaXMuZ2V0TGFuZ3VhZ2VOYW1lKCksXHJcbiAgICAgIGVkaXRvcixcclxuICAgICAgcG9pbnQsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gT3V0bGluZSBWaWV3IHZpYSBMUyBkb2N1bWVudFN5bWJvbC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIHByb3ZpZGVPdXRsaW5lcygpOiBhdG9tSWRlJE91dGxpbmVQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgIGdyYW1tYXJTY29wZXM6IHRoaXMuZ2V0R3JhbW1hclNjb3BlcygpLFxyXG4gICAgICBwcmlvcml0eTogMSxcclxuICAgICAgZ2V0T3V0bGluZTogdGhpcy5nZXRPdXRsaW5lLmJpbmQodGhpcyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0T3V0bGluZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P2F0b21JZGUkT3V0bGluZT4ge1xyXG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcclxuICAgIGlmIChzZXJ2ZXIgPT0gbnVsbCB8fCAhT3V0bGluZVZpZXdBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3V0bGluZVZpZXcgPSB0aGlzLm91dGxpbmVWaWV3IHx8IG5ldyBPdXRsaW5lVmlld0FkYXB0ZXIoKTtcclxuICAgIHJldHVybiB0aGlzLm91dGxpbmVWaWV3LmdldE91dGxpbmUoc2VydmVyLmNvbm5lY3Rpb24sIGVkaXRvcik7XHJcbiAgfVxyXG5cclxuICAvLyBMaW50ZXIgcHVzaCB2MiBBUEkgdmlhIExTIHB1Ymxpc2hEaWFnbm9zdGljc1xyXG4gIGNvbnN1bWVMaW50ZXJWMihyZWdpc3RlckluZGllOiAoe25hbWU6IHN0cmluZ30pID0+IGxpbnRlciRWMkluZGllRGVsZWdhdGUpOiB2b2lkIHtcclxuICAgIHRoaXMuX2xpbnRlckRlbGVnYXRlID0gcmVnaXN0ZXJJbmRpZSh7bmFtZTogdGhpcy5uYW1lfSk7XHJcbiAgICBpZiAodGhpcy5fbGludGVyRGVsZWdhdGUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBzZXJ2ZXIgb2YgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRBY3RpdmVTZXJ2ZXJzKCkpIHtcclxuICAgICAgaWYgKHNlcnZlci5saW50ZXJQdXNoVjIgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlci5saW50ZXJQdXNoVjIuYXR0YWNoKHRoaXMuX2xpbnRlckRlbGVnYXRlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRmluZCBSZWZlcmVuY2VzIHZpYSBMUyBmaW5kUmVmZXJlbmNlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gIHByb3ZpZGVGaW5kUmVmZXJlbmNlcygpOiBhdG9tSWRlJEZpbmRSZWZlcmVuY2VzUHJvdmlkZXIge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaXNFZGl0b3JTdXBwb3J0ZWQ6IChlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikgPT4gdGhpcy5nZXRHcmFtbWFyU2NvcGVzKCkuaW5jbHVkZXMoZWRpdG9yLmdldEdyYW1tYXIoKS5zY29wZU5hbWUpLFxyXG4gICAgICBmaW5kUmVmZXJlbmNlczogdGhpcy5nZXRSZWZlcmVuY2VzLmJpbmQodGhpcyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0UmVmZXJlbmNlcyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcG9pbnQ6IGF0b20kUG9pbnQpOiBQcm9taXNlPD9hdG9tSWRlJEZpbmRSZWZlcmVuY2VzUmV0dXJuPiB7XHJcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmdldFNlcnZlcihlZGl0b3IpO1xyXG4gICAgaWYgKHNlcnZlciA9PSBudWxsIHx8ICFGaW5kUmVmZXJlbmNlc0FkYXB0ZXIuY2FuQWRhcHQoc2VydmVyLmNhcGFiaWxpdGllcykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5maW5kUmVmZXJlbmNlcyA9IHRoaXMuZmluZFJlZmVyZW5jZXMgfHwgbmV3IEZpbmRSZWZlcmVuY2VzQWRhcHRlcigpO1xyXG4gICAgcmV0dXJuIHRoaXMuZmluZFJlZmVyZW5jZXMuZ2V0UmVmZXJlbmNlcyhzZXJ2ZXIuY29ubmVjdGlvbiwgZWRpdG9yLCBwb2ludCwgc2VydmVyLnByb2plY3RQYXRoKTtcclxuICB9XHJcblxyXG4gIC8vIERhdGF0aXAgdmlhIExTIHRleHREb2N1bWVudC9ob3Zlci0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICBjb25zdW1lRGF0YXRpcChzZXJ2aWNlOiBhdG9tSWRlJERhdGF0aXBTZXJ2aWNlKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChcclxuICAgICAgc2VydmljZS5hZGRQcm92aWRlcih7XHJcbiAgICAgICAgcHJvdmlkZXJOYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgcHJpb3JpdHk6IDEsXHJcbiAgICAgICAgZ3JhbW1hclNjb3BlczogdGhpcy5nZXRHcmFtbWFyU2NvcGVzKCksXHJcbiAgICAgICAgdmFsaWRGb3JTY29wZTogKHNjb3BlTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmFtbWFyU2NvcGVzKCkuaW5jbHVkZXMoc2NvcGVOYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRhdGF0aXA6IHRoaXMuZ2V0RGF0YXRpcC5iaW5kKHRoaXMpLFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXREYXRhdGlwKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBwb2ludDogYXRvbSRQb2ludCk6IFByb21pc2U8P2F0b21JZGUkRGF0YXRpcD4ge1xyXG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcclxuICAgIGlmIChzZXJ2ZXIgPT0gbnVsbCB8fCAhRGF0YXRpcEFkYXB0ZXIuY2FuQWRhcHQoc2VydmVyLmNhcGFiaWxpdGllcykpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kYXRhdGlwID0gdGhpcy5kYXRhdGlwIHx8IG5ldyBEYXRhdGlwQWRhcHRlcigpO1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0YXRpcC5nZXREYXRhdGlwKHNlcnZlci5jb25uZWN0aW9uLCBlZGl0b3IsIHBvaW50KTtcclxuICB9XHJcblxyXG4gIC8vIENvZGUgRm9ybWF0IHZpYSBMUyBmb3JtYXREb2N1bWVudCAmIGZvcm1hdERvY3VtZW50UmFuZ2UtLS0tLS0tLS0tLS1cclxuICBwcm92aWRlQ29kZUZvcm1hdCgpOiBhdG9tSWRlJFJhbmdlQ29kZUZvcm1hdFByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdyYW1tYXJTY29wZXM6IHRoaXMuZ2V0R3JhbW1hclNjb3BlcygpLFxyXG4gICAgICBwcmlvcml0eTogMSxcclxuICAgICAgZm9ybWF0Q29kZTogdGhpcy5nZXRDb2RlRm9ybWF0LmJpbmQodGhpcyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q29kZUZvcm1hdChlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcmFuZ2U6IGF0b20kUmFuZ2UpOiBQcm9taXNlPEFycmF5PGF0b21JZGUkVGV4dEVkaXQ+PiB7XHJcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmdldFNlcnZlcihlZGl0b3IpO1xyXG4gICAgaWYgKHNlcnZlciA9PSBudWxsIHx8ICFDb2RlRm9ybWF0QWRhcHRlci5jYW5BZGFwdChzZXJ2ZXIuY2FwYWJpbGl0aWVzKSkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdChzZXJ2ZXIuY29ubmVjdGlvbiwgc2VydmVyLmNhcGFiaWxpdGllcywgZWRpdG9yLCByYW5nZSk7XHJcbiAgfVxyXG5cclxuICBwcm92aWRlQ29kZUhpZ2hsaWdodCgpOiBhdG9tSWRlJENvZGVIaWdobGlnaHRQcm92aWRlciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBncmFtbWFyU2NvcGVzOiB0aGlzLmdldEdyYW1tYXJTY29wZXMoKSxcclxuICAgICAgcHJpb3JpdHk6IDEsXHJcbiAgICAgIGhpZ2hsaWdodDogKGVkaXRvciwgcG9zaXRpb24pID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2RlSGlnaGxpZ2h0KGVkaXRvciwgcG9zaXRpb24pO1xyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGdldENvZGVIaWdobGlnaHQoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHBvc2l0aW9uOiBhdG9tJFBvaW50KTogUHJvbWlzZTw/QXJyYXk8YXRvbSRSYW5nZT4+IHtcclxuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuX3NlcnZlck1hbmFnZXIuZ2V0U2VydmVyKGVkaXRvcik7XHJcbiAgICBpZiAoc2VydmVyID09IG51bGwgfHwgIUNvZGVIaWdobGlnaHRBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBDb2RlSGlnaGxpZ2h0QWRhcHRlci5oaWdobGlnaHQoc2VydmVyLmNvbm5lY3Rpb24sIHNlcnZlci5jYXBhYmlsaXRpZXMsIGVkaXRvciwgcG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgcHJvdmlkZUNvZGVBY3Rpb25zKCk6IGF0b21JZGUkQ29kZUFjdGlvblByb3ZpZGVyIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGdyYW1tYXJTY29wZXM6IHRoaXMuZ2V0R3JhbW1hclNjb3BlcygpLFxyXG4gICAgICBwcmlvcml0eTogMSxcclxuICAgICAgZ2V0Q29kZUFjdGlvbnM6IChlZGl0b3IsIHJhbmdlLCBkaWFnbm9zdGljcykgPT4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvZGVBY3Rpb25zKGVkaXRvciwgcmFuZ2UsIGRpYWdub3N0aWNzKTtcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRDb2RlQWN0aW9ucyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcmFuZ2U6IGF0b20kUmFuZ2UsIGRpYWdub3N0aWNzOiBBcnJheTxhdG9tSWRlJERpYWdub3N0aWM+KSB7XHJcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmdldFNlcnZlcihlZGl0b3IpO1xyXG4gICAgaWYgKHNlcnZlciA9PSBudWxsIHx8ICFDb2RlQWN0aW9uQWRhcHRlci5jYW5BZGFwdChzZXJ2ZXIuY2FwYWJpbGl0aWVzKSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQ29kZUFjdGlvbkFkYXB0ZXIuZ2V0Q29kZUFjdGlvbnMoXHJcbiAgICAgIHNlcnZlci5jb25uZWN0aW9uLFxyXG4gICAgICBzZXJ2ZXIuY2FwYWJpbGl0aWVzLFxyXG4gICAgICBzZXJ2ZXIubGludGVyUHVzaFYyLFxyXG4gICAgICBlZGl0b3IsXHJcbiAgICAgIHJhbmdlLFxyXG4gICAgICBkaWFnbm9zdGljcyxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb25zdW1lU2lnbmF0dXJlSGVscChyZWdpc3RyeTogYXRvbUlkZSRTaWduYXR1cmVIZWxwUmVnaXN0cnkpOiBJRGlzcG9zYWJsZSB7XHJcbiAgICB0aGlzLl9zaWduYXR1cmVIZWxwUmVnaXN0cnkgPSByZWdpc3RyeTtcclxuICAgIGZvciAoY29uc3Qgc2VydmVyIG9mIHRoaXMuX3NlcnZlck1hbmFnZXIuZ2V0QWN0aXZlU2VydmVycygpKSB7XHJcbiAgICAgIGlmIChzZXJ2ZXIuc2lnbmF0dXJlSGVscEFkYXB0ZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlci5zaWduYXR1cmVIZWxwQWRhcHRlci5hdHRhY2gocmVnaXN0cnkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERpc3Bvc2FibGUoKCkgPT4ge1xyXG4gICAgICB0aGlzLl9zaWduYXR1cmVIZWxwUmVnaXN0cnkgPSBudWxsO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBjb25zdW1lQnVzeVNpZ25hbChzZXJ2aWNlOiBhdG9tSWRlJEJ1c3lTaWduYWxTZXJ2aWNlKTogSURpc3Bvc2FibGUge1xyXG4gICAgdGhpcy5idXN5U2lnbmFsU2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICByZXR1cm4gbmV3IERpc3Bvc2FibGUoKCkgPT4gZGVsZXRlIHRoaXMuYnVzeVNpZ25hbFNlcnZpY2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYGRpZENoYW5nZVdhdGNoZWRGaWxlc2AgbWVzc2FnZSBmaWx0ZXJpbmcsIG92ZXJyaWRlIGZvciBjdXN0b20gbG9naWMuXHJcbiAgICogQHBhcmFtIGZpbGVQYXRoIHBhdGggb2YgYSBmaWxlIHRoYXQgaGFzIGNoYW5nZWQgaW4gdGhlIHByb2plY3QgcGF0aFxyXG4gICAqIEByZXR1cm4gZmFsc2UgPT4gbWVzc2FnZSB3aWxsIG5vdCBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAgKi9cclxuICBmaWx0ZXJDaGFuZ2VXYXRjaGVkRmlsZXMoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgb24gbGFuZ3VhZ2Ugc2VydmVyIHN0ZGVyciBvdXRwdXQuXHJcbiAgICogQHBhcmFtIHN0ZGVyciBhIGNodW5rIG9mIHN0ZGVyciBmcm9tIGEgbGFuZ3VhZ2Ugc2VydmVyIGluc3RhbmNlXHJcbiAgICovXHJcbiAgaGFuZGxlU2VydmVyU3RkZXJyKHN0ZGVycjogc3RyaW5nLCBwcm9qZWN0UGF0aDogc3RyaW5nKSB7XHJcbiAgICBzdGRlcnIuc3BsaXQoJ1xcbicpLmZpbHRlcihsID0+IGwpLmZvckVhY2gobGluZSA9PiB0aGlzLmxvZ2dlci53YXJuKGBzdGRlcnIgJHtsaW5lfWApKTtcclxuICB9XHJcbn1cclxuIl19