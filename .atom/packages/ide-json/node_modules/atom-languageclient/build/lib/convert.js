Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Public: Class that contains a number of helper methods for general conversions
// between the language server protocol and Atom/Atom packages.
let Convert = class Convert {
  // Public: Convert a path to a Uri.
  //
  // * `filePath` A file path to convert to a Uri.
  //
  // Returns the Uri corresponding to the path. e.g. file:///a/b/c.txt
  static pathToUri(filePath) {
    let newPath = filePath.replace(/\\/g, '/');
    if (newPath[0] !== '/') {
      newPath = `/${newPath}`;
    }
    return encodeURI(`file://${newPath}`).replace(/[?#]/g, encodeURIComponent);
  }

  // Public: Convert a Uri to a path.
  //
  // * `uri` A Uri to convert to a file path.
  //
  // Returns a file path corresponding to the Uri. e.g. /a/b/c.txt
  static uriToPath(uri) {
    let filePath = decodeURIComponent(uri);
    if (filePath.startsWith('file://')) {
      filePath = filePath.substr(7);
    }
    if (process.platform === 'win32') {
      // Deal with Windows drive names
      if (filePath[0] === '/') {
        filePath = filePath.substr(1);
      }
      return filePath.replace(/\//g, '\\');
    }
    return filePath;
  }

  // Public: Convert an Atom {PointObject} to a language server {Position}.
  //
  // * `point` An Atom {PointObject} to convert from.
  //
  // Returns the {Position} representation of the Atom {PointObject}.
  static pointToPosition(point) {
    return { line: point.row, character: point.column };
  }

  // Public: Convert a language server {Position} into an Atom {PointObject}.
  //
  // * 'position' A language server {Position} to convert from.
  //
  // Returns the Atom {PointObject} representation of the given {Position}.
  static positionToPoint(position) {
    return new _atom.Point(position.line, position.character);
  }

  // Public: Convert a language server {Range} into an Atom {Range}.
  //
  // * 'range' A language server {Range} to convert from.
  //
  // Returns the Atom {Range} representation of the given language server {Range}.
  static lsRangeToAtomRange(range) {
    return new _atom.Range(Convert.positionToPoint(range.start), Convert.positionToPoint(range.end));
  }

  // Public: Convert an Atom {Range} into an language server {Range}.
  //
  // * 'range' An Atom {Range} to convert from.
  //
  // Returns the language server {Range} representation of the given Atom {Range}.
  static atomRangeToLSRange(range) {
    return {
      start: Convert.pointToPosition(range.start),
      end: Convert.pointToPosition(range.end)
    };
  }

  // Public: Create a {TextDocumentIdentifier} from an Atom {TextEditor}.
  //
  // * `editor` A {TextEditor} that will be used to form the uri property.
  //
  // Returns a {TextDocumentIdentifier} that has a `uri` property with the Uri for the
  // given editor's path.
  static editorToTextDocumentIdentifier(editor) {
    return { uri: Convert.pathToUri(editor.getPath() || '') };
  }

  // Public: Create a {TextDocumentPositionParams} from a {TextEditor} and optional {Point}.
  //
  // * `editor` A {TextEditor} that will be used to form the uri property.
  // * `point`  An optional {Point} that will supply the position property. If not specified
  //            the current cursor position will be used.
  //
  // Returns a {TextDocumentPositionParams} that has textDocument property with the editors {TextDocumentIdentifier}
  // and a position property with the supplied point (or current cursor position when not specified).
  static editorToTextDocumentPositionParams(editor, point) {
    return {
      textDocument: Convert.editorToTextDocumentIdentifier(editor),
      position: Convert.pointToPosition(point != null ? point : editor.getCursorBufferPosition())
    };
  }

  // Public: Create a string of scopes for the atom text editor using the data-grammar selector from an
  // {Array} of grammarScope strings.
  //
  // * `grammarScopes` An {Array} of grammar scope string to convert from.
  //
  // Returns a single comma-separated list of CSS selectors targetting the grammars of Atom text editors.
  // e.g. `['c', 'cpp']` => `'atom-text-editor[data-grammar='c'], atom-text-editor[data-grammar='cpp']`
  static grammarScopesToTextEditorScopes(grammarScopes) {
    return grammarScopes.map(g => `atom-text-editor[data-grammar="${Convert.encodeHTMLAttribute(g.replace(/\./g, ' '))}"]`).join(', ');
  }

  // Public: Encode a string so that it can be safely used within a HTML attribute - i.e. replacing all quoted
  // values with their HTML entity encoded versions.  e.g. `Hello"` becomes `Hello&quot;`
  //
  // * 's' A string to be encoded.
  //
  // Returns a string that is HTML attribute encoded by replacing &, <, >, " and ' with their HTML entity
  // named equivalents.
  static encodeHTMLAttribute(s) {
    const attributeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&apos;'
    };
    return s.replace(/[&<>'"]/g, c => attributeMap[c]);
  }
};
exports.default = Convert;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jb252ZXJ0LmpzIl0sIm5hbWVzIjpbImxzIiwiQ29udmVydCIsInBhdGhUb1VyaSIsImZpbGVQYXRoIiwibmV3UGF0aCIsInJlcGxhY2UiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1cmlUb1BhdGgiLCJ1cmkiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwicHJvY2VzcyIsInBsYXRmb3JtIiwicG9pbnRUb1Bvc2l0aW9uIiwicG9pbnQiLCJsaW5lIiwicm93IiwiY2hhcmFjdGVyIiwiY29sdW1uIiwicG9zaXRpb25Ub1BvaW50IiwicG9zaXRpb24iLCJsc1JhbmdlVG9BdG9tUmFuZ2UiLCJyYW5nZSIsInN0YXJ0IiwiZW5kIiwiYXRvbVJhbmdlVG9MU1JhbmdlIiwiZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiZWRpdG9yIiwiZ2V0UGF0aCIsImVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJ0ZXh0RG9jdW1lbnQiLCJnZXRDdXJzb3JCdWZmZXJQb3NpdGlvbiIsImdyYW1tYXJTY29wZXNUb1RleHRFZGl0b3JTY29wZXMiLCJncmFtbWFyU2NvcGVzIiwibWFwIiwiZyIsImVuY29kZUhUTUxBdHRyaWJ1dGUiLCJqb2luIiwicyIsImF0dHJpYnV0ZU1hcCIsImMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0lBQVlBLEU7O0FBQ1o7Ozs7QUFFQTtBQUNBO0lBQ3FCQyxPLEdBQU4sTUFBTUEsT0FBTixDQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxTQUFQLENBQWlCQyxRQUFqQixFQUEyQztBQUN6QyxRQUFJQyxVQUFVRCxTQUFTRSxPQUFULENBQWlCLEtBQWpCLEVBQXdCLEdBQXhCLENBQWQ7QUFDQSxRQUFJRCxRQUFRLENBQVIsTUFBZSxHQUFuQixFQUF3QjtBQUN0QkEsZ0JBQVcsSUFBR0EsT0FBUSxFQUF0QjtBQUNEO0FB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LE1BRmM7QUFHbkIsV0FBSyxNQUhjO0FBSW5CLFdBQUssUUFKYztBQUtuQixXQUFLO0FBTGMsS0FBckI7QUFPQSxXQUFPRCxFQUFFbkMsT0FBRixDQUFVLFVBQVYsRUFBc0JxQyxLQUFLRCxhQUFhQyxDQUFiLENBQTNCLENBQVA7QUFDRDtBQWxJMEIsQztrQkFBUnpDLE8iLCJmaWxlIjoiY29udmVydC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQgKiBhcyBscyBmcm9tICcuL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IHtQb2ludCwgUmFuZ2V9IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBDbGFzcyB0aGF0IGNvbnRhaW5zIGEgbnVtYmVyIG9mIGhlbHBlciBtZXRob2RzIGZvciBnZW5lcmFsIGNvbnZlcnNpb25zXHJcbi8vIGJldHdlZW4gdGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBhbmQgQXRvbS9BdG9tIHBhY2thZ2VzLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb252ZXJ0IHtcclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBwYXRoIHRvIGEgVXJpLlxyXG4gIC8vXHJcbiAgLy8gKiBgZmlsZVBhdGhgIEEgZmlsZSBwYXRoIHRvIGNvbnZlcnQgdG8gYSBVcmkuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSBVcmkgY29ycmVzcG9uZGluZyB0byB0aGUgcGF0aC4gZS5nLiBmaWxlOi8vL2EvYi9jLnR4dFxyXG4gIHN0YXRpYyBwYXRoVG9VcmkoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBsZXQgbmV3UGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcclxuICAgIGlmIChuZXdQYXRoWzBdICE9PSAnLycpIHtcclxuICAgICAgbmV3UGF0aCA9IGAvJHtuZXdQYXRofWA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW5jb2RlVVJJKGBmaWxlOi8vJHtuZXdQYXRofWApLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIFVyaSB0byBhIHBhdGguXHJcbiAgLy9cclxuICAvLyAqIGB1cmlgIEEgVXJpIHRvIGNvbnZlcnQgdG8gYSBmaWxlIHBhdGguXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgZmlsZSBwYXRoIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFVyaS4gZS5nLiAvYS9iL2MudHh0XHJcbiAgc3RhdGljIHVyaVRvUGF0aCh1cmk6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBsZXQgZmlsZVBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodXJpKTtcclxuICAgIGlmIChmaWxlUGF0aC5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcclxuICAgICAgZmlsZVBhdGggPSBmaWxlUGF0aC5zdWJzdHIoNyk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xyXG4gICAgICAvLyBEZWFsIHdpdGggV2luZG93cyBkcml2ZSBuYW1lc1xyXG4gICAgICBpZiAoZmlsZVBhdGhbMF0gPT09ICcvJykge1xyXG4gICAgICAgIGZpbGVQYXRoID0gZmlsZVBhdGguc3Vic3RyKDEpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmaWxlUGF0aC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmaWxlUGF0aDtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBBdG9tIHtQb2ludE9iamVjdH0gdG8gYSBsYW5ndWFnZSBzZXJ2ZXIge1Bvc2l0aW9ufS5cclxuICAvL1xyXG4gIC8vICogYHBvaW50YCBBbiBBdG9tIHtQb2ludE9iamVjdH0gdG8gY29udmVydCBmcm9tLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUge1Bvc2l0aW9ufSByZXByZXNlbnRhdGlvbiBvZiB0aGUgQXRvbSB7UG9pbnRPYmplY3R9LlxyXG4gIHN0YXRpYyBwb2ludFRvUG9zaXRpb24ocG9pbnQ6IGF0b20kUG9pbnRPYmplY3QpOiBscy5Qb3NpdGlvbiB7XHJcbiAgICByZXR1cm4ge2xpbmU6IHBvaW50LnJvdywgY2hhcmFjdGVyOiBwb2ludC5jb2x1bW59O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgbGFuZ3VhZ2Ugc2VydmVyIHtQb3NpdGlvbn0gaW50byBhbiBBdG9tIHtQb2ludE9iamVjdH0uXHJcbiAgLy9cclxuICAvLyAqICdwb3NpdGlvbicgQSBsYW5ndWFnZSBzZXJ2ZXIge1Bvc2l0aW9ufSB0byBjb252ZXJ0IGZyb20uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSBBdG9tIHtQb2ludE9iamVjdH0gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHtQb3NpdGlvbn0uXHJcbiAgc3RhdGljIHBvc2l0aW9uVG9Qb2ludChwb3NpdGlvbjogbHMuUG9zaXRpb24pOiBhdG9tJFBvaW50IHtcclxuICAgIHJldHVybiBuZXcgUG9pbnQocG9zaXRpb24ubGluZSwgcG9zaXRpb24uY2hhcmFjdGVyKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIGxhbmd1YWdlIHNlcnZlciB7UmFuZ2V9IGludG8gYW4gQXRvbSB7UmFuZ2V9LlxyXG4gIC8vXHJcbiAgLy8gKiAncmFuZ2UnIEEgbGFuZ3VhZ2Ugc2VydmVyIHtSYW5nZX0gdG8gY29udmVydCBmcm9tLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUgQXRvbSB7UmFuZ2V9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIge1JhbmdlfS5cclxuICBzdGF0aWMgbHNSYW5nZVRvQXRvbVJhbmdlKHJhbmdlOiBscy5SYW5nZSk6IGF0b20kUmFuZ2Uge1xyXG4gICAgcmV0dXJuIG5ldyBSYW5nZShDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChyYW5nZS5zdGFydCksIENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHJhbmdlLmVuZCkpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIEF0b20ge1JhbmdlfSBpbnRvIGFuIGxhbmd1YWdlIHNlcnZlciB7UmFuZ2V9LlxyXG4gIC8vXHJcbiAgLy8gKiAncmFuZ2UnIEFuIEF0b20ge1JhbmdlfSB0byBjb252ZXJ0IGZyb20uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSBsYW5ndWFnZSBzZXJ2ZXIge1JhbmdlfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gQXRvbSB7UmFuZ2V9LlxyXG4gIHN0YXRpYyBhdG9tUmFuZ2VUb0xTUmFuZ2UocmFuZ2U6IGF0b20kUmFuZ2UpOiBscy5SYW5nZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGFydDogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocmFuZ2Uuc3RhcnQpLFxyXG4gICAgICBlbmQ6IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHJhbmdlLmVuZCksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dERvY3VtZW50SWRlbnRpZmllcn0gZnJvbSBhbiBBdG9tIHtUZXh0RWRpdG9yfS5cclxuICAvL1xyXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZm9ybSB0aGUgdXJpIHByb3BlcnR5LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSB0aGF0IGhhcyBhIGB1cmlgIHByb3BlcnR5IHdpdGggdGhlIFVyaSBmb3IgdGhlXHJcbiAgLy8gZ2l2ZW4gZWRpdG9yJ3MgcGF0aC5cclxuICBzdGF0aWMgZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogbHMuVGV4dERvY3VtZW50SWRlbnRpZmllciB7XHJcbiAgICByZXR1cm4ge3VyaTogQ29udmVydC5wYXRoVG9VcmkoZWRpdG9yLmdldFBhdGgoKSB8fCAnJyl9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXN9IGZyb20gYSB7VGV4dEVkaXRvcn0gYW5kIG9wdGlvbmFsIHtQb2ludH0uXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGZvcm0gdGhlIHVyaSBwcm9wZXJ0eS5cclxuICAvLyAqIGBwb2ludGAgIEFuIG9wdGlvbmFsIHtQb2ludH0gdGhhdCB3aWxsIHN1cHBseSB0aGUgcG9zaXRpb24gcHJvcGVydHkuIElmIG5vdCBzcGVjaWZpZWRcclxuICAvLyAgICAgICAgICAgIHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvbiB3aWxsIGJlIHVzZWQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfSB0aGF0IGhhcyB0ZXh0RG9jdW1lbnQgcHJvcGVydHkgd2l0aCB0aGUgZWRpdG9ycyB7VGV4dERvY3VtZW50SWRlbnRpZmllcn1cclxuICAvLyBhbmQgYSBwb3NpdGlvbiBwcm9wZXJ0eSB3aXRoIHRoZSBzdXBwbGllZCBwb2ludCAob3IgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gd2hlbiBub3Qgc3BlY2lmaWVkKS5cclxuICBzdGF0aWMgZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhcclxuICAgIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6ID9hdG9tJFBvaW50LFxyXG4gICk6IGxzLlRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcclxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHBvaW50ICE9IG51bGwgPyBwb2ludCA6IGVkaXRvci5nZXRDdXJzb3JCdWZmZXJQb3NpdGlvbigpKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIHN0cmluZyBvZiBzY29wZXMgZm9yIHRoZSBhdG9tIHRleHQgZWRpdG9yIHVzaW5nIHRoZSBkYXRhLWdyYW1tYXIgc2VsZWN0b3IgZnJvbSBhblxyXG4gIC8vIHtBcnJheX0gb2YgZ3JhbW1hclNjb3BlIHN0cmluZ3MuXHJcbiAgLy9cclxuICAvLyAqIGBncmFtbWFyU2NvcGVzYCBBbiB7QXJyYXl9IG9mIGdyYW1tYXIgc2NvcGUgc3RyaW5nIHRvIGNvbnZlcnQgZnJvbS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzaW5nbGUgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgQ1NTIHNlbGVjdG9ycyB0YXJnZXR0aW5nIHRoZSBncmFtbWFycyBvZiBBdG9tIHRleHQgZWRpdG9ycy5cclxuICAvLyBlLmcuIGBbJ2MnLCAnY3BwJ11gID0+IGAnYXRvbS10ZXh0LWVkaXRvcltkYXRhLWdyYW1tYXI9J2MnXSwgYXRvbS10ZXh0LWVkaXRvcltkYXRhLWdyYW1tYXI9J2NwcCddYFxyXG4gIHN0YXRpYyBncmFtbWFyU2NvcGVzVG9UZXh0RWRpdG9yU2NvcGVzKGdyYW1tYXJTY29wZXM6IEFycmF5PHN0cmluZz4pOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGdyYW1tYXJTY29wZXNcclxuICAgICAgLm1hcChnID0+IGBhdG9tLXRleHQtZWRpdG9yW2RhdGEtZ3JhbW1hcj1cIiR7Q29udmVydC5lbmNvZGVIVE1MQXR0cmlidXRlKGcucmVwbGFjZSgvXFwuL2csICcgJykpfVwiXWApXHJcbiAgICAgIC5qb2luKCcsICcpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBFbmNvZGUgYSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYmUgc2FmZWx5IHVzZWQgd2l0aGluIGEgSFRNTCBhdHRyaWJ1dGUgLSBpLmUuIHJlcGxhY2luZyBhbGwgcXVvdGVkXHJcbiAgLy8gdmFsdWVzIHdpdGggdGhlaXIgSFRNTCBlbnRpdHkgZW5jb2RlZCB2ZXJzaW9ucy4gIGUuZy4gYEhlbGxvXCJgIGJlY29tZXMgYEhlbGxvJnF1b3Q7YFxyXG4gIC8vXHJcbiAgLy8gKiAncycgQSBzdHJpbmcgdG8gYmUgZW5jb2RlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBIVE1MIGF0dHJpYnV0ZSBlbmNvZGVkIGJ5IHJlcGxhY2luZyAmLCA8LCA+LCBcIiBhbmQgJyB3aXRoIHRoZWlyIEhUTUwgZW50aXR5XHJcbiAgLy8gbmFtZWQgZXF1aXZhbGVudHMuXHJcbiAgc3RhdGljIGVuY29kZUhUTUxBdHRyaWJ1dGUoczogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZU1hcCA9IHtcclxuICAgICAgJyYnOiAnJmFtcDsnLFxyXG4gICAgICAnPCc6ICcmbHQ7JyxcclxuICAgICAgJz4nOiAnJmd0OycsXHJcbiAgICAgICdcIic6ICcmcXVvdDsnLFxyXG4gICAgICBcIidcIjogJyZhcG9zOycsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWyY8PidcIl0vZywgYyA9PiBhdHRyaWJ1dGVNYXBbY10pO1xyXG4gIH1cclxufVxyXG4iXX0=