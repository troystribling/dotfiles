Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _atom = require('atom');

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// Public: Class that contains a number of helper methods for general conversions
// between the language server protocol and Atom/Atom packages.
class Convert {
  // Public: Convert a path to a Uri.
  //
  // * `filePath` A file path to convert to a Uri.
  //
  // Returns the Uri corresponding to the path. e.g. file:///a/b/c.txt
  static pathToUri(filePath) {
    let newPath = filePath.replace(/\\/g, '/');
    if (newPath[0] !== '/') {
      newPath = `/${newPath}`;
    }
    return encodeURI(`file://${newPath}`).replace(/[?#]/g, encodeURIComponent);
  }

  // Public: Convert a Uri to a path.
  //
  // * `uri` A Uri to convert to a file path.
  //
  // Returns a file path corresponding to the Uri. e.g. /a/b/c.txt
  // If the Uri does not begin file: then it is returned as-is to allow Atom
  // to deal with http/https sources in the future.
  static uriToPath(uri) {
    const url = _url2.default.parse(uri);
    if (url.protocol !== 'file:' || url.path === undefined) {
      return uri;
    }

    let filePath = decodeURIComponent(url.path);
    if (process.platform === 'win32') {
      // Deal with Windows drive names
      if (filePath[0] === '/') {
        filePath = filePath.substr(1);
      }
      return filePath.replace(/\//g, '\\');
    }
    return filePath;
  }

  // Public: Convert an Atom {PointObject} to a language server {Position}.
  //
  // * `point` An Atom {PointObject} to convert from.
  //
  // Returns the {Position} representation of the Atom {PointObject}.
  static pointToPosition(point) {
    return { line: point.row, character: point.column };
  }

  // Public: Convert a language server {Position} into an Atom {PointObject}.
  //
  // * 'position' A language server {Position} to convert from.
  //
  // Returns the Atom {PointObject} representation of the given {Position}.
  static positionToPoint(position) {
    return new _atom.Point(position.line, position.character);
  }

  // Public: Convert a language server {Range} into an Atom {Range}.
  //
  // * 'range' A language server {Range} to convert from.
  //
  // Returns the Atom {Range} representation of the given language server {Range}.
  static lsRangeToAtomRange(range) {
    return new _atom.Range(Convert.positionToPoint(range.start), Convert.positionToPoint(range.end));
  }

  // Public: Convert an Atom {Range} into an language server {Range}.
  //
  // * 'range' An Atom {Range} to convert from.
  //
  // Returns the language server {Range} representation of the given Atom {Range}.
  static atomRangeToLSRange(range) {
    return {
      start: Convert.pointToPosition(range.start),
      end: Convert.pointToPosition(range.end)
    };
  }

  // Public: Create a {TextDocumentIdentifier} from an Atom {TextEditor}.
  //
  // * `editor` A {TextEditor} that will be used to form the uri property.
  //
  // Returns a {TextDocumentIdentifier} that has a `uri` property with the Uri for the
  // given editor's path.
  static editorToTextDocumentIdentifier(editor) {
    return { uri: Convert.pathToUri(editor.getPath() || '') };
  }

  // Public: Create a {TextDocumentPositionParams} from a {TextEditor} and optional {Point}.
  //
  // * `editor` A {TextEditor} that will be used to form the uri property.
  // * `point`  An optional {Point} that will supply the position property. If not specified
  //            the current cursor position will be used.
  //
  // Returns a {TextDocumentPositionParams} that has textDocument property with the editors {TextDocumentIdentifier}
  // and a position property with the supplied point (or current cursor position when not specified).
  static editorToTextDocumentPositionParams(editor, point) {
    return {
      textDocument: Convert.editorToTextDocumentIdentifier(editor),
      position: Convert.pointToPosition(point != null ? point : editor.getCursorBufferPosition())
    };
  }

  // Public: Create a string of scopes for the atom text editor using the data-grammar selector from an
  // {Array} of grammarScope strings.
  //
  // * `grammarScopes` An {Array} of grammar scope string to convert from.
  //
  // Returns a single comma-separated list of CSS selectors targetting the grammars of Atom text editors.
  // e.g. `['c', 'cpp']` => `'atom-text-editor[data-grammar='c'], atom-text-editor[data-grammar='cpp']`
  static grammarScopesToTextEditorScopes(grammarScopes) {
    return grammarScopes.map(g => `atom-text-editor[data-grammar="${Convert.encodeHTMLAttribute(g.replace(/\./g, ' '))}"]`).join(', ');
  }

  // Public: Encode a string so that it can be safely used within a HTML attribute - i.e. replacing all quoted
  // values with their HTML entity encoded versions.  e.g. `Hello"` becomes `Hello&quot;`
  //
  // * 's' A string to be encoded.
  //
  // Returns a string that is HTML attribute encoded by replacing &, <, >, " and ' with their HTML entity
  // named equivalents.
  static encodeHTMLAttribute(s) {
    const attributeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&apos;'
    };
    return s.replace(/[&<>'"]/g, c => attributeMap[c]);
  }

  // Public: Convert an Atom File Event as received from atom.project.onDidChangeFiles and convert
  // it into an Array of Language Server Protocol {FileEvent} objects. Normally this will be a 1-to-1
  // but renames will be represented by a deletion and a subsequent creation as LSP does not know about
  // renames.
  //
  // * 'fileEvent' An {atom$ProjectFileEvent} to be converted.
  //
  // Returns an array of LSP {ls.FileEvent} objects that equivalent conversions to the fileEvent parameter.
  static atomFileEventToLSFileEvents(fileEvent) {
    switch (fileEvent.action) {
      case 'created':
        return [{ uri: Convert.pathToUri(fileEvent.path), type: ls.FileChangeType.Created }];
      case 'modified':
        return [{ uri: Convert.pathToUri(fileEvent.path), type: ls.FileChangeType.Changed }];
      case 'deleted':
        return [{ uri: Convert.pathToUri(fileEvent.path), type: ls.FileChangeType.Deleted }];
      case 'renamed':
        {
          const results = [];
          if (fileEvent.oldPath) {
            results.push({ uri: Convert.pathToUri(fileEvent.oldPath || ''), type: ls.FileChangeType.Deleted });
          }
          if (fileEvent.path) {
            results.push({ uri: Convert.pathToUri(fileEvent.path), type: ls.FileChangeType.Created });
          }
          return results;
        }
      default:
        return [];
    }
  }

  static atomIdeDiagnosticToLSDiagnostic(diagnostic) {
    return {
      range: Convert.atomRangeToLSRange(diagnostic.range),
      severity: Convert.diagnosticTypeToLSSeverity(diagnostic.type),
      source: diagnostic.providerName,
      message: diagnostic.text || ''
    };
  }

  static diagnosticTypeToLSSeverity(type) {
    switch (type) {
      case 'Error':
        return ls.DiagnosticSeverity.Error;
      case 'Warning':
        return ls.DiagnosticSeverity.Warning;
      case 'Info':
        return ls.DiagnosticSeverity.Information;
      default:
        type;
        throw Error(`Unexpected diagnostic type ${type}`);
    }
  }

  // Public: Convert an array of language server protocol {TextEdit} objects to an
  // equivalent array of Atom {TextEdit} objects.
  //
  // * `textEdits` The language server protocol {TextEdit} objects to convert.
  //
  // Returns an {Array} of Atom {TextEdit} objects.
  static convertLsTextEdits(textEdits) {
    return (textEdits || []).map(Convert.convertLsTextEdit);
  }

  // Public: Convert a language server protocol {TextEdit} object to the
  // Atom equivalent {TextEdit}.
  //
  // * `textEdits` The language server protocol {TextEdit} objects to convert.
  //
  // Returns an Atom {TextEdit} object.
  static convertLsTextEdit(textEdit) {
    return {
      oldRange: Convert.lsRangeToAtomRange(textEdit.range),
      newText: textEdit.newText
    };
  }
}
exports.default = Convert;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9jb252ZXJ0LmpzIl0sIm5hbWVzIjpbImxzIiwiQ29udmVydCIsInBhdGhUb1VyaSIsImZpbGVQYXRoIiwibmV3UGF0aCIsInJlcGxhY2UiLCJlbmNvZGVVUkkiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ1cmlUb1BhdGgiLCJ1cmkiLCJ1cmwiLCJwYXJzZSIsInByb3RvY29sIiwicGF0aCIsInVuZGVmaW5lZCIsImRlY29kZVVSSUNvbXBvbmVudCIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsInN1YnN0ciIsInBvaW50VG9Qb3NpdGlvbiIsInBvaW50IiwibGluZSIsInJvdyIsImNoYXJhY3RlciIsImNvbHVtbiIsInBvc2l0aW9uVG9Qb2ludCIsInBvc2l0aW9uIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwicmFuZ2UiLCJzdGFydCIsImVuZCIsImF0b21SYW5nZVRvTFNSYW5nZSIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsImVkaXRvciIsImdldFBhdGgiLCJlZGl0b3JUb1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIiwidGV4dERvY3VtZW50IiwiZ2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24iLCJncmFtbWFyU2NvcGVzVG9UZXh0RWRpdG9yU2NvcGVzIiwiZ3JhbW1hclNjb3BlcyIsIm1hcCIsImciLCJlbmNvZGVIVE1MQXR0cmlidXRlIiwiam9pbiIsInMiLCJhdHRyaWJ1dGVNYXAiLCJjIiwiYXRvbUZpbGVFdmVudFRvTFNGaWxlRXZlbnRzIiwiZmlsZUV2ZW50IiwiYWN0aW9uIiwidHlwZSIsIkZpbGVDaGFuZ2VUeXBlIiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwicmVzdWx0cyIsIm9sZFBhdGgiLCJwdXNoIiwiYXRvbUlkZURpYWdub3N0aWNUb0xTRGlhZ25vc3RpYyIsImRpYWdub3N0aWMiLCJzZXZlcml0eSIsImRpYWdub3N0aWNUeXBlVG9MU1NldmVyaXR5Iiwic291cmNlIiwicHJvdmlkZXJOYW1lIiwibWVzc2FnZSIsInRleHQiLCJEaWFnbm9zdGljU2V2ZXJpdHkiLCJFcnJvciIsIldhcm5pbmciLCJJbmZvcm1hdGlvbiIsImNvbnZlcnRMc1RleHRFZGl0cyIsInRleHRFZGl0cyIsImNvbnZlcnRMc1RleHRFZGl0IiwidGV4dEVkaXQiLCJvbGRSYW5nZSIsIm5ld1RleHQiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7SUFBWUEsRTs7QUFDWjs7QUFDQTs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUMsT0FBTixDQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxTQUFQLENBQWlCQyxRQUFqQixFQUEyQztBQUN6QyxRQUFJQyxVQUFVRCxTQUFTRSxPQUFULENBQWlCLEtBQWpCLEVBQXdCLEdBQXhCLENBQWQ7QUFDQSxRQUFJRCxRQUFRLENBQVIsTUFBZSxHQUFuQixFQUF3QjtBQUN0QkEsZ0JBQVcsSUFBR0EsT0FBUSxFQUF0QjtBQUNEO0FBQ0QsV0FBT0UsVUFBVyxVQUFTRixPQUFRLEVBQTVCLEVBQStCQyxPQUEvQixDQUF1QyxPQUF2QyxFQUFnREUsa0JBQWhELENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFNBQVAsQ0FBaUJDLEdBQWpCLEVBQXNDO0FBQ3BDLFVBQU1DLE1BQU0sY0FBSUMsS0FBSixDQUFVRixHQUFWLENBQVo7QUFDQSxRQUFJQyxJQUFJRSxRQUFKLEtBQWlCLE9BQWpCLElBQTRCRixJQUFJRyxJQUFKLEtBQWFDLFNBQTdDLEVBQXdEO0FBQ3RELGFBQU9MLEdBQVA7QUFDRDs7QUFFRCxRQUFJTixXQUFXWSxtQkFBbUJMLElBQUlHLElBQXZCLENBQWY7QUFDQSxRQUFJRyxRQUFRQyxRQUFSLEtBQXFCLE9BQXpCLEVBQWtDO0FBQ2hDO0FBQ0EsVUFBSWQsU0FBUyxDQUFULE1BQWdCLEdBQXBCLEVBQXlCO0FBQ3ZCQSxtQkFBV0EsU0FBU2UsTUFBVCxDQUFnQixDQUFoQixDQUFYO0FBQ0Q7QUFDRCxhQUFP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LElBQVI7QUFDRSxXQUFLLE9BQUw7QUFDRSxlQUFPbEQsR0FBR2tFLGtCQUFILENBQXNCQyxLQUE3QjtBQUNGLFdBQUssU0FBTDtBQUNFLGVBQU9uRSxHQUFHa0Usa0JBQUgsQ0FBc0JFLE9BQTdCO0FBQ0YsV0FBSyxNQUFMO0FBQ0UsZUFBT3BFLEdBQUdrRSxrQkFBSCxDQUFzQkcsV0FBN0I7QUFDRjtBQUNHbkIsWUFBRDtBQUNBLGNBQU1pQixNQUFPLDhCQUE2QmpCLElBQUssRUFBekMsQ0FBTjtBQVRKO0FBV0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT29CLGtCQUFQLENBQTBCQyxTQUExQixFQUFtRjtBQUNqRixXQUFPLENBQUNBLGFBQWEsRUFBZCxFQUFrQi9CLEdBQWxCLENBQXNCdkMsUUFBUXVFLGlCQUE5QixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0EsaUJBQVAsQ0FBeUJDLFFBQXpCLEVBQWtFO0FBQ2hFLFdBQU87QUFDTEMsZ0JBQVV6RSxRQUFRMEIsa0JBQVIsQ0FBMkI4QyxTQUFTN0MsS0FBcEMsQ0FETDtBQUVMK0MsZUFBU0YsU0FBU0U7QUFGYixLQUFQO0FBSUQ7QUFuTjBCO2tCQUFSMUUsTyIsImZpbGUiOiJjb252ZXJ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCAqIGFzIGxzIGZyb20gJy4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQge1BvaW50LCBSYW5nZX0gZnJvbSAnYXRvbSc7XHJcbmltcG9ydCBVUkwgZnJvbSAndXJsJztcclxuXHJcbi8vIFB1YmxpYzogQ2xhc3MgdGhhdCBjb250YWlucyBhIG51bWJlciBvZiBoZWxwZXIgbWV0aG9kcyBmb3IgZ2VuZXJhbCBjb252ZXJzaW9uc1xyXG4vLyBiZXR3ZWVuIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgYW5kIEF0b20vQXRvbSBwYWNrYWdlcy5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udmVydCB7XHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgcGF0aCB0byBhIFVyaS5cclxuICAvL1xyXG4gIC8vICogYGZpbGVQYXRoYCBBIGZpbGUgcGF0aCB0byBjb252ZXJ0IHRvIGEgVXJpLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUgVXJpIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHBhdGguIGUuZy4gZmlsZTovLy9hL2IvYy50eHRcclxuICBzdGF0aWMgcGF0aFRvVXJpKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgbGV0IG5ld1BhdGggPSBmaWxlUGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XHJcbiAgICBpZiAobmV3UGF0aFswXSAhPT0gJy8nKSB7XHJcbiAgICAgIG5ld1BhdGggPSBgLyR7bmV3UGF0aH1gO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuY29kZVVSSShgZmlsZTovLyR7bmV3UGF0aH1gKS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBVcmkgdG8gYSBwYXRoLlxyXG4gIC8vXHJcbiAgLy8gKiBgdXJpYCBBIFVyaSB0byBjb252ZXJ0IHRvIGEgZmlsZSBwYXRoLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIGZpbGUgcGF0aCBjb3JyZXNwb25kaW5nIHRvIHRoZSBVcmkuIGUuZy4gL2EvYi9jLnR4dFxyXG4gIC8vIElmIHRoZSBVcmkgZG9lcyBub3QgYmVnaW4gZmlsZTogdGhlbiBpdCBpcyByZXR1cm5lZCBhcy1pcyB0byBhbGxvdyBBdG9tXHJcbiAgLy8gdG8gZGVhbCB3aXRoIGh0dHAvaHR0cHMgc291cmNlcyBpbiB0aGUgZnV0dXJlLlxyXG4gIHN0YXRpYyB1cmlUb1BhdGgodXJpOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgdXJsID0gVVJMLnBhcnNlKHVyaSk7XHJcbiAgICBpZiAodXJsLnByb3RvY29sICE9PSAnZmlsZTonIHx8IHVybC5wYXRoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHVyaTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgZmlsZVBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodXJsLnBhdGgpO1xyXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcclxuICAgICAgLy8gRGVhbCB3aXRoIFdpbmRvd3MgZHJpdmUgbmFtZXNcclxuICAgICAgaWYgKGZpbGVQYXRoWzBdID09PSAnLycpIHtcclxuICAgICAgICBmaWxlUGF0aCA9IGZpbGVQYXRoLnN1YnN0cigxKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZSgvXFwvL2csICdcXFxcJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmlsZVBhdGg7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gQXRvbSB7UG9pbnRPYmplY3R9IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHtQb3NpdGlvbn0uXHJcbiAgLy9cclxuICAvLyAqIGBwb2ludGAgQW4gQXRvbSB7UG9pbnRPYmplY3R9IHRvIGNvbnZlcnQgZnJvbS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgdGhlIHtQb3NpdGlvbn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIEF0b20ge1BvaW50T2JqZWN0fS5cclxuICBzdGF0aWMgcG9pbnRUb1Bvc2l0aW9uKHBvaW50OiBhdG9tJFBvaW50T2JqZWN0KTogbHMuUG9zaXRpb24ge1xyXG4gICAgcmV0dXJuIHtsaW5lOiBwb2ludC5yb3csIGNoYXJhY3RlcjogcG9pbnQuY29sdW1ufTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIGxhbmd1YWdlIHNlcnZlciB7UG9zaXRpb259IGludG8gYW4gQXRvbSB7UG9pbnRPYmplY3R9LlxyXG4gIC8vXHJcbiAgLy8gKiAncG9zaXRpb24nIEEgbGFuZ3VhZ2Ugc2VydmVyIHtQb3NpdGlvbn0gdG8gY29udmVydCBmcm9tLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUgQXRvbSB7UG9pbnRPYmplY3R9IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB7UG9zaXRpb259LlxyXG4gIHN0YXRpYyBwb3NpdGlvblRvUG9pbnQocG9zaXRpb246IGxzLlBvc2l0aW9uKTogYXRvbSRQb2ludCB7XHJcbiAgICByZXR1cm4gbmV3IFBvaW50KHBvc2l0aW9uLmxpbmUsIHBvc2l0aW9uLmNoYXJhY3Rlcik7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBsYW5ndWFnZSBzZXJ2ZXIge1JhbmdlfSBpbnRvIGFuIEF0b20ge1JhbmdlfS5cclxuICAvL1xyXG4gIC8vICogJ3JhbmdlJyBBIGxhbmd1YWdlIHNlcnZlciB7UmFuZ2V9IHRvIGNvbnZlcnQgZnJvbS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgdGhlIEF0b20ge1JhbmdlfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyIHtSYW5nZX0uXHJcbiAgc3RhdGljIGxzUmFuZ2VUb0F0b21SYW5nZShyYW5nZTogbHMuUmFuZ2UpOiBhdG9tJFJhbmdlIHtcclxuICAgIHJldHVybiBuZXcgUmFuZ2UoQ29udmVydC5wb3NpdGlvblRvUG9pbnQocmFuZ2Uuc3RhcnQpLCBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChyYW5nZS5lbmQpKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBBdG9tIHtSYW5nZX0gaW50byBhbiBsYW5ndWFnZSBzZXJ2ZXIge1JhbmdlfS5cclxuICAvL1xyXG4gIC8vICogJ3JhbmdlJyBBbiBBdG9tIHtSYW5nZX0gdG8gY29udmVydCBmcm9tLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHtSYW5nZX0gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIEF0b20ge1JhbmdlfS5cclxuICBzdGF0aWMgYXRvbVJhbmdlVG9MU1JhbmdlKHJhbmdlOiBhdG9tJFJhbmdlKTogbHMuUmFuZ2Uge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhcnQ6IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHJhbmdlLnN0YXJ0KSxcclxuICAgICAgZW5kOiBDb252ZXJ0LnBvaW50VG9Qb3NpdGlvbihyYW5nZS5lbmQpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1RleHREb2N1bWVudElkZW50aWZpZXJ9IGZyb20gYW4gQXRvbSB7VGV4dEVkaXRvcn0uXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGZvcm0gdGhlIHVyaSBwcm9wZXJ0eS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7VGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhhdCBoYXMgYSBgdXJpYCBwcm9wZXJ0eSB3aXRoIHRoZSBVcmkgZm9yIHRoZVxyXG4gIC8vIGdpdmVuIGVkaXRvcidzIHBhdGguXHJcbiAgc3RhdGljIGVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IGxzLlRleHREb2N1bWVudElkZW50aWZpZXIge1xyXG4gICAgcmV0dXJuIHt1cmk6IENvbnZlcnQucGF0aFRvVXJpKGVkaXRvci5nZXRQYXRoKCkgfHwgJycpfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfSBmcm9tIGEge1RleHRFZGl0b3J9IGFuZCBvcHRpb25hbCB7UG9pbnR9LlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0aGF0IHdpbGwgYmUgdXNlZCB0byBmb3JtIHRoZSB1cmkgcHJvcGVydHkuXHJcbiAgLy8gKiBgcG9pbnRgICBBbiBvcHRpb25hbCB7UG9pbnR9IHRoYXQgd2lsbCBzdXBwbHkgdGhlIHBvc2l0aW9uIHByb3BlcnR5LiBJZiBub3Qgc3BlY2lmaWVkXHJcbiAgLy8gICAgICAgICAgICB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gd2lsbCBiZSB1c2VkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc30gdGhhdCBoYXMgdGV4dERvY3VtZW50IHByb3BlcnR5IHdpdGggdGhlIGVkaXRvcnMge1RleHREb2N1bWVudElkZW50aWZpZXJ9XHJcbiAgLy8gYW5kIGEgcG9zaXRpb24gcHJvcGVydHkgd2l0aCB0aGUgc3VwcGxpZWQgcG9pbnQgKG9yIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIHdoZW4gbm90IHNwZWNpZmllZCkuXHJcbiAgc3RhdGljIGVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoXHJcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICAgIHBvaW50OiA/YXRvbSRQb2ludCxcclxuICApOiBscy5UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICAgIHBvc2l0aW9uOiBDb252ZXJ0LnBvaW50VG9Qb3NpdGlvbihwb2ludCAhPSBudWxsID8gcG9pbnQgOiBlZGl0b3IuZ2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24oKSksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSBzdHJpbmcgb2Ygc2NvcGVzIGZvciB0aGUgYXRvbSB0ZXh0IGVkaXRvciB1c2luZyB0aGUgZGF0YS1ncmFtbWFyIHNlbGVjdG9yIGZyb20gYW5cclxuICAvLyB7QXJyYXl9IG9mIGdyYW1tYXJTY29wZSBzdHJpbmdzLlxyXG4gIC8vXHJcbiAgLy8gKiBgZ3JhbW1hclNjb3Blc2AgQW4ge0FycmF5fSBvZiBncmFtbWFyIHNjb3BlIHN0cmluZyB0byBjb252ZXJ0IGZyb20uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc2luZ2xlIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIENTUyBzZWxlY3RvcnMgdGFyZ2V0dGluZyB0aGUgZ3JhbW1hcnMgb2YgQXRvbSB0ZXh0IGVkaXRvcnMuXHJcbiAgLy8gZS5nLiBgWydjJywgJ2NwcCddYCA9PiBgJ2F0b20tdGV4dC1lZGl0b3JbZGF0YS1ncmFtbWFyPSdjJ10sIGF0b20tdGV4dC1lZGl0b3JbZGF0YS1ncmFtbWFyPSdjcHAnXWBcclxuICBzdGF0aWMgZ3JhbW1hclNjb3Blc1RvVGV4dEVkaXRvclNjb3BlcyhncmFtbWFyU2NvcGVzOiBBcnJheTxzdHJpbmc+KTogc3RyaW5nIHtcclxuICAgIHJldHVybiBncmFtbWFyU2NvcGVzXHJcbiAgICAgIC5tYXAoZyA9PiBgYXRvbS10ZXh0LWVkaXRvcltkYXRhLWdyYW1tYXI9XCIke0NvbnZlcnQuZW5jb2RlSFRNTEF0dHJpYnV0ZShnLnJlcGxhY2UoL1xcLi9nLCAnICcpKX1cIl1gKVxyXG4gICAgICAuam9pbignLCAnKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogRW5jb2RlIGEgc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGJlIHNhZmVseSB1c2VkIHdpdGhpbiBhIEhUTUwgYXR0cmlidXRlIC0gaS5lLiByZXBsYWNpbmcgYWxsIHF1b3RlZFxyXG4gIC8vIHZhbHVlcyB3aXRoIHRoZWlyIEhUTUwgZW50aXR5IGVuY29kZWQgdmVyc2lvbnMuICBlLmcuIGBIZWxsb1wiYCBiZWNvbWVzIGBIZWxsbyZxdW90O2BcclxuICAvL1xyXG4gIC8vICogJ3MnIEEgc3RyaW5nIHRvIGJlIGVuY29kZWQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgSFRNTCBhdHRyaWJ1dGUgZW5jb2RlZCBieSByZXBsYWNpbmcgJiwgPCwgPiwgXCIgYW5kICcgd2l0aCB0aGVpciBIVE1MIGVudGl0eVxyXG4gIC8vIG5hbWVkIGVxdWl2YWxlbnRzLlxyXG4gIHN0YXRpYyBlbmNvZGVIVE1MQXR0cmlidXRlKHM6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBhdHRyaWJ1dGVNYXAgPSB7XHJcbiAgICAgICcmJzogJyZhbXA7JyxcclxuICAgICAgJzwnOiAnJmx0OycsXHJcbiAgICAgICc+JzogJyZndDsnLFxyXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcclxuICAgICAgXCInXCI6ICcmYXBvczsnLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBzLnJlcGxhY2UoL1smPD4nXCJdL2csIGMgPT4gYXR0cmlidXRlTWFwW2NdKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBBdG9tIEZpbGUgRXZlbnQgYXMgcmVjZWl2ZWQgZnJvbSBhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VGaWxlcyBhbmQgY29udmVydFxyXG4gIC8vIGl0IGludG8gYW4gQXJyYXkgb2YgTGFuZ3VhZ2UgU2VydmVyIFByb3RvY29sIHtGaWxlRXZlbnR9IG9iamVjdHMuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSBhIDEtdG8tMVxyXG4gIC8vIGJ1dCByZW5hbWVzIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgYSBkZWxldGlvbiBhbmQgYSBzdWJzZXF1ZW50IGNyZWF0aW9uIGFzIExTUCBkb2VzIG5vdCBrbm93IGFib3V0XHJcbiAgLy8gcmVuYW1lcy5cclxuICAvL1xyXG4gIC8vICogJ2ZpbGVFdmVudCcgQW4ge2F0b20kUHJvamVjdEZpbGVFdmVudH0gdG8gYmUgY29udmVydGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBMU1Age2xzLkZpbGVFdmVudH0gb2JqZWN0cyB0aGF0IGVxdWl2YWxlbnQgY29udmVyc2lvbnMgdG8gdGhlIGZpbGVFdmVudCBwYXJhbWV0ZXIuXHJcbiAgc3RhdGljIGF0b21GaWxlRXZlbnRUb0xTRmlsZUV2ZW50cyhmaWxlRXZlbnQ6IGF0b20kUHJvamVjdEZpbGVFdmVudCk6IGxzLkZpbGVFdmVudFtdIHtcclxuICAgIHN3aXRjaCAoZmlsZUV2ZW50LmFjdGlvbikge1xyXG4gICAgICBjYXNlICdjcmVhdGVkJzpcclxuICAgICAgICByZXR1cm4gW3t1cmk6IENvbnZlcnQucGF0aFRvVXJpKGZpbGVFdmVudC5wYXRoKSwgdHlwZTogbHMuRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZH1dO1xyXG4gICAgICBjYXNlICdtb2RpZmllZCc6XHJcbiAgICAgICAgcmV0dXJuIFt7dXJpOiBDb252ZXJ0LnBhdGhUb1VyaShmaWxlRXZlbnQucGF0aCksIHR5cGU6IGxzLkZpbGVDaGFuZ2VUeXBlLkNoYW5nZWR9XTtcclxuICAgICAgY2FzZSAnZGVsZXRlZCc6XHJcbiAgICAgICAgcmV0dXJuIFt7dXJpOiBDb252ZXJ0LnBhdGhUb1VyaShmaWxlRXZlbnQucGF0aCksIHR5cGU6IGxzLkZpbGVDaGFuZ2VUeXBlLkRlbGV0ZWR9XTtcclxuICAgICAgY2FzZSAncmVuYW1lZCc6IHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgaWYgKGZpbGVFdmVudC5vbGRQYXRoKSB7XHJcbiAgICAgICAgICByZXN1bHRzLnB1c2goe3VyaTogQ29udmVydC5wYXRoVG9VcmkoZmlsZUV2ZW50Lm9sZFBhdGggfHwgJycpLCB0eXBlOiBscy5GaWxlQ2hhbmdlVHlwZS5EZWxldGVkfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWxlRXZlbnQucGF0aCkge1xyXG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHt1cmk6IENvbnZlcnQucGF0aFRvVXJpKGZpbGVFdmVudC5wYXRoKSwgdHlwZTogbHMuRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgfVxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBhdG9tSWRlRGlhZ25vc3RpY1RvTFNEaWFnbm9zdGljKGRpYWdub3N0aWM6IGF0b21JZGUkRGlhZ25vc3RpYyk6IGxzLkRpYWdub3N0aWMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmFuZ2U6IENvbnZlcnQuYXRvbVJhbmdlVG9MU1JhbmdlKGRpYWdub3N0aWMucmFuZ2UpLFxyXG4gICAgICBzZXZlcml0eTogQ29udmVydC5kaWFnbm9zdGljVHlwZVRvTFNTZXZlcml0eShkaWFnbm9zdGljLnR5cGUpLFxyXG4gICAgICBzb3VyY2U6IGRpYWdub3N0aWMucHJvdmlkZXJOYW1lLFxyXG4gICAgICBtZXNzYWdlOiBkaWFnbm9zdGljLnRleHQgfHwgJycsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGRpYWdub3N0aWNUeXBlVG9MU1NldmVyaXR5KHR5cGU6IGF0b21JZGUkRGlhZ25vc3RpY1R5cGUpOiAkVmFsdWVzPHR5cGVvZiBscy5EaWFnbm9zdGljU2V2ZXJpdHk+IHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICBjYXNlICdFcnJvcic6XHJcbiAgICAgICAgcmV0dXJuIGxzLkRpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcclxuICAgICAgY2FzZSAnV2FybmluZyc6XHJcbiAgICAgICAgcmV0dXJuIGxzLkRpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xyXG4gICAgICBjYXNlICdJbmZvJzpcclxuICAgICAgICByZXR1cm4gbHMuRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgICh0eXBlOiBlbXB0eSk7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgZGlhZ25vc3RpYyB0eXBlICR7dHlwZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBhcnJheSBvZiBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wge1RleHRFZGl0fSBvYmplY3RzIHRvIGFuXHJcbiAgLy8gZXF1aXZhbGVudCBhcnJheSBvZiBBdG9tIHtUZXh0RWRpdH0gb2JqZWN0cy5cclxuICAvL1xyXG4gIC8vICogYHRleHRFZGl0c2AgVGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCB7VGV4dEVkaXR9IG9iamVjdHMgdG8gY29udmVydC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYW4ge0FycmF5fSBvZiBBdG9tIHtUZXh0RWRpdH0gb2JqZWN0cy5cclxuICBzdGF0aWMgY29udmVydExzVGV4dEVkaXRzKHRleHRFZGl0czogP0FycmF5PGxzLlRleHRFZGl0Pik6IEFycmF5PGF0b21JZGUkVGV4dEVkaXQ+IHtcclxuICAgIHJldHVybiAodGV4dEVkaXRzIHx8IFtdKS5tYXAoQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdCk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wge1RleHRFZGl0fSBvYmplY3QgdG8gdGhlXHJcbiAgLy8gQXRvbSBlcXVpdmFsZW50IHtUZXh0RWRpdH0uXHJcbiAgLy9cclxuICAvLyAqIGB0ZXh0RWRpdHNgIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wge1RleHRFZGl0fSBvYmplY3RzIHRvIGNvbnZlcnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIEF0b20ge1RleHRFZGl0fSBvYmplY3QuXHJcbiAgc3RhdGljIGNvbnZlcnRMc1RleHRFZGl0KHRleHRFZGl0OiBscy5UZXh0RWRpdCk6IGF0b21JZGUkVGV4dEVkaXQge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb2xkUmFuZ2U6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKHRleHRFZGl0LnJhbmdlKSxcclxuICAgICAgbmV3VGV4dDogdGV4dEVkaXQubmV3VGV4dCxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdfQ==