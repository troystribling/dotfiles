Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           Optional file length in bytes for cases where the server will not supply the
//                      Content-Length header but the value is known in advance. Without either the
//                      percentage on the callback can not be determined.
//
// Returns a {Promise} that will accept when complete.
exports.default = async function downloadFile(sourceUrl, targetFile, progressCallback, length) {
  const request = new Request(sourceUrl, {
    headers: new Headers({ 'Content-Type': 'application/octet-stream' })
  });

  const response = await fetch(request);
  if (!response.ok) {
    throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
  }

  const body = response.body;
  if (body == null) {
    throw Error('No response body');
  }

  const finalLength = length || parseInt(response.headers.get('Content-Length' || '0'), 10);
  const reader = body.getReader();
  const writer = _fs2.default.createWriteStream(targetFile);

  await streamWithProgress(finalLength, reader, writer, progressCallback);
  writer.end();
};

// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `targwriteretFile` {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.


async function streamWithProgress(length, reader, writer, progressCallback) {
  let bytesDone = 0;

  while (true) {
    const result = await reader.read();
    if (result.done) {
      if (progressCallback != null) {
        progressCallback(length, 100);
      }
      return;
    }

    const chunk = result.value;
    if (chunk == null) {
      throw Error('Empty chunk received during download');
    } else {
      writer.write(Buffer.from(chunk));
      if (progressCallback != null) {
        bytesDone += chunk.byteLength;
        const percent = length === 0 ? null : Math.floor(bytesDone / length * 100);
        progressCallback(bytesDone, percent);
      }
    }
  }
}

// Public: Progress callback function signature indicating the bytesDone and
// optional percentage when length is known.
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLmpzIl0sIm5hbWVzIjpbImRvd25sb2FkRmlsZSIsInNvdXJjZVVybCIsInRhcmdldEZpbGUiLCJwcm9ncmVzc0NhbGxiYWNrIiwibGVuZ3RoIiwicmVxdWVzdCIsIlJlcXVlc3QiLCJoZWFkZXJzIiwiSGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImJvZHkiLCJmaW5hbExlbmd0aCIsInBhcnNlSW50IiwiZ2V0IiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwid3JpdGVyIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJzdHJlYW1XaXRoUHJvZ3Jlc3MiLCJlbmQiLCJieXRlc0RvbmUiLCJyZXN1bHQiLCJyZWFkIiwiZG9uZSIsImNodW5rIiwidmFsdWUiLCJ3cml0ZSIsIkJ1ZmZlciIsImZyb20iLCJieXRlTGVuZ3RoIiwicGVyY2VudCIsIk1hdGgiLCJmbG9vciJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO2tCQUNnQixlQUFlQSxZQUFmLENBQ2RDLFNBRGMsRUFFZEMsVUFGYyxFQUdkQyxnQkFIYyxFQUlkQyxNQUpjLEVBS0M7QUFDZixRQUFNQyxVQUFVLElBQUlDLE9BQUosQ0FBWUwsU0FBWixFQUF1QjtBQUNyQ00sYUFBUyxJQUFJQyxPQUFKLENBQVksRUFBQyxnQkFBZ0IsMEJBQWpCLEVBQVo7QUFENEIsR0FBdkIsQ0FBaEI7O0FBSUEsUUFBTUMsV0FBVyxNQUFNQyxNQUFNTCxPQUFOLENBQXZCO0FBQ0EsTUFBSSxDQUFDSSxTQUFTRSxFQUFkLEVBQWtCO0FBQ2hCLFVBQU1DLE1BQU8sdUNBQXNDSCxTQUFTSSxNQUFPLElBQUdKLFNBQVNLLFVBQVcsRUFBcEYsQ0FBTjtBQUNEOztBQUVELFFBQU1DLE9BQU9OLFNBQVNNLElBQXRCO0FBQ0EsTUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFVBQU1ILE1BQU0sa0JBQU4sQ0FBTjtBQUNEOztBQUVELFFBQU1JLGNBQWNaLFVBQVVhLFNBQVNSLFNBQVNGLE9BQVQsQ0FBaUJXLEdBQWpCLENBQXFCLG9CQUFvQixHQUF6QyxDQUFULEVBQXdELEVBQXhELENBQTlCO0FBQ0EsUUFBTUMsU0FBU0osS0FBS0ssU0FBTCxFQUFmO0FBQ0EsUUFBTUMsU0FBUyxhQUFHQyxpQkFBSCxDQUFxQnBCLFVBQXJCLENBQWY7O0FBRUEsUUFBTXFCLG1CQUFtQlAsV0FBbkIsRUFBZ0NHLE1BQWhDLEVBQXdDRSxNQUF4QyxFQUFnRGxCLGdCQUFoRCxDQUFOO0FBQ0FrQixTQUFPRyxHQUFQO0FBQ0QsQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGVBQWVELGtCQUFmLENBQ0VuQixNQURGLEVBRUVlLE1BRkYsRUFHRUUsTUFIRixFQUlFbEIsZ0JBSkYsRUFLaUI7QUFDZixNQUFJc0IsWUFBWSxDQUFoQjs7QUFFQSxTQUFPLElBQVAsRUFBYTtBQUNYLFVBQU1DLFNBQVMsTUFBTVAsT0FBT1EsSUFBUCxFQUFyQjtBQUNBLFFBQUlELE9BQU9FLElBQVgsRUFBaUI7QUFDZixVQUFJekIsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCQSx5QkFBaUJDLE1BQWpCLEVBQXlCLEdBQXpCO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFVBQU15QixRQUFRSCxPQUFPSSxLQUFyQjtBQUNBLFFBQUlELFNBQVMsSUFBYixFQUFtQjtBQUNqQixZQUFNakIsTUFBTSxzQ0FBTixDQUFOO0FBQ0QsS0FGRCxNQUVPO0FBQ0xTLGFBQU9VLEtBQVAsQ0FBYUMsT0FBT0MsSUFBUCxDQUFZSixLQUFaLENBQWI7QUFDQSxVQUFJMUIsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCc0IscUJBQWFJLE1BQU1LLFVBQW5CO0FBQ0EsY0FBTUMsVUFBbUIvQixXQUFXLENBQVgsR0FBZSxJQUFmLEdBQXNCZ0MsS0FBS0MsS0FBTCxDQUFXWixZQUFZckIsTUFBWixHQUFxQixHQUFoQyxDQUEvQztBQUNBRCx5QkFBaUJzQixTQUFqQixFQUE0QlUsT0FBNUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBIiwiZmlsZSI6ImRvd25sb2FkLWZpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuXHJcbi8vIFB1YmxpYzogRG93bmxvYWQgYSBmaWxlIGFuZCBzdG9yZSBpdCBvbiBhIGZpbGUgc3lzdGVtIHVzaW5nIHN0cmVhbWluZyB3aXRoIGFwcHJvcHJpYXRlIHByb2dyZXNzIGNhbGxiYWNrLlxyXG4vL1xyXG4vLyAqIGBzb3VyY2VVcmxgICAgICAgICBVcmwgdG8gZG93bmxvYWQgZnJvbS5cclxuLy8gKiBgdGFyZ2V0RmlsZWAgICAgICAgRmlsZSBwYXRoIHRvIHNhdmUgdG8uXHJcbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcclxuLy8gICAgICAgICAgICAgICAgICAgICAgYm90aCBieXRlc0RvbmUgYW5kIHBlcmNlbnQuXHJcbi8vICogYGxlbmd0aGAgICAgICAgICAgIE9wdGlvbmFsIGZpbGUgbGVuZ3RoIGluIGJ5dGVzIGZvciBjYXNlcyB3aGVyZSB0aGUgc2VydmVyIHdpbGwgbm90IHN1cHBseSB0aGVcclxuLy8gICAgICAgICAgICAgICAgICAgICAgQ29udGVudC1MZW5ndGggaGVhZGVyIGJ1dCB0aGUgdmFsdWUgaXMga25vd24gaW4gYWR2YW5jZS4gV2l0aG91dCBlaXRoZXIgdGhlXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2Ugb24gdGhlIGNhbGxiYWNrIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC5cclxuLy9cclxuLy8gUmV0dXJucyBhIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXHJcbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoXHJcbiAgc291cmNlVXJsOiBzdHJpbmcsXHJcbiAgdGFyZ2V0RmlsZTogc3RyaW5nLFxyXG4gIHByb2dyZXNzQ2FsbGJhY2s6ID9CeXRlUHJvZ3Jlc3NDYWxsYmFjayxcclxuICBsZW5ndGg6ID9udW1iZXIsXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChzb3VyY2VVcmwsIHtcclxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSd9KSxcclxuICB9KTtcclxuXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcclxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRvd25sb2FkLCBzZXJ2ZXIgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xyXG4gIGlmIChib2R5ID09IG51bGwpIHtcclxuICAgIHRocm93IEVycm9yKCdObyByZXNwb25zZSBib2R5Jyk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBmaW5hbExlbmd0aCA9IGxlbmd0aCB8fCBwYXJzZUludChyZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1MZW5ndGgnIHx8ICcwJyksIDEwKTtcclxuICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xyXG4gIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldEZpbGUpO1xyXG5cclxuICBhd2FpdCBzdHJlYW1XaXRoUHJvZ3Jlc3MoZmluYWxMZW5ndGgsIHJlYWRlciwgd3JpdGVyLCBwcm9ncmVzc0NhbGxiYWNrKTtcclxuICB3cml0ZXIuZW5kKCk7XHJcbn0pO1xyXG5cclxuLy8gU3RyZWFtIGZyb20gYSB7UmVhZGFibGVTdHJlYW1SZWFkZXJ9IHRvIGEge1dyaXRlU3RyZWFtfSB3aXRoIHByb2dyZXNzIGNhbGxiYWNrLlxyXG4vL1xyXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBGaWxlIGxlbmd0aCBpbiBieXRlcy5cclxuLy8gKiBgcmVhZGVyYCAgICAgICAgICAge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byByZWFkIGZyb20uXHJcbi8vICogYHRhcmd3cml0ZXJldEZpbGVgIHtXcml0ZVN0cmVhbX0gdG8gd3JpdGUgdG8uXHJcbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcclxuLy8gICAgICAgICAgICAgICAgICAgICAgYm90aCBieXRlc0RvbmUgYW5kIHBlcmNlbnQuXHJcbi8vXHJcbi8vIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCB3aWxsIGFjY2VwdCB3aGVuIGNvbXBsZXRlLlxyXG5hc3luYyBmdW5jdGlvbiBzdHJlYW1XaXRoUHJvZ3Jlc3MoXHJcbiAgbGVuZ3RoOiBudW1iZXIsXHJcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcixcclxuICB3cml0ZXI6IGZzLldyaXRlU3RyZWFtLFxyXG4gIHByb2dyZXNzQ2FsbGJhY2s6ID9CeXRlUHJvZ3Jlc3NDYWxsYmFjayxcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgbGV0IGJ5dGVzRG9uZSA9IDA7XHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xyXG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XHJcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGxlbmd0aCwgMTAwKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2h1bmsgPSByZXN1bHQudmFsdWU7XHJcbiAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBFcnJvcignRW1wdHkgY2h1bmsgcmVjZWl2ZWQgZHVyaW5nIGRvd25sb2FkJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cml0ZXIud3JpdGUoQnVmZmVyLmZyb20oY2h1bmspKTtcclxuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgIT0gbnVsbCkge1xyXG4gICAgICAgIGJ5dGVzRG9uZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHBlcmNlbnQ6ID9udW1iZXIgPSBsZW5ndGggPT09IDAgPyBudWxsIDogTWF0aC5mbG9vcihieXRlc0RvbmUgLyBsZW5ndGggKiAxMDApO1xyXG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2soYnl0ZXNEb25lLCBwZXJjZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gUHVibGljOiBQcm9ncmVzcyBjYWxsYmFjayBmdW5jdGlvbiBzaWduYXR1cmUgaW5kaWNhdGluZyB0aGUgYnl0ZXNEb25lIGFuZFxyXG4vLyBvcHRpb25hbCBwZXJjZW50YWdlIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxyXG5leHBvcnQgdHlwZSBCeXRlUHJvZ3Jlc3NDYWxsYmFjayA9IChieXRlc0RvbmU6IG51bWJlciwgcGVyY2VudDogP251bWJlcikgPT4ge307XHJcbiJdfQ==