Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerManager = undefined;

require('./logger');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _convert = require('./convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Manages the language server lifecycles and their associated objects necessary
// for adapting them to Atom IDE.


// The necessary elements for a server that has started or is starting.
class ServerManager {

  constructor(startServer, logger, startForEditor, changeWatchedFileFilter, busySignalServiceGetter, languageServerName) {
    this._activeServers = [];
    this._startingServerPromises = new Map();
    this._restartCounterPerProject = new Map();
    this._stoppingServers = [];
    this._disposable = new _atom.CompositeDisposable();
    this._editorToServer = new Map();
    this._normalizedProjectPaths = [];
    this._isStarted = false;

    this._languageServerName = languageServerName;
    this._startServer = startServer;
    this._logger = logger;
    this._startForEditor = startForEditor;
    this.updateNormalizedProjectPaths();
    this._changeWatchedFileFilter = changeWatchedFileFilter;
    this._getBusySignalService = busySignalServiceGetter;
  }

  startListening() {
    if (!this._isStarted) {
      this._disposable = new _atom.CompositeDisposable();
      this._disposable.add(atom.textEditors.observe(this.observeTextEditors.bind(this)));
      this._disposable.add(atom.project.onDidChangePaths(this.projectPathsChanged.bind(this)));
      if (atom.project.onDidChangeFiles) {
        this._disposable.add(atom.project.onDidChangeFiles(this.projectFilesChanged.bind(this)));
      }
    }
  }

  stopListening() {
    if (this._isStarted) {
      this._disposable.dispose();
      this._isStarted = false;
    }
  }

  observeTextEditors(editor) {
    // Track grammar changes for opened editors
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => listener.dispose()));
    // Try to see if editor can have LS connected to it
    this._handleTextEditor(editor);
  }

  async _handleTextEditor(editor) {
    if (!this._editorToServer.has(editor)) {
      // editor hasn't been processed yet, so process it by allocating LS for it if necessary
      const server = await this.getServer(editor, { shouldStart: true });
      if (server != null) {
        // There LS for the editor (either started now and already running)
        this._editorToServer.set(editor, server);
        this._disposable.add(editor.onDidDestroy(() => {
          this._editorToServer.delete(editor);
          this.stopUnusedServers();
        }));
      }
    }
  }

  _handleGrammarChange(editor) {
    if (this._startForEditor(editor)) {
      // If editor is interesting for LS process the editor further to attempt to start LS if needed
      this._handleTextEditor(editor);
    } else {
      // Editor is not supported by the LS
      const server = this._editorToServer.get(editor);
      // If LS is running for the unsupported editor then disconnect the editor from LS and shut down LS if necessary
      if (server) {
        // LS is up for unsupported server
        if (server.docSyncAdapter) {
          const syncAdapter = server.docSyncAdapter.getEditorSyncAdapter(editor);
          if (syncAdapter) {
            // Immitate editor close to disconnect LS from the editor
            syncAdapter.didClose();
          }
        }
        // Remove editor from the cache
        this._editorToServer.delete(editor);
        // Shut down LS if it's used by any other editor
        this.stopUnusedServers();
      }
    }
  }

  getActiveServers() {
    return this._activeServers.slice();
  }

  async getServer(textEditor, { shouldStart } = { shouldStart: false }) {
    const finalProjectPath = this.determineProjectPath(textEditor);
    if (finalProjectPath == null) {
      // Files not yet saved have no path
      return null;
    }

    const foundActiveServer = this._activeServers.find(s => finalProjectPath === s.projectPath);
    if (foundActiveServer) {
      return foundActiveServer;
    }

    const startingPromise = this._startingServerPromises.get(finalProjectPath);
    if (startingPromise) {
      return startingPromise;
    }

    return shouldStart && this._startForEditor(textEditor) ? await this.startServer(finalProjectPath) : null;
  }

  async startServer(projectPath) {
    this._logger.debug(`Server starting "${projectPath}"`);
    const startingPromise = this._startServer(projectPath);
    this._startingServerPromises.set(projectPath, startingPromise);
    const startedActiveServer = await startingPromise;
    this._activeServers.push(startedActiveServer);
    this._startingServerPromises.delete(projectPath);
    this._logger.debug(`Server started "${projectPath}" (pid ${startedActiveServer.process.pid})`);
    return startedActiveServer;
  }

  async stopUnusedServers() {
    const usedServers = new Set(this._editorToServer.values());
    const unusedServers = this._activeServers.filter(s => !usedServers.has(s));
    if (unusedServers.length > 0) {
      this._logger.debug(`Stopping ${unusedServers.length} unused servers`);
      await Promise.all(unusedServers.map(s => this.stopServer(s)));
    }
  }

  async stopAllServers() {
    for (const [projectPath, restartCounter] of this._restartCounterPerProject) {
      clearTimeout(restartCounter.timerId);
      this._restartCounterPerProject.delete(projectPath);
    }

    await Promise.all(this._activeServers.map(s => this.stopServer(s)));
  }

  async restartAllServers() {
    this.stopListening();
    await this.stopAllServers();
    this._editorToServer = new Map();
    this.startListening();
  }

  hasServerReachedRestartLimit(server) {
    let restartCounter = this._restartCounterPerProject.get(server.projectPath);

    if (!restartCounter) {
      restartCounter = {
        restarts: 0,
        timerId: setTimeout(() => {
          this._restartCounterPerProject.delete(server.projectPath);
        }, 3 * 60 * 1000 /* 3 minutes */)
      };

      this._restartCounterPerProject.set(server.projectPath, restartCounter);
    }

    return ++restartCounter.restarts > 5;
  }

  async stopServer(server) {
    const busySignalService = this._getBusySignalService();
    const signal = busySignalService && busySignalService.reportBusy(`Stopping ${this._languageServerName} for ${_path2.default.basename(server.projectPath)}`);
    try {
      this._logger.debug(`Server stopping "${server.projectPath}"`);
      // Immediately remove the server to prevent further usage.
      // If we re-open the file after this point, we'll get a new server.
      this._activeServers.splice(this._activeServers.indexOf(server), 1);
      this._stoppingServers.push(server);
      server.disposable.dispose();
      if (server.connection.isConnected) {
        await server.connection.shutdown();
      }

      for (const [editor, mappedServer] of this._editorToServer) {
        if (mappedServer === server) {
          this._editorToServer.delete(editor);
        }
      }

      this.exitServer(server);
      this._stoppingServers.splice(this._stoppingServers.indexOf(server), 1);
    } finally {
      signal && signal.dispose();
    }
  }

  exitServer(server) {
    const pid = server.process.pid;
    try {
      if (server.connection.isConnected) {
        server.connection.exit();
        server.connection.dispose();
      }
    } finally {
      server.process.kill();
    }
    this._logger.debug(`Server stopped "${server.projectPath}" (pid ${pid})`);
  }

  terminate() {
    this._stoppingServers.forEach(server => {
      this._logger.debug(`Server terminating "${server.projectPath}"`);
      this.exitServer(server);
    });
  }

  determineProjectPath(textEditor) {
    const filePath = textEditor.getPath();
    if (filePath == null) {
      return null;
    }
    return this._normalizedProjectPaths.find(d => filePath.startsWith(d));
  }

  updateNormalizedProjectPaths() {
    this._normalizedProjectPaths = atom.project.getDirectories().map(d => this.normalizePath(d.getPath()));
  }

  normalizePath(projectPath) {
    return !projectPath.endsWith(_path2.default.sep) ? _path2.default.join(projectPath, _path2.default.sep) : projectPath;
  }

  projectPathsChanged(projectPaths) {
    const pathsSet = new Set(projectPaths.map(this.normalizePath));
    const serversToStop = this._activeServers.filter(s => !pathsSet.has(s.projectPath));
    Promise.all(serversToStop.map(s => this.stopServer(s)));
    this.updateNormalizedProjectPaths();
  }

  projectFilesChanged(fileEvents) {
    if (this._activeServers.length === 0) {
      return;
    }

    for (const activeServer of this._activeServers) {
      const changes = [];
      for (const fileEvent of fileEvents) {
        if (fileEvent.path.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.path)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[0]);
        }
        if (fileEvent.oldPath && fileEvent.oldPath.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.oldPath)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[1]);
        }
      }
      if (changes.length > 0) {
        activeServer.connection.didChangeWatchedFiles({ changes });
      }
    }
  }
}
exports.ServerManager = ServerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9zZXJ2ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJscyIsIlNlcnZlck1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0U2VydmVyIiwibG9nZ2VyIiwic3RhcnRGb3JFZGl0b3IiLCJjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlciIsImJ1c3lTaWduYWxTZXJ2aWNlR2V0dGVyIiwibGFuZ3VhZ2VTZXJ2ZXJOYW1lIiwiX2FjdGl2ZVNlcnZlcnMiLCJfc3RhcnRpbmdTZXJ2ZXJQcm9taXNlcyIsIk1hcCIsIl9yZXN0YXJ0Q291bnRlclBlclByb2plY3QiLCJfc3RvcHBpbmdTZXJ2ZXJzIiwiX2Rpc3Bvc2FibGUiLCJfZWRpdG9yVG9TZXJ2ZXIiLCJfbm9ybWFsaXplZFByb2plY3RQYXRocyIsIl9pc1N0YXJ0ZWQiLCJfbGFuZ3VhZ2VTZXJ2ZXJOYW1lIiwiX3N0YXJ0U2VydmVyIiwiX2xvZ2dlciIsIl9zdGFydEZvckVkaXRvciIsInVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMiLCJfY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIiLCJfZ2V0QnVzeVNpZ25hbFNlcnZpY2UiLCJzdGFydExpc3RlbmluZyIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvcnMiLCJiaW5kIiwicHJvamVjdCIsIm9uRGlkQ2hhbmdlUGF0aHMiLCJwcm9qZWN0UGF0aHNDaGFuZ2VkIiwib25EaWRDaGFuZ2VGaWxlcyIsInByb2plY3RGaWxlc0NoYW5nZWQiLCJzdG9wTGlzdGVuaW5nIiwiZGlzcG9zZSIsImVkaXRvciIsImxpc3RlbmVyIiwib2JzZXJ2ZUdyYW1tYXIiLCJncmFtbWFyIiwiX2hhbmRsZUdyYW1tYXJDaGFuZ2UiLCJvbkRpZERlc3Ryb3kiLCJfaGFuZGxlVGV4dEVkaXRvciIsImhhcyIsInNlcnZlciIsImdldFNlcnZlciIsInNob3VsZFN0YXJ0Iiwic2V0IiwiZGVsZXRlIiwic3RvcFVudXNlZFNlcnZlcnMiLCJnZXQiLCJkb2NTeW5jQWRhcHRlciIsInN5bmNBZGFwdGVyIiwiZ2V0RWRpdG9yU3luY0FkYXB0ZXIiLCJkaWRDbG9zZSIsImdldEFjdGl2ZVNlcnZlcnMiLCJzbGljZSIsInRleHRFZGl0b3IiLCJmaW5hbFByb2plY3RQYXRoIiwiZGV0ZXJtaW5lUHJvamVjdFBhdGgiLCJmb3VuZEFjdGl2ZVNlcnZlciIsImZpbmQiLCJzIiwicHJvamVjdFBhdGgiLCJzdGFydGluZ1Byb21pc2UiLCJkZWJ1ZyIsInN0YXJ0ZWRBY3RpdmVTZXJ2ZXIiLCJwdXNoIiwicHJvY2VzcyIsInBpZCIsInVzZWRTZXJ2ZXJzIiwiU2V0IiwidmFsdWVzIiwidW51c2VkU2VydmVycyIsImZpbHRlciIsImxlbmd0aCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJzdG9wU2VydmVyIiwic3RvcEFsbFNlcnZlcnMiLCJyZXN0YXJ0Q291bnRlciIsImNsZWFyVGltZW91dCIsInRpbWVySWQiLCJyZXN0YXJ0QWxsU2VydmVycyIsImhhc1NlcnZlclJlYWNoZWRSZXN0YXJ0TGltaXQiLCJyZXN0YXJ0cyIsInNldFRpbWVvdXQiLCJidXN5U2lnbmFsU2VydmljZSIsInNpZ25hbCIsInJlcG9ydEJ1c3kiLCJiYXNlbmFtZSIsInNwbGljZSIsImluZGV4T2YiLCJkaXNwb3NhYmxlIiwiY29ubmVjdGlvbiIsImlzQ29ubmVjdGVkIiwic2h1dGRvd24iLCJtYXBwZWRTZXJ2ZXIiLCJleGl0U2VydmVyIiwiZXhpdCIsImtpbGwiLCJ0ZXJtaW5hdGUiLCJmb3JFYWNoIiwiZmlsZVBhdGgiLCJnZXRQYXRoIiwiZCIsInN0YXJ0c1dpdGgiLCJnZXREaXJlY3RvcmllcyIsIm5vcm1hbGl6ZVBhdGgiLCJlbmRzV2l0aCIsInNlcCIsImpvaW4iLCJwcm9qZWN0UGF0aHMiLCJwYXRoc1NldCIsInNlcnZlcnNUb1N0b3AiLCJmaWxlRXZlbnRzIiwiYWN0aXZlU2VydmVyIiwiY2hhbmdlcyIsImZpbGVFdmVudCIsInBhdGgiLCJhdG9tRmlsZUV2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LEVBQTBHO0FBQ3hHRixrQkFBUW5ELElBQVIsQ0FBYSxrQkFBUXNELDJCQUFSLENBQW9DRixTQUFwQyxFQUErQyxDQUEvQyxDQUFiO0FBQ0Q7QUFDRCxZQUNFQSxVQUFVRyxPQUFWLElBQ0FILFVBQVVHLE9BQVYsQ0FBa0JmLFVBQWxCLENBQTZCVSxhQUFhdEQsV0FBMUMsQ0FEQSxJQUVBLEtBQUszQyx3QkFBTCxDQUE4Qm1HLFVBQVVHLE9BQXhDLENBSEYsRUFJRTtBQUNBSixrQkFBUW5ELElBQVIsQ0FBYSxrQkFBUXNELDJCQUFSLENBQW9DRixTQUFwQyxFQUErQyxDQUEvQyxDQUFiO0FBQ0Q7QUFDRjtBQUNELFVBQUlELFFBQVEzQyxNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCMEMscUJBQWF0QixVQUFiLENBQXdCNEIscUJBQXhCLENBQThDLEVBQUNMLE9BQUQsRUFBOUM7QUFDRDtBQUNGO0FBQ0Y7QUFwUndCO1FBQWR4SCxhLEdBQUFBLGEiLCJmaWxlIjoic2VydmVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHt0eXBlIExvZ2dlcn0gZnJvbSAnLi9sb2dnZXInO1xyXG5pbXBvcnQgdHlwZSBMaW50ZXJQdXNoVjJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvbGludGVyLXB1c2gtdjItYWRhcHRlcic7XHJcbmltcG9ydCB0eXBlIERvY3VtZW50U3luY0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXInO1xyXG5pbXBvcnQgdHlwZSBTaWduYXR1cmVIZWxwQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL3NpZ25hdHVyZS1oZWxwLWFkYXB0ZXInO1xyXG5cclxuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIGxzIGZyb20gJy4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuL2NvbnZlcnQnO1xyXG5pbXBvcnQge0NvbXBvc2l0ZURpc3Bvc2FibGV9IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gVGhlIG5lY2Vzc2FyeSBlbGVtZW50cyBmb3IgYSBzZXJ2ZXIgdGhhdCBoYXMgc3RhcnRlZCBvciBpcyBzdGFydGluZy5cclxuZXhwb3J0IHR5cGUgQWN0aXZlU2VydmVyID0ge1xyXG4gIGRpc3Bvc2FibGU6IENvbXBvc2l0ZURpc3Bvc2FibGUsXHJcbiAgcHJvamVjdFBhdGg6IHN0cmluZyxcclxuICBwcm9jZXNzOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2VzcyxcclxuICBjb25uZWN0aW9uOiBscy5MYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgY2FwYWJpbGl0aWVzOiBscy5TZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgbGludGVyUHVzaFYyPzogTGludGVyUHVzaFYyQWRhcHRlcixcclxuICBkb2NTeW5jQWRhcHRlcj86IERvY3VtZW50U3luY0FkYXB0ZXIsXHJcbiAgc2lnbmF0dXJlSGVscEFkYXB0ZXI/OiBTaWduYXR1cmVIZWxwQWRhcHRlcixcclxufTtcclxuXHJcbnR5cGUgUmVzdGFydENvdW50ZXIgPSB7XHJcbiAgcmVzdGFydHM6IG51bWJlcjtcclxuICB0aW1lcklkOiBudW1iZXI7XHJcbn07XHJcblxyXG4vLyBNYW5hZ2VzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgbGlmZWN5Y2xlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBvYmplY3RzIG5lY2Vzc2FyeVxyXG4vLyBmb3IgYWRhcHRpbmcgdGhlbSB0byBBdG9tIElERS5cclxuZXhwb3J0IGNsYXNzIFNlcnZlck1hbmFnZXIge1xyXG4gIF9hY3RpdmVTZXJ2ZXJzOiBBcnJheTxBY3RpdmVTZXJ2ZXI+ID0gW107XHJcbiAgX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXM6IE1hcDxzdHJpbmcsIFByb21pc2U8QWN0aXZlU2VydmVyPj4gPSBuZXcgTWFwKCk7XHJcbiAgX3Jlc3RhcnRDb3VudGVyUGVyUHJvamVjdDogTWFwPHN0cmluZywgUmVzdGFydENvdW50ZXI+ID0gbmV3IE1hcCgpO1xyXG4gIF9zdG9wcGluZ1NlcnZlcnM6IEFycmF5PEFjdGl2ZVNlcnZlcj4gPSBbXTtcclxuICBfZGlzcG9zYWJsZTogQ29tcG9zaXRlRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgX2VkaXRvclRvU2VydmVyOiBNYXA8YXRvbSRUZXh0RWRpdG9yLCBBY3RpdmVTZXJ2ZXI+ID0gbmV3IE1hcCgpO1xyXG4gIF9sb2dnZXI6IExvZ2dlcjtcclxuICBfbm9ybWFsaXplZFByb2plY3RQYXRoczogQXJyYXk8c3RyaW5nPiA9IFtdO1xyXG4gIF9zdGFydEZvckVkaXRvcjogKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKSA9PiBib29sZWFuO1xyXG4gIF9zdGFydFNlcnZlcjogKHByb2plY3RQYXRoOiBzdHJpbmcpID0+IFByb21pc2U8QWN0aXZlU2VydmVyPjtcclxuICBfY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXI6IChmaWxlUGF0aDogc3RyaW5nKSA9PiBib29sZWFuO1xyXG4gIF9nZXRCdXN5U2lnbmFsU2VydmljZTogKCkgPT4gP2F0b21JZGUkQnVzeVNpZ25hbFNlcnZpY2U7XHJcbiAgX2xhbmd1YWdlU2VydmVyTmFtZTogc3RyaW5nO1xyXG4gIF9pc1N0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBzdGFydFNlcnZlcjogKHByb2plY3RQYXRoOiBzdHJpbmcpID0+IFByb21pc2U8QWN0aXZlU2VydmVyPixcclxuICAgIGxvZ2dlcjogTG9nZ2VyLFxyXG4gICAgc3RhcnRGb3JFZGl0b3I6IChlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikgPT4gYm9vbGVhbixcclxuICAgIGNoYW5nZVdhdGNoZWRGaWxlRmlsdGVyOiAoZmlsZVBhdGg6IHN0cmluZykgPT4gYm9vbGVhbixcclxuICAgIGJ1c3lTaWduYWxTZXJ2aWNlR2V0dGVyOiAoKSA9PiA/YXRvbUlkZSRCdXN5U2lnbmFsU2VydmljZSxcclxuICAgIGxhbmd1YWdlU2VydmVyTmFtZTogc3RyaW5nLFxyXG4gICkge1xyXG4gICAgdGhpcy5fbGFuZ3VhZ2VTZXJ2ZXJOYW1lID0gbGFuZ3VhZ2VTZXJ2ZXJOYW1lO1xyXG4gICAgdGhpcy5fc3RhcnRTZXJ2ZXIgPSBzdGFydFNlcnZlcjtcclxuICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcjtcclxuICAgIHRoaXMuX3N0YXJ0Rm9yRWRpdG9yID0gc3RhcnRGb3JFZGl0b3I7XHJcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMoKTtcclxuICAgIHRoaXMuX2NoYW5nZVdhdGNoZWRGaWxlRmlsdGVyID0gY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXI7XHJcbiAgICB0aGlzLl9nZXRCdXN5U2lnbmFsU2VydmljZSA9IGJ1c3lTaWduYWxTZXJ2aWNlR2V0dGVyO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRMaXN0ZW5pbmcoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2lzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS50ZXh0RWRpdG9ycy5vYnNlcnZlKHRoaXMub2JzZXJ2ZVRleHRFZGl0b3JzLmJpbmQodGhpcykpKTtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlUGF0aHModGhpcy5wcm9qZWN0UGF0aHNDaGFuZ2VkLmJpbmQodGhpcykpKTtcclxuICAgICAgaWYgKGF0b20ucHJvamVjdC5vbkRpZENoYW5nZUZpbGVzKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlRmlsZXModGhpcy5wcm9qZWN0RmlsZXNDaGFuZ2VkLmJpbmQodGhpcykpKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RvcExpc3RlbmluZygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgb2JzZXJ2ZVRleHRFZGl0b3JzKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICAvLyBUcmFjayBncmFtbWFyIGNoYW5nZXMgZm9yIG9wZW5lZCBlZGl0b3JzXHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IGVkaXRvci5vYnNlcnZlR3JhbW1hcihncmFtbWFyID0+IHRoaXMuX2hhbmRsZUdyYW1tYXJDaGFuZ2UoZWRpdG9yKSk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IGxpc3RlbmVyLmRpc3Bvc2UoKSkpO1xyXG4gICAgLy8gVHJ5IHRvIHNlZSBpZiBlZGl0b3IgY2FuIGhhdmUgTFMgY29ubmVjdGVkIHRvIGl0XHJcbiAgICB0aGlzLl9oYW5kbGVUZXh0RWRpdG9yKGVkaXRvcik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBfaGFuZGxlVGV4dEVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLl9lZGl0b3JUb1NlcnZlci5oYXMoZWRpdG9yKSkge1xyXG4gICAgICAvLyBlZGl0b3IgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldCwgc28gcHJvY2VzcyBpdCBieSBhbGxvY2F0aW5nIExTIGZvciBpdCBpZiBuZWNlc3NhcnlcclxuICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXIoZWRpdG9yLCB7c2hvdWxkU3RhcnQ6IHRydWV9KTtcclxuICAgICAgaWYgKHNlcnZlciAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgTFMgZm9yIHRoZSBlZGl0b3IgKGVpdGhlciBzdGFydGVkIG5vdyBhbmQgYWxyZWFkeSBydW5uaW5nKVxyXG4gICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLnNldChlZGl0b3IsIHNlcnZlcik7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZGVsZXRlKGVkaXRvcik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFVudXNlZFNlcnZlcnMoKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhcnRGb3JFZGl0b3IoZWRpdG9yKSkge1xyXG4gICAgICAvLyBJZiBlZGl0b3IgaXMgaW50ZXJlc3RpbmcgZm9yIExTIHByb2Nlc3MgdGhlIGVkaXRvciBmdXJ0aGVyIHRvIGF0dGVtcHQgdG8gc3RhcnQgTFMgaWYgbmVlZGVkXHJcbiAgICAgIHRoaXMuX2hhbmRsZVRleHRFZGl0b3IoZWRpdG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEVkaXRvciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBMU1xyXG4gICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9lZGl0b3JUb1NlcnZlci5nZXQoZWRpdG9yKTtcclxuICAgICAgLy8gSWYgTFMgaXMgcnVubmluZyBmb3IgdGhlIHVuc3VwcG9ydGVkIGVkaXRvciB0aGVuIGRpc2Nvbm5lY3QgdGhlIGVkaXRvciBmcm9tIExTIGFuZCBzaHV0IGRvd24gTFMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGlmIChzZXJ2ZXIpIHtcclxuICAgICAgICAvLyBMUyBpcyB1cCBmb3IgdW5zdXBwb3J0ZWQgc2VydmVyXHJcbiAgICAgICAgaWYgKHNlcnZlci5kb2NTeW5jQWRhcHRlcikge1xyXG4gICAgICAgICAgY29uc3Qgc3luY0FkYXB0ZXIgPSBzZXJ2ZXIuZG9jU3luY0FkYXB0ZXIuZ2V0RWRpdG9yU3luY0FkYXB0ZXIoZWRpdG9yKTtcclxuICAgICAgICAgIGlmIChzeW5jQWRhcHRlcikge1xyXG4gICAgICAgICAgICAvLyBJbW1pdGF0ZSBlZGl0b3IgY2xvc2UgdG8gZGlzY29ubmVjdCBMUyBmcm9tIHRoZSBlZGl0b3JcclxuICAgICAgICAgICAgc3luY0FkYXB0ZXIuZGlkQ2xvc2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGVkaXRvciBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgIC8vIFNodXQgZG93biBMUyBpZiBpdCdzIHVzZWQgYnkgYW55IG90aGVyIGVkaXRvclxyXG4gICAgICAgIHRoaXMuc3RvcFVudXNlZFNlcnZlcnMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0QWN0aXZlU2VydmVycygpOiBBcnJheTxBY3RpdmVTZXJ2ZXI+IHtcclxuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTZXJ2ZXJzLnNsaWNlKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRTZXJ2ZXIoXHJcbiAgICB0ZXh0RWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgICB7c2hvdWxkU3RhcnR9OiB7c2hvdWxkU3RhcnQ/OiBib29sZWFufSA9IHtzaG91bGRTdGFydDogZmFsc2V9LFxyXG4gICk6IFByb21pc2U8P0FjdGl2ZVNlcnZlcj4ge1xyXG4gICAgY29uc3QgZmluYWxQcm9qZWN0UGF0aCA9IHRoaXMuZGV0ZXJtaW5lUHJvamVjdFBhdGgodGV4dEVkaXRvcik7XHJcbiAgICBpZiAoZmluYWxQcm9qZWN0UGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIC8vIEZpbGVzIG5vdCB5ZXQgc2F2ZWQgaGF2ZSBubyBwYXRoXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvdW5kQWN0aXZlU2VydmVyID0gdGhpcy5fYWN0aXZlU2VydmVycy5maW5kKHMgPT4gZmluYWxQcm9qZWN0UGF0aCA9PT0gcy5wcm9qZWN0UGF0aCk7XHJcbiAgICBpZiAoZm91bmRBY3RpdmVTZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIGZvdW5kQWN0aXZlU2VydmVyO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0aW5nUHJvbWlzZSA9IHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuZ2V0KGZpbmFsUHJvamVjdFBhdGgpO1xyXG4gICAgaWYgKHN0YXJ0aW5nUHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gc3RhcnRpbmdQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaG91bGRTdGFydCAmJiB0aGlzLl9zdGFydEZvckVkaXRvcih0ZXh0RWRpdG9yKSA/IGF3YWl0IHRoaXMuc3RhcnRTZXJ2ZXIoZmluYWxQcm9qZWN0UGF0aCkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RhcnRTZXJ2ZXIocHJvamVjdFBhdGg6IHN0cmluZyk6IFByb21pc2U8QWN0aXZlU2VydmVyPiB7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdGFydGluZyBcIiR7cHJvamVjdFBhdGh9XCJgKTtcclxuICAgIGNvbnN0IHN0YXJ0aW5nUHJvbWlzZSA9IHRoaXMuX3N0YXJ0U2VydmVyKHByb2plY3RQYXRoKTtcclxuICAgIHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuc2V0KHByb2plY3RQYXRoLCBzdGFydGluZ1Byb21pc2UpO1xyXG4gICAgY29uc3Qgc3RhcnRlZEFjdGl2ZVNlcnZlciA9IGF3YWl0IHN0YXJ0aW5nUHJvbWlzZTtcclxuICAgIHRoaXMuX2FjdGl2ZVNlcnZlcnMucHVzaChzdGFydGVkQWN0aXZlU2VydmVyKTtcclxuICAgIHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuZGVsZXRlKHByb2plY3RQYXRoKTtcclxuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0YXJ0ZWQgXCIke3Byb2plY3RQYXRofVwiIChwaWQgJHtzdGFydGVkQWN0aXZlU2VydmVyLnByb2Nlc3MucGlkfSlgKTtcclxuICAgIHJldHVybiBzdGFydGVkQWN0aXZlU2VydmVyO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RvcFVudXNlZFNlcnZlcnMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB1c2VkU2VydmVycyA9IG5ldyBTZXQodGhpcy5fZWRpdG9yVG9TZXJ2ZXIudmFsdWVzKCkpO1xyXG4gICAgY29uc3QgdW51c2VkU2VydmVycyA9IHRoaXMuX2FjdGl2ZVNlcnZlcnMuZmlsdGVyKHMgPT4gIXVzZWRTZXJ2ZXJzLmhhcyhzKSk7XHJcbiAgICBpZiAodW51c2VkU2VydmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU3RvcHBpbmcgJHt1bnVzZWRTZXJ2ZXJzLmxlbmd0aH0gdW51c2VkIHNlcnZlcnNgKTtcclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodW51c2VkU2VydmVycy5tYXAocyA9PiB0aGlzLnN0b3BTZXJ2ZXIocykpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHN0b3BBbGxTZXJ2ZXJzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgZm9yIChjb25zdCBbcHJvamVjdFBhdGgsIHJlc3RhcnRDb3VudGVyXSBvZiB0aGlzLl9yZXN0YXJ0Q291bnRlclBlclByb2plY3QpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHJlc3RhcnRDb3VudGVyLnRpbWVySWQpO1xyXG4gICAgICB0aGlzLl9yZXN0YXJ0Q291bnRlclBlclByb2plY3QuZGVsZXRlKHByb2plY3RQYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl9hY3RpdmVTZXJ2ZXJzLm1hcChzID0+IHRoaXMuc3RvcFNlcnZlcihzKSkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVzdGFydEFsbFNlcnZlcnMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcclxuICAgIGF3YWl0IHRoaXMuc3RvcEFsbFNlcnZlcnMoKTtcclxuICAgIHRoaXMuX2VkaXRvclRvU2VydmVyID0gbmV3IE1hcCgpO1xyXG4gICAgdGhpcy5zdGFydExpc3RlbmluZygpO1xyXG4gIH1cclxuXHJcbiAgaGFzU2VydmVyUmVhY2hlZFJlc3RhcnRMaW1pdChzZXJ2ZXI6IEFjdGl2ZVNlcnZlcikge1xyXG4gICAgbGV0IHJlc3RhcnRDb3VudGVyID0gdGhpcy5fcmVzdGFydENvdW50ZXJQZXJQcm9qZWN0LmdldChzZXJ2ZXIucHJvamVjdFBhdGgpO1xyXG5cclxuICAgIGlmICghcmVzdGFydENvdW50ZXIpIHtcclxuICAgICAgcmVzdGFydENvdW50ZXIgPSB7XHJcbiAgICAgICAgcmVzdGFydHM6IDAsXHJcbiAgICAgICAgdGltZXJJZDogc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9yZXN0YXJ0Q291bnRlclBlclByb2plY3QuZGVsZXRlKHNlcnZlci5wcm9qZWN0UGF0aCk7XHJcbiAgICAgICAgfSwgMyAqIDYwICogMTAwMCAvKiAzIG1pbnV0ZXMgKi8pLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5fcmVzdGFydENvdW50ZXJQZXJQcm9qZWN0LnNldChzZXJ2ZXIucHJvamVjdFBhdGgsIHJlc3RhcnRDb3VudGVyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKytyZXN0YXJ0Q291bnRlci5yZXN0YXJ0cyA+IDU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wU2VydmVyKHNlcnZlcjogQWN0aXZlU2VydmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBidXN5U2lnbmFsU2VydmljZSA9IHRoaXMuX2dldEJ1c3lTaWduYWxTZXJ2aWNlKCk7XHJcbiAgICBjb25zdCBzaWduYWwgPSBidXN5U2lnbmFsU2VydmljZSAmJiBidXN5U2lnbmFsU2VydmljZS5yZXBvcnRCdXN5KFxyXG4gICAgICBgU3RvcHBpbmcgJHt0aGlzLl9sYW5ndWFnZVNlcnZlck5hbWV9IGZvciAke3BhdGguYmFzZW5hbWUoc2VydmVyLnByb2plY3RQYXRoKX1gLFxyXG4gICAgKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0b3BwaW5nIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCJgKTtcclxuICAgICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBzZXJ2ZXIgdG8gcHJldmVudCBmdXJ0aGVyIHVzYWdlLlxyXG4gICAgICAvLyBJZiB3ZSByZS1vcGVuIHRoZSBmaWxlIGFmdGVyIHRoaXMgcG9pbnQsIHdlJ2xsIGdldCBhIG5ldyBzZXJ2ZXIuXHJcbiAgICAgIHRoaXMuX2FjdGl2ZVNlcnZlcnMuc3BsaWNlKHRoaXMuX2FjdGl2ZVNlcnZlcnMuaW5kZXhPZihzZXJ2ZXIpLCAxKTtcclxuICAgICAgdGhpcy5fc3RvcHBpbmdTZXJ2ZXJzLnB1c2goc2VydmVyKTtcclxuICAgICAgc2VydmVyLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICBpZiAoc2VydmVyLmNvbm5lY3Rpb24uaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5zaHV0ZG93bigpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIG1hcHBlZFNlcnZlcl0gb2YgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIpIHtcclxuICAgICAgICBpZiAobWFwcGVkU2VydmVyID09PSBzZXJ2ZXIpIHtcclxuICAgICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5leGl0U2VydmVyKHNlcnZlcik7XHJcbiAgICAgIHRoaXMuX3N0b3BwaW5nU2VydmVycy5zcGxpY2UodGhpcy5fc3RvcHBpbmdTZXJ2ZXJzLmluZGV4T2Yoc2VydmVyKSwgMSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzaWduYWwgJiYgc2lnbmFsLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4aXRTZXJ2ZXIoc2VydmVyOiBBY3RpdmVTZXJ2ZXIpOiB2b2lkIHtcclxuICAgIGNvbnN0IHBpZCA9IHNlcnZlci5wcm9jZXNzLnBpZDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmIChzZXJ2ZXIuY29ubmVjdGlvbi5pc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgIHNlcnZlci5jb25uZWN0aW9uLmV4aXQoKTtcclxuICAgICAgICBzZXJ2ZXIuY29ubmVjdGlvbi5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNlcnZlci5wcm9jZXNzLmtpbGwoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0b3BwZWQgXCIke3NlcnZlci5wcm9qZWN0UGF0aH1cIiAocGlkICR7cGlkfSlgKTtcclxuICB9XHJcblxyXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3N0b3BwaW5nU2VydmVycy5mb3JFYWNoKHNlcnZlciA9PiB7XHJcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHRlcm1pbmF0aW5nIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCJgKTtcclxuICAgICAgdGhpcy5leGl0U2VydmVyKHNlcnZlcik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9zdHJpbmcge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSB0ZXh0RWRpdG9yLmdldFBhdGgoKTtcclxuICAgIGlmIChmaWxlUGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMuZmluZChkID0+IGZpbGVQYXRoLnN0YXJ0c1dpdGgoZCkpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpOiB2b2lkIHtcclxuICAgIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMgPSBhdG9tLnByb2plY3QuZ2V0RGlyZWN0b3JpZXMoKS5tYXAoZCA9PiB0aGlzLm5vcm1hbGl6ZVBhdGgoZC5nZXRQYXRoKCkpKTtcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZVBhdGgocHJvamVjdFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gIXByb2plY3RQYXRoLmVuZHNXaXRoKHBhdGguc2VwKSA/IHBhdGguam9pbihwcm9qZWN0UGF0aCwgcGF0aC5zZXApIDogcHJvamVjdFBhdGg7XHJcbiAgfVxyXG5cclxuICBwcm9qZWN0UGF0aHNDaGFuZ2VkKHByb2plY3RQYXRoczogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgY29uc3QgcGF0aHNTZXQgPSBuZXcgU2V0KHByb2plY3RQYXRocy5tYXAodGhpcy5ub3JtYWxpemVQYXRoKSk7XHJcbiAgICBjb25zdCBzZXJ2ZXJzVG9TdG9wID0gdGhpcy5fYWN0aXZlU2VydmVycy5maWx0ZXIocyA9PiAhcGF0aHNTZXQuaGFzKHMucHJvamVjdFBhdGgpKTtcclxuICAgIFByb21pc2UuYWxsKHNlcnZlcnNUb1N0b3AubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMoKTtcclxuICB9XHJcblxyXG4gIHByb2plY3RGaWxlc0NoYW5nZWQoZmlsZUV2ZW50czogQXJyYXk8YXRvbSRQcm9qZWN0RmlsZUV2ZW50Pik6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZVNlcnZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGFjdGl2ZVNlcnZlciBvZiB0aGlzLl9hY3RpdmVTZXJ2ZXJzKSB7XHJcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBmaWxlRXZlbnQgb2YgZmlsZUV2ZW50cykge1xyXG4gICAgICAgIGlmIChmaWxlRXZlbnQucGF0aC5zdGFydHNXaXRoKGFjdGl2ZVNlcnZlci5wcm9qZWN0UGF0aCkgJiYgdGhpcy5fY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIoZmlsZUV2ZW50LnBhdGgpKSB7XHJcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goQ29udmVydC5hdG9tRmlsZUV2ZW50VG9MU0ZpbGVFdmVudHMoZmlsZUV2ZW50KVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGZpbGVFdmVudC5vbGRQYXRoICYmXHJcbiAgICAgICAgICBmaWxlRXZlbnQub2xkUGF0aC5zdGFydHNXaXRoKGFjdGl2ZVNlcnZlci5wcm9qZWN0UGF0aCkgJiZcclxuICAgICAgICAgIHRoaXMuX2NoYW5nZVdhdGNoZWRGaWxlRmlsdGVyKGZpbGVFdmVudC5vbGRQYXRoKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY2hhbmdlcy5wdXNoKENvbnZlcnQuYXRvbUZpbGVFdmVudFRvTFNGaWxlRXZlbnRzKGZpbGVFdmVudClbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgYWN0aXZlU2VydmVyLmNvbm5lY3Rpb24uZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKHtjaGFuZ2VzfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19