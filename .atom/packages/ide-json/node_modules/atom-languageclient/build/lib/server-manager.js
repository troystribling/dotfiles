Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerManager = undefined;

require('./logger');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Manages the language server lifecycles and their associated objects necessary
// for adapting them to Atom and Atom IDE UI.


// The necessary elements for a server that has started or is starting.
let ServerManager = exports.ServerManager = class ServerManager {

  constructor(startServer, logger, startForEditor) {
    this._activeServers = [];
    this._startingServerPromises = new Map();
    this._editorToServer = new Map();
    this._normalizedProjectPaths = [];

    this._startServer = startServer;
    this._logger = logger;
    this._startForEditor = startForEditor;
    this.updateNormalizedProjectPaths();
    this._disposable = new _atom.CompositeDisposable();
    this._disposable.add(atom.project.onDidChangePaths(this.projectPathsChanged.bind(this)));
    this._disposable.add(atom.textEditors.observe(this.observeTextEditors.bind(this)));
  }

  dispose() {
    this.stopAllServers();
    this._disposable.dispose();
  }

  observeTextEditors(editor) {
    // Track grammar changes for opened editors
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => listener.dispose()));
    // Try to see if editor can have LS connected to it
    this._handleTextEditor(editor);
  }

  _handleTextEditor(editor) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (!_this._editorToServer.has(editor)) {
        // editor hasn't been processed yet, so process it by allocating LS for it if necessary
        const server = yield _this.getServer(editor, { shouldStart: true });
        if (server != null) {
          // There LS for the editor (either started now and already running)
          _this._editorToServer.set(editor, server);
          _this._disposable.add(editor.onDidDestroy(function () {
            _this._editorToServer.delete(editor);
            _this.stopUnusedServers();
          }));
        }
      }
    })();
  }

  _handleGrammarChange(editor) {
    if (this._startForEditor(editor)) {
      // If editor is interesting for LS process the editor further to attempt to start LS if needed
      this._handleTextEditor(editor);
    } else {
      // Editor is not supported by the LS
      const server = this._editorToServer.get(editor);
      // If LS is running for the unsupported editor then disconnect the editor from LS and shut down LS if necessary
      if (server) {
        // LS is up for unsupported server
        if (server.docSyncAdapter) {
          const syncAdapter = server.docSyncAdapter.getEditorSyncAdapter(editor);
          if (syncAdapter) {
            // Immitate editor close to disconnect LS from the editor
            syncAdapter.didDestroy();
          }
        }
        // Remove editor from the cache
        this._editorToServer.delete(editor);
        // Shut down LS if it's used by any other editor
        this.stopUnusedServers();
      }
    }
  }

  getActiveServers() {
    return this._activeServers.slice();
  }

  getServer(textEditor, { shouldStart } = { shouldStart: false }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const finalProjectPath = _this2.determineProjectPath(textEditor);
      if (finalProjectPath == null) {
        // Files not yet saved have no path
        return null;
      }

      const foundActiveServer = _this2._activeServers.find(function (s) {
        return finalProjectPath === s.projectPath;
      });
      if (foundActiveServer) {
        return foundActiveServer;
      }

      const startingPromise = _this2._startingServerPromises.get(finalProjectPath);
      if (startingPromise) {
        return startingPromise;
      }

      return shouldStart && _this2._startForEditor(textEditor) ? yield _this2.startServer(finalProjectPath) : null;
    })();
  }

  startServer(projectPath) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3._logger.debug(`Server starting "${projectPath}"`);
      const startingPromise = _this3._startServer(projectPath);
      _this3._startingServerPromises.set(projectPath, startingPromise);
      const startedActiveServer = yield startingPromise;
      _this3._activeServers.push(startedActiveServer);
      _this3._startingServerPromises.delete(projectPath);
      _this3._logger.debug(`Server started "${projectPath}"`);
      return startedActiveServer;
    })();
  }

  stopUnusedServers() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const usedServers = new Set(_this4._editorToServer.values());
      const unusedServers = _this4._activeServers.filter(function (s) {
        return !usedServers.has(s);
      });
      if (unusedServers.length > 0) {
        _this4._logger.debug(`Stopping ${unusedServers.length} unused servers`);
        yield Promise.all(unusedServers.map(function (s) {
          return _this4.stopServer(s);
        }));
      }
    })();
  }

  stopAllServers() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      yield Promise.all(_this5._activeServers.map(function (s) {
        return _this5.stopServer(s);
      }));
    })();
  }

  stopServer(server) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      _this6._logger.debug(`Server stopping "${server.projectPath}"`);
      // Immediately remove the server to prevent further usage.
      // If we re-open the file after this point, we'll get a new server.
      const serverIndex = _this6._activeServers.indexOf(server);
      _this6._activeServers.splice(serverIndex, 1);
      server.disposable.dispose();
      yield server.connection.shutdown();
      server.process.kill();
      _this6._logger.debug(`Server stopped "${server.projectPath}"`);
    })();
  }

  determineProjectPath(textEditor) {
    const filePath = textEditor.getPath();
    if (filePath == null) {
      return null;
    }
    return this._normalizedProjectPaths.find(d => filePath.startsWith(d));
  }

  updateNormalizedProjectPaths() {
    this._normalizedProjectPaths = atom.project.getDirectories().map(d => this.normalizePath(d.getPath()));
  }

  normalizePath(projectPath) {
    return !projectPath.endsWith(_path2.default.sep) ? _path2.default.join(projectPath, _path2.default.sep) : projectPath;
  }

  projectPathsChanged(projectPaths) {
    const pathsSet = new Set(projectPaths.map(this.normalizePath));
    const serversToStop = this._activeServers.filter(s => !pathsSet.has(s.projectPath));
    Promise.all(serversToStop.map(s => this.stopServer(s)));
    this.updateNormalizedProjectPaths();
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9zZXJ2ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJscyIsIlNlcnZlck1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0U2VydmVyIiwibG9nZ2VyIiwic3RhcnRGb3JFZGl0b3IiLCJfYWN0aXZlU2VydmVycyIsIl9zdGFydGluZ1NlcnZlclByb21pc2VzIiwiTWFwIiwiX2VkaXRvclRvU2VydmVyIiwiX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMiLCJfc3RhcnRTZXJ2ZXIiLCJfbG9nZ2VyIiwiX3N0YXJ0Rm9yRWRpdG9yIiwidXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocyIsIl9kaXNwb3NhYmxlIiwiYWRkIiwiYXRvbSIsInByb2plY3QiLCJvbkRpZENoYW5nZVBhdGhzIiwicHJvamVjdFBhdGhzQ2hhbmdlZCIsImJpbmQiLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvcnMiLCJkaXNwb3NlIiwic3RvcEFsbFNlcnZlcnMiLCJlZGl0b3IiLCJsaXN0ZW5lciIsIm9ic2VydmVHcmFtbWFyIiwiZ3JhbW1hciIsIl9oYW5kbGVHcmFtbWFyQ2hhbmdlIiwib25EaWREZXN0cm95IiwiX2hhbmRsZVRleHRFZGl0b3IiLCJoYXMiLCJzZXJ2ZXIiLCJnZXRTZXJ2ZXIiLCJzaG91bGRTdGFydCIsInNldCIsImRlbGV0ZSIsInN0b3BVbnVzZWRTZXJ2ZXJzIiwiZ2V0IiwiZG9jU3luY0FkYXB0ZXIiLCJzeW5jQWRhcHRlciIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwiZGlkRGVzdHJveSIsImdldEFjdGl2ZVNlcnZlcnMiLCJzbGljZSIsInRleHRFZGl0b3IiLCJmaW5hbFByb2plY3RQYXRoIiwiZGV0ZXJtaW5lUHJvamVjdFBhdGgiLCJmb3VuZEFjdGl2ZVNlcnZlciIsImZpbmQiLCJzIiwicHJvamVjdFBhdGgiLCJzdGFydGluZ1Byb21pc2UiLCJkZWJ1ZyIsInN0YXJ0ZWRBY3RpdmVTZXJ2ZXIiLCJwdXNoIiwidXNlZFNlcnZlcnMiLCJTZXQiLCJ2YWx1ZXMiLCJ1bnVzZWRTZXJ2ZXJzIiwiZmlsdGVyIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInN0b3BTZXJ2ZXIiLCJzZXJ2ZXJJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJkaXNwb3NhYmxlIiwiY29ubmVjdGlvbiIsInNodXRkb3duIiwicHJvY2VzcyIsImtpbGwiLCJmaWxlUGF0aCIsImdldFBhdGgiLCJkIiwic3RhcnRzV2l0aCIsImdldERpcmVjdG9yaWVzIiwibm9ybWFsaXplUGF0aCIsImVuZHNXaXRoIiwic2VwIiwiam9pbiIsInByb2plY3RQYXRocyIsInBhdGhzU2V0Iiwic2VydmVyc1RvU3RvcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7QUFJQTs7OztBQUNBOztJQUFZQSxFOztBQUNaOzs7Ozs7OztBQWFBO0FBQ0E7OztBQVpBO0lBYWFDLGEsV0FBQUEsYSxHQUFOLE1BQU1BLGFBQU4sQ0FBb0I7O0FBVXpCQyxjQUNFQyxXQURGLEVBRUVDLE1BRkYsRUFHRUMsY0FIRixFQUlFO0FBQUEsU0FiRkMsY0FhRSxHQWJvQyxFQWFwQztBQUFBLFNBWkZDLHVCQVlFLEdBWjRELElBQUlDLEdBQUosRUFZNUQ7QUFBQSxTQVZGQyxlQVVFLEdBVm9ELElBQUlELEdBQUosRUFVcEQ7QUFBQSxTQVJGRSx1QkFRRSxHQVJ1QyxFQVF2Qzs7QUFDQSxTQUFLQyxZQUFMLEdBQW9CUixXQUFwQjtBQUNBLFNBQUtTLE9BQUwsR0FBZVIsTUFBZjtBQUNBLFNBQUtTLGVBQUwsR0FBdUJSLGNBQXZCO0FBQ0EsU0FBS1MsNEJBQUw7QUFDQSxTQUFLQyxXQUFMLEdBQW1CLCtCQUFuQjtBQUNBLFNBQUtBLFdBQUwsQ0FBaUJDLEdBQWpCLENBQXFCQyxLQUFLQyxPQUFMLENBQWFDLGdCQUFiLENBQThCLEtBQUtDLG1CQUFMLENBQXlCQyxJQUF6QixDQUE4QixJQUE5QixDQUE5QixDQUFyQjtBQUNBLFNBQUtOLFdBQUwsQ0FBaUJDLEdBQWpCLENBQXFCQyxL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LEdBQTlCLENBQWtDWSxLQUFLLEtBQUtHLGFBQUwsQ0FBbUJILEVBQUVELE9BQUYsRUFBbkIsQ0FBdkMsQ0FBL0I7QUFDRDs7QUFFREksZ0JBQWM1QixXQUFkLEVBQTJDO0FBQ3pDLFdBQU8sQ0FBQ0EsWUFBWTZCLFFBQVosQ0FBcUIsZUFBS0MsR0FBMUIsQ0FBRCxHQUFrQyxlQUFLQyxJQUFMLENBQVUvQixXQUFWLEVBQXVCLGVBQUs4QixHQUE1QixDQUFsQyxHQUFxRTlCLFdBQTVFO0FBQ0Q7O0FBRURsQyxzQkFBb0JrRSxZQUFwQixFQUF1RDtBQUNyRCxVQUFNQyxXQUFXLElBQUkzQixHQUFKLENBQVEwQixhQUFhbkIsR0FBYixDQUFpQixLQUFLZSxhQUF0QixDQUFSLENBQWpCO0FBQ0EsVUFBTU0sZ0JBQWdCLEtBQUtsRixjQUFMLENBQW9CeUQsTUFBcEIsQ0FBMkJWLEtBQUssQ0FBQ2tDLFNBQVNyRCxHQUFULENBQWFtQixFQUFFQyxXQUFmLENBQWpDLENBQXRCO0FBQ0FXLFlBQVFDLEdBQVIsQ0FBWXNCLGNBQWNyQixHQUFkLENBQWtCZCxLQUFLLEtBQUtlLFVBQUwsQ0FBZ0JmLENBQWhCLENBQXZCLENBQVo7QUFDQSxTQUFLdkMsNEJBQUw7QUFDRDtBQW5Ld0IsQyIsImZpbGUiOiJzZXJ2ZXItbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQge3R5cGUgTG9nZ2VyfSBmcm9tICcuL2xvZ2dlcic7XHJcbmltcG9ydCB0eXBlIExpbnRlclB1c2hWMkFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9saW50ZXItcHVzaC12Mi1hZGFwdGVyJztcclxuaW1wb3J0IHR5cGUgRG9jdW1lbnRTeW5jQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2RvY3VtZW50LXN5bmMtYWRhcHRlcic7XHJcblxyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0ICogYXMgbHMgZnJvbSAnLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCB7Q29tcG9zaXRlRGlzcG9zYWJsZX0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBUaGUgbmVjZXNzYXJ5IGVsZW1lbnRzIGZvciBhIHNlcnZlciB0aGF0IGhhcyBzdGFydGVkIG9yIGlzIHN0YXJ0aW5nLlxyXG5leHBvcnQgdHlwZSBBY3RpdmVTZXJ2ZXIgPSB7XHJcbiAgZGlzcG9zYWJsZTogQ29tcG9zaXRlRGlzcG9zYWJsZSxcclxuICBwcm9qZWN0UGF0aDogc3RyaW5nLFxyXG4gIHByb2Nlc3M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzLFxyXG4gIGNvbm5lY3Rpb246IGxzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBjYXBhYmlsaXRpZXM6IGxzLlNlcnZlckNhcGFiaWxpdGllcyxcclxuICBsaW50ZXJQdXNoVjI/OiBMaW50ZXJQdXNoVjJBZGFwdGVyLFxyXG4gIGRvY1N5bmNBZGFwdGVyPzogRG9jdW1lbnRTeW5jQWRhcHRlcixcclxufTtcclxuXHJcbi8vIE1hbmFnZXMgdGhlIGxhbmd1YWdlIHNlcnZlciBsaWZlY3ljbGVzIGFuZCB0aGVpciBhc3NvY2lhdGVkIG9iamVjdHMgbmVjZXNzYXJ5XHJcbi8vIGZvciBhZGFwdGluZyB0aGVtIHRvIEF0b20gYW5kIEF0b20gSURFIFVJLlxyXG5leHBvcnQgY2xhc3MgU2VydmVyTWFuYWdlciB7XHJcbiAgX2FjdGl2ZVNlcnZlcnM6IEFycmF5PEFjdGl2ZVNlcnZlcj4gPSBbXTtcclxuICBfc3RhcnRpbmdTZXJ2ZXJQcm9taXNlczogTWFwPHN0cmluZywgUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+PiA9IG5ldyBNYXAoKTtcclxuICBfZGlzcG9zYWJsZTogQ29tcG9zaXRlRGlzcG9zYWJsZTtcclxuICBfZWRpdG9yVG9TZXJ2ZXI6IE1hcDxhdG9tJFRleHRFZGl0b3IsIEFjdGl2ZVNlcnZlcj4gPSBuZXcgTWFwKCk7XHJcbiAgX2xvZ2dlcjogTG9nZ2VyO1xyXG4gIF9ub3JtYWxpemVkUHJvamVjdFBhdGhzOiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgX3N0YXJ0Rm9yRWRpdG9yOiAoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpID0+IGJvb2xlYW47XHJcbiAgX3N0YXJ0U2VydmVyOiAocHJvamVjdFBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+O1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHN0YXJ0U2VydmVyOiAocHJvamVjdFBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+LFxyXG4gICAgbG9nZ2VyOiBMb2dnZXIsXHJcbiAgICBzdGFydEZvckVkaXRvcjogKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKSA9PiBib29sZWFuLFxyXG4gICkge1xyXG4gICAgdGhpcy5fc3RhcnRTZXJ2ZXIgPSBzdGFydFNlcnZlcjtcclxuICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcjtcclxuICAgIHRoaXMuX3N0YXJ0Rm9yRWRpdG9yID0gc3RhcnRGb3JFZGl0b3I7XHJcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMoKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlUGF0aHModGhpcy5wcm9qZWN0UGF0aHNDaGFuZ2VkLmJpbmQodGhpcykpKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20udGV4dEVkaXRvcnMub2JzZXJ2ZSh0aGlzLm9ic2VydmVUZXh0RWRpdG9ycy5iaW5kKHRoaXMpKSk7XHJcbiAgfVxyXG5cclxuICBkaXNwb3NlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5zdG9wQWxsU2VydmVycygpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICBvYnNlcnZlVGV4dEVkaXRvcnMoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIC8vIFRyYWNrIGdyYW1tYXIgY2hhbmdlcyBmb3Igb3BlbmVkIGVkaXRvcnNcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gZWRpdG9yLm9ic2VydmVHcmFtbWFyKGdyYW1tYXIgPT4gdGhpcy5faGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3IpKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4gbGlzdGVuZXIuZGlzcG9zZSgpKSk7XHJcbiAgICAvLyBUcnkgdG8gc2VlIGlmIGVkaXRvciBjYW4gaGF2ZSBMUyBjb25uZWN0ZWQgdG8gaXRcclxuICAgIHRoaXMuX2hhbmRsZVRleHRFZGl0b3IoZWRpdG9yKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIF9oYW5kbGVUZXh0RWRpdG9yKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBpZiAoIXRoaXMuX2VkaXRvclRvU2VydmVyLmhhcyhlZGl0b3IpKSB7XHJcbiAgICAgIC8vIGVkaXRvciBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LCBzbyBwcm9jZXNzIGl0IGJ5IGFsbG9jYXRpbmcgTFMgZm9yIGl0IGlmIG5lY2Vzc2FyeVxyXG4gICAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLmdldFNlcnZlcihlZGl0b3IsIHtzaG91bGRTdGFydDogdHJ1ZX0pO1xyXG4gICAgICBpZiAoc2VydmVyICE9IG51bGwpIHtcclxuICAgICAgICAvLyBUaGVyZSBMUyBmb3IgdGhlIGVkaXRvciAoZWl0aGVyIHN0YXJ0ZWQgbm93IGFuZCBhbHJlYWR5IHJ1bm5pbmcpXHJcbiAgICAgICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuc2V0KGVkaXRvciwgc2VydmVyKTtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChcclxuICAgICAgICAgIGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9lZGl0b3JUb1NlcnZlci5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wVW51c2VkU2VydmVycygpO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX2hhbmRsZUdyYW1tYXJDaGFuZ2UoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpIHtcclxuICAgIGlmICh0aGlzLl9zdGFydEZvckVkaXRvcihlZGl0b3IpKSB7XHJcbiAgICAgIC8vIElmIGVkaXRvciBpcyBpbnRlcmVzdGluZyBmb3IgTFMgcHJvY2VzcyB0aGUgZWRpdG9yIGZ1cnRoZXIgdG8gYXR0ZW1wdCB0byBzdGFydCBMUyBpZiBuZWVkZWRcclxuICAgICAgdGhpcy5faGFuZGxlVGV4dEVkaXRvcihlZGl0b3IpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRWRpdG9yIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIExTXHJcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX2VkaXRvclRvU2VydmVyLmdldChlZGl0b3IpO1xyXG4gICAgICAvLyBJZiBMUyBpcyBydW5uaW5nIGZvciB0aGUgdW5zdXBwb3J0ZWQgZWRpdG9yIHRoZW4gZGlzY29ubmVjdCB0aGUgZWRpdG9yIGZyb20gTFMgYW5kIHNodXQgZG93biBMUyBpZiBuZWNlc3NhcnlcclxuICAgICAgaWYgKHNlcnZlcikge1xyXG4gICAgICAgIC8vIExTIGlzIHVwIGZvciB1bnN1cHBvcnRlZCBzZXJ2ZXJcclxuICAgICAgICBpZiAoc2VydmVyLmRvY1N5bmNBZGFwdGVyKSB7XHJcbiAgICAgICAgICBjb25zdCBzeW5jQWRhcHRlciA9IHNlcnZlci5kb2NTeW5jQWRhcHRlci5nZXRFZGl0b3JTeW5jQWRhcHRlcihlZGl0b3IpO1xyXG4gICAgICAgICAgaWYgKHN5bmNBZGFwdGVyKSB7XHJcbiAgICAgICAgICAgIC8vIEltbWl0YXRlIGVkaXRvciBjbG9zZSB0byBkaXNjb25uZWN0IExTIGZyb20gdGhlIGVkaXRvclxyXG4gICAgICAgICAgICBzeW5jQWRhcHRlci5kaWREZXN0cm95KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlZGl0b3IgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICB0aGlzLl9lZGl0b3JUb1NlcnZlci5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgICAvLyBTaHV0IGRvd24gTFMgaWYgaXQncyB1c2VkIGJ5IGFueSBvdGhlciBlZGl0b3JcclxuICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEFjdGl2ZVNlcnZlcnMoKTogQXJyYXk8QWN0aXZlU2VydmVyPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlU2VydmVycy5zbGljZSgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U2VydmVyKFxyXG4gICAgdGV4dEVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gICAge3Nob3VsZFN0YXJ0fToge3Nob3VsZFN0YXJ0PzogYm9vbGVhbn0gPSB7c2hvdWxkU3RhcnQ6IGZhbHNlfSxcclxuICApOiBQcm9taXNlPD9BY3RpdmVTZXJ2ZXI+IHtcclxuICAgIGNvbnN0IGZpbmFsUHJvamVjdFBhdGggPSB0aGlzLmRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3IpO1xyXG4gICAgaWYgKGZpbmFsUHJvamVjdFBhdGggPT0gbnVsbCkge1xyXG4gICAgICAvLyBGaWxlcyBub3QgeWV0IHNhdmVkIGhhdmUgbm8gcGF0aFxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3VuZEFjdGl2ZVNlcnZlciA9IHRoaXMuX2FjdGl2ZVNlcnZlcnMuZmluZChzID0+IGZpbmFsUHJvamVjdFBhdGggPT09IHMucHJvamVjdFBhdGgpO1xyXG4gICAgaWYgKGZvdW5kQWN0aXZlU2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBmb3VuZEFjdGl2ZVNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmdldChmaW5hbFByb2plY3RQYXRoKTtcclxuICAgIGlmIChzdGFydGluZ1Byb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHN0YXJ0aW5nUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2hvdWxkU3RhcnQgJiYgdGhpcy5fc3RhcnRGb3JFZGl0b3IodGV4dEVkaXRvcikgPyBhd2FpdCB0aGlzLnN0YXJ0U2VydmVyKGZpbmFsUHJvamVjdFBhdGgpIDogbnVsbDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0YXJ0U2VydmVyKHByb2plY3RQYXRoOiBzdHJpbmcpOiBQcm9taXNlPEFjdGl2ZVNlcnZlcj4ge1xyXG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RhcnRpbmcgXCIke3Byb2plY3RQYXRofVwiYCk7XHJcbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydFNlcnZlcihwcm9qZWN0UGF0aCk7XHJcbiAgICB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLnNldChwcm9qZWN0UGF0aCwgc3RhcnRpbmdQcm9taXNlKTtcclxuICAgIGNvbnN0IHN0YXJ0ZWRBY3RpdmVTZXJ2ZXIgPSBhd2FpdCBzdGFydGluZ1Byb21pc2U7XHJcbiAgICB0aGlzLl9hY3RpdmVTZXJ2ZXJzLnB1c2goc3RhcnRlZEFjdGl2ZVNlcnZlcik7XHJcbiAgICB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmRlbGV0ZShwcm9qZWN0UGF0aCk7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdGFydGVkIFwiJHtwcm9qZWN0UGF0aH1cImApO1xyXG4gICAgcmV0dXJuIHN0YXJ0ZWRBY3RpdmVTZXJ2ZXI7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wVW51c2VkU2VydmVycygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGNvbnN0IHVzZWRTZXJ2ZXJzID0gbmV3IFNldCh0aGlzLl9lZGl0b3JUb1NlcnZlci52YWx1ZXMoKSk7XHJcbiAgICBjb25zdCB1bnVzZWRTZXJ2ZXJzID0gdGhpcy5fYWN0aXZlU2VydmVycy5maWx0ZXIocyA9PiAhdXNlZFNlcnZlcnMuaGFzKHMpKTtcclxuICAgIGlmICh1bnVzZWRTZXJ2ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTdG9wcGluZyAke3VudXNlZFNlcnZlcnMubGVuZ3RofSB1bnVzZWQgc2VydmVyc2ApO1xyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh1bnVzZWRTZXJ2ZXJzLm1hcChzID0+IHRoaXMuc3RvcFNlcnZlcihzKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RvcEFsbFNlcnZlcnMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl9hY3RpdmVTZXJ2ZXJzLm1hcChzID0+IHRoaXMuc3RvcFNlcnZlcihzKSkpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RvcFNlcnZlcihzZXJ2ZXI6IEFjdGl2ZVNlcnZlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RvcHBpbmcgXCIke3NlcnZlci5wcm9qZWN0UGF0aH1cImApO1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBzZXJ2ZXIgdG8gcHJldmVudCBmdXJ0aGVyIHVzYWdlLlxyXG4gICAgLy8gSWYgd2UgcmUtb3BlbiB0aGUgZmlsZSBhZnRlciB0aGlzIHBvaW50LCB3ZSdsbCBnZXQgYSBuZXcgc2VydmVyLlxyXG4gICAgY29uc3Qgc2VydmVySW5kZXggPSB0aGlzLl9hY3RpdmVTZXJ2ZXJzLmluZGV4T2Yoc2VydmVyKTtcclxuICAgIHRoaXMuX2FjdGl2ZVNlcnZlcnMuc3BsaWNlKHNlcnZlckluZGV4LCAxKTtcclxuICAgIHNlcnZlci5kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgIGF3YWl0IHNlcnZlci5jb25uZWN0aW9uLnNodXRkb3duKCk7XHJcbiAgICBzZXJ2ZXIucHJvY2Vzcy5raWxsKCk7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdG9wcGVkIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCJgKTtcclxuICB9XHJcblxyXG4gIGRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9zdHJpbmcge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSB0ZXh0RWRpdG9yLmdldFBhdGgoKTtcclxuICAgIGlmIChmaWxlUGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMuZmluZChkID0+IGZpbGVQYXRoLnN0YXJ0c1dpdGgoZCkpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpOiB2b2lkIHtcclxuICAgIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMgPSBhdG9tLnByb2plY3QuZ2V0RGlyZWN0b3JpZXMoKS5tYXAoZCA9PiB0aGlzLm5vcm1hbGl6ZVBhdGgoZC5nZXRQYXRoKCkpKTtcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZVBhdGgocHJvamVjdFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gIXByb2plY3RQYXRoLmVuZHNXaXRoKHBhdGguc2VwKSA/IHBhdGguam9pbihwcm9qZWN0UGF0aCwgcGF0aC5zZXApIDogcHJvamVjdFBhdGg7XHJcbiAgfVxyXG5cclxuICBwcm9qZWN0UGF0aHNDaGFuZ2VkKHByb2plY3RQYXRoczogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgY29uc3QgcGF0aHNTZXQgPSBuZXcgU2V0KHByb2plY3RQYXRocy5tYXAodGhpcy5ub3JtYWxpemVQYXRoKSk7XHJcbiAgICBjb25zdCBzZXJ2ZXJzVG9TdG9wID0gdGhpcy5fYWN0aXZlU2VydmVycy5maWx0ZXIocyA9PiAhcGF0aHNTZXQuaGFzKHMucHJvamVjdFBhdGgpKTtcclxuICAgIFByb21pc2UuYWxsKHNlcnZlcnNUb1N0b3AubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMoKTtcclxuICB9XHJcbn1cclxuIl19