var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _atom = require('atom');

var _chai = require('chai');

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _languageclient = require('../../lib/languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _datatipAdapter = require('../../lib/adapters/datatip-adapter');

var _datatipAdapter2 = _interopRequireDefault(_datatipAdapter);

var _helpers = require('../helpers.js');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

describe('DatatipAdapter', () => {
  let fakeEditor;
  let connection;

  beforeEach(() => {
    connection = new ls.LanguageClientConnection((0, _helpers.createSpyConnection)());
    fakeEditor = (0, _helpers.createFakeEditor)();
  });

  describe('canAdapt', () => {
    it('returns true if hoverProvider is supported', () => {
      const result = _datatipAdapter2.default.canAdapt({ hoverProvider: true });
      (0, _chai.expect)(result).to.be.true;
    });

    it('returns false if hoverProvider not supported', () => {
      const result = _datatipAdapter2.default.canAdapt({});
      (0, _chai.expect)(result).to.be.false;
    });
  });

  describe('getDatatip', () => {
    it('calls LSP document/hover at the given position', _asyncToGenerator(function* () {
      _sinon2.default.stub(connection, 'hover').resolves({
        range: {
          start: { line: 0, character: 1 },
          end: { line: 0, character: 2 }
        },
        contents: ['test', { language: 'testlang', value: 'test snippet' }]
      });

      const grammarSpy = _sinon2.default.spy(atom.grammars, 'grammarForScopeName');

      const datatipAdapter = new _datatipAdapter2.default();
      const datatip = yield datatipAdapter.getDatatip(connection, fakeEditor, new _atom.Point(0, 0));
      (0, _chai.expect)(datatip).to.be.ok;
      (0, _assert2.default)(datatip != null);

      (0, _chai.expect)(datatip.range.start.row).equal(0);
      (0, _chai.expect)(datatip.range.start.column).equal(1);
      (0, _chai.expect)(datatip.range.end.row).equal(0);
      (0, _chai.expect)(datatip.range.end.column).equal(2);

      (0, _chai.expect)(datatip.markedStrings).to.have.lengthOf(2);
      (0, _chai.expect)(datatip.markedStrings[0]).eql({ type: 'markdown', value: 'test' });

      const snippet = datatip.markedStrings[1];
      (0, _chai.expect)(snippet.type).equal('snippet');
      (0, _assert2.default)(snippet.type === 'snippet');
      (0, _chai.expect)(snippet.grammar.scopeName).equal('text.plain.null-grammar');
      (0, _chai.expect)(snippet.value).equal('test snippet');

      (0, _chai.expect)(grammarSpy.calledWith('source.testlang')).to.be.true;
    }));
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvZGF0YXRpcC1hZGFwdGVyLnRlc3QuanMiXSwibmFtZXMiOlsibHMiLCJkZXNjcmliZSIsImZha2VFZGl0b3IiLCJjb25uZWN0aW9uIiwiYmVmb3JlRWFjaCIsIkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiIsIml0IiwicmVzdWx0IiwiY2FuQWRhcHQiLCJob3ZlclByb3ZpZGVyIiwidG8iLCJiZSIsInRydWUiLCJmYWxzZSIsInN0dWIiLCJyZXNvbHZlcyIsInJhbmdlIiwic3RhcnQiLCJsaW5lIiwiY2hhcmFjdGVyIiwiZW5kIiwiY29udGVudHMiLCJsYW5ndWFnZSIsInZhbHVlIiwiZ3JhbW1hclNweSIsInNweSIsImF0b20iLCJncmFtbWFycyIsImRhdGF0aXBBZGFwdGVyIiwiZGF0YXRpcCIsImdldERhdGF0aXAiLCJvayIsInJvdyIsImVxdWFsIiwiY29sdW1uIiwibWFya2VkU3RyaW5ncyIsImhhdmUiLCJsZW5ndGhPZiIsImVxbCIsInR5cGUiLCJzbmlwcGV0IiwiZ3JhbW1hciIsInNjb3BlTmFtZSIsImNhbGxlZFdpdGgiXSwibWFwcGluZ3MiOiJBQUVBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBWUEsRTs7QUFDWjs7OztBQUNBOzs7Ozs7OztBQUVBQyxTQUFTLGdCQUFULEVBQTJCLE1BQU07QUFDL0IsTUFBSUMsVUFBSjtBQUNBLE1BQUlDLFVBQUo7O0FBRUFDLGFBQVcsTUFBTTtBQUNmRCxpQkFBYSxJQUFJSCxHQUFHSyx3QkFBUCxDQUFnQyxtQ0FBaEMsQ0FBYjtBQUNBSCxpQkFBYSxnQ0FBYjtBQUNELEdBSEQ7O0FBS0FELFdBQVMsVUFBVCxFQUFxQixNQUFNO0FBQ3pCSyxPQUFHLDRDQUFILEVBQWlELE1BQU07QUFDckQsWUFBTUMsU0FBUyx5QkFBZUMsUUFBZixDQUF3QixFQUFDQyxlQUFlLElBQWhCLEVBQXhCLENBQWY7QUFDQSx3QkFBT0YsTUFBUCxFQUFlRyxFQUFmLENBQWtCQyxFQUFsQixDQUFxQkMsSUFBckI7QUFDRCxLQUhEOztBQUtBTixPQUFHLDhDQUFILEVBQW1ELE1BQU07QUFDdkQsWUFBTUMsU0FBUyx5QkFBZUMsUUFBZixDQUF3QixFQUF4QixDQUFmO0FBQ0Esd0JBQU9ELE1BQVAsRUFBZUcsRUFBZixDQUFrQkMsRUFBbEIsQ0FBcUJFLEtBQXJCO0FBQ0QsS0FIRDtBQUlELEdBVkQ7O0FBWUFaLFdBQVMsWUFBVCxFQUF1QixNQUFNO0FBQzNCSyxPQUFHLGdEQUFILG9CQUFxRCxhQUFZO0FBQy9ELHNCQUFNUSxJQUFOLENBQVdYLFVBQVgsRUFBdUIsT0FBdkIsRUFBZ0NZLFFBQWhDLENBQXlDO0FBQ3ZDQyxlQUFPO0FBQ0xDLGlCQUFPLEVBQUNDLE1BQU0sQ0FBUCxFQUFVQyxXQUFXLENBQXJCLEVBREY7QUFFTEMsZUFBSyxFQUFDRixNQUFNLENBQVAsRUFBVUMsV0FBVyxDQUFyQjtBQUZBLFNBRGdDO0FBS3ZDRSxrQkFBVSxDQUFDLE1BQUQsRUFBUyxFQUFDQyxVQUFVLFVBQVgsRUFBdUJDLE9BQU8sY0FBOUIsRUFBVDtBQUw2QixPQUF6Qzs7QUFRQSxZQUFNQyxhQUFhLGdCQUFNQyxHQUFOLENBQVVDLEtBQUtDLFFBQWYsRUFBeUIscUJBQXpCLENBQW5COztBQUVBLFlBQU1DLGlCQUFpQiw4QkFBdkI7QUFDQSxZQUFNQyxVQUFVLE1BQU1ELGVBQWVFLFVBQWYsQ0FBMEIzQixVQUExQixFQUFzQ0QsVUFBdEMsRUFBa0QsZ0JBQVUsQ0FBVixFQUFhLENBQWIsQ0FBbEQsQ0FBdEI7QUFDQSx3QkFBTzJCLE9BQVAsRUFBZ0JuQixFQUFoQixDQUFtQkMsRUFBbkIsQ0FBc0JvQixFQUF0QjtBQUNBLDRCQUFVRixXQUFXLElBQXJCOztBQUVBLHdCQUFPQSxRQUFRYixLQUFSLENBQWNDLEtBQWQsQ0FBb0JlLEdBQTNCLEVBQWdDQyxLQUFoQyxDQUFzQyxDQUF0QztBQUNBLHdCQUFPSixRQUFRYixLQUFSLENBQWNDLEtBQWQsQ0FBb0JpQixNQUEzQixFQUFtQ0QsS0FBbkMsQ0FBeUMsQ0FBekM7QUFDQSx3QkFBT0osUUFBUWIsS0FBUixDQUFjSSxHQUFkLENBQWtCWSxHQUF6QixFQUE4QkMsS0FBOUIsQ0FBb0MsQ0FBcEM7QUFDQSx3QkFBT0osUUFBUWIsS0FBUixDQUFjSSxHQUFkLENBQWtCYyxNQUF6QixFQUFpQ0QsS0FBakMsQ0FBdUMsQ0FBdkM7O0FBRUEsd0JBQU9KLFFBQVFNLGFBQWYsRUFBOEJ6QixFQUE5QixDQUFpQzBCLElBQWpDLENBQXNDQyxRQUF0QyxDQUErQyxDQUEvQztBQUNBLHdCQUFPUixRQUFRTSxhQUFSLENBQXNCLENBQXRCLENBQVAsRUFBaUNHLEdBQWpDLENBQXFDLEVBQUNDLE1BQU0sVUFBUCxFQUFtQmhCLE9BQU8sTUFBMUIsRUFBckM7O0FBRUEsWUFBTWlCLFVBQVVYLFFBQVFNLGFBQVIsQ0FBc0IsQ0FBdEIsQ0FBaEI7QUFDQSx3QkFBT0ssUUFBUUQsSUFBZixFQUFxQk4sS0FBckIsQ0FBMkIsU0FBM0I7QUFDQSw0QkFBVU8sUUFBUUQsSUFBUixLQUFpQixTQUEzQjtBQUNBLHdCQUFPQyxRQUFRQyxPQUFSLENBQWdCQyxTQUF2QixFQUFrQ1QsS0FBbEMsQ0FBd0MseUJBQXhDO0FBQ0Esd0JBQU9PLFFBQVFqQixLQUFmLEVBQXNCVSxLQUF0QixDQUE0QixjQUE1Qjs7QUFFQSx3QkFBT1QsV0FBV21CLFVBQVgsQ0FBc0IsaUJBQXRCLENBQVAsRUFBaURqQyxFQUFqRCxDQUFvREMsRUFBcEQsQ0FBdURDLElBQXZEO0FBQ0QsS0EvQkQ7QUFnQ0QsR0FqQ0Q7QUFrQ0QsQ0F2REQiLCJmaWxlIjoiZGF0YXRpcC1hZGFwdGVyLnRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge1BvaW50fSBmcm9tICdhdG9tJztcclxuaW1wb3J0IHtleHBlY3R9IGZyb20gJ2NoYWknO1xyXG5pbXBvcnQgc2lub24gZnJvbSAnc2lub24nO1xyXG5pbXBvcnQgKiBhcyBscyBmcm9tICcuLi8uLi9saWIvbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgRGF0YXRpcEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL2RhdGF0aXAtYWRhcHRlcic7XHJcbmltcG9ydCB7Y3JlYXRlU3B5Q29ubmVjdGlvbiwgY3JlYXRlRmFrZUVkaXRvcn0gZnJvbSAnLi4vaGVscGVycy5qcyc7XHJcblxyXG5kZXNjcmliZSgnRGF0YXRpcEFkYXB0ZXInLCAoKSA9PiB7XHJcbiAgbGV0IGZha2VFZGl0b3I7XHJcbiAgbGV0IGNvbm5lY3Rpb247XHJcblxyXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgY29ubmVjdGlvbiA9IG5ldyBscy5MYW5ndWFnZUNsaWVudENvbm5lY3Rpb24oY3JlYXRlU3B5Q29ubmVjdGlvbigpKTtcclxuICAgIGZha2VFZGl0b3IgPSBjcmVhdGVGYWtlRWRpdG9yKCk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdjYW5BZGFwdCcsICgpID0+IHtcclxuICAgIGl0KCdyZXR1cm5zIHRydWUgaWYgaG92ZXJQcm92aWRlciBpcyBzdXBwb3J0ZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IERhdGF0aXBBZGFwdGVyLmNhbkFkYXB0KHtob3ZlclByb3ZpZGVyOiB0cnVlfSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLnRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncmV0dXJucyBmYWxzZSBpZiBob3ZlclByb3ZpZGVyIG5vdCBzdXBwb3J0ZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IERhdGF0aXBBZGFwdGVyLmNhbkFkYXB0KHt9KTtcclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUuZmFsc2U7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2dldERhdGF0aXAnLCAoKSA9PiB7XHJcbiAgICBpdCgnY2FsbHMgTFNQIGRvY3VtZW50L2hvdmVyIGF0IHRoZSBnaXZlbiBwb3NpdGlvbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgc2lub24uc3R1Yihjb25uZWN0aW9uLCAnaG92ZXInKS5yZXNvbHZlcyh7XHJcbiAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAxfSxcclxuICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50czogWyd0ZXN0Jywge2xhbmd1YWdlOiAndGVzdGxhbmcnLCB2YWx1ZTogJ3Rlc3Qgc25pcHBldCd9XSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBncmFtbWFyU3B5ID0gc2lub24uc3B5KGF0b20uZ3JhbW1hcnMsICdncmFtbWFyRm9yU2NvcGVOYW1lJyk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhdGlwQWRhcHRlciA9IG5ldyBEYXRhdGlwQWRhcHRlcigpO1xyXG4gICAgICBjb25zdCBkYXRhdGlwID0gYXdhaXQgZGF0YXRpcEFkYXB0ZXIuZ2V0RGF0YXRpcChjb25uZWN0aW9uLCBmYWtlRWRpdG9yLCBuZXcgUG9pbnQoMCwgMCkpO1xyXG4gICAgICBleHBlY3QoZGF0YXRpcCkudG8uYmUub2s7XHJcbiAgICAgIGludmFyaWFudChkYXRhdGlwICE9IG51bGwpO1xyXG5cclxuICAgICAgZXhwZWN0KGRhdGF0aXAucmFuZ2Uuc3RhcnQucm93KS5lcXVhbCgwKTtcclxuICAgICAgZXhwZWN0KGRhdGF0aXAucmFuZ2Uuc3RhcnQuY29sdW1uKS5lcXVhbCgxKTtcclxuICAgICAgZXhwZWN0KGRhdGF0aXAucmFuZ2UuZW5kLnJvdykuZXF1YWwoMCk7XHJcbiAgICAgIGV4cGVjdChkYXRhdGlwLnJhbmdlLmVuZC5jb2x1bW4pLmVxdWFsKDIpO1xyXG5cclxuICAgICAgZXhwZWN0KGRhdGF0aXAubWFya2VkU3RyaW5ncykudG8uaGF2ZS5sZW5ndGhPZigyKTtcclxuICAgICAgZXhwZWN0KGRhdGF0aXAubWFya2VkU3RyaW5nc1swXSkuZXFsKHt0eXBlOiAnbWFya2Rvd24nLCB2YWx1ZTogJ3Rlc3QnfSk7XHJcblxyXG4gICAgICBjb25zdCBzbmlwcGV0ID0gZGF0YXRpcC5tYXJrZWRTdHJpbmdzWzFdO1xyXG4gICAgICBleHBlY3Qoc25pcHBldC50eXBlKS5lcXVhbCgnc25pcHBldCcpO1xyXG4gICAgICBpbnZhcmlhbnQoc25pcHBldC50eXBlID09PSAnc25pcHBldCcpO1xyXG4gICAgICBleHBlY3Qoc25pcHBldC5ncmFtbWFyLnNjb3BlTmFtZSkuZXF1YWwoJ3RleHQucGxhaW4ubnVsbC1ncmFtbWFyJyk7XHJcbiAgICAgIGV4cGVjdChzbmlwcGV0LnZhbHVlKS5lcXVhbCgndGVzdCBzbmlwcGV0Jyk7XHJcblxyXG4gICAgICBleHBlY3QoZ3JhbW1hclNweS5jYWxsZWRXaXRoKCdzb3VyY2UudGVzdGxhbmcnKSkudG8uYmUudHJ1ZTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl19