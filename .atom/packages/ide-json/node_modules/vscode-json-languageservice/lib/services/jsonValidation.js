(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../parser/jsonParser", "vscode-languageserver-types"], factory);
    }
})(function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var jsonParser_1 = require("../parser/jsonParser");
    var vscode_languageserver_types_1 = require("vscode-languageserver-types");
    var JSONValidation = (function () {
        function JSONValidation(jsonSchemaService, promiseConstructor) {
            this.jsonSchemaService = jsonSchemaService;
            this.promise = promiseConstructor;
            this.validationEnabled = true;
        }
        JSONValidation.prototype.configure = function (raw) {
            if (raw) {
                this.validationEnabled = raw.validate;
            }
        };
        JSONValidation.prototype.doValidation = function (textDocument, jsonDocument) {
            if (!this.validationEnabled) {
                return this.promise.resolve([]);
            }
            var diagnostics = [];
            var added = {};
            var addProblem = function (problem) {
                // remove duplicated messages
                var signature = problem.location.start + ' ' + problem.location.end + ' ' + problem.message;
                if (!added[signature]) {
                    added[signature] = true;
                    var range = {
                        start: textDocument.positionAt(problem.location.start),
                        end: textDocument.positionAt(problem.location.end)
                    };
                    var severity = problem.severity === jsonParser_1.ProblemSeverity.Error ? vscode_languageserver_types_1.DiagnosticSeverity.Error : vscode_languageserver_types_1.DiagnosticSeverity.Warning;
                    diagnostics.push({ severity: severity, range: range, message: problem.message });
                }
            };
            jsonDocument.syntaxErrors.forEach(addProblem);
            return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function (schema) {
                if (schema) {
                    if (schema.errors.length && jsonDocument.root) {
                        var astRoot = jsonDocument.root;
                        var property = astRoot.type === 'object' ? astRoot.getFirstProperty('$schema') : null;
                        if (property) {
                            var node = property.value || property;
                            addProblem({ location: { start: node.start, end: node.end }, message: schema.errors[0], severity: jsonParser_1.ProblemSeverity.Warning });
                        }
                        else {
                            addProblem({ location: { start: astRoot.start, end: astRoot.start + 1 }, message: schema.errors[0], severity: jsonParser_1.ProblemSeverity.Warning });
                        }
                    }
                    else {
                        var semanticErrors = jsonDocument.validate(schema.schema);
                        if (semanticErrors) {
                            semanticErrors.forEach(addProblem);
                        }
                    }
                }
                return diagnostics;
            });
        };
        return JSONValidation;
    }());
    exports.JSONValidation = JSONValidation;
});
//# sourceMappingURL=jsonValidation.js.map