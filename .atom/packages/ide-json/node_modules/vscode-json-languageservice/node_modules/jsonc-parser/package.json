{
  "_args": [
    [
      {
        "raw": "jsonc-parser@^2.0.0-next.1",
        "scope": null,
        "escapedName": "jsonc-parser",
        "name": "jsonc-parser",
        "rawSpec": "^2.0.0-next.1",
        "spec": ">=2.0.0-next.1 <3.0.0",
        "type": "range"
      },
      "/private/var/folders/sw/29ny48hs3wj9v9m9rkcd56h00000gn/T/apm-install-dir-118217-51815-1u5ovpm.nr5vm6xbt9/node_modules/ide-json/node_modules/vscode-json-languageservice"
    ]
  ],
  "_from": "jsonc-parser@>=2.0.0-next.1 <3.0.0",
  "_id": "jsonc-parser@2.0.0-next.1",
  "_inCache": true,
  "_location": "/ide-json/vscode-json-languageservice/jsonc-parser",
  "_nodeVersion": "8.9.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/jsonc-parser_2.0.0-next.1_1520515883996_0.3197754837243043"
  },
  "_npmUser": {
    "name": "aeschli",
    "email": "martinae@microsoft.com"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "jsonc-parser@^2.0.0-next.1",
    "scope": null,
    "escapedName": "jsonc-parser",
    "name": "jsonc-parser",
    "rawSpec": "^2.0.0-next.1",
    "spec": ">=2.0.0-next.1 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/ide-json/vscode-json-languageservice"
  ],
  "_resolved": "https://registry.npmjs.org/jsonc-parser/-/jsonc-parser-2.0.0-next.1.tgz",
  "_shasum": "445a824f765a96abfbb286d759a9b1d226b18088",
  "_shrinkwrap": null,
  "_spec": "jsonc-parser@^2.0.0-next.1",
  "_where": "/private/var/folders/sw/29ny48hs3wj9v9m9rkcd56h00000gn/T/apm-install-dir-118217-51815-1u5ovpm.nr5vm6xbt9/node_modules/ide-json/node_modules/vscode-json-languageservice",
  "author": {
    "name": "Microsoft Corporation"
  },
  "bugs": {
    "url": "https://github.com/Microsoft/node-jsonc-parser/issues"
  },
  "dependencies": {},
  "description": "Scanner and parser for JSON with comments.",
  "devDependencies": {
    "@types/mocha": "^2.2.32",
    "@types/node": "^7.0.43",
    "mocha": "^5.0.4",
    "rimraf": "^2.6.2",
    "tslint": "^5.9.1",
    "typescript": "^2.7.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-7BRgtZ0wPCWOUz8oD1m0qo9KKWq8LF1R6Ko38ofbTG3PLa84ucKLIkC/8PLvjFBInfqRo+ah5aazBLscsLTd2Q==",
    "shasum": "445a824f765a96abfbb286d759a9b1d226b18088",
    "tarball": "https://registry.npmjs.org/jsonc-parser/-/jsonc-parser-2.0.0-next.1.tgz",
    "fileCount": 19,
    "unpackedSize": 152311
  },
  "gitHead": "a65f945f66d46ba6546f01289f74bebfea2044f3",
  "homepage": "https://github.com/Microsoft/node-jsonc-parser#readme",
  "license": "MIT",
  "main": "./lib/umd/main.js",
  "maintainers": [
    {
      "name": "aeschli",
      "email": "martinae@microsoft.com"
    },
    {
      "name": "alexandrudima",
      "email": "alexdima@microsoft.com"
    },
    {
      "name": "aweinand",
      "email": "aweinand@microsoft.com"
    },
    {
      "name": "bpasero",
      "email": "benjpas@microsoft.com"
    },
    {
      "name": "chrisdias",
      "email": "cdias@microsoft.com"
    },
    {
      "name": "dbaeumer",
      "email": "dirk.baeumer@gmail.com"
    },
    {
      "name": "egamma",
      "email": "egamma@microsoft.com"
    },
    {
      "name": "isidor",
      "email": "inikolic@microsoft.com"
    },
    {
      "name": "joaomoreno.ms",
      "email": "joao.moreno@microsoft.com"
    },
    {
      "name": "jrieken",
      "email": "jrieken@microsoft.com"
    },
    {
      "name": "microsoft",
      "email": "npmjs@microsoft.com"
    }
  ],
  "module": "./lib/esm/main.js",
  "name": "jsonc-parser",
  "optionalDependencies": {},
  "readme": "# jsonc-parser\nScanner and parser for JSON with comments.\n\n[![npm Package](https://img.shields.io/npm/v/jsonc-parser.svg?style=flat-square)](https://www.npmjs.org/package/jsonc-parser)\n[![NPM Downloads](https://img.shields.io/npm/dm/jsonc-parser.svg)](https://npmjs.org/package/jsonc-parser)\n[![Build Status](https://travis-ci.org/Microsoft/node-jsonc-parser.svg?branch=master)](https://travis-ci.org/Microsoft/node-jsonc-parser)\n\nWhy?\n----\nJSONC is JSON with JavaScript style comments. This node module provides a scanner and fault tolerant parser that can process JSONC but is also useful for standard JSON.\n - the *scanner* tokenizes the input string into tokens and token offsets\n - the *visit* function implements a 'SAX' style parser with callbacks for the encountered properties and values.\n - the *parseTree* function computes a hierarchical DOM with offsets representing the encountered properties and values.\n - the *parse* function evaluates the JavaScipt object represented by JSON string in a fault tolerant fashion. \n - the *getLocation* API returns a location object that describes the property or value located at a given offset in a JSON document.\n - ths *findNodeAtLocation* API finds the node at a given location path in a JSON DOM.\n - the *format* API computes edits to format a JSON document.\n - the *modify* API computes edits to insert, remove or replace a property or value in a JSON document.\n - the *applyEdits* API applies edits to a document.\n\nInstallation\n------------\n\n    npm install --save jsonc-parser\n    \n    \nAPI\n---\n\n### Scanner:\n```typescript\n\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text:string, ignoreTrivia:boolean = false):JSONScanner;\n    \n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n    /**\n     * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n     */\n    setPosition(pos: number): any;\n    /**\n     * Read the next token. Returns the tolen code.\n     */\n    scan(): SyntaxKind;\n    /**\n     * Returns the current scan position, which is after the last read token.\n     */\n    getPosition(): number;\n    /**\n     * Returns the last read token.\n     */\n    getToken(): SyntaxKind;\n    /**\n     * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n     */\n    getTokenValue(): string;\n    /**\n     * The start offset of the last read token.\n     */\n    getTokenOffset(): number;\n    /**\n     * The length of the last read token.\n     */\n    getTokenLength(): number;\n    /**\n     * An error code of the last scan.\n     */\n    getTokenError(): ScanError;\n}\n```\n\n### Parser:\n```typescript\n\nexport interface ParseOptions {\n    disallowComments?: boolean;\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault lolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport declare function parse(text: string, errors?: {error: ParseErrorCode;}[], options?: ParseOptions): any;\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport declare function visit(text: string, visitor: JSONVisitor, options?: ParseOptions): any;\n\nexport interface JSONVisitor {\n    /**\n     * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n     */\n    onObjectBegin?: (offset: number, length: number) => void;\n    /**\n     * Invoked when a property is encountered. The offset and length represent the location of the property name.\n     */\n    onObjectProperty?: (property: string, offset: number, length: number) => void;\n    /**\n     * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n     */\n    onObjectEnd?: (offset: number, length: number) => void;\n    /**\n     * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n     */\n    onArrayBegin?: (offset: number, length: number) => void;\n    /**\n     * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n     */\n    onArrayEnd?: (offset: number, length: number) => void;\n    /**\n     * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n     */\n    onLiteralValue?: (value: any, offset: number, length: number) => void;\n    /**\n     * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n     */\n    onSeparator?: (charcter: string, offset: number, length: number) => void;\n\t/**\n\t * When comments are allowed, invoked when a line or block comment is encountered. The offset and length represent the location of the comment.\n\t */\n\tonComment?: (offset: number, length: number) => void;    \n    /**\n     * Invoked on an error.\n     */\n    onError?: (error: ParseErrorCode, offset: number, length: number) => void;\n}\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport declare function parseTree(text: string, errors?: ParseError[], options?: ParseOptions): Node;\n\nexport declare type NodeType = \"object\" | \"array\" | \"property\" | \"string\" | \"number\" | \"boolean\" | \"null\";\nexport interface Node {\n    type: NodeType;\n    value?: any;\n    offset: number;\n    length: number;\n    columnOffset?: number;\n    parent?: Node;\n    children?: Node[];\n}\n\n```\n\n### Utilities:\n```typescript\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport declare function stripComments(text: string, replaceCh?: string): string;\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport declare function getLocation(text: string, position: number): Location;\n\nexport declare type Segment = string | number;\nexport interface Location {\n    /**\n     * The previous property key or literal value (string, number, boolean or null) or undefined.\n     */\n    previousNode?: Node;\n    /**\n     * The path describing the location in the JSON document. The path consists of a sequence strings\n     * representing an object property or numbers for array indices.\n     */\n    path: Segment[];\n    /**\n     * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n     * '*' will match a single segment, of any property name or index.\n     * '**' will match a sequece of segments or no segment, of any property name or index.\n     */\n    matches: (patterns: Segment[]) => boolean;\n    /**\n     * If set, the location's offset is at a property key.\n     */\n    isAtPropertyKey: boolean;\n}\n\n/**\n * Finds the node at the given path in a JSON DOM.\n */\nexport function findNodeAtLocation(root: Node, path: JSONPath): Node | undefined;\n\n/**\n * Evaluates the JavaScript object of the given JSON DOM node \n */\nexport function getNodeValue(node: Node): any;\n\n/**\n * Computes the edits needed to format a JSON document. \n * \n * @param documentText The input text \n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nexport function format(documentText: string, range: Range, options: FormattingOptions): Edit[];\n\n\n/**\n * Computes the edits needed to modify a value in the JSON document.\n * \n * @param documentText The input text \n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created. \n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`\n */\nexport function modify(text: string, path: JSONPath, value: any, options: ModificationOptions): Edit[];\n\n/**\n * Applies edits to a input string.\n */\nexport function applyEdits(text: string, edits: Edit[]): string;\n\n/**\n * Represents a text modification\n */\nexport interface Edit {\n\t/**\n\t * The start offset of the modification.\n\t */\n\toffset: number;\n\t/**\n\t * The length of the modification. Must not be negative. Empty length represents an *insert*.\n\t */\n\tlength: number;\n\t/**\n\t * The new content. Empty content represents a *remove*.\n\t */\n\tcontent: string;\n}\n\n/**\n * A text range in the document\n*/\nexport interface Range {\n\t/**\n\t * The start offset of the range. \n\t */\n\toffset: number;\n\t/**\n\t * The length of the range. Must not be negative.  \n\t */\n\tlength: number;\n}\n\nexport interface FormattingOptions {\n\t/**\n\t * If indentation is based on spaces (`insertSpaces` = true), then what is the number of spaces that make an indent?\n\t */\n\ttabSize: number;\n\t/**\n\t * Is indentation based on spaces?\n\t */\n\tinsertSpaces: boolean;\n\t/**\n\t * The default 'end of line' character\n\t */\n\teol: string;\n}\n\n```\n\n\nLicense\n-------\n\n(MIT License)\n\nCopyright 2018, Microsoft",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Microsoft/node-jsonc-parser.git"
  },
  "scripts": {
    "clean": "rimraf lib",
    "compile": "tsc -p ./src",
    "compile-esm": "tsc -p ./src/tsconfig.esm.json",
    "postversion": "git push && git push --tags",
    "prepublishOnly": "npm run clean && npm run compile-esm && npm run test",
    "preversion": "npm test",
    "test": "npm run compile && mocha",
    "watch": "tsc -w -p ./src"
  },
  "typings": "./lib/umd/main",
  "version": "2.0.0-next.1"
}
