"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeAndroidDevices = observeAndroidDevices;
exports.adbDeviceForIdentifier = adbDeviceForIdentifier;

var _log4js = require("log4js");

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _SimpleCache = require("@atom-ide-community/nuclide-commons/SimpleCache");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _expected = require("@atom-ide-community/nuclide-commons/expected");

var _nuclideUri = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/nuclideUri"));

var _analytics = require("@atom-ide-community/nuclide-commons/analytics");

var _utils = require("./utils");

var _passesGK = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/passesGK"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
function observeAndroidDevices(host) {
  const serviceUri = _nuclideUri.default.isRemote(host) ? _nuclideUri.default.createRemoteUri(_nuclideUri.default.getHostname(host), '/') : '';
  return pollersForUris.getOrCreate(serviceUri, () => {
    return _rxjsCompatUmdMin.Observable.defer(() => (0, _passesGK.default)('nuclide_device_panel_use_adb_track_devices')).concatMap(useTrackDevices => useTrackDevices ? observeDevicesViaTrackDevices(serviceUri) : observeDevicesViaPolling(serviceUri)).distinctUntilChanged((a, b) => (0, _expected.expectedEqual)(a, b, (v1, v2) => (0, _collection.arrayEqual)(v1, v2, _shallowequal.default), (e1, e2) => e1.message === e2.message)).do(async value => {
      if (value.isError) {
        const {
          error
        } = value;
        const logger = (0, _log4js.getLogger)('@atom-ide-community/nuclide-adb');
        let extras = {
          error
        };

        try {
          if ( // $FlowIgnore
          error.originalError != null && // $FlowIgnore
          error.originalError.code === 'ENOENT') {
            const infoService = await getInfoServiceByNuclideUri(serviceUri);

            if (infoService != null) {
              const rpcEnv = infoService.getServerEnvironment();
              extras = { ...extras,
                pathEnv: rpcEnv.PATH
              };
            }
          }
        } finally {
          logger.warn(value.error.message);
          (0, _analytics.track)('@atom-ide-community/nuclide-adb:device-poller:error', extras);
        }
      }
    }).publishReplay(1).refCount();
  });
}

function convertErrorToValue(error) {
  let message; // $FlowFixMe error.code

  if (error.code === 'ENOENT') {
    message = "'adb' not found in $PATH.";
  } else if ( // RPC call timed out
  error.name === 'RpcTimeoutError' || // RPC call succeeded, but the adb call itself timed out
  error.message === 'Timeout has occurred') {
    message = 'Request timed out, retrying...';
  } else if (error.message === 'Connection Closed') {
    return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending());
  } else {
    message = error.message;
  }

  const newError = new Error("Can't fetch Android devices. " + message); // $FlowIgnore

  newError.originalError = error;
  return _rxjsCompatUmdMin.Observable.of(_expected.Expect.error(newError));
}

function observeDevicesViaPolling(serviceUri) {
  return _rxjsCompatUmdMin.Observable.interval(2000).startWith(0).exhaustMap(() => {
    const service = (0, _utils.getAdbServiceByNuclideUri)(serviceUri);

    if (service == null) {
      // Gracefully handle a lost remote connection
      return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending());
    }

    return _rxjsCompatUmdMin.Observable.fromPromise(service.getDeviceList()).map(devices => _expected.Expect.value(devices)).catch(error => convertErrorToValue(error));
  });
}

function observeDevicesViaTrackDevices(serviceUri) {
  return _rxjsCompatUmdMin.Observable.defer(() => {
    const service = (0, _utils.getAdbServiceByNuclideUri)(serviceUri);

    if (service == null) {
      // Gracefully handle a lost remote connection
      return _rxjsCompatUmdMin.Observable.of(_expected.Expect.pending());
    }

    return service.trackDevices().refCount().map(devices => _expected.Expect.value(devices)).catch(error => convertErrorToValue(error));
  }) // If the process ever exits, retry after 5s
  // $FlowFixMe repeatWhen
  .repeatWhen(notifications => notifications.delay(5000)) // Also, never complete this observable, so we don't switch to a new observable
  // if the process exits, which would invalidate later caching (distinctUntilChanged/publishReplay)
  .merge(_rxjsCompatUmdMin.Observable.never());
}

function getInfoServiceByNuclideUri(uri) {
  let rpcService = null; // Atom's service hub is synchronous.

  atom.packages.serviceHub.consume('nuclide-rpc-services', '0.0.0', provider => {
    rpcService = provider;
  }).dispose();

  if (rpcService == null) {
    return null;
  }

  return rpcService.getServiceByNuclideUri('InfoService', uri);
} // This is a convenient way for any device panel plugins of type Android to get from Device to
// to the strongly typed AdbDevice.


async function adbDeviceForIdentifier(host, identifier) {
  const devices = await observeAndroidDevices(host).take(1).toPromise();
  return devices.getOrDefault([]).find(d => d.serial === identifier);
}

const pollersForUris = new _SimpleCache.SimpleCache();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1hZGIvbGliL0FkYkRldmljZVBvbGxlci5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlQW5kcm9pZERldmljZXMiLCJob3N0Iiwic2VydmljZVVyaSIsIm51Y2xpZGVVcmkiLCJpc1JlbW90ZSIsImNyZWF0ZVJlbW90ZVVyaSIsImdldEhvc3RuYW1lIiwicG9sbGVyc0ZvclVyaXMiLCJnZXRPckNyZWF0ZSIsIk9ic2VydmFibGUiLCJkZWZlciIsImNvbmNhdE1hcCIsInVzZVRyYWNrRGV2aWNlcyIsIm9ic2VydmVEZXZpY2VzVmlhVHJhY2tEZXZpY2VzIiwib2JzZXJ2ZURldmljZXNWaWFQb2xsaW5nIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJhIiwiYiIsInYxIiwidjIiLCJzaGFsbG93RXF1YWwiLCJlMSIsImUyIiwibWVzc2FnZSIsImRvIiwidmFsdWUiLCJpc0Vycm9yIiwiZXJyb3IiLCJsb2dnZXIiLCJleHRyYXMiLCJvcmlnaW5hbEVycm9yIiwiY29kZSIsImluZm9TZXJ2aWNlIiwiZ2V0SW5mb1NlcnZpY2VCeU51Y2xpZGVVcmkiLCJycGNFbnYiLCJnZXRTZXJ2ZXJFbnZpcm9ubWVudCIsInBhdGhFbnYiLCJQQVRIIiwid2FybiIsInB1Ymxpc2hSZXBsYXkiLCJyZWZDb3VudCIsImNvbnZlcnRFcnJvclRvVmFsdWUiLCJuYW1lIiwib2YiLCJFeHBlY3QiLCJwZW5kaW5nIiwibmV3RXJyb3IiLCJFcnJvciIsImludGVydmFsIiwic3RhcnRXaXRoIiwiZXhoYXVzdE1hcCIsInNlcnZpY2UiLCJmcm9tUHJvbWlzZSIsImdldERldmljZUxpc3QiLCJtYXAiLCJkZXZpY2VzIiwiY2F0Y2giLCJ0cmFja0RldmljZXMiLCJyZXBlYXRXaGVuIiwibm90aWZpY2F0aW9ucyIsImRlbGF5IiwibWVyZ2UiLCJuZXZlciIsInVyaSIsInJwY1NlcnZpY2UiLCJhdG9tIiwicGFja2FnZXMiLCJzZXJ2aWNlSHViIiwiY29uc3VtZSIsInByb3ZpZGVyIiwiZGlzcG9zZSIsImdldFNlcnZpY2VCeU51Y2xpZGVVcmkiLCJhZGJEZXZpY2VGb3JJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsInRha2UiLCJ0b1Byb21pc2UiLCJnZXRPckRlZmF1bHQiLCJmaW5kIiwiZCIsInNlcmlhbCIsIlNpbXBsZUNhY2hlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQXpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJPLFNBQVNBLHFCQUFULENBQ0xDLElBREssRUFFbUM7QUFDeEMsUUFBTUMsVUFBVSxHQUFHQyxvQkFBV0MsUUFBWCxDQUFvQkgsSUFBcEIsSUFDZkUsb0JBQVdFLGVBQVgsQ0FBMkJGLG9CQUFXRyxXQUFYLENBQXVCTCxJQUF2QixDQUEzQixFQUF5RCxHQUF6RCxDQURlLEdBRWYsRUFGSjtBQUdBLFNBQU9NLGNBQWMsQ0FBQ0MsV0FBZixDQUEyQk4sVUFBM0IsRUFBdUMsTUFBTTtBQUNsRCxXQUFPTyw2QkFBV0MsS0FBWCxDQUFpQixNQUN0Qix1QkFBUyw0Q0FBVCxDQURLLEVBR0pDLFNBSEksQ0FJSEMsZUFBZSxJQUNiQSxlQUFlLEdBQ1hDLDZCQUE2QixDQUFDWCxVQUFELENBRGxCLEdBRVhZLHdCQUF3QixDQUFDWixVQUFELENBUDNCLEVBU0phLG9CQVRJLENBU2lCLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUNwQiw2QkFDRUQsQ0FERixFQUVFQyxDQUZGLEVBR0UsQ0FBQ0MsRUFBRCxFQUFLQyxFQUFMLEtBQVksNEJBQVdELEVBQVgsRUFBZUMsRUFBZixFQUFtQkMscUJBQW5CLENBSGQsRUFJRSxDQUFDQyxFQUFELEVBQUtDLEVBQUwsS0FBWUQsRUFBRSxDQUFDRSxPQUFILEtBQWVELEVBQUUsQ0FBQ0MsT0FKaEMsQ0FWRyxFQWlCSkMsRUFqQkksQ0FpQkQsTUFB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SyxFQUVMd0UsVUFGSyxFQUdnQjtBQUNyQixRQUFNbEIsT0FBTyxHQUFHLE1BQU12RCxxQkFBcUIsQ0FBQ0MsSUFBRCxDQUFyQixDQUNuQnlFLElBRG1CLENBQ2QsQ0FEYyxFQUVuQkMsU0FGbUIsRUFBdEI7QUFHQSxTQUFPcEIsT0FBTyxDQUFDcUIsWUFBUixDQUFxQixFQUFyQixFQUF5QkMsSUFBekIsQ0FBOEJDLENBQUMsSUFBSUEsQ0FBQyxDQUFDQyxNQUFGLEtBQWFOLFVBQWhELENBQVA7QUFDRDs7QUFFRCxNQUFNbEUsY0FHTCxHQUFHLElBQUl5RSx3QkFBSixFQUhKIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtFeHBlY3RlZH0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXhwZWN0ZWQnO1xyXG5pbXBvcnQgdHlwZSB7TnVjbGlkZVVyaX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvbnVjbGlkZVVyaSc7XHJcbmltcG9ydCB0eXBlIHtBZGJEZXZpY2V9IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtnZXRMb2dnZXJ9IGZyb20gJ2xvZzRqcyc7XHJcbmltcG9ydCB7YXJyYXlFcXVhbH0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvY29sbGVjdGlvbic7XHJcbmltcG9ydCB7U2ltcGxlQ2FjaGV9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1NpbXBsZUNhY2hlJztcclxuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICdzaGFsbG93ZXF1YWwnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCB7RXhwZWN0LCBleHBlY3RlZEVxdWFsfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9leHBlY3RlZCc7XHJcbmltcG9ydCBudWNsaWRlVXJpIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL251Y2xpZGVVcmknO1xyXG5pbXBvcnQge3RyYWNrfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9hbmFseXRpY3MnO1xyXG5pbXBvcnQge2dldEFkYlNlcnZpY2VCeU51Y2xpZGVVcml9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQgcGFzc2VzR0sgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvcGFzc2VzR0snO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVBbmRyb2lkRGV2aWNlcyhcclxuICBob3N0OiBOdWNsaWRlVXJpLFxyXG4pOiBPYnNlcnZhYmxlPEV4cGVjdGVkPEFycmF5PEFkYkRldmljZT4+PiB7XHJcbiAgY29uc3Qgc2VydmljZVVyaSA9IG51Y2xpZGVVcmkuaXNSZW1vdGUoaG9zdClcclxuICAgID8gbnVjbGlkZVVyaS5jcmVhdGVSZW1vdGVVcmkobnVjbGlkZVVyaS5nZXRIb3N0bmFtZShob3N0KSwgJy8nKVxyXG4gICAgOiAnJztcclxuICByZXR1cm4gcG9sbGVyc0ZvclVyaXMuZ2V0T3JDcmVhdGUoc2VydmljZVVyaSwgKCkgPT4ge1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGUuZGVmZXIoKCkgPT5cclxuICAgICAgcGFzc2VzR0soJ251Y2xpZGVfZGV2aWNlX3BhbmVsX3VzZV9hZGJfdHJhY2tfZGV2aWNlcycpLFxyXG4gICAgKVxyXG4gICAgICAuY29uY2F0TWFwKFxyXG4gICAgICAgIHVzZVRyYWNrRGV2aWNlcyA9PlxyXG4gICAgICAgICAgdXNlVHJhY2tEZXZpY2VzXHJcbiAgICAgICAgICAgID8gb2JzZXJ2ZURldmljZXNWaWFUcmFja0RldmljZXMoc2VydmljZVVyaSlcclxuICAgICAgICAgICAgOiBvYnNlcnZlRGV2aWNlc1ZpYVBvbGxpbmcoc2VydmljZVVyaSksXHJcbiAgICAgIClcclxuICAgICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKChhLCBiKSA9PlxyXG4gICAgICAgIGV4cGVjdGVkRXF1YWwoXHJcbiAgICAgICAgICBhLFxyXG4gICAgICAgICAgYixcclxuICAgICAgICAgICh2MSwgdjIpID0+IGFycmF5RXF1YWwodjEsIHYyLCBzaGFsbG93RXF1YWwpLFxyXG4gICAgICAgICAgKGUxLCBlMikgPT4gZTEubWVzc2FnZSA9PT0gZTIubWVzc2FnZSxcclxuICAgICAgICApLFxyXG4gICAgICApXHJcbiAgICAgIC5kbyhhc3luYyB2YWx1ZSA9PiB7XHJcbiAgICAgICAgaWYgKHZhbHVlLmlzRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnN0IHtlcnJvcn0gPSB2YWx1ZTtcclxuICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcignQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWFkYicpO1xyXG4gICAgICAgICAgbGV0IGV4dHJhcyA9IHtlcnJvcn07XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgLy8gJEZsb3dJZ25vcmVcclxuICAgICAgICAgICAgICAoZXJyb3I6IGFueSkub3JpZ2luYWxFcnJvciAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgLy8gJEZsb3dJZ25vcmVcclxuICAgICAgICAgICAgICAoZXJyb3I6IGFueSkub3JpZ2luYWxFcnJvci5jb2RlID09PSAnRU5PRU5UJ1xyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICBjb25zdCBpbmZvU2VydmljZSA9IGF3YWl0IGdldEluZm9TZXJ2aWNlQnlOdWNsaWRlVXJpKHNlcnZpY2VVcmkpO1xyXG4gICAgICAgICAgICAgIGlmIChpbmZvU2VydmljZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBycGNFbnYgPSBpbmZvU2VydmljZS5nZXRTZXJ2ZXJFbnZpcm9ubWVudCgpO1xyXG4gICAgICAgICAgICAgICAgZXh0cmFzID0gey4uLmV4dHJhcywgcGF0aEVudjogcnBjRW52LlBBVEh9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4odmFsdWUuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHRyYWNrKCdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtYWRiOmRldmljZS1wb2xsZXI6ZXJyb3InLCBleHRyYXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLnB1Ymxpc2hSZXBsYXkoMSlcclxuICAgICAgLnJlZkNvdW50KCk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnZlcnRFcnJvclRvVmFsdWUoXHJcbiAgZXJyb3I6IEVycm9yLFxyXG4pOiBPYnNlcnZhYmxlPEV4cGVjdGVkPEFycmF5PEFkYkRldmljZT4+PiB7XHJcbiAgbGV0IG1lc3NhZ2U7XHJcbiAgLy8gJEZsb3dGaXhNZSBlcnJvci5jb2RlXHJcbiAgaWYgKGVycm9yLmNvZGUgPT09ICdFTk9FTlQnKSB7XHJcbiAgICBtZXNzYWdlID0gXCInYWRiJyBub3QgZm91bmQgaW4gJFBBVEguXCI7XHJcbiAgfSBlbHNlIGlmIChcclxuICAgIC8vIFJQQyBjYWxsIHRpbWVkIG91dFxyXG4gICAgZXJyb3IubmFtZSA9PT0gJ1JwY1RpbWVvdXRFcnJvcicgfHxcclxuICAgIC8vIFJQQyBjYWxsIHN1Y2NlZWRlZCwgYnV0IHRoZSBhZGIgY2FsbCBpdHNlbGYgdGltZWQgb3V0XHJcbiAgICBlcnJvci5tZXNzYWdlID09PSAnVGltZW91dCBoYXMgb2NjdXJyZWQnXHJcbiAgKSB7XHJcbiAgICBtZXNzYWdlID0gJ1JlcXVlc3QgdGltZWQgb3V0LCByZXRyeWluZy4uLic7XHJcbiAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlID09PSAnQ29ubmVjdGlvbiBDbG9zZWQnKSB7XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihFeHBlY3QucGVuZGluZygpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgfVxyXG4gIGNvbnN0IG5ld0Vycm9yID0gbmV3IEVycm9yKFwiQ2FuJ3QgZmV0Y2ggQW5kcm9pZCBkZXZpY2VzLiBcIiArIG1lc3NhZ2UpO1xyXG4gIC8vICRGbG93SWdub3JlXHJcbiAgKG5ld0Vycm9yOiBhbnkpLm9yaWdpbmFsRXJyb3IgPSBlcnJvcjtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5vZihFeHBlY3QuZXJyb3IobmV3RXJyb3IpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gb2JzZXJ2ZURldmljZXNWaWFQb2xsaW5nKFxyXG4gIHNlcnZpY2VVcmk6IE51Y2xpZGVVcmksXHJcbik6IE9ic2VydmFibGU8RXhwZWN0ZWQ8QXJyYXk8QWRiRGV2aWNlPj4+IHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKVxyXG4gICAgLnN0YXJ0V2l0aCgwKVxyXG4gICAgLmV4aGF1c3RNYXAoKCkgPT4ge1xyXG4gICAgICBjb25zdCBzZXJ2aWNlID0gZ2V0QWRiU2VydmljZUJ5TnVjbGlkZVVyaShzZXJ2aWNlVXJpKTtcclxuICAgICAgaWYgKHNlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGEgbG9zdCByZW1vdGUgY29ubmVjdGlvblxyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKEV4cGVjdC5wZW5kaW5nKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb21Qcm9taXNlKHNlcnZpY2UuZ2V0RGV2aWNlTGlzdCgpKVxyXG4gICAgICAgIC5tYXAoZGV2aWNlcyA9PiBFeHBlY3QudmFsdWUoZGV2aWNlcykpXHJcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IGNvbnZlcnRFcnJvclRvVmFsdWUoZXJyb3IpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBvYnNlcnZlRGV2aWNlc1ZpYVRyYWNrRGV2aWNlcyhcclxuICBzZXJ2aWNlVXJpOiBOdWNsaWRlVXJpLFxyXG4pOiBPYnNlcnZhYmxlPEV4cGVjdGVkPEFycmF5PEFkYkRldmljZT4+PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIE9ic2VydmFibGUuZGVmZXIoKCkgPT4ge1xyXG4gICAgICBjb25zdCBzZXJ2aWNlID0gZ2V0QWRiU2VydmljZUJ5TnVjbGlkZVVyaShzZXJ2aWNlVXJpKTtcclxuICAgICAgaWYgKHNlcnZpY2UgPT0gbnVsbCkge1xyXG4gICAgICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGEgbG9zdCByZW1vdGUgY29ubmVjdGlvblxyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKEV4cGVjdC5wZW5kaW5nKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZXJ2aWNlXHJcbiAgICAgICAgLnRyYWNrRGV2aWNlcygpXHJcbiAgICAgICAgLnJlZkNvdW50KClcclxuICAgICAgICAubWFwKGRldmljZXMgPT4gRXhwZWN0LnZhbHVlKGRldmljZXMpKVxyXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiBjb252ZXJ0RXJyb3JUb1ZhbHVlKGVycm9yKSk7XHJcbiAgICB9KVxyXG4gICAgICAvLyBJZiB0aGUgcHJvY2VzcyBldmVyIGV4aXRzLCByZXRyeSBhZnRlciA1c1xyXG4gICAgICAvLyAkRmxvd0ZpeE1lIHJlcGVhdFdoZW5cclxuICAgICAgLnJlcGVhdFdoZW4obm90aWZpY2F0aW9ucyA9PiBub3RpZmljYXRpb25zLmRlbGF5KDUwMDApKVxyXG4gICAgICAvLyBBbHNvLCBuZXZlciBjb21wbGV0ZSB0aGlzIG9ic2VydmFibGUsIHNvIHdlIGRvbid0IHN3aXRjaCB0byBhIG5ldyBvYnNlcnZhYmxlXHJcbiAgICAgIC8vIGlmIHRoZSBwcm9jZXNzIGV4aXRzLCB3aGljaCB3b3VsZCBpbnZhbGlkYXRlIGxhdGVyIGNhY2hpbmcgKGRpc3RpbmN0VW50aWxDaGFuZ2VkL3B1Ymxpc2hSZXBsYXkpXHJcbiAgICAgIC5tZXJnZShPYnNlcnZhYmxlLm5ldmVyKCkpXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0SW5mb1NlcnZpY2VCeU51Y2xpZGVVcmkoXHJcbiAgdXJpOiBOdWNsaWRlVXJpLFxyXG4gIC8vICRGbG93SWdub3JlIGVudiBjYW4gY29udGFpbiBhbnl0aGluZ1xyXG4pOiA/e2dldFNlcnZlckVudmlyb25tZW50KCk6IFByb21pc2U8T2JqZWN0Pn0ge1xyXG4gIGxldCBycGNTZXJ2aWNlOiA/bnVjbGlkZSRScGNTZXJ2aWNlID0gbnVsbDtcclxuICAvLyBBdG9tJ3Mgc2VydmljZSBodWIgaXMgc3luY2hyb25vdXMuXHJcbiAgYXRvbS5wYWNrYWdlcy5zZXJ2aWNlSHViXHJcbiAgICAuY29uc3VtZSgnbnVjbGlkZS1ycGMtc2VydmljZXMnLCAnMC4wLjAnLCBwcm92aWRlciA9PiB7XHJcbiAgICAgIHJwY1NlcnZpY2UgPSBwcm92aWRlcjtcclxuICAgIH0pXHJcbiAgICAuZGlzcG9zZSgpO1xyXG4gIGlmIChycGNTZXJ2aWNlID09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuICByZXR1cm4gcnBjU2VydmljZS5nZXRTZXJ2aWNlQnlOdWNsaWRlVXJpKCdJbmZvU2VydmljZScsIHVyaSk7XHJcbn1cclxuXHJcbi8vIFRoaXMgaXMgYSBjb252ZW5pZW50IHdheSBmb3IgYW55IGRldmljZSBwYW5lbCBwbHVnaW5zIG9mIHR5cGUgQW5kcm9pZCB0byBnZXQgZnJvbSBEZXZpY2UgdG9cclxuLy8gdG8gdGhlIHN0cm9uZ2x5IHR5cGVkIEFkYkRldmljZS5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkYkRldmljZUZvcklkZW50aWZpZXIoXHJcbiAgaG9zdDogTnVjbGlkZVVyaSxcclxuICBpZGVudGlmaWVyOiBzdHJpbmcsXHJcbik6IFByb21pc2U8P0FkYkRldmljZT4ge1xyXG4gIGNvbnN0IGRldmljZXMgPSBhd2FpdCBvYnNlcnZlQW5kcm9pZERldmljZXMoaG9zdClcclxuICAgIC50YWtlKDEpXHJcbiAgICAudG9Qcm9taXNlKCk7XHJcbiAgcmV0dXJuIGRldmljZXMuZ2V0T3JEZWZhdWx0KFtdKS5maW5kKGQgPT4gZC5zZXJpYWwgPT09IGlkZW50aWZpZXIpO1xyXG59XHJcblxyXG5jb25zdCBwb2xsZXJzRm9yVXJpczogU2ltcGxlQ2FjaGU8XHJcbiAgc3RyaW5nLFxyXG4gIE9ic2VydmFibGU8RXhwZWN0ZWQ8QXJyYXk8QWRiRGV2aWNlPj4+LFxyXG4+ID0gbmV3IFNpbXBsZUNhY2hlKCk7XHJcbiJdfQ==