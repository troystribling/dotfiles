"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.startTunnelingAdb = startTunnelingAdb;
exports.stopTunnelingAdb = stopTunnelingAdb;
exports.isAdbTunneled = isAdbTunneled;
exports.VERSION_MISMATCH_ERROR = exports.MISSING_ADB_ERROR = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _electron = require("electron");

var _log4js = require("log4js");

var _SimpleCache = require("@atom-ide-community/nuclide-commons/SimpleCache");

var _nuclideUri = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/nuclideUri"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _consumeFirstProvider = _interopRequireDefault(require("@atom-ide-community/nuclide-commons-atom/consumeFirstProvider"));

var _utils = require("./utils");

var _analytics = require("@atom-ide-community/nuclide-commons/analytics");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
let passesGK = async _ => false;

try {
  const fbPassesGK = // eslint-disable-next-line nuclide-internal/modules-dependencies
  require('@atom-ide-community/nuclide-commons/passesGK');

  passesGK = fbPassesGK.default;
} catch (e) {}

const MISSING_ADB_ERROR = 'MissingAdbError';
exports.MISSING_ADB_ERROR = MISSING_ADB_ERROR;
const VERSION_MISMATCH_ERROR = 'VersionMismatchError'; // 1. Starts adb tunneling immediately (does not care if you subscribe)
// 2. Tunneling stays turned on even after you unsubscribe (to prevent too much on/off toggling)
// 3. Sends a value when everything is ready (if already active, it sends 'ready' immediately)
// 4. Guarantees that tunneling is active as long as the observable is not complete (or errored)

exports.VERSION_MISMATCH_ERROR = VERSION_MISMATCH_ERROR;

function startTunnelingAdb(uri, options = {}) {
  if (!_nuclideUri.default.isRemote(uri)) {
    return _rxjsCompatUmdMin.Observable.of('ready').concat(_rxjsCompatUmdMin.Observable.never());
  }

  const {
    tunnels
  } = activeTunnels.getOrCreate(uri, (_, serviceUri) => {
    (0, _assert.default)(typeof serviceUri === 'string');
    const adbService = (0, _utils.getAdbServiceByNuclideUri)(serviceUri);
    const localAdbService = (0, _utils.getAdbServiceByNuclideUri)('');

    const observable = _rxjsCompatUmdMin.Observable.defer(async () => {
      try {
        const [adbVersion, localAdbVersion] = await Promise.all([adbService.getVersion().catch(e => {
          e.host = serviceUri;
          throw e;
        }), localAdbService.getVersion().catch(e => {
          e.host = '';
          throw e;
        })]);

        if (adbVersion !== localAdbVersion) {
          const versionMismatchError = new Error(`Your remote adb version differs from the local one: ${adbVersion} (remote) != ${localAdbVersion} (local)`);
          versionMismatchError.name = VERSION_MISMATCH_ERROR;
          throw versionMismatchError;
        }
      } catch (e) {
        if (e.code === 'ENOENT' && e.host != null) {
          const missingAdbError = new Error(`'adb' not found in ${e.host === '' ? 'local' : 'remote'} $PATH.`);
          missingAdbError.name = MISSING_ADB_ERROR;
          throw missingAdbError;
        } else {
          throw e;
        }
      }

      return adbService.checkMuxStatus();
    }).switchMap(useAdbmux => useAdbmux ? checkInToAdbmux(serviceUri) : openTunnelsManually(serviceUri)).publishReplay(1);

    let adbmuxPort;
    const subscription = observable.subscribe({
      next: port => adbmuxPort = port,
      error: e => {
        (0, _log4js.getLogger)('@atom-ide-community/nuclide-adb:tunneling').error(e);
        (0, _analytics.track)('@atom-ide-community/nuclide-adb:tunneling:error', {
          host: uri,
          error: e
        });

        if (e.name === MISSING_ADB_ERROR) {
          return;
        }

        let detail;
        const buttons = [];

        if (e.name === VERSION_MISMATCH_ERROR) {
          detail = e.message;
          const {
            adbUpgradeLink
          } = options;

          if (e.name === VERSION_MISMATCH_ERROR && adbUpgradeLink != null) {
            buttons.push({
              text: 'View upgrade instructions',
              onDidClick: () => _electron.shell.openExternal(adbUpgradeLink)
            });
          }
        } else {
          detail = "Your local devices won't be available on this host." + (e.name != null && e.name !== 'Error' ? `\n \n${e.name}` : '');
        }

        atom.notifications.addError('Failed to tunnel Android devices', {
          dismissable: true,
          detail,
          buttons
        });
      }
    }); // .add returns a Subscription, the teardown logic of which doesn't seem to get disposed on unsubscribe

    subscription.add(() => {
      if (adbmuxPort != null) {
        adbService.checkOutMuxPort(adbmuxPort);
        adbmuxPort = null;
      }

      stopTunnelingAdb(uri);
    }) // Start everything!
    .add(observable.connect());
    return {
      subscription,
      tunnels: observable
    };
  });
  changes.next();
  return tunnels.mapTo('ready');
}

function stopTunnelingAdb(uri) {
  activeTunnels.delete(uri);
  changes.next();
}

function isAdbTunneled(uri) {
  return changes.startWith(undefined).map(() => activeTunnels.get(uri) != null).distinctUntilChanged();
}

const activeTunnels = new _SimpleCache.SimpleCache({
  keyFactory: uri => _nuclideUri.default.createRemoteUri(_nuclideUri.default.getHostname(uri), '/'),
  dispose: value => value.subscription.unsubscribe()
});
const changes = new _rxjsCompatUmdMin.Subject();

function checkInToAdbmux(host) {
  return _rxjsCompatUmdMin.Observable.defer(async () => {
    const getService = (0, _consumeFirstProvider.default)('nuclide.ssh-tunnel');
    const [service, avoidPrecreatingExopackageTunnel] = await Promise.all([getService, passesGK('nuclide_adb_exopackage_tunnel')]);
    (0, _assert.default)(service);
    return {
      service,
      avoidPrecreatingExopackageTunnel
    };
  }).switchMap(({
    service,
    avoidPrecreatingExopackageTunnel
  }) => {
    const tunnels = [{
      description: 'adbmux',
      from: {
        host,
        port: 'any_available',
        family: 4
      },
      to: {
        host: 'localhost',
        port: 5037,
        family: 4
      }
    }];

    if (!avoidPrecreatingExopackageTunnel) {
      tunnels.push({
        description: 'exopackage',
        from: {
          host,
          port: 2829,
          family: 4
        },
        to: {
          host: 'localhost',
          port: 2829,
          family: 4
        }
      });
    }

    return service.openTunnels(tunnels).map(resolved => resolved[0].from.port);
  }).switchMap(async port => {
    const service = (0, _utils.getAdbServiceByNuclideUri)(host);
    await service.checkInMuxPort(port);
    return port;
  });
}

function openTunnelsManually(host) {
  let retries = 3;
  return _rxjsCompatUmdMin.Observable.defer(async () => {
    await (0, _utils.getAdbServiceByNuclideUri)(host).killServer();
    const service = await (0, _consumeFirstProvider.default)('nuclide.ssh-tunnel');
    (0, _assert.default)(service);
    return service;
  }).timeout(5000).switchMap(service => service.openTunnels([{
    description: 'adb',
    from: {
      host,
      port: 5037,
      family: 4
    },
    to: {
      host: 'localhost',
      port: 5037,
      family: 4
    }
  }, {
    description: 'emulator console',
    from: {
      host,
      port: 5554,
      family: 4
    },
    to: {
      host: 'localhost',
      port: 5554,
      family: 4
    }
  }, {
    description: 'emulator adb',
    from: {
      host,
      port: 5555,
      family: 4
    },
    to: {
      host: 'localhost',
      port: 5555,
      family: 4
    }
  }, {
    description: 'exopackage',
    from: {
      host,
      port: 2829,
      family: 4
    },
    to: {
      host: 'localhost',
      port: 2829,
      family: 4
    }
  }])).retryWhen(errors => {
    return errors.do(error => {
      if (retries-- <= 0) {
        throw error;
      }
    });
  }).mapTo(null);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1hZGIvbGliL1R1bm5lbGluZy5qcyJdLCJuYW1lcyI6WyJwYXNzZXNHSyIsIl8iLCJmYlBhc3Nlc0dLIiwicmVxdWlyZSIsImRlZmF1bHQiLCJlIiwiTUlTU0lOR19BREJfRVJST1IiLCJWRVJTSU9OX01JU01BVENIX0VSUk9SIiwic3RhcnRUdW5uZWxpbmdBZGIiLCJ1cmkiLCJvcHRpb25zIiwibnVjbGlkZVVyaSIsImlzUmVtb3RlIiwiT2JzZXJ2YWJsZSIsIm9mIiwiY29uY2F0IiwibmV2ZXIiLCJ0dW5uZWxzIiwiYWN0aXZlVHVubmVscyIsImdldE9yQ3JlYXRlIiwic2VydmljZVVyaSIsImFkYlNlcnZpY2UiLCJsb2NhbEFkYlNlcnZpY2UiLCJvYnNlcnZhYmxlIiwiZGVmZXIiLCJhZGJWZXJzaW9uIiwibG9jYWxBZGJWZXJzaW9uIiwiUHJvbWlzZSIsImFsbCIsImdldFZlcnNpb24iLCJjYXRjaCIsImhvc3QiLCJ2ZXJzaW9uTWlzbWF0Y2hFcnJvciIsIkVycm9yIiwibmFtZSIsImNvZGUiLCJtaXNzaW5nQWRiRXJyb3IiLCJjaGVja011eFN0YXR1cyIsInN3aXRjaE1hcCIsInVzZUFkYm11eCIsImNoZWNrSW5Ub0FkYm11eCIsIm9wZW5UdW5uZWxzTWFudWFsbHkiLCJwdWJsaXNoUmVwbGF5IiwiYWRibXV4UG9ydCIsInN1YnNjcmlwdGlvbiIsInN1YnNjcmliZSIsIm5leHQiLCJwb3J0IiwiZXJyb3IiLCJkZXRhaWwiLCJidXR0b25zIiwibWVzc2FnZSIsImFkYlVwZ3JhZGVMaW5rIiwicHVzaCIsInRleHQiLCJvbkRpZENsaWNrIiwic2hlbGwiLCJvcGVuRXh0ZXJuYWwiLCJhdG9tIiwibm90aWZpY2F0aW9ucyIsImFkZEVycm9yIiwiZGlzbWlzc2FibGUiLCJhZGQiLCJjaGVja091dE11eFBvcnQiLCJzdG9wVHVubmVsaW5nQWRiIiwiY29ubmVjdCIsImNoYW5nZXMiLCJtYXBUbyIsImRlbGV0ZSIsImlzQWRiVHVubmVsZWQiLCJzdGFydFdpdGgiLCJ1bmRlZmluZWQiLCJtYXAiLCJnZXQiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIlNpbXBsZUNhY2hlIiwia2V5RmFjdG9yeSIsImNyZWF0ZVJlbW90ZVVyaSIsImdldEhvc3RuYW1lIiwiZGlzcG9zZSIsInZhbHVlIiwidW5zdWJzY3JpYmUiLCJTdWJqZWN0IiwiZ2V0U2VydmljZSIsInNlcnZpY2UiLCJhdm9pZFByZWNyZWF0aW5nRXhvcGFja2FnZVR1bm5lbCIsImRlc2NyaXB0aW9uIiwiZnJvbSIsImZhbWlseSIsInRvIiwib3BlblR1bm5lbHMiLCJyZXNvbHZlZCIsImNoZWNrSW5NdXhQb3J0IiwicmV0cmllcyIsImtpbGxTZXJ2ZXIiLCJ0aW1lb3V0IiwicmV0cnlXaGVuIiwiZXJyb3JzIiwiZG8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFnQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUF4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9CQSxJQUFJQSxRQUFRLEdBQUcsTUFBTUMsQ0FBTixJQUFXLEtBQTFCOztBQUNBLElBQUk7QUFDRixRQUFNQyxVQUFVLEdBQ2Q7QUFDQUMsRUFBQUEsT0FBTyxDQUFDLDhDQUFELENBRlQ7O0FBR0FILEVBQUFBLFFBQVEsR0FBR0UsVUFBVSxDQUFDRSxPQUF0QjtBQUNELENBTEQsQ0FLRSxPQUFPQyxDQUFQLEVBQVUsQ0FBRTs7QUFFUCxNQUFNQyxpQkFBaUIsR0FBRyxpQkFBMUI7O0FBQ0EsTUFBTUMsc0JBQXNCLEdBQUcsc0JBQS9CLEMsQ0FFUDtBQUNBO0FBQ0E7QUFDQTs7OztBQUNPLFNBQVNDLGlCQUFULENBQ0xDLEdBREssRUFFTEMsT0FBNkIsR0FBRyxFQUYzQixFQUdnQjtBQUNyQixNQUFJLENBQUNDLG9CQUFXQyxRQUFYLENBQW9CSCxHQUFwQixDQUFMLEVBQStCO0FBQzdCLFdBQU9J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aywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtTc2hUdW5uZWxTZXJ2aWNlfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtYWRiL2xpYi90eXBlcyc7XHJcbmltcG9ydCB0eXBlIHtOdWNsaWRlVXJpfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9udWNsaWRlVXJpJztcclxuaW1wb3J0IHR5cGUge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IHtzaGVsbH0gZnJvbSAnZWxlY3Ryb24nO1xyXG5pbXBvcnQge2dldExvZ2dlcn0gZnJvbSAnbG9nNGpzJztcclxuaW1wb3J0IHtTaW1wbGVDYWNoZX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvU2ltcGxlQ2FjaGUnO1xyXG5pbXBvcnQgbnVjbGlkZVVyaSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9udWNsaWRlVXJpJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgY29uc3VtZUZpcnN0UHJvdmlkZXIgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMtYXRvbS9jb25zdW1lRmlyc3RQcm92aWRlcic7XHJcbmltcG9ydCB7Z2V0QWRiU2VydmljZUJ5TnVjbGlkZVVyaX0gZnJvbSAnLi91dGlscyc7XHJcbmltcG9ydCB7dHJhY2t9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2FuYWx5dGljcyc7XHJcblxyXG5leHBvcnQgdHlwZSBBZGJUdW5uZWxpbmdPcHRpb25zID0ge1xyXG4gIGFkYlVwZ3JhZGVMaW5rPzogc3RyaW5nLFxyXG59O1xyXG5cclxubGV0IHBhc3Nlc0dLID0gYXN5bmMgXyA9PiBmYWxzZTtcclxudHJ5IHtcclxuICBjb25zdCBmYlBhc3Nlc0dLID1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBudWNsaWRlLWludGVybmFsL21vZHVsZXMtZGVwZW5kZW5jaWVzXHJcbiAgICByZXF1aXJlKCdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9wYXNzZXNHSycpO1xyXG4gIHBhc3Nlc0dLID0gZmJQYXNzZXNHSy5kZWZhdWx0O1xyXG59IGNhdGNoIChlKSB7fVxyXG5cclxuZXhwb3J0IGNvbnN0IE1JU1NJTkdfQURCX0VSUk9SID0gJ01pc3NpbmdBZGJFcnJvcic7XHJcbmV4cG9ydCBjb25zdCBWRVJTSU9OX01JU01BVENIX0VSUk9SID0gJ1ZlcnNpb25NaXNtYXRjaEVycm9yJztcclxuXHJcbi8vIDEuIFN0YXJ0cyBhZGIgdHVubmVsaW5nIGltbWVkaWF0ZWx5IChkb2VzIG5vdCBjYXJlIGlmIHlvdSBzdWJzY3JpYmUpXHJcbi8vIDIuIFR1bm5lbGluZyBzdGF5cyB0dXJuZWQgb24gZXZlbiBhZnRlciB5b3UgdW5zdWJzY3JpYmUgKHRvIHByZXZlbnQgdG9vIG11Y2ggb24vb2ZmIHRvZ2dsaW5nKVxyXG4vLyAzLiBTZW5kcyBhIHZhbHVlIHdoZW4gZXZlcnl0aGluZyBpcyByZWFkeSAoaWYgYWxyZWFkeSBhY3RpdmUsIGl0IHNlbmRzICdyZWFkeScgaW1tZWRpYXRlbHkpXHJcbi8vIDQuIEd1YXJhbnRlZXMgdGhhdCB0dW5uZWxpbmcgaXMgYWN0aXZlIGFzIGxvbmcgYXMgdGhlIG9ic2VydmFibGUgaXMgbm90IGNvbXBsZXRlIChvciBlcnJvcmVkKVxyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRUdW5uZWxpbmdBZGIoXHJcbiAgdXJpOiBOdWNsaWRlVXJpLFxyXG4gIG9wdGlvbnM/OiBBZGJUdW5uZWxpbmdPcHRpb25zID0ge30sXHJcbik6IE9ic2VydmFibGU8J3JlYWR5Jz4ge1xyXG4gIGlmICghbnVjbGlkZVVyaS5pc1JlbW90ZSh1cmkpKSB7XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZigncmVhZHknKS5jb25jYXQoT2JzZXJ2YWJsZS5uZXZlcigpKTtcclxuICB9XHJcbiAgY29uc3Qge3R1bm5lbHN9ID0gYWN0aXZlVHVubmVscy5nZXRPckNyZWF0ZSh1cmksIChfLCBzZXJ2aWNlVXJpKSA9PiB7XHJcbiAgICBpbnZhcmlhbnQodHlwZW9mIHNlcnZpY2VVcmkgPT09ICdzdHJpbmcnKTtcclxuICAgIGNvbnN0IGFkYlNlcnZpY2UgPSBnZXRBZGJTZXJ2aWNlQnlOdWNsaWRlVXJpKHNlcnZpY2VVcmkpO1xyXG4gICAgY29uc3QgbG9jYWxBZGJTZXJ2aWNlID0gZ2V0QWRiU2VydmljZUJ5TnVjbGlkZVVyaSgnJyk7XHJcblxyXG4gICAgY29uc3Qgb2JzZXJ2YWJsZSA9IE9ic2VydmFibGUuZGVmZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IFthZGJWZXJzaW9uLCBsb2NhbEFkYlZlcnNpb25dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgYWRiU2VydmljZS5nZXRWZXJzaW9uKCkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIGUuaG9zdCA9IHNlcnZpY2VVcmk7XHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIGxvY2FsQWRiU2VydmljZS5nZXRWZXJzaW9uKCkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIGUuaG9zdCA9ICcnO1xyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICAgXSk7XHJcblxyXG4gICAgICAgIGlmIChhZGJWZXJzaW9uICE9PSBsb2NhbEFkYlZlcnNpb24pIHtcclxuICAgICAgICAgIGNvbnN0IHZlcnNpb25NaXNtYXRjaEVycm9yID0gbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgWW91ciByZW1vdGUgYWRiIHZlcnNpb24gZGlmZmVycyBmcm9tIHRoZSBsb2NhbCBvbmU6ICR7YWRiVmVyc2lvbn0gKHJlbW90ZSkgIT0gJHtsb2NhbEFkYlZlcnNpb259IChsb2NhbClgLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHZlcnNpb25NaXNtYXRjaEVycm9yLm5hbWUgPSBWRVJTSU9OX01JU01BVENIX0VSUk9SO1xyXG4gICAgICAgICAgdGhyb3cgdmVyc2lvbk1pc21hdGNoRXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcgJiYgZS5ob3N0ICE9IG51bGwpIHtcclxuICAgICAgICAgIGNvbnN0IG1pc3NpbmdBZGJFcnJvciA9IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYCdhZGInIG5vdCBmb3VuZCBpbiAke2UuaG9zdCA9PT0gJycgPyAnbG9jYWwnIDogJ3JlbW90ZSd9ICRQQVRILmAsXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgbWlzc2luZ0FkYkVycm9yLm5hbWUgPSBNSVNTSU5HX0FEQl9FUlJPUjtcclxuICAgICAgICAgIHRocm93IG1pc3NpbmdBZGJFcnJvcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhZGJTZXJ2aWNlLmNoZWNrTXV4U3RhdHVzKCk7XHJcbiAgICB9KVxyXG4gICAgICAuc3dpdGNoTWFwKFxyXG4gICAgICAgIHVzZUFkYm11eCA9PlxyXG4gICAgICAgICAgdXNlQWRibXV4XHJcbiAgICAgICAgICAgID8gY2hlY2tJblRvQWRibXV4KHNlcnZpY2VVcmkpXHJcbiAgICAgICAgICAgIDogb3BlblR1bm5lbHNNYW51YWxseShzZXJ2aWNlVXJpKSxcclxuICAgICAgKVxyXG4gICAgICAucHVibGlzaFJlcGxheSgxKTtcclxuXHJcbiAgICBsZXQgYWRibXV4UG9ydDtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcclxuICAgICAgbmV4dDogcG9ydCA9PiAoYWRibXV4UG9ydCA9IHBvcnQpLFxyXG4gICAgICBlcnJvcjogZSA9PiB7XHJcbiAgICAgICAgZ2V0TG9nZ2VyKCdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtYWRiOnR1bm5lbGluZycpLmVycm9yKGUpO1xyXG4gICAgICAgIHRyYWNrKCdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtYWRiOnR1bm5lbGluZzplcnJvcicsIHtob3N0OiB1cmksIGVycm9yOiBlfSk7XHJcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gTUlTU0lOR19BREJfRVJST1IpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRldGFpbDtcclxuICAgICAgICBjb25zdCBidXR0b25zID0gW107XHJcbiAgICAgICAgaWYgKGUubmFtZSA9PT0gVkVSU0lPTl9NSVNNQVRDSF9FUlJPUikge1xyXG4gICAgICAgICAgZGV0YWlsID0gZS5tZXNzYWdlO1xyXG4gICAgICAgICAgY29uc3Qge2FkYlVwZ3JhZGVMaW5rfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSBWRVJTSU9OX01JU01BVENIX0VSUk9SICYmIGFkYlVwZ3JhZGVMaW5rICE9IG51bGwpIHtcclxuICAgICAgICAgICAgYnV0dG9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICB0ZXh0OiAnVmlldyB1cGdyYWRlIGluc3RydWN0aW9ucycsXHJcbiAgICAgICAgICAgICAgb25EaWRDbGljazogKCkgPT4gc2hlbGwub3BlbkV4dGVybmFsKGFkYlVwZ3JhZGVMaW5rKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGRldGFpbCA9XHJcbiAgICAgICAgICAgIFwiWW91ciBsb2NhbCBkZXZpY2VzIHdvbid0IGJlIGF2YWlsYWJsZSBvbiB0aGlzIGhvc3QuXCIgK1xyXG4gICAgICAgICAgICAoZS5uYW1lICE9IG51bGwgJiYgZS5uYW1lICE9PSAnRXJyb3InID8gYFxcbiBcXG4ke2UubmFtZX1gIDogJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IoJ0ZhaWxlZCB0byB0dW5uZWwgQW5kcm9pZCBkZXZpY2VzJywge1xyXG4gICAgICAgICAgZGlzbWlzc2FibGU6IHRydWUsXHJcbiAgICAgICAgICBkZXRhaWwsXHJcbiAgICAgICAgICBidXR0b25zLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gLmFkZCByZXR1cm5zIGEgU3Vic2NyaXB0aW9uLCB0aGUgdGVhcmRvd24gbG9naWMgb2Ygd2hpY2ggZG9lc24ndCBzZWVtIHRvIGdldCBkaXNwb3NlZCBvbiB1bnN1YnNjcmliZVxyXG4gICAgc3Vic2NyaXB0aW9uXHJcbiAgICAgIC5hZGQoKCkgPT4ge1xyXG4gICAgICAgIGlmIChhZGJtdXhQb3J0ICE9IG51bGwpIHtcclxuICAgICAgICAgIGFkYlNlcnZpY2UuY2hlY2tPdXRNdXhQb3J0KGFkYm11eFBvcnQpO1xyXG4gICAgICAgICAgYWRibXV4UG9ydCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BUdW5uZWxpbmdBZGIodXJpKTtcclxuICAgICAgfSlcclxuICAgICAgLy8gU3RhcnQgZXZlcnl0aGluZyFcclxuICAgICAgLmFkZChvYnNlcnZhYmxlLmNvbm5lY3QoKSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3Vic2NyaXB0aW9uLFxyXG4gICAgICB0dW5uZWxzOiBvYnNlcnZhYmxlLFxyXG4gICAgfTtcclxuICB9KTtcclxuICBjaGFuZ2VzLm5leHQoKTtcclxuXHJcbiAgcmV0dXJuIHR1bm5lbHMubWFwVG8oJ3JlYWR5Jyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzdG9wVHVubmVsaW5nQWRiKHVyaTogTnVjbGlkZVVyaSkge1xyXG4gIGFjdGl2ZVR1bm5lbHMuZGVsZXRlKHVyaSk7XHJcbiAgY2hhbmdlcy5uZXh0KCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0FkYlR1bm5lbGVkKHVyaTogTnVjbGlkZVVyaSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gIHJldHVybiBjaGFuZ2VzXHJcbiAgICAuc3RhcnRXaXRoKHVuZGVmaW5lZClcclxuICAgIC5tYXAoKCkgPT4gYWN0aXZlVHVubmVscy5nZXQodXJpKSAhPSBudWxsKVxyXG4gICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKCk7XHJcbn1cclxuXHJcbmNvbnN0IGFjdGl2ZVR1bm5lbHM6IFNpbXBsZUNhY2hlPFxyXG4gIE51Y2xpZGVVcmksXHJcbiAge3R1bm5lbHM6IE9ic2VydmFibGU8P251bWJlcj4sIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9ufSxcclxuPiA9IG5ldyBTaW1wbGVDYWNoZSh7XHJcbiAga2V5RmFjdG9yeTogdXJpID0+XHJcbiAgICBudWNsaWRlVXJpLmNyZWF0ZVJlbW90ZVVyaShudWNsaWRlVXJpLmdldEhvc3RuYW1lKHVyaSksICcvJyksXHJcbiAgZGlzcG9zZTogdmFsdWUgPT4gdmFsdWUuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCksXHJcbn0pO1xyXG5jb25zdCBjaGFuZ2VzOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW5Ub0FkYm11eChob3N0OiBOdWNsaWRlVXJpKTogT2JzZXJ2YWJsZTw/bnVtYmVyPiB7XHJcbiAgcmV0dXJuIE9ic2VydmFibGUuZGVmZXIoYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZ2V0U2VydmljZTogUHJvbWlzZTxTc2hUdW5uZWxTZXJ2aWNlPiA9IGNvbnN1bWVGaXJzdFByb3ZpZGVyKFxyXG4gICAgICAnbnVjbGlkZS5zc2gtdHVubmVsJyxcclxuICAgICk7XHJcbiAgICBjb25zdCBbc2VydmljZSwgYXZvaWRQcmVjcmVhdGluZ0V4b3BhY2thZ2VUdW5uZWxdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICBnZXRTZXJ2aWNlLFxyXG4gICAgICBwYXNzZXNHSygnbnVjbGlkZV9hZGJfZXhvcGFja2FnZV90dW5uZWwnKSxcclxuICAgIF0pO1xyXG4gICAgaW52YXJpYW50KHNlcnZpY2UpO1xyXG4gICAgcmV0dXJuIHtzZXJ2aWNlLCBhdm9pZFByZWNyZWF0aW5nRXhvcGFja2FnZVR1bm5lbH07XHJcbiAgfSlcclxuICAgIC5zd2l0Y2hNYXAoKHtzZXJ2aWNlLCBhdm9pZFByZWNyZWF0aW5nRXhvcGFja2FnZVR1bm5lbH0pID0+IHtcclxuICAgICAgY29uc3QgdHVubmVscyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ2FkYm11eCcsXHJcbiAgICAgICAgICBmcm9tOiB7aG9zdCwgcG9ydDogJ2FueV9hdmFpbGFibGUnLCBmYW1pbHk6IDR9LFxyXG4gICAgICAgICAgdG86IHtob3N0OiAnbG9jYWxob3N0JywgcG9ydDogNTAzNywgZmFtaWx5OiA0fSxcclxuICAgICAgICB9LFxyXG4gICAgICBdO1xyXG4gICAgICBpZiAoIWF2b2lkUHJlY3JlYXRpbmdFeG9wYWNrYWdlVHVubmVsKSB7XHJcbiAgICAgICAgdHVubmVscy5wdXNoKHtcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnZXhvcGFja2FnZScsXHJcbiAgICAgICAgICBmcm9tOiB7aG9zdCwgcG9ydDogMjgyOSwgZmFtaWx5OiA0fSxcclxuICAgICAgICAgIHRvOiB7aG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQ6IDI4MjksIGZhbWlseTogNH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlcnZpY2VcclxuICAgICAgICAub3BlblR1bm5lbHModHVubmVscylcclxuICAgICAgICAubWFwKHJlc29sdmVkID0+IHJlc29sdmVkWzBdLmZyb20ucG9ydCk7XHJcbiAgICB9KVxyXG4gICAgLnN3aXRjaE1hcChhc3luYyBwb3J0ID0+IHtcclxuICAgICAgY29uc3Qgc2VydmljZSA9IGdldEFkYlNlcnZpY2VCeU51Y2xpZGVVcmkoaG9zdCk7XHJcbiAgICAgIGF3YWl0IHNlcnZpY2UuY2hlY2tJbk11eFBvcnQocG9ydCk7XHJcbiAgICAgIHJldHVybiBwb3J0O1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wZW5UdW5uZWxzTWFudWFsbHkoaG9zdDogTnVjbGlkZVVyaSk6IE9ic2VydmFibGU8P251bWJlcj4ge1xyXG4gIGxldCByZXRyaWVzID0gMztcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5kZWZlcihhc3luYyAoKSA9PiB7XHJcbiAgICBhd2FpdCBnZXRBZGJTZXJ2aWNlQnlOdWNsaWRlVXJpKGhvc3QpLmtpbGxTZXJ2ZXIoKTtcclxuXHJcbiAgICBjb25zdCBzZXJ2aWNlOiBTc2hUdW5uZWxTZXJ2aWNlID0gYXdhaXQgY29uc3VtZUZpcnN0UHJvdmlkZXIoXHJcbiAgICAgICdudWNsaWRlLnNzaC10dW5uZWwnLFxyXG4gICAgKTtcclxuICAgIGludmFyaWFudChzZXJ2aWNlKTtcclxuICAgIHJldHVybiBzZXJ2aWNlO1xyXG4gIH0pXHJcbiAgICAudGltZW91dCg1MDAwKVxyXG4gICAgLnN3aXRjaE1hcChzZXJ2aWNlID0+XHJcbiAgICAgIHNlcnZpY2Uub3BlblR1bm5lbHMoW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnYWRiJyxcclxuICAgICAgICAgIGZyb206IHtob3N0LCBwb3J0OiA1MDM3LCBmYW1pbHk6IDR9LFxyXG4gICAgICAgICAgdG86IHtob3N0OiAnbG9jYWxob3N0JywgcG9ydDogNTAzNywgZmFtaWx5OiA0fSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnZW11bGF0b3IgY29uc29sZScsXHJcbiAgICAgICAgICBmcm9tOiB7aG9zdCwgcG9ydDogNTU1NCwgZmFtaWx5OiA0fSxcclxuICAgICAgICAgIHRvOiB7aG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQ6IDU1NTQsIGZhbWlseTogNH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ2VtdWxhdG9yIGFkYicsXHJcbiAgICAgICAgICBmcm9tOiB7aG9zdCwgcG9ydDogNTU1NSwgZmFtaWx5OiA0fSxcclxuICAgICAgICAgIHRvOiB7aG9zdDogJ2xvY2FsaG9zdCcsIHBvcnQ6IDU1NTUsIGZhbWlseTogNH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ2V4b3BhY2thZ2UnLFxyXG4gICAgICAgICAgZnJvbToge2hvc3QsIHBvcnQ6IDI4MjksIGZhbWlseTogNH0sXHJcbiAgICAgICAgICB0bzoge2hvc3Q6ICdsb2NhbGhvc3QnLCBwb3J0OiAyODI5LCBmYW1pbHk6IDR9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0pLFxyXG4gICAgKVxyXG4gICAgLnJldHJ5V2hlbihlcnJvcnMgPT4ge1xyXG4gICAgICByZXR1cm4gZXJyb3JzLmRvKGVycm9yID0+IHtcclxuICAgICAgICBpZiAocmV0cmllcy0tIDw9IDApIHtcclxuICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KVxyXG4gICAgLm1hcFRvKG51bGwpO1xyXG59XHJcbiJdfQ==