"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showMenuForEvent = showMenuForEvent;
exports.default = void 0;

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _assert = _interopRequireDefault(require("assert"));

var _electron = require("electron");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * This class represents a collection of context menu items that have been registered with Atom's
 * ContextMenuManager under a single CSS selector. These items are ordered based on the specified
 * priority with which they are added to this object. (The CSS selector is either specified
 * explicitly via the `cssSelector` property of the RootMenuOptions passed to the constructor, or
 * implicitly via the `parent` property of the SubmenuOptions passed to the constructor.)
 *
 * This is in contrast to Atom's ContextMenuManager, which relies on the specificity of the CSS
 * selector for a menu item to determine its precedence. The motivation behind this approach is to
 * provide a total order on menu item ordering rather than a partial order. As such, this class
 * serves as an adapter between the numeric priority model and ContextMenuManager's model.
 *
 * Note that this class also provides support for submenu items. This requires Atom 1.6 or later
 * because it relies on this fix: https://github.com/atom/atom/pull/10486.
 */
class ContextMenu {
  /**
   * List of items that have been added to this context menu in the order they were added.
   * Note that this list does not get sorted: only a filtered version of it does.
   * Further, this list is mutated heavily, but it is never reassigned.
   */

  /**
   * This is the Disposable that represents adding all of this object's menu items to Atom's own
   * ContextMenuManager. When a new item is added to this object, we must remove all of the items
   * that we previously added to the ContextMenuManager and then re-add them based on the new
   * ordering of priorities that results from the new item.
   */
  constructor(menuOptions) {
    this._menuOptions = void 0;
    this._items = void 0;
    this._needsSort = void 0;
    this._sort = void 0;
    this._disposable = void 0;
    this._menuOptions = menuOptions;
    this._items = [];
    this._needsSort = false;
    this._sort = this._sort.bind(this);
    this._disposable = null;
  }
  /**
   * @return true if this menu does not contain any items; otherwise, returns false. Note this will
   *   return true if it contains only empty submenu items.
   */


  isEmpty() {
    return this._items.length === 0;
  }
  /**
   * Adds the specified item to this contenxt menu.
   *
   * Items with lower priority values appear earlier in the context menu
   * (i.e., items appear in numerical order with respect to priority).
   *
   * @return object whose dispose() method can be used to remove the menu item from this object.
   */


  addItem(item, priority) {
    const value = {
      type: 'item',
      item,
      priority
    };
    return this._addItemToList(value);
  }
  /**
   * Adds the specified submenu to this contenxt menu.
   *
   * Items with lower priority values appear earlier in the context menu
   * (i.e., items appear in numerical order with respect to priority).
   *
   * @return object whose dispose() method can be used to remove the submenu from this object.
   */


  addSubmenu(contextMenu, priority) {
    const value = {
      type: 'menu',
      menu: contextMenu,
      priority
    };
    return this._addItemToList(value);
  }

  _addItemToList(value) {
    this._items.push(value);

    this._needsSort = true;
    process.nextTick(this._sort); // TODO(mbolin): Ideally, this Disposable should be garbage-collected if this ContextMenu is
    // disposed.

    return new _UniversalDisposable.default(() => {
      const index = this._items.indexOf(value);

      this._items.splice(index, 1); // We need to invoke _sort for the management of this._disposable and atom.contextMenu.add.


      this._needsSort = true;

      this._sort();
    });
  }
  /**
   * This method must be invoked after this._items has been modified. If necessary, it will remove
   * all items that this object previously registered with Atom's ContextMenuManager. Then it will
   * re-register everything in this._items once it has been sorted.
   */


  _sort() {
    if (!this._needsSort) {
      return;
    }

    this._needsSort = false;

    if (this._disposable != null) {
      this._disposable.dispose();
    }

    const menuOptions = this._menuOptions;

    if (menuOptions.type === 'root') {
      const items = this._sortAndFilterItems();

      this._disposable = atom.contextMenu.add({
        [menuOptions.cssSelector]: items.map(this._contextMenuItemForInternalItem, this)
      });
    } else if (menuOptions.type === 'submenu') {
      // Tell the parent menu to sort itself.
      menuOptions.parent._needsSort = true;

      menuOptions.parent._sort();
    }
  }
  /** Translates this object's internal representation of a menu item to Atom's representation. */


  _contextMenuItemForInternalItem(internalItem) {
    if (internalItem.type === 'item') {
      return internalItem.item;
    } else if (internalItem.type === 'menu') {
      // Note that due to our own strict renaming rules, this must be a private method instead of a
      // static function because of the access to _menuOptions and _items.
      const menuOptions = internalItem.menu._menuOptions;
      (0, _assert.default)(menuOptions.type === 'submenu');

      const items = internalItem.menu._sortAndFilterItems();

      return {
        label: menuOptions.label,
        submenu: items.map(this._contextMenuItemForInternalItem, this),
        shouldDisplay: menuOptions.shouldDisplay
      };
    } else {
      (0, _assert.default)(false);
    }
  }

  _sortAndFilterItems() {
    const items = this._items.filter(item => {
      if (item.type === 'item') {
        return true;
      } else if (item.type === 'menu') {
        const contextMenu = item.menu;
        return !contextMenu.isEmpty();
      }
    });

    items.sort(compareInternalItems);
    return items;
  }
  /** Removes all items this object has added to Atom's ContextMenuManager. */


  dispose() {
    this._needsSort = false;

    if (this._disposable != null) {
      this._disposable.dispose();
    }

    this._items.length = 0;
  }

  static isEventFromContextMenu(event) {
    // Context menu commands contain a specific `detail` parameter:
    // https://github.com/atom/atom/blob/v1.15.0/src/main-process/context-menu.coffee#L17
    return (// $FlowFixMe(>=0.68.0) Flow suppress (T27187857)
      Array.isArray(event.detail) && // flowlint-next-line sketchy-null-mixed:off
      event.detail[0] && event.detail[0].contextCommand
    );
  }

}
/** Comparator used to sort menu items by priority: lower priorities appear earlier. */


exports.default = ContextMenu;

function compareInternalItems(a, b) {
  return a.priority - b.priority;
}
/**
 * Shows the provided menu template. This will result in [an extra call to `templateForEvent()`][1],
 * but it means that we still go through `showMenuForEvent()`, maintaining its behavior wrt
 * (a)synchronousness. See atom/atom#13398.
 *
 * [1]: https://github.com/atom/atom/blob/v1.13.0/src/context-menu-manager.coffee#L200
 */


function showMenuForEvent(event, menuTemplate) {
  (0, _assert.default)(_electron.remote != null);

  const win = _electron.remote.getCurrentWindow();

  const originalEmit = win.emit;

  const restore = () => {
    win.emit = originalEmit;
  };

  win.emit = (eventType, ...args) => {
    if (eventType !== 'context-menu') {
      return originalEmit(eventType, ...args);
    }

    const result = originalEmit('context-menu', menuTemplate);
    restore();
    return result;
  };

  atom.contextMenu.showForEvent(event);
  return new _UniversalDisposable.default(restore);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vQ29udGV4dE1lbnUuanMiXSwibmFtZXMiOlsiQ29udGV4dE1lbnUiLCJjb25zdHJ1Y3RvciIsIm1lbnVPcHRpb25zIiwiX21lbnVPcHRpb25zIiwiX2l0ZW1zIiwiX25lZWRzU29ydCIsIl9zb3J0IiwiX2Rpc3Bvc2FibGUiLCJiaW5kIiwiaXNFbXB0eSIsImxlbmd0aCIsImFkZEl0ZW0iLCJpdGVtIiwicHJpb3JpdHkiLCJ2YWx1ZSIsInR5cGUiLCJfYWRkSXRlbVRvTGlzdCIsImFkZFN1Ym1lbnUiLCJjb250ZXh0TWVudSIsIm1lbnUiLCJwdXNoIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsImluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsImRpc3Bvc2UiLCJpdGVtcyIsIl9zb3J0QW5kRmlsdGVySXRlbXMiLCJhdG9tIiwiYWRkIiwiY3NzU2VsZWN0b3IiLCJtYXAiLCJfY29udGV4dE1lbnVJdGVtRm9ySW50ZXJuYWxJdGVtIiwicGFyZW50IiwiaW50ZXJuYWxJdGVtIiwibGFiZWwiLCJzdWJtZW51Iiwic2hvdWxkRGlzcGxheSIsImZpbHRlciIsInNvcnQiLCJjb21wYXJlSW50ZXJuYWxJdGVtcyIsImlzRXZlbnRGcm9tQ29udGV4dE1lbnUiLCJldmVudCIsIkFycmF5IiwiaXNBcnJheSIsImRldGFpbCIsImNvbnRleHRDb21tYW5kIiwiYSIsImIiLCJzaG93TWVudUZvckV2ZW50IiwibWVudVRlbXBsYXRlIiwicmVtb3RlIiwid2luIiwiZ2V0Q3VycmVudFdpbmRvdyIsIm9yaWdpbmFsRW1pdCIsImVtaXQiLCJyZXN0b3JlIiwiZXZlbnRUeXBlIiwiYXJncyIsInJlc3VsdCIsInNob3dGb3JFdmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7OztBQWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Z0I7QUFDckIsdUJBQVVDLG9CQUFVLElBQXBCOztBQUNBLFFBQU1DLEdBQUcsR0FBSUQsaUJBQU9FLGdCQUFQLEVBQWI7O0FBQ0EsUUFBTUMsWUFBWSxHQUFHRixHQUFHLENBQUNHLElBQXpCOztBQUNBLFFBQU1DLE9BQU8sR0FBRyxNQUFNO0FBQ3BCSixJQUFBQSxHQUFHLENBQUNHLElBQUosR0FBV0QsWUFBWDtBQUNELEdBRkQ7O0FBR0FGLEVBQUFBLEdBQUcsQ0FBQ0csSUFBSixHQUFXLENBQUNFLFNBQUQsRUFBWSxHQUFHQyxJQUFmLEtBQXdCO0FBQ2pDLFFBQUlELFNBQVMsS0FBSyxjQUFsQixFQUFrQztBQUNoQyxhQUFPSCxZQUFZLENBQUNHLFNBQUQsRUFBWSxHQUFHQyxJQUFmLENBQW5CO0FBQ0Q7O0FBQ0QsVUFBTUMsTUFBTSxHQUFHTCxZQUFZLENBQUMsY0FBRCxFQUFpQkosWUFBakIsQ0FBM0I7QUFDQU0sSUFBQUEsT0FBTztBQUNQLFdBQU9HLE1BQVA7QUFDRCxHQVBEOztBQVFBL0IsRUFBQUEsSUFBSSxDQUFDWixXQUFMLENBQWlCNEMsWUFBakIsQ0FBOEJsQixLQUE5QjtBQUNBLFNBQU8sSUFBSXJCLDRCQUFKLENBQXdCbUMsT0FBeEIsQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvVW5pdmVyc2FsRGlzcG9zYWJsZSc7XHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IHtyZW1vdGV9IGZyb20gJ2VsZWN0cm9uJztcclxuXHJcbnR5cGUgSXRlbSA9IHtcclxuICB0eXBlOiAnaXRlbScsXHJcbiAgaXRlbTogYXRvbSRDb250ZXh0TWVudUl0ZW0sXHJcbiAgcHJpb3JpdHk6IG51bWJlcixcclxufTtcclxuXHJcbnR5cGUgTWVudSA9IHtcclxuICB0eXBlOiAnbWVudScsXHJcbiAgbWVudTogQ29udGV4dE1lbnUsXHJcbiAgcHJpb3JpdHk6IG51bWJlcixcclxufTtcclxuXHJcbnR5cGUgSW50ZXJuYWxJdGVtID0gSXRlbSB8IE1lbnU7XHJcblxyXG50eXBlIFJvb3RNZW51T3B0aW9ucyA9IHtcclxuICB0eXBlOiAncm9vdCcsXHJcbiAgY3NzU2VsZWN0b3I6IHN0cmluZyxcclxufTtcclxuXHJcbnR5cGUgU3VibWVudU9wdGlvbnMgPSB7XHJcbiAgdHlwZTogJ3N1Ym1lbnUnLFxyXG4gIGxhYmVsOiBzdHJpbmcsXHJcbiAgcGFyZW50OiBDb250ZXh0TWVudSxcclxuICBzaG91bGREaXNwbGF5PzogKGU6IE1vdXNlRXZlbnQpID0+IGJvb2xlYW4sXHJcbn07XHJcblxyXG50eXBlIE1lbnVPcHRpb25zID0gUm9vdE1lbnVPcHRpb25zIHwgU3VibWVudU9wdGlvbnM7XHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBjb250ZXh0IG1lbnUgaXRlbXMgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB3aXRoIEF0b20nc1xyXG4gKiBDb250ZXh0TWVudU1hbmFnZXIgdW5kZXIgYSBzaW5nbGUgQ1NTIHNlbGVjdG9yLiBUaGVzZSBpdGVtcyBhcmUgb3JkZXJlZCBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkXHJcbiAqIHByaW9yaXR5IHdpdGggd2hpY2ggdGhleSBhcmUgYWRkZWQgdG8gdGhpcyBvYmplY3QuIChUaGUgQ1NTIHNlbGVjdG9yIGlzIGVpdGhlciBzcGVjaWZpZWRcclxuICogZXhwbGljaXRseSB2aWEgdGhlIGBjc3NTZWxlY3RvcmAgcHJvcGVydHkgb2YgdGhlIFJvb3RNZW51T3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBvclxyXG4gKiBpbXBsaWNpdGx5IHZpYSB0aGUgYHBhcmVudGAgcHJvcGVydHkgb2YgdGhlIFN1Ym1lbnVPcHRpb25zIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuKVxyXG4gKlxyXG4gKiBUaGlzIGlzIGluIGNvbnRyYXN0IHRvIEF0b20ncyBDb250ZXh0TWVudU1hbmFnZXIsIHdoaWNoIHJlbGllcyBvbiB0aGUgc3BlY2lmaWNpdHkgb2YgdGhlIENTU1xyXG4gKiBzZWxlY3RvciBmb3IgYSBtZW51IGl0ZW0gdG8gZGV0ZXJtaW5lIGl0cyBwcmVjZWRlbmNlLiBUaGUgbW90aXZhdGlvbiBiZWhpbmQgdGhpcyBhcHByb2FjaCBpcyB0b1xyXG4gKiBwcm92aWRlIGEgdG90YWwgb3JkZXIgb24gbWVudSBpdGVtIG9yZGVyaW5nIHJhdGhlciB0aGFuIGEgcGFydGlhbCBvcmRlci4gQXMgc3VjaCwgdGhpcyBjbGFzc1xyXG4gKiBzZXJ2ZXMgYXMgYW4gYWRhcHRlciBiZXR3ZWVuIHRoZSBudW1lcmljIHByaW9yaXR5IG1vZGVsIGFuZCBDb250ZXh0TWVudU1hbmFnZXIncyBtb2RlbC5cclxuICpcclxuICogTm90ZSB0aGF0IHRoaXMgY2xhc3MgYWxzbyBwcm92aWRlcyBzdXBwb3J0IGZvciBzdWJtZW51IGl0ZW1zLiBUaGlzIHJlcXVpcmVzIEF0b20gMS42IG9yIGxhdGVyXHJcbiAqIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHRoaXMgZml4OiBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9hdG9tL3B1bGwvMTA0ODYuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250ZXh0TWVudSB7XHJcbiAgX21lbnVPcHRpb25zOiBNZW51T3B0aW9ucztcclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdCBvZiBpdGVtcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGlzIGNvbnRleHQgbWVudSBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGFkZGVkLlxyXG4gICAqIE5vdGUgdGhhdCB0aGlzIGxpc3QgZG9lcyBub3QgZ2V0IHNvcnRlZDogb25seSBhIGZpbHRlcmVkIHZlcnNpb24gb2YgaXQgZG9lcy5cclxuICAgKiBGdXJ0aGVyLCB0aGlzIGxpc3QgaXMgbXV0YXRlZCBoZWF2aWx5LCBidXQgaXQgaXMgbmV2ZXIgcmVhc3NpZ25lZC5cclxuICAgKi9cclxuICBfaXRlbXM6IEFycmF5PEludGVybmFsSXRlbT47XHJcblxyXG4gIF9uZWVkc1NvcnQ6IGJvb2xlYW47XHJcbiAgX3NvcnQ6IEZ1bmN0aW9uO1xyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGlzIHRoZSBEaXNwb3NhYmxlIHRoYXQgcmVwcmVzZW50cyBhZGRpbmcgYWxsIG9mIHRoaXMgb2JqZWN0J3MgbWVudSBpdGVtcyB0byBBdG9tJ3Mgb3duXHJcbiAgICogQ29udGV4dE1lbnVNYW5hZ2VyLiBXaGVuIGEgbmV3IGl0ZW0gaXMgYWRkZWQgdG8gdGhpcyBvYmplY3QsIHdlIG11c3QgcmVtb3ZlIGFsbCBvZiB0aGUgaXRlbXNcclxuICAgKiB0aGF0IHdlIHByZXZpb3VzbHkgYWRkZWQgdG8gdGhlIENvbnRleHRNZW51TWFuYWdlciBhbmQgdGhlbiByZS1hZGQgdGhlbSBiYXNlZCBvbiB0aGUgbmV3XHJcbiAgICogb3JkZXJpbmcgb2YgcHJpb3JpdGllcyB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgbmV3IGl0ZW0uXHJcbiAgICovXHJcbiAgX2Rpc3Bvc2FibGU6ID9JRGlzcG9zYWJsZTtcclxuXHJcbiAgY29uc3RydWN0b3IobWVudU9wdGlvbnM6IE1lbnVPcHRpb25zKSB7XHJcbiAgICB0aGlzLl9tZW51T3B0aW9ucyA9IG1lbnVPcHRpb25zO1xyXG4gICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgIHRoaXMuX25lZWRzU29ydCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fc29ydCA9IHRoaXMuX3NvcnQuYmluZCh0aGlzKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHJldHVybiB0cnVlIGlmIHRoaXMgbWVudSBkb2VzIG5vdCBjb250YWluIGFueSBpdGVtczsgb3RoZXJ3aXNlLCByZXR1cm5zIGZhbHNlLiBOb3RlIHRoaXMgd2lsbFxyXG4gICAqICAgcmV0dXJuIHRydWUgaWYgaXQgY29udGFpbnMgb25seSBlbXB0eSBzdWJtZW51IGl0ZW1zLlxyXG4gICAqL1xyXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoID09PSAwO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIGl0ZW0gdG8gdGhpcyBjb250ZW54dCBtZW51LlxyXG4gICAqXHJcbiAgICogSXRlbXMgd2l0aCBsb3dlciBwcmlvcml0eSB2YWx1ZXMgYXBwZWFyIGVhcmxpZXIgaW4gdGhlIGNvbnRleHQgbWVudVxyXG4gICAqIChpLmUuLCBpdGVtcyBhcHBlYXIgaW4gbnVtZXJpY2FsIG9yZGVyIHdpdGggcmVzcGVjdCB0byBwcmlvcml0eSkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIG9iamVjdCB3aG9zZSBkaXNwb3NlKCkgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbWVudSBpdGVtIGZyb20gdGhpcyBvYmplY3QuXHJcbiAgICovXHJcbiAgYWRkSXRlbShpdGVtOiBhdG9tJENvbnRleHRNZW51SXRlbSwgcHJpb3JpdHk6IG51bWJlcik6IElEaXNwb3NhYmxlIHtcclxuICAgIGNvbnN0IHZhbHVlID0ge3R5cGU6ICdpdGVtJywgaXRlbSwgcHJpb3JpdHl9O1xyXG4gICAgcmV0dXJuIHRoaXMuX2FkZEl0ZW1Ub0xpc3QodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIHN1Ym1lbnUgdG8gdGhpcyBjb250ZW54dCBtZW51LlxyXG4gICAqXHJcbiAgICogSXRlbXMgd2l0aCBsb3dlciBwcmlvcml0eSB2YWx1ZXMgYXBwZWFyIGVhcmxpZXIgaW4gdGhlIGNvbnRleHQgbWVudVxyXG4gICAqIChpLmUuLCBpdGVtcyBhcHBlYXIgaW4gbnVtZXJpY2FsIG9yZGVyIHdpdGggcmVzcGVjdCB0byBwcmlvcml0eSkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIG9iamVjdCB3aG9zZSBkaXNwb3NlKCkgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgc3VibWVudSBmcm9tIHRoaXMgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGFkZFN1Ym1lbnUoY29udGV4dE1lbnU6IENvbnRleHRNZW51LCBwcmlvcml0eTogbnVtYmVyKTogSURpc3Bvc2FibGUge1xyXG4gICAgY29uc3QgdmFsdWUgPSB7dHlwZTogJ21lbnUnLCBtZW51OiBjb250ZXh0TWVudSwgcHJpb3JpdHl9O1xyXG4gICAgcmV0dXJuIHRoaXMuX2FkZEl0ZW1Ub0xpc3QodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgX2FkZEl0ZW1Ub0xpc3QodmFsdWU6IEludGVybmFsSXRlbSk6IElEaXNwb3NhYmxlIHtcclxuICAgIHRoaXMuX2l0ZW1zLnB1c2godmFsdWUpO1xyXG4gICAgdGhpcy5fbmVlZHNTb3J0ID0gdHJ1ZTtcclxuICAgIHByb2Nlc3MubmV4dFRpY2sodGhpcy5fc29ydCk7XHJcblxyXG4gICAgLy8gVE9ETyhtYm9saW4pOiBJZGVhbGx5LCB0aGlzIERpc3Bvc2FibGUgc2hvdWxkIGJlIGdhcmJhZ2UtY29sbGVjdGVkIGlmIHRoaXMgQ29udGV4dE1lbnUgaXNcclxuICAgIC8vIGRpc3Bvc2VkLlxyXG4gICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKHZhbHVlKTtcclxuICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgIC8vIFdlIG5lZWQgdG8gaW52b2tlIF9zb3J0IGZvciB0aGUgbWFuYWdlbWVudCBvZiB0aGlzLl9kaXNwb3NhYmxlIGFuZCBhdG9tLmNvbnRleHRNZW51LmFkZC5cclxuICAgICAgdGhpcy5fbmVlZHNTb3J0ID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fc29ydCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCBtdXN0IGJlIGludm9rZWQgYWZ0ZXIgdGhpcy5faXRlbXMgaGFzIGJlZW4gbW9kaWZpZWQuIElmIG5lY2Vzc2FyeSwgaXQgd2lsbCByZW1vdmVcclxuICAgKiBhbGwgaXRlbXMgdGhhdCB0aGlzIG9iamVjdCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBBdG9tJ3MgQ29udGV4dE1lbnVNYW5hZ2VyLiBUaGVuIGl0IHdpbGxcclxuICAgKiByZS1yZWdpc3RlciBldmVyeXRoaW5nIGluIHRoaXMuX2l0ZW1zIG9uY2UgaXQgaGFzIGJlZW4gc29ydGVkLlxyXG4gICAqL1xyXG4gIF9zb3J0KCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLl9uZWVkc1NvcnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX25lZWRzU29ydCA9IGZhbHNlO1xyXG5cclxuICAgIGlmICh0aGlzLl9kaXNwb3NhYmxlICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWVudU9wdGlvbnMgPSB0aGlzLl9tZW51T3B0aW9ucztcclxuICAgIGlmIChtZW51T3B0aW9ucy50eXBlID09PSAncm9vdCcpIHtcclxuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9zb3J0QW5kRmlsdGVySXRlbXMoKTtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZSA9IGF0b20uY29udGV4dE1lbnUuYWRkKHtcclxuICAgICAgICBbbWVudU9wdGlvbnMuY3NzU2VsZWN0b3JdOiBpdGVtcy5tYXAoXHJcbiAgICAgICAgICB0aGlzLl9jb250ZXh0TWVudUl0ZW1Gb3JJbnRlcm5hbEl0ZW0sXHJcbiAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICksXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChtZW51T3B0aW9ucy50eXBlID09PSAnc3VibWVudScpIHtcclxuICAgICAgLy8gVGVsbCB0aGUgcGFyZW50IG1lbnUgdG8gc29ydCBpdHNlbGYuXHJcbiAgICAgIG1lbnVPcHRpb25zLnBhcmVudC5fbmVlZHNTb3J0ID0gdHJ1ZTtcclxuICAgICAgbWVudU9wdGlvbnMucGFyZW50Ll9zb3J0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKiogVHJhbnNsYXRlcyB0aGlzIG9iamVjdCdzIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbWVudSBpdGVtIHRvIEF0b20ncyByZXByZXNlbnRhdGlvbi4gKi9cclxuICBfY29udGV4dE1lbnVJdGVtRm9ySW50ZXJuYWxJdGVtKFxyXG4gICAgaW50ZXJuYWxJdGVtOiBJbnRlcm5hbEl0ZW0sXHJcbiAgKTogYXRvbSRDb250ZXh0TWVudUl0ZW0ge1xyXG4gICAgaWYgKGludGVybmFsSXRlbS50eXBlID09PSAnaXRlbScpIHtcclxuICAgICAgcmV0dXJuIGludGVybmFsSXRlbS5pdGVtO1xyXG4gICAgfSBlbHNlIGlmIChpbnRlcm5hbEl0ZW0udHlwZSA9PT0gJ21lbnUnKSB7XHJcbiAgICAgIC8vIE5vdGUgdGhhdCBkdWUgdG8gb3VyIG93biBzdHJpY3QgcmVuYW1pbmcgcnVsZXMsIHRoaXMgbXVzdCBiZSBhIHByaXZhdGUgbWV0aG9kIGluc3RlYWQgb2YgYVxyXG4gICAgICAvLyBzdGF0aWMgZnVuY3Rpb24gYmVjYXVzZSBvZiB0aGUgYWNjZXNzIHRvIF9tZW51T3B0aW9ucyBhbmQgX2l0ZW1zLlxyXG4gICAgICBjb25zdCBtZW51T3B0aW9ucyA9IGludGVybmFsSXRlbS5tZW51Ll9tZW51T3B0aW9ucztcclxuICAgICAgaW52YXJpYW50KG1lbnVPcHRpb25zLnR5cGUgPT09ICdzdWJtZW51Jyk7XHJcbiAgICAgIGNvbnN0IGl0ZW1zID0gaW50ZXJuYWxJdGVtLm1lbnUuX3NvcnRBbmRGaWx0ZXJJdGVtcygpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGxhYmVsOiBtZW51T3B0aW9ucy5sYWJlbCxcclxuICAgICAgICBzdWJtZW51OiBpdGVtcy5tYXAodGhpcy5fY29udGV4dE1lbnVJdGVtRm9ySW50ZXJuYWxJdGVtLCB0aGlzKSxcclxuICAgICAgICBzaG91bGREaXNwbGF5OiBtZW51T3B0aW9ucy5zaG91bGREaXNwbGF5LFxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW52YXJpYW50KGZhbHNlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9zb3J0QW5kRmlsdGVySXRlbXMoKTogQXJyYXk8SW50ZXJuYWxJdGVtPiB7XHJcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zLmZpbHRlcigoaXRlbTogSW50ZXJuYWxJdGVtKSA9PiB7XHJcbiAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdpdGVtJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ21lbnUnKSB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dE1lbnUgPSBpdGVtLm1lbnU7XHJcbiAgICAgICAgcmV0dXJuICFjb250ZXh0TWVudS5pc0VtcHR5KCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaXRlbXMuc29ydChjb21wYXJlSW50ZXJuYWxJdGVtcyk7XHJcbiAgICByZXR1cm4gaXRlbXM7XHJcbiAgfVxyXG5cclxuICAvKiogUmVtb3ZlcyBhbGwgaXRlbXMgdGhpcyBvYmplY3QgaGFzIGFkZGVkIHRvIEF0b20ncyBDb250ZXh0TWVudU1hbmFnZXIuICovXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuX25lZWRzU29ydCA9IGZhbHNlO1xyXG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2FibGUgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2l0ZW1zLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgaXNFdmVudEZyb21Db250ZXh0TWVudShldmVudDogRXZlbnQpIHtcclxuICAgIC8vIENvbnRleHQgbWVudSBjb21tYW5kcyBjb250YWluIGEgc3BlY2lmaWMgYGRldGFpbGAgcGFyYW1ldGVyOlxyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b20vYXRvbS9ibG9iL3YxLjE1LjAvc3JjL21haW4tcHJvY2Vzcy9jb250ZXh0LW1lbnUuY29mZmVlI0wxN1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgLy8gJEZsb3dGaXhNZSg+PTAuNjguMCkgRmxvdyBzdXBwcmVzcyAoVDI3MTg3ODU3KVxyXG4gICAgICBBcnJheS5pc0FycmF5KGV2ZW50LmRldGFpbCkgJiZcclxuICAgICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHNrZXRjaHktbnVsbC1taXhlZDpvZmZcclxuICAgICAgZXZlbnQuZGV0YWlsWzBdICYmXHJcbiAgICAgIChldmVudC5kZXRhaWxbMF06IGFueSkuY29udGV4dENvbW1hbmRcclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKiogQ29tcGFyYXRvciB1c2VkIHRvIHNvcnQgbWVudSBpdGVtcyBieSBwcmlvcml0eTogbG93ZXIgcHJpb3JpdGllcyBhcHBlYXIgZWFybGllci4gKi9cclxuZnVuY3Rpb24gY29tcGFyZUludGVybmFsSXRlbXMoYTogSW50ZXJuYWxJdGVtLCBiOiBJbnRlcm5hbEl0ZW0pOiBudW1iZXIge1xyXG4gIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3dzIHRoZSBwcm92aWRlZCBtZW51IHRlbXBsYXRlLiBUaGlzIHdpbGwgcmVzdWx0IGluIFthbiBleHRyYSBjYWxsIHRvIGB0ZW1wbGF0ZUZvckV2ZW50KClgXVsxXSxcclxuICogYnV0IGl0IG1lYW5zIHRoYXQgd2Ugc3RpbGwgZ28gdGhyb3VnaCBgc2hvd01lbnVGb3JFdmVudCgpYCwgbWFpbnRhaW5pbmcgaXRzIGJlaGF2aW9yIHdydFxyXG4gKiAoYSlzeW5jaHJvbm91c25lc3MuIFNlZSBhdG9tL2F0b20jMTMzOTguXHJcbiAqXHJcbiAqIFsxXTogaHR0cHM6Ly9naXRodWIuY29tL2F0b20vYXRvbS9ibG9iL3YxLjEzLjAvc3JjL2NvbnRleHQtbWVudS1tYW5hZ2VyLmNvZmZlZSNMMjAwXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2hvd01lbnVGb3JFdmVudChcclxuICBldmVudDogTW91c2VFdmVudCxcclxuICBtZW51VGVtcGxhdGU6IEFycmF5PE9iamVjdD4sXHJcbik6IFVuaXZlcnNhbERpc3Bvc2FibGUge1xyXG4gIGludmFyaWFudChyZW1vdGUgIT0gbnVsbCk7XHJcbiAgY29uc3Qgd2luID0gKHJlbW90ZS5nZXRDdXJyZW50V2luZG93KCk6IGFueSk7XHJcbiAgY29uc3Qgb3JpZ2luYWxFbWl0ID0gd2luLmVtaXQ7XHJcbiAgY29uc3QgcmVzdG9yZSA9ICgpID0+IHtcclxuICAgIHdpbi5lbWl0ID0gb3JpZ2luYWxFbWl0O1xyXG4gIH07XHJcbiAgd2luLmVtaXQgPSAoZXZlbnRUeXBlLCAuLi5hcmdzKSA9PiB7XHJcbiAgICBpZiAoZXZlbnRUeXBlICE9PSAnY29udGV4dC1tZW51Jykge1xyXG4gICAgICByZXR1cm4gb3JpZ2luYWxFbWl0KGV2ZW50VHlwZSwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hbEVtaXQoJ2NvbnRleHQtbWVudScsIG1lbnVUZW1wbGF0ZSk7XHJcbiAgICByZXN0b3JlKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcbiAgYXRvbS5jb250ZXh0TWVudS5zaG93Rm9yRXZlbnQoZXZlbnQpO1xyXG4gIHJldHVybiBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShyZXN0b3JlKTtcclxufVxyXG4iXX0=