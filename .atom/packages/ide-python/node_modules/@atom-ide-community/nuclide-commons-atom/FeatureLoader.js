"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.INITIAL_FEATURE_GROUP = exports.REQUIRED_FEATURE_GROUP = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _idx = _interopRequireDefault(require("idx"));

var _event = require("@atom-ide-community/nuclide-commons/event");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _activatePackages = _interopRequireDefault(require("./experimental-packages/activatePackages"));

var _nuclideConfig = _interopRequireDefault(require("./nuclide-config"));

var _featureConfig = _interopRequireDefault(require("./feature-config"));

var _path2 = _interopRequireDefault(require("path"));

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* global localStorage */
// eslint-disable-line nuclide-internal/prefer-nuclide-uri
const ALWAYS_ENABLED = 'always';
const NEVER_ENABLED = 'never';
const DEFAULT = 'default';
const {
  devMode
} = atom.getLoadSettings();
const REQUIRED_FEATURE_GROUP = 'nuclide-required';
exports.REQUIRED_FEATURE_GROUP = REQUIRED_FEATURE_GROUP;
const INITIAL_FEATURE_GROUP = 'nuclide-core';
exports.INITIAL_FEATURE_GROUP = INITIAL_FEATURE_GROUP;

class FeatureLoader {
  constructor({
    features,
    path: _path,
    featureGroups
  }) {
    this._activationDisposable = void 0;
    this._loadDisposable = void 0;
    this._config = void 0;
    this._features = void 0;
    this._featureBeingActivated = void 0;
    this._featureBeingDeactivated = void 0;
    this._featureGroups = void 0;
    this._deferringFeatureActivation = true;
    this._pkgName = void 0;
    this._path = void 0;
    this._currentlyActiveFeatures = new Set();
    this._path = _path;
    this._features = reorderFeatures(features);
    this._loadDisposable = new _UniversalDisposable.default();
    this._pkgName = packageNameFromPath(this._path);
    this._featureGroups = groupFeatures(this._features, featureGroups == null ? {} : featureGroups);
  } // Build the config. Should occur with root package's load


  load() {
    (0, _assert.default)(!this._loadDisposable.disposed);
    patchPackageManager(); // Add a dummy deserializer. This forces Atom to load Nuclide's main module
    // (this file) when the package is loaded, which is super important because
    // this module loads all of the Nuclide features. We could accomplish the same
    // thing by unsetting [the local storage value][1] that Atom uses to indicate
    // whether the main module load can be deferred, however, that would mean that
    // (for a brief time, at least), the flag would be set. If there were an error
    // during that time and we never got a chance to unset the flag, Nuclide
    // features would never load again!
    //
    // [1] https://github.com/atom/atom/blob/v1.9.8/src/package.coffee#L442

    this._loadDisposable.add(atom.deserializers.add({
      name: `${this._pkgName}.ForceMainModuleLoad`,

      deserialize() {}

    }));

    _featureConfig.default.setPackageName(this._pkgName);

    _nuclideConfig.default.setPackageName(this._pkgName); //
    // Build the "config" object. This determines the config defaults and
    // it's what is shown by the Settings view. It includes:
    // (1) An entry to enable/disable each feature - called "${pkgName}.use.*".
    // (2) Each feature's merged config.
    //
    // https://atom.io/docs/api/latest/Config
    //


    this._config = buildConfig(this._features); // Load enabled features. This needs to be done during Atom's load phase to
    // make sure that deserializers are registered, etc.
    // https://github.com/atom/atom/blob/v1.1.0/src/atom-environment.coffee#L625-L631
    // https://atom.io/docs/api/latest/PackageManager

    const featuresToLoad = this.getEnabledFeatures();

    this._loadDisposable.add( // Nesting loads within loads leads to reverse activation order- that is, if
    // the root package loads feature packages, then the feature package activations will
    // happen before the root package's. So we wait until the root package is done loading,
    // but before it activates, to load the features.
    didLoadPackage(this._pkgName).subscribe(() => {
      // Load "regular" feature packages.
      featuresToLoad.forEach(feature => {
        atom.packages.loadPackage(feature.path);
      });
    }), // Load "experimental" format packages.
    didLoadPackage(this._pkgName).switchMap(() => _rxjsCompatUmdMin.Observable.create(() => new _UniversalDisposable.default((0, _activatePackages.default)([...featuresToLoad])))).subscribe());

    const featureNames = new Set(this._features.map(feature => feature.pkg.name)); // Ensure that the root package is initialized before all of its features. This is important
    // because the root package defines the config for all managed features and we need to make
    // sure that it's present before they're initialized (i.e. before their deserializers are
    // called).
    // $FlowIssue: Need to upstream this.

    const onWillInitializePackageDisposable = atom.packages.onWillInitializePackage(pack => {
      if (featureNames.has(pack.name)) {
        onWillInitializePackageDisposable.dispose();
        const rootPackage = atom.packages.getLoadedPackage(this._pkgName);
        (0, _nullthrows.default)(rootPackage).initializeIfNeeded();
      }
    });

    this._loadDisposable.add(onWillInitializePackageDisposable); // Clean up when the package is unloaded.


    this._loadDisposable.add(atom.packages.onDidUnloadPackage(pack => {
      if (pack.name === this._pkgName) {
        this._loadDisposable.dispose();
      }
    }));
  }

  activate() {
    (0, _assert.default)(this._activationDisposable == null);
    const rootPackage = atom.packages.getLoadedPackage(this._pkgName);
    (0, _assert.default)(rootPackage != null); // This is a failsafe in case the `.ForceMainModuleLoad` deserializer
    // defined above does not register in time, or if the defer key has been set
    // w/o our knowledge. This can happen during OSS upgrades.

    localStorage.removeItem(rootPackage.getCanDeferMainModuleRequireStorageKey());
    this.updateActiveFeatures(); // Watch things that should trigger reevaluation of active features. Note that we do this
    // *after* the initial `updateActiveFeatures()` call because that could trigger one of these
    // events.

    this._activationDisposable = new _UniversalDisposable.default(atom.config.onDidChange(this.getUseKeyPath(), () => {
      this.updateActiveFeatures();
    }), atom.config.onDidChange(this.getEnabledFeatureGroupsKeyPath(), () => {
      this.updateActiveFeatures();
    }), _rxjsCompatUmdMin.Observable.merge(didAddFirstPath, didAddFirstTextEditor).take(1).subscribe(() => {
      // Hopefully we've opened a project so we don't have to load all the features.
      this._deferringFeatureActivation = false;
      this.updateActiveFeatures();
    }));
  }

  updateActiveFeatures() {
    // `updateActiveFeatures()` can't be called recursively. If it is, just warn and bail.
    if (this._featureBeingActivated != null) {
      // eslint-disable-next-line no-console
      console.warn(`Activating ${this._featureBeingActivated.pkg.name} caused a` + ' reevaluation of active features.');
      return;
    }

    if (this._featureBeingDeactivated != null) {
      // eslint-disable-next-line no-console
      console.warn(`Deactivating ${this._featureBeingDeactivated.pkg.name} caused a` + ' reevaluation of active features.');
      return;
    }

    this.updateActiveFeaturesNow();
  }
  /**
   * Enable and disable the correct features according to the current configuration.
   */


  updateActiveFeaturesNow() {
    const enabledFeatures = this.getEnabledFeatures();
    const featuresToActivate = (0, _collection.setUnion)(this._featureGroups.get(REQUIRED_FEATURE_GROUP), this._deferringFeatureActivation ? (0, _collection.setIntersect)(enabledFeatures, this._featureGroups.get(INITIAL_FEATURE_GROUP)) : enabledFeatures); // Enable all packages in featuresToActivate but not in currentState.
    // Disable all packages not in featuresToActivate but in currentState.

    for (const feature of featuresToActivate) {
      if (!this._currentlyActiveFeatures.has(feature)) {
        this._featureBeingActivated = feature;
        atom.packages.activatePackage(feature.path);
        this._featureBeingActivated = null;
      }
    }

    for (const feature of this._currentlyActiveFeatures) {
      if (!featuresToActivate.has(feature)) {
        this._featureBeingDeactivated = feature;
        safeDeactivate(feature);
        this._featureBeingDeactivated = null;
      }
    }

    this._currentlyActiveFeatures = featuresToActivate;
  }

  deactivate() {
    (0, _assert.default)(this._activationDisposable && !this._activationDisposable.disposed);

    this._currentlyActiveFeatures.forEach(feature => {
      // Deactivate the package, but don't serialize. That needs to be done in a separate phase so that
      // we don't end up disconnecting a service and then serializing the disconnected state.
      safeDeactivate(feature, true);
    });

    this._currentlyActiveFeatures = new Set();
    (0, _assert.default)(this._activationDisposable); // reasserting for flow

    this._activationDisposable.dispose();

    this._activationDisposable = null;
  }
  /**
   * Determine which features are enabled based on the current state of the configuration. This set
   * is then used to load and activate the features.
   */


  getEnabledFeatures() {
    // we know enabledFeatureGroups must be ?Array, and useFeatureRules must be ?UseFeatureRules,
    // since it's in our schema. However, flow thinks it's a mixed type, since it doesn't know about
    // the schema enforcements.
    const useFeatureRules = atom.config.get(this.getUseKeyPath());
    const enabledFeatureGroups = atom.config.get(this.getEnabledFeatureGroupsKeyPath());
    const featuresInEnabledGroups = enabledFeatureGroups == null ? new Set(this._features) // If featuregroups is undefined, assume all features should be enabled.
    : (0, _collection.setUnion)(...enabledFeatureGroups.map(featureGroup => this._featureGroups.get(featureGroup)));
    const requiredFeatures = this._featureGroups.get(REQUIRED_FEATURE_GROUP) || new Set(); // If a feature is "always enabled", it should be on whether or not a feature-group includes it.
    // If a feature is "default", it should be on if and only if a feature-group includes it.

    return new Set(this._features.filter(feature => {
      const featureName = packageNameFromPath(feature.path);
      const rawRule = (0, _idx.default)(useFeatureRules, _ => _[featureName]);
      const rule = rawRule == null ? getFeatureDefaultValue(feature) : rawRule;
      return rule === ALWAYS_ENABLED || rule === true || featuresInEnabledGroups.has(feature) && rule === DEFAULT || requiredFeatures.has(feature);
    }));
  }

  getConfig() {
    (0, _assert.default)(this._config != null);
    return this._config;
  }

  serialize() {
    // When the root package is serialized, all of its features need to be serialized. This is an abuse of
    // `serialize()` since we're using it to do side effects instead of returning the serialization,
    // but it ensures that serialization of the Atom packages happens at the right point in the
    // package lifecycle. Unfortunately, it also means that Nuclide features will be serialized twice
    // on deactivation.
    this._features.forEach(safeSerialize);
  }

  getUseKeyPath() {
    return `${this._pkgName}.use`;
  }

  getEnabledFeatureGroupsKeyPath() {
    return `${this._pkgName}.enabledFeatureGroups`;
  }

}

exports.default = FeatureLoader;

function safeDeactivate(feature, suppressSerialization = false) {
  const name = packageNameFromPath(feature.path);

  try {
    const pack = atom.packages.getLoadedPackage(name);

    if (pack != null) {
      atom.packages.deactivatePackage(name, suppressSerialization);
    }
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error(`Error deactivating "${name}": ${err.message}`);
  }
}

function getFeatureDefaultValue(feature) {
  const name = packageNameFromPath(feature.path);
  return name.startsWith('sample-') || name.startsWith('fb-sample-') ? NEVER_ENABLED : DEFAULT;
}

function safeSerialize(feature) {
  const name = packageNameFromPath(feature.path);

  try {
    const pack = atom.packages.getActivePackage(name);

    if (pack != null) {
      // Serialize the package
      atom.packages.serializePackage(pack);
    }
  } catch (err) {
    // eslint-disable-next-line no-console
    console.error(`Error serializing "${name}": ${err.message}`);
  }
} // this could be inlined into its use above, but this makes the intent more
// explicit, and unifies it in the case this ever needs to change.


function packageNameFromPath(pkgPath) {
  return _path2.default.basename(pkgPath);
}

function packageIsRepositoryProvider(pkg) {
  return Boolean((0, _idx.default)(pkg, _ => _.providedServices['atom.repository-provider']));
}

function buildConfig(features) {
  const config = {
    use: {
      title: 'Enabled Features',
      description: 'Enable and disable individual features',
      type: 'object',
      collapsed: true,
      properties: {}
    }
  };
  features.forEach(feature => {
    const featurePkg = feature.pkg;
    const name = packageNameFromPath(feature.path);
    const setting = {
      title: featurePkg.displayName == null ? `Enable the "${name}" feature` : `Enable ${featurePkg.displayName}`,
      description: featurePkg.description || '',
      type: 'string',
      enum: [{
        value: ALWAYS_ENABLED,
        description: 'Always enabled'
      }, {
        value: NEVER_ENABLED,
        description: 'Never enabled'
      }, {
        value: DEFAULT,
        description: 'Only when in an enabled package group'
      }],
      default: getFeatureDefaultValue(feature)
    };

    if (devMode) {
      if (featurePkg.providedServices) {
        const provides = Object.keys(featurePkg.providedServices).join(', ');
        setting.description += `<br/>**Provides:** _${provides}_`;
      }

      if (featurePkg.consumedServices) {
        const consumes = Object.keys(featurePkg.consumedServices).join(', ');
        setting.description += `<br/>**Consumes:** _${consumes}_`;
      }
    }

    config.use.properties[name] = setting; // Merge in the feature's config

    const featurePkgConfig = featurePkg.atomConfig || featurePkg.nuclide && featurePkg.nuclide.config;

    if (featurePkgConfig) {
      config[name] = {
        type: 'object',
        title: featurePkg.displayName,
        description: featurePkg.description,
        collapsed: true,
        properties: {}
      };
      Object.keys(featurePkgConfig).forEach(key => {
        config[name].properties[key] = { ...featurePkgConfig[key],
          title: featurePkgConfig[key].title || key
        };
      });
    }
  });
  return config;
}
/**
 * Hack time!! Atom's repository APIs are synchronous. Any package that tries to use them before
 * we've had a chance to provide our implementation are going to get wrong answers. The correct
 * thing to do would be to always go through an async API that awaits until
 * `atom.packages.onDidActivateInitialPackages()` completes. However, we have some legacy sync
 * codepaths that make that difficult. As a temporary (I hope) workaround, we prioritize
 * activation of the features that provide this service.
 */


function reorderFeatures(features_) {
  const features = features_.slice();
  const originalOrder = new Map(features.map((feature, i) => [feature, i]));
  features.sort((a, b) => {
    const aIsRepoProvider = packageIsRepositoryProvider(a.pkg);
    const bIsRepoProvider = packageIsRepositoryProvider(b.pkg);

    if (aIsRepoProvider !== bIsRepoProvider) {
      return aIsRepoProvider ? -1 : 1;
    }

    const aIndex = (0, _nullthrows.default)(originalOrder.get(a));
    const bIndex = (0, _nullthrows.default)(originalOrder.get(b));
    return aIndex - bIndex;
  });
  return features;
}
/**
 * Construct a map whose keys are feature group names and values are sets of features belonging to
 * the group.
 */


function groupFeatures(features, rawFeatureGroups) {
  const namesToFeatures = new Map();
  features.forEach(feature => {
    namesToFeatures.set(_path2.default.basename(feature.path), feature);
  });
  const featureGroups = new _collection.MultiMap();

  for (const key of Object.keys(rawFeatureGroups)) {
    if (Array.isArray(rawFeatureGroups[key])) {
      const featuresForKey = rawFeatureGroups[key].map(featureName => namesToFeatures.get(featureName)).filter(Boolean);

      if (featuresForKey != null) {
        featureGroups.set(key, featuresForKey);
      }
    }
  }

  return featureGroups;
}
/**
 * Patch the package manager and packages to (1) implement `onWillInitializePackage` and (2) call
 * `registerConfigSchemaFromMainModule()` when a package is initialized (to guarantee its config
 * schema is ready when its deserializers are called). This should be removed once these changes
 * are upstreamed.
 */


function patchPackageManager() {
  if (atom.packages.onWillInitializePackage == null && !atom.packages.__onWillInitializePackagePatched) {
    atom.packages.onWillInitializePackage = function (callback) {
      atom.packages.__onWillInitializePackagePatched = true;
      return this.emitter.on('will-initialize-package', callback);
    };
  }

  if (!atom.packages.__packageLookupPatched) {
    atom.packages.__packageLookupPatched = true;
    const loadPackage = atom.packages.loadPackage;

    atom.packages.loadPackage = function (nameOrPath, ...args) {
      const pack = loadPackage.call(this, nameOrPath, ...args);

      if (pack == null) {
        return null;
      }

      patchPackage(pack);
      return pack;
    };

    const getLoadedPackage = atom.packages.getLoadedPackage;

    atom.packages.getLoadedPackage = function (name, ...args) {
      const pack = getLoadedPackage.call(this, name, ...args);

      if (pack == null) {
        return null;
      }

      patchPackage(pack);
      return pack;
    };
  }
}

function patchPackage(pack) {
  if (pack.__initializeIfNeededPatched) {
    return;
  }

  pack.__initializeIfNeededPatched = true;
  const initializeIfNeeded = pack.initializeIfNeeded;

  pack.initializeIfNeeded = function () {
    if (this.mainInitialized) {
      return;
    }

    if (atom.packages.__onWillInitializePackagePatched) {
      // If we didn't apply our patch for this, Atom is already dispatching the event.
      atom.packages.emitter.emit('will-initialize-package', pack);
    }

    this.registerConfigSchemaFromMainModule();
    return initializeIfNeeded.call(this);
  };
}

const didLoadPackage = pkgName => (0, _event.observableFromSubscribeFunction)(cb => atom.packages.onDidLoadPackage(cb)).startWith(null).filter(() => atom.packages.getLoadedPackage(pkgName) != null).take(1);

const didAddFirstPath = (0, _event.observableFromSubscribeFunction)(cb => atom.project.onDidChangePaths(cb)).startWith(null).filter(() => atom.project.getDirectories().length > 0).take(1);
const didAddFirstTextEditor = (0, _event.observableFromSubscribeFunction)(cb => atom.workspace.getCenter().onDidAddTextEditor(cb)).startWith(null).filter(() => atom.workspace.getCenter().getTextEditors().length > 0).take(1);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vRmVhdHVyZUxvYWRlci5qcyJdLCJuYW1lcyI6WyJBTFdBWVNfRU5BQkxFRCIsIk5FVkVSX0VOQUJMRUQiLCJERUZBVUxUIiwiZGV2TW9kZSIsImF0b20iLCJnZXRMb2FkU2V0dGluZ3MiLCJSRVFVSVJFRF9GRUFUVVJFX0dST1VQIiwiSU5JVElBTF9GRUFUVVJFX0dST1VQIiwiRmVhdHVyZUxvYWRlciIsImNvbnN0cnVjdG9yIiwiZmVhdHVyZXMiLCJwYXRoIiwiX3BhdGgiLCJmZWF0dXJlR3JvdXBzIiwiX2FjdGl2YXRpb25EaXNwb3NhYmxlIiwiX2xvYWREaXNwb3NhYmxlIiwiX2NvbmZpZyIsIl9mZWF0dXJlcyIsIl9mZWF0dXJlQmVpbmdBY3RpdmF0ZWQiLCJfZmVhdHVyZUJlaW5nRGVhY3RpdmF0ZWQiLCJfZmVhdHVyZUdyb3VwcyIsIl9kZWZlcnJpbmdGZWF0dXJlQWN0aXZhdGlvbiIsIl9wa2dOYW1lIiwiX2N1cnJlbnRseUFjdGl2ZUZlYXR1cmVzIiwiU2V0IiwicmVvcmRlckZlYXR1cmVzIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsInBhY2thZ2VOYW1lRnJvbVBhdGgiLCJncm91cEZlYXR1cmVzIiwibG9hZCIsImRpc3Bvc2VkIiwicGF0Y2hQYWNrYWdlTWFuYWdlciIsImFkZCIsImRlc2VyaWFsaXplcnMiLCJuYW1lIiwiZGVzZXJpYWxpemUiLCJmZWF0dXJlQ29uZmlnIiwic2V0UGFja2FnZU5hbWUiLCJudWNsaWRlQ29uZmlnIiwiYnVpbGRDb25maWciLCJmZWF0dXJlc1RvTG9hZCIsImdldEVuYWJsZWRGZWF0dXJlcyIsImRpZExvYWRQYWNrYWdlIiwic3Vic2NyaWJlIiwiZm9yRWFjaCIsImZlYXR1cmUiLCJwYWNrYWdlcyIsImxvYWRQYWNrYWdlIiwic3dpdGNoTWFwIiwiT2JzZXJ2YWJsZSIsImNyZWF0ZSIsImZlYXR1cmVOYW1lcyIsIm1hcCIsInBrZyIsIm9uV2lsbEluaXRpYWxpemVQYWNrYWdlRGlzcG9zYWJsZSIsIm9uV2lsbEluaXRpYWxpemVQYWNrYWdlIiwicGFjayIsImhhcyIsImRpc3Bvc2UiLCJyb290UGFja2FnZSIsImdldExvYWRlZFBhY2thZ2UiLCJpbml0aWFsaXplSWZOZWVkZWQiLCJvbkRpZFVubG9hZFBhY2thZ2UiLCJhY3RpdmF0ZSIsImxvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJnZXRDYW5EZWZlck1haW5Nb2R1bGVSZXF1aXJlU3RvcmFnZUtleSIsInVwZGF0ZUFjdGl2ZUZlYXR1cmVzIiwiY29uZmlnIiwib25EaWRDaGFuZ2UiLCJnZXRVc2VLZXlQYXRoIiwiZ2V0RW5hYmxlZEZlYXR1cmVHcm91cHNLZXlQYXRoIiwibWVyZ2UiLCJkaWRBZGRGaXJzdFBhdGgiLCJkaWRBZGRGaXJzdFRleHRFZGl0b3IiLCJ0YWtlIiwiY29uc29sZSIsIndhcm4iLCJ1cGRhdGVBY3RpdmVGZWF0dXJlc05vdyIsImVuYWJsZWRGZWF0dXJlcyIsImZlYXR1cmVzVG9BY3RpdmF0ZSIsImdldCIsImFjdGl2YXRlUGFja2FnZSIsInNhZmVEZWFjdGl2YXRlIiwiZGVhY3RpdmF0ZSIsInVzZUZlYXR1cmVSdWxlcyIsImVuYWJsZWRGZWF0dXJlR3JvdXBzIiwiZmVhdHVyZXNJbkVuYWJsZWRHcm91cHMiLCJmZWF0dXJlR3JvdXAiLCJyZXF1aXJlZEZlYXR1cmVzIiwiZmlsdGVyIiwiZmVhdHVyZU5hbWUiLCJyYXdSdWxlIiwiXyIsInJ1bGUiLCJnZXRGZWF0dXJlRGVmYXVsdFZhbHVlIiwiZ2V0Q29uZmlnIiwic2VyaWFsaXplIiwic2FmZVNlcmlhbGl6ZSIsInN1cHByZXNzU2VyaWFsaXphdGlvbiIsImRlYWN0aXZhdGVQYWNrYWdlIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsImdldEFjdGl2ZVBhY2thZ2UiLCJzZXJpYWxpemVQYWNrYWdlIiwicGtnUGF0aCIsImJhc2VuYW1lIiwicGFja2FnZUlzUmVwb3NpdG9yeVByb3ZpZGVyIiwiQm9vbGVhbiIsInByb3ZpZGVkU2VydmljZXMiLCJ1c2UiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwidHlwZSIsImNvbGxhcHNlZCIsInByb3BlcnRpZXMiLCJmZWF0dXJlUGtnIiwic2V0dGluZyIsImRpc3BsYXlOYW1lIiwiZW51bSIsInZhbHVlIiwiZGVmYXVsdCIsInByb3ZpZGVzIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJjb25zdW1lZFNlcnZpY2VzIiwiY29uc3VtZXMiLCJmZWF0dXJlUGtnQ29uZmlnIiwiYXRvbUNvbmZpZyIsIm51Y2xpZGUiLCJrZXkiLCJmZWF0dXJlc18iLCJzbGljZSIsIm9yaWdpbmFsT3JkZXIiLCJNYXAiLCJpIiwic29ydCIsImEiLCJiIiwiYUlzUmVwb1Byb3ZpZGVyIiwiYklzUmVwb1Byb3ZpZGVyIiwiYUluZGV4IiwiYkluZGV4IiwicmF3RmVhdHVyZUdyb3VwcyIsIm5hbWVzVG9GZWF0dXJlcyIsInNldCIsIk11bHRpTWFwIiwiQXJyYXkiLCJpc0FycmF5IiwiZmVhdHVyZXNGb3JLZXkiLCJfX29uV2lsbEluaXRpYWxpemVQYWNrYWdlUGF0Y2hlZCIsImNhbGxiYWNrIiwiZW1pdHRlciIsIm9uIiwiX19wYWNrYWdlTG9va3VwUGF0Y2hlZCIsIm5hbWVPclBhdGgiLCJhcmdzIiwiY2FsbCIsInBhdGNoUGFja2FnZSIsIl9faW5pdGlhbGl6ZUlmTmVlZGVkUGF0Y2hlZCIsIm1haW5Jbml0aWFsaXplZCIsImVtaXQiLCJyZWdpc3RlckNvbmZpZ1NjaGVtYUZyb21NYWluTW9kdWxlIiwicGtnTmFtZSIsImNiIiwib25EaWRMb2FkUGFja2FnZSIsInN0YXJ0V2l0aCIsInByb2plY3QiLCJvbkRpZENoYW5nZVBhdGhzIiwiZ2V0RGlyZWN0b3JpZXMiLCJsZW5ndGgiLCJ3b3Jrc3BhY2UiLCJnZXRDZW50ZXIiLCJvbkRpZEFkZFRleHRFZGl0b3IiLCJnZXRUZXh0RWRpdG9ycyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztB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LE1BQU10SCxjQUFjLEdBQUk0SCxPQUFELElBQ3JCLDRDQUFnQ0MsRUFBRSxJQUFJbkssSUFBSSxDQUFDMEMsUUFBTCxDQUFjMEgsZ0JBQWQsQ0FBK0JELEVBQS9CLENBQXRDLEVBQ0dFLFNBREgsQ0FDYSxJQURiLEVBRUcvRSxNQUZILENBRVUsTUFBTXRGLElBQUksQ0FBQzBDLFFBQUwsQ0FBY2MsZ0JBQWQsQ0FBK0IwRyxPQUEvQixLQUEyQyxJQUYzRCxFQUdHM0YsSUFISCxDQUdRLENBSFIsQ0FERjs7QUFNQSxNQUFNRixlQUFlLEdBQUcsNENBQWdDOEYsRUFBRSxJQUN4RG5LLElBQUksQ0FBQ3NLLE9BQUwsQ0FBYUMsZ0JBQWIsQ0FBOEJKLEVBQTlCLENBRHNCLEVBR3JCRSxTQUhxQixDQUdYLElBSFcsRUFJckIvRSxNQUpxQixDQUlkLE1BQU10RixJQUFJLENBQUNzSyxPQUFMLENBQWFFLGNBQWIsR0FBOEJDLE1BQTlCLEdBQXVDLENBSi9CLEVBS3JCbEcsSUFMcUIsQ0FLaEIsQ0FMZ0IsQ0FBeEI7QUFPQSxNQUFNRCxxQkFBcUIsR0FBRyw0Q0FBZ0M2RixFQUFFLElBQzlEbkssSUFBSSxDQUFDMEssU0FBTCxDQUFlQyxTQUFmLEdBQTJCQyxrQkFBM0IsQ0FBOENULEVBQTlDLENBRDRCLEVBRzNCRSxTQUgyQixDQUdqQixJQUhpQixFQUkzQi9FLE1BSjJCLENBSXBCLE1BQU10RixJQUFJLENBQUMwSyxTQUFMLENBQWVDLFNBQWYsR0FBMkJFLGNBQTNCLEdBQTRDSixNQUE1QyxHQUFxRCxDQUp2QyxFQUszQmxHLElBTDJCLENBS3RCLENBTHNCLENBQTlCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuLyogZ2xvYmFsIGxvY2FsU3RvcmFnZSAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQgaWR4IGZyb20gJ2lkeCc7XHJcbmltcG9ydCB7b2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbn0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZXZlbnQnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IG51bGx0aHJvd3MgZnJvbSAnbnVsbHRocm93cyc7XHJcbmltcG9ydCBhY3RpdmF0ZUV4cGVyaW1lbnRhbFBhY2thZ2VzIGZyb20gJy4vZXhwZXJpbWVudGFsLXBhY2thZ2VzL2FjdGl2YXRlUGFja2FnZXMnO1xyXG5pbXBvcnQgbnVjbGlkZUNvbmZpZyBmcm9tICcuL251Y2xpZGUtY29uZmlnJztcclxuaW1wb3J0IGZlYXR1cmVDb25maWcgZnJvbSAnLi9mZWF0dXJlLWNvbmZpZyc7XHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG51Y2xpZGUtaW50ZXJuYWwvcHJlZmVyLW51Y2xpZGUtdXJpXHJcbmltcG9ydCB7TXVsdGlNYXAsIHNldEludGVyc2VjdCwgc2V0VW5pb259IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2NvbGxlY3Rpb24nO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcblxyXG50eXBlIEZlYXR1cmVQa2cgPSB7XHJcbiAgbmFtZTogc3RyaW5nLFxyXG4gIGF0b21Db25maWc/OiBPYmplY3QsXHJcbiAgY29uc3VtZWRTZXJ2aWNlcz86IE9iamVjdCxcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZyxcclxuICBkaXNwbGF5TmFtZT86IHN0cmluZyxcclxuICBudWNsaWRlPzoge1xyXG4gICAgY29uZmlnPzogT2JqZWN0LFxyXG4gIH0sXHJcbiAgcHJvdmlkZWRTZXJ2aWNlcz86IE9iamVjdCxcclxuICBmZWF0dXJlR3JvdXBzPzogQXJyYXk8c3RyaW5nPixcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIEZlYXR1cmUgPSB7XHJcbiAgcGF0aDogc3RyaW5nLFxyXG4gIHBrZzogRmVhdHVyZVBrZyxcclxufTtcclxuXHJcbnR5cGUgRmVhdHVyZUxvYWRlclBhcmFtcyA9IHtcclxuICBwYXRoOiBzdHJpbmcsXHJcbiAgZmVhdHVyZXM6IEFycmF5PEZlYXR1cmU+LFxyXG4gIGZlYXR1cmVHcm91cHM/OiB7XHJcbiAgICBbc3RyaW5nXTogQXJyYXk8c3RyaW5nPixcclxuICB9LFxyXG59O1xyXG5cclxudHlwZSBVc2VGZWF0dXJlUnVsZXMgPSB7XHJcbiAgW25hbWU6IHN0cmluZ106ICdhbHdheXMnIHwgJ25ldmVyJyB8ICdkZWZhdWx0JyxcclxufTtcclxuXHJcbmNvbnN0IEFMV0FZU19FTkFCTEVEID0gJ2Fsd2F5cyc7XHJcbmNvbnN0IE5FVkVSX0VOQUJMRUQgPSAnbmV2ZXInO1xyXG5jb25zdCBERUZBVUxUID0gJ2RlZmF1bHQnO1xyXG5cclxuY29uc3Qge2Rldk1vZGV9ID0gYXRvbS5nZXRMb2FkU2V0dGluZ3MoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBSRVFVSVJFRF9GRUFUVVJFX0dST1VQID0gJ251Y2xpZGUtcmVxdWlyZWQnO1xyXG5leHBvcnQgY29uc3QgSU5JVElBTF9GRUFUVVJFX0dST1VQID0gJ251Y2xpZGUtY29yZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGZWF0dXJlTG9hZGVyIHtcclxuICBfYWN0aXZhdGlvbkRpc3Bvc2FibGU6ID9Vbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG4gIF9sb2FkRGlzcG9zYWJsZTogVW5pdmVyc2FsRGlzcG9zYWJsZTtcclxuXHJcbiAgX2NvbmZpZzogP09iamVjdDtcclxuICBfZmVhdHVyZXM6IEFycmF5PEZlYXR1cmU+O1xyXG4gIF9mZWF0dXJlQmVpbmdBY3RpdmF0ZWQ6ID9GZWF0dXJlO1xyXG4gIF9mZWF0dXJlQmVpbmdEZWFjdGl2YXRlZDogP0ZlYXR1cmU7XHJcbiAgX2ZlYXR1cmVHcm91cHM6IE11bHRpTWFwPHN0cmluZywgRmVhdHVyZT47XHJcbiAgX2RlZmVycmluZ0ZlYXR1cmVBY3RpdmF0aW9uOiBib29sZWFuID0gdHJ1ZTtcclxuICBfcGtnTmFtZTogc3RyaW5nO1xyXG4gIF9wYXRoOiBzdHJpbmc7XHJcbiAgX2N1cnJlbnRseUFjdGl2ZUZlYXR1cmVzOiBTZXQ8RmVhdHVyZT4gPSBuZXcgU2V0KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHtmZWF0dXJlcywgcGF0aDogX3BhdGgsIGZlYXR1cmVHcm91cHN9OiBGZWF0dXJlTG9hZGVyUGFyYW1zKSB7XHJcbiAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICB0aGlzLl9mZWF0dXJlcyA9IHJlb3JkZXJGZWF0dXJlcyhmZWF0dXJlcyk7XHJcbiAgICB0aGlzLl9sb2FkRGlzcG9zYWJsZSA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCk7XHJcbiAgICB0aGlzLl9wa2dOYW1lID0gcGFja2FnZU5hbWVGcm9tUGF0aCh0aGlzLl9wYXRoKTtcclxuICAgIHRoaXMuX2ZlYXR1cmVHcm91cHMgPSBncm91cEZlYXR1cmVzKFxyXG4gICAgICB0aGlzLl9mZWF0dXJlcyxcclxuICAgICAgZmVhdHVyZUdyb3VwcyA9PSBudWxsID8ge30gOiBmZWF0dXJlR3JvdXBzLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIEJ1aWxkIHRoZSBjb25maWcuIFNob3VsZCBvY2N1ciB3aXRoIHJvb3QgcGFja2FnZSdzIGxvYWRcclxuICBsb2FkKCk6IHZvaWQge1xyXG4gICAgaW52YXJpYW50KCF0aGlzLl9sb2FkRGlzcG9zYWJsZS5kaXNwb3NlZCk7XHJcblxyXG4gICAgcGF0Y2hQYWNrYWdlTWFuYWdlcigpO1xyXG5cclxuICAgIC8vIEFkZCBhIGR1bW15IGRlc2VyaWFsaXplci4gVGhpcyBmb3JjZXMgQXRvbSB0byBsb2FkIE51Y2xpZGUncyBtYWluIG1vZHVsZVxyXG4gICAgLy8gKHRoaXMgZmlsZSkgd2hlbiB0aGUgcGFja2FnZSBpcyBsb2FkZWQsIHdoaWNoIGlzIHN1cGVyIGltcG9ydGFudCBiZWNhdXNlXHJcbiAgICAvLyB0aGlzIG1vZHVsZSBsb2FkcyBhbGwgb2YgdGhlIE51Y2xpZGUgZmVhdHVyZXMuIFdlIGNvdWxkIGFjY29tcGxpc2ggdGhlIHNhbWVcclxuICAgIC8vIHRoaW5nIGJ5IHVuc2V0dGluZyBbdGhlIGxvY2FsIHN0b3JhZ2UgdmFsdWVdWzFdIHRoYXQgQXRvbSB1c2VzIHRvIGluZGljYXRlXHJcbiAgICAvLyB3aGV0aGVyIHRoZSBtYWluIG1vZHVsZSBsb2FkIGNhbiBiZSBkZWZlcnJlZCwgaG93ZXZlciwgdGhhdCB3b3VsZCBtZWFuIHRoYXRcclxuICAgIC8vIChmb3IgYSBicmllZiB0aW1lLCBhdCBsZWFzdCksIHRoZSBmbGFnIHdvdWxkIGJlIHNldC4gSWYgdGhlcmUgd2VyZSBhbiBlcnJvclxyXG4gICAgLy8gZHVyaW5nIHRoYXQgdGltZSBhbmQgd2UgbmV2ZXIgZ290IGEgY2hhbmNlIHRvIHVuc2V0IHRoZSBmbGFnLCBOdWNsaWRlXHJcbiAgICAvLyBmZWF0dXJlcyB3b3VsZCBuZXZlciBsb2FkIGFnYWluIVxyXG4gICAgLy9cclxuICAgIC8vIFsxXSBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9hdG9tL2Jsb2IvdjEuOS44L3NyYy9wYWNrYWdlLmNvZmZlZSNMNDQyXHJcbiAgICB0aGlzLl9sb2FkRGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGF0b20uZGVzZXJpYWxpemVycy5hZGQoe1xyXG4gICAgICAgIG5hbWU6IGAke3RoaXMuX3BrZ05hbWV9LkZvcmNlTWFpbk1vZHVsZUxvYWRgLFxyXG4gICAgICAgIGRlc2VyaWFsaXplKCkge30sXHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuXHJcbiAgICBmZWF0dXJlQ29uZmlnLnNldFBhY2thZ2VOYW1lKHRoaXMuX3BrZ05hbWUpO1xyXG4gICAgbnVjbGlkZUNvbmZpZy5zZXRQYWNrYWdlTmFtZSh0aGlzLl9wa2dOYW1lKTtcclxuXHJcbiAgICAvL1xyXG4gICAgLy8gQnVpbGQgdGhlIFwiY29uZmlnXCIgb2JqZWN0LiBUaGlzIGRldGVybWluZXMgdGhlIGNvbmZpZyBkZWZhdWx0cyBhbmRcclxuICAgIC8vIGl0J3Mgd2hhdCBpcyBzaG93biBieSB0aGUgU2V0dGluZ3Mgdmlldy4gSXQgaW5jbHVkZXM6XHJcbiAgICAvLyAoMSkgQW4gZW50cnkgdG8gZW5hYmxlL2Rpc2FibGUgZWFjaCBmZWF0dXJlIC0gY2FsbGVkIFwiJHtwa2dOYW1lfS51c2UuKlwiLlxyXG4gICAgLy8gKDIpIEVhY2ggZmVhdHVyZSdzIG1lcmdlZCBjb25maWcuXHJcbiAgICAvL1xyXG4gICAgLy8gaHR0cHM6Ly9hdG9tLmlvL2RvY3MvYXBpL2xhdGVzdC9Db25maWdcclxuICAgIC8vXHJcbiAgICB0aGlzLl9jb25maWcgPSBidWlsZENvbmZpZyh0aGlzLl9mZWF0dXJlcyk7XHJcblxyXG4gICAgLy8gTG9hZCBlbmFibGVkIGZlYXR1cmVzLiBUaGlzIG5lZWRzIHRvIGJlIGRvbmUgZHVyaW5nIEF0b20ncyBsb2FkIHBoYXNlIHRvXHJcbiAgICAvLyBtYWtlIHN1cmUgdGhhdCBkZXNlcmlhbGl6ZXJzIGFyZSByZWdpc3RlcmVkLCBldGMuXHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9hdG9tL2Jsb2IvdjEuMS4wL3NyYy9hdG9tLWVudmlyb25tZW50LmNvZmZlZSNMNjI1LUw2MzFcclxuICAgIC8vIGh0dHBzOi8vYXRvbS5pby9kb2NzL2FwaS9sYXRlc3QvUGFja2FnZU1hbmFnZXJcclxuICAgIGNvbnN0IGZlYXR1cmVzVG9Mb2FkID0gdGhpcy5nZXRFbmFibGVkRmVhdHVyZXMoKTtcclxuICAgIHRoaXMuX2xvYWREaXNwb3NhYmxlLmFkZChcclxuICAgICAgLy8gTmVzdGluZyBsb2FkcyB3aXRoaW4gbG9hZHMgbGVhZHMgdG8gcmV2ZXJzZSBhY3RpdmF0aW9uIG9yZGVyLSB0aGF0IGlzLCBpZlxyXG4gICAgICAvLyB0aGUgcm9vdCBwYWNrYWdlIGxvYWRzIGZlYXR1cmUgcGFja2FnZXMsIHRoZW4gdGhlIGZlYXR1cmUgcGFja2FnZSBhY3RpdmF0aW9ucyB3aWxsXHJcbiAgICAgIC8vIGhhcHBlbiBiZWZvcmUgdGhlIHJvb3QgcGFja2FnZSdzLiBTbyB3ZSB3YWl0IHVudGlsIHRoZSByb290IHBhY2thZ2UgaXMgZG9uZSBsb2FkaW5nLFxyXG4gICAgICAvLyBidXQgYmVmb3JlIGl0IGFjdGl2YXRlcywgdG8gbG9hZCB0aGUgZmVhdHVyZXMuXHJcbiAgICAgIGRpZExvYWRQYWNrYWdlKHRoaXMuX3BrZ05hbWUpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgLy8gTG9hZCBcInJlZ3VsYXJcIiBmZWF0dXJlIHBhY2thZ2VzLlxyXG4gICAgICAgIGZlYXR1cmVzVG9Mb2FkLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICAgICAgICBhdG9tLnBhY2thZ2VzLmxvYWRQYWNrYWdlKGZlYXR1cmUucGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pLFxyXG4gICAgICAvLyBMb2FkIFwiZXhwZXJpbWVudGFsXCIgZm9ybWF0IHBhY2thZ2VzLlxyXG4gICAgICBkaWRMb2FkUGFja2FnZSh0aGlzLl9wa2dOYW1lKVxyXG4gICAgICAgIC5zd2l0Y2hNYXAoKCkgPT5cclxuICAgICAgICAgIE9ic2VydmFibGUuY3JlYXRlKFxyXG4gICAgICAgICAgICAoKSA9PlxyXG4gICAgICAgICAgICAgIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKFxyXG4gICAgICAgICAgICAgICAgYWN0aXZhdGVFeHBlcmltZW50YWxQYWNrYWdlcyhbLi4uZmVhdHVyZXNUb0xvYWRdKSxcclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICApXHJcbiAgICAgICAgLnN1YnNjcmliZSgpLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBmZWF0dXJlTmFtZXMgPSBuZXcgU2V0KFxyXG4gICAgICB0aGlzLl9mZWF0dXJlcy5tYXAoZmVhdHVyZSA9PiBmZWF0dXJlLnBrZy5uYW1lKSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHJvb3QgcGFja2FnZSBpcyBpbml0aWFsaXplZCBiZWZvcmUgYWxsIG9mIGl0cyBmZWF0dXJlcy4gVGhpcyBpcyBpbXBvcnRhbnRcclxuICAgIC8vIGJlY2F1c2UgdGhlIHJvb3QgcGFja2FnZSBkZWZpbmVzIHRoZSBjb25maWcgZm9yIGFsbCBtYW5hZ2VkIGZlYXR1cmVzIGFuZCB3ZSBuZWVkIHRvIG1ha2VcclxuICAgIC8vIHN1cmUgdGhhdCBpdCdzIHByZXNlbnQgYmVmb3JlIHRoZXkncmUgaW5pdGlhbGl6ZWQgKGkuZS4gYmVmb3JlIHRoZWlyIGRlc2VyaWFsaXplcnMgYXJlXHJcbiAgICAvLyBjYWxsZWQpLlxyXG4gICAgLy8gJEZsb3dJc3N1ZTogTmVlZCB0byB1cHN0cmVhbSB0aGlzLlxyXG4gICAgY29uc3Qgb25XaWxsSW5pdGlhbGl6ZVBhY2thZ2VEaXNwb3NhYmxlID0gYXRvbS5wYWNrYWdlcy5vbldpbGxJbml0aWFsaXplUGFja2FnZShcclxuICAgICAgcGFjayA9PiB7XHJcbiAgICAgICAgaWYgKGZlYXR1cmVOYW1lcy5oYXMocGFjay5uYW1lKSkge1xyXG4gICAgICAgICAgb25XaWxsSW5pdGlhbGl6ZVBhY2thZ2VEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIGNvbnN0IHJvb3RQYWNrYWdlID0gYXRvbS5wYWNrYWdlcy5nZXRMb2FkZWRQYWNrYWdlKHRoaXMuX3BrZ05hbWUpO1xyXG4gICAgICAgICAgbnVsbHRocm93cyhyb290UGFja2FnZSkuaW5pdGlhbGl6ZUlmTmVlZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICAgIHRoaXMuX2xvYWREaXNwb3NhYmxlLmFkZChvbldpbGxJbml0aWFsaXplUGFja2FnZURpc3Bvc2FibGUpO1xyXG5cclxuICAgIC8vIENsZWFuIHVwIHdoZW4gdGhlIHBhY2thZ2UgaXMgdW5sb2FkZWQuXHJcbiAgICB0aGlzLl9sb2FkRGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGF0b20ucGFja2FnZXMub25EaWRVbmxvYWRQYWNrYWdlKHBhY2sgPT4ge1xyXG4gICAgICAgIGlmIChwYWNrLm5hbWUgPT09IHRoaXMuX3BrZ05hbWUpIHtcclxuICAgICAgICAgIHRoaXMuX2xvYWREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGFjdGl2YXRlKCk6IHZvaWQge1xyXG4gICAgaW52YXJpYW50KHRoaXMuX2FjdGl2YXRpb25EaXNwb3NhYmxlID09IG51bGwpO1xyXG4gICAgY29uc3Qgcm9vdFBhY2thZ2UgPSBhdG9tLnBhY2thZ2VzLmdldExvYWRlZFBhY2thZ2UodGhpcy5fcGtnTmFtZSk7XHJcbiAgICBpbnZhcmlhbnQocm9vdFBhY2thZ2UgIT0gbnVsbCk7XHJcblxyXG4gICAgLy8gVGhpcyBpcyBhIGZhaWxzYWZlIGluIGNhc2UgdGhlIGAuRm9yY2VNYWluTW9kdWxlTG9hZGAgZGVzZXJpYWxpemVyXHJcbiAgICAvLyBkZWZpbmVkIGFib3ZlIGRvZXMgbm90IHJlZ2lzdGVyIGluIHRpbWUsIG9yIGlmIHRoZSBkZWZlciBrZXkgaGFzIGJlZW4gc2V0XHJcbiAgICAvLyB3L28gb3VyIGtub3dsZWRnZS4gVGhpcyBjYW4gaGFwcGVuIGR1cmluZyBPU1MgdXBncmFkZXMuXHJcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcclxuICAgICAgcm9vdFBhY2thZ2UuZ2V0Q2FuRGVmZXJNYWluTW9kdWxlUmVxdWlyZVN0b3JhZ2VLZXkoKSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy51cGRhdGVBY3RpdmVGZWF0dXJlcygpO1xyXG5cclxuICAgIC8vIFdhdGNoIHRoaW5ncyB0aGF0IHNob3VsZCB0cmlnZ2VyIHJlZXZhbHVhdGlvbiBvZiBhY3RpdmUgZmVhdHVyZXMuIE5vdGUgdGhhdCB3ZSBkbyB0aGlzXHJcbiAgICAvLyAqYWZ0ZXIqIHRoZSBpbml0aWFsIGB1cGRhdGVBY3RpdmVGZWF0dXJlcygpYCBjYWxsIGJlY2F1c2UgdGhhdCBjb3VsZCB0cmlnZ2VyIG9uZSBvZiB0aGVzZVxyXG4gICAgLy8gZXZlbnRzLlxyXG4gICAgdGhpcy5fYWN0aXZhdGlvbkRpc3Bvc2FibGUgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgICAgYXRvbS5jb25maWcub25EaWRDaGFuZ2UodGhpcy5nZXRVc2VLZXlQYXRoKCksICgpID0+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUZlYXR1cmVzKCk7XHJcbiAgICAgIH0pLFxyXG4gICAgICBhdG9tLmNvbmZpZy5vbkRpZENoYW5nZSh0aGlzLmdldEVuYWJsZWRGZWF0dXJlR3JvdXBzS2V5UGF0aCgpLCAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVGZWF0dXJlcygpO1xyXG4gICAgICB9KSxcclxuICAgICAgT2JzZXJ2YWJsZS5tZXJnZShkaWRBZGRGaXJzdFBhdGgsIGRpZEFkZEZpcnN0VGV4dEVkaXRvcilcclxuICAgICAgICAudGFrZSgxKVxyXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgLy8gSG9wZWZ1bGx5IHdlJ3ZlIG9wZW5lZCBhIHByb2plY3Qgc28gd2UgZG9uJ3QgaGF2ZSB0byBsb2FkIGFsbCB0aGUgZmVhdHVyZXMuXHJcbiAgICAgICAgICB0aGlzLl9kZWZlcnJpbmdGZWF0dXJlQWN0aXZhdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVGZWF0dXJlcygpO1xyXG4gICAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZUFjdGl2ZUZlYXR1cmVzKCkge1xyXG4gICAgLy8gYHVwZGF0ZUFjdGl2ZUZlYXR1cmVzKClgIGNhbid0IGJlIGNhbGxlZCByZWN1cnNpdmVseS4gSWYgaXQgaXMsIGp1c3Qgd2FybiBhbmQgYmFpbC5cclxuICAgIGlmICh0aGlzLl9mZWF0dXJlQmVpbmdBY3RpdmF0ZWQgIT0gbnVsbCkge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYEFjdGl2YXRpbmcgJHt0aGlzLl9mZWF0dXJlQmVpbmdBY3RpdmF0ZWQucGtnLm5hbWV9IGNhdXNlZCBhYCArXHJcbiAgICAgICAgICAnIHJlZXZhbHVhdGlvbiBvZiBhY3RpdmUgZmVhdHVyZXMuJyxcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2ZlYXR1cmVCZWluZ0RlYWN0aXZhdGVkICE9IG51bGwpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBEZWFjdGl2YXRpbmcgJHt0aGlzLl9mZWF0dXJlQmVpbmdEZWFjdGl2YXRlZC5wa2cubmFtZX0gY2F1c2VkIGFgICtcclxuICAgICAgICAgICcgcmVldmFsdWF0aW9uIG9mIGFjdGl2ZSBmZWF0dXJlcy4nLFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZUZlYXR1cmVzTm93KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGUgYW5kIGRpc2FibGUgdGhlIGNvcnJlY3QgZmVhdHVyZXMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXHJcbiAgICovXHJcbiAgdXBkYXRlQWN0aXZlRmVhdHVyZXNOb3coKSB7XHJcbiAgICBjb25zdCBlbmFibGVkRmVhdHVyZXMgPSB0aGlzLmdldEVuYWJsZWRGZWF0dXJlcygpO1xyXG4gICAgY29uc3QgZmVhdHVyZXNUb0FjdGl2YXRlID0gc2V0VW5pb24oXHJcbiAgICAgIHRoaXMuX2ZlYXR1cmVHcm91cHMuZ2V0KFJFUVVJUkVEX0ZFQVRVUkVfR1JPVVApLFxyXG4gICAgICB0aGlzLl9kZWZlcnJpbmdGZWF0dXJlQWN0aXZhdGlvblxyXG4gICAgICAgID8gc2V0SW50ZXJzZWN0KFxyXG4gICAgICAgICAgICBlbmFibGVkRmVhdHVyZXMsXHJcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVHcm91cHMuZ2V0KElOSVRJQUxfRkVBVFVSRV9HUk9VUCksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiBlbmFibGVkRmVhdHVyZXMsXHJcbiAgICApO1xyXG5cclxuICAgIC8vIEVuYWJsZSBhbGwgcGFja2FnZXMgaW4gZmVhdHVyZXNUb0FjdGl2YXRlIGJ1dCBub3QgaW4gY3VycmVudFN0YXRlLlxyXG4gICAgLy8gRGlzYWJsZSBhbGwgcGFja2FnZXMgbm90IGluIGZlYXR1cmVzVG9BY3RpdmF0ZSBidXQgaW4gY3VycmVudFN0YXRlLlxyXG4gICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIGZlYXR1cmVzVG9BY3RpdmF0ZSkge1xyXG4gICAgICBpZiAoIXRoaXMuX2N1cnJlbnRseUFjdGl2ZUZlYXR1cmVzLmhhcyhmZWF0dXJlKSkge1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVCZWluZ0FjdGl2YXRlZCA9IGZlYXR1cmU7XHJcbiAgICAgICAgYXRvbS5wYWNrYWdlcy5hY3RpdmF0ZVBhY2thZ2UoZmVhdHVyZS5wYXRoKTtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlQmVpbmdBY3RpdmF0ZWQgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIHRoaXMuX2N1cnJlbnRseUFjdGl2ZUZlYXR1cmVzKSB7XHJcbiAgICAgIGlmICghZmVhdHVyZXNUb0FjdGl2YXRlLmhhcyhmZWF0dXJlKSkge1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVCZWluZ0RlYWN0aXZhdGVkID0gZmVhdHVyZTtcclxuICAgICAgICBzYWZlRGVhY3RpdmF0ZShmZWF0dXJlKTtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlQmVpbmdEZWFjdGl2YXRlZCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jdXJyZW50bHlBY3RpdmVGZWF0dXJlcyA9IGZlYXR1cmVzVG9BY3RpdmF0ZTtcclxuICB9XHJcblxyXG4gIGRlYWN0aXZhdGUoKTogdm9pZCB7XHJcbiAgICBpbnZhcmlhbnQoXHJcbiAgICAgIHRoaXMuX2FjdGl2YXRpb25EaXNwb3NhYmxlICYmICF0aGlzLl9hY3RpdmF0aW9uRGlzcG9zYWJsZS5kaXNwb3NlZCxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5fY3VycmVudGx5QWN0aXZlRmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcclxuICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgcGFja2FnZSwgYnV0IGRvbid0IHNlcmlhbGl6ZS4gVGhhdCBuZWVkcyB0byBiZSBkb25lIGluIGEgc2VwYXJhdGUgcGhhc2Ugc28gdGhhdFxyXG4gICAgICAvLyB3ZSBkb24ndCBlbmQgdXAgZGlzY29ubmVjdGluZyBhIHNlcnZpY2UgYW5kIHRoZW4gc2VyaWFsaXppbmcgdGhlIGRpc2Nvbm5lY3RlZCBzdGF0ZS5cclxuICAgICAgc2FmZURlYWN0aXZhdGUoZmVhdHVyZSwgdHJ1ZSk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2N1cnJlbnRseUFjdGl2ZUZlYXR1cmVzID0gbmV3IFNldCgpO1xyXG5cclxuICAgIGludmFyaWFudCh0aGlzLl9hY3RpdmF0aW9uRGlzcG9zYWJsZSk7IC8vIHJlYXNzZXJ0aW5nIGZvciBmbG93XHJcbiAgICB0aGlzLl9hY3RpdmF0aW9uRGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICB0aGlzLl9hY3RpdmF0aW9uRGlzcG9zYWJsZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgYXJlIGVuYWJsZWQgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbmZpZ3VyYXRpb24uIFRoaXMgc2V0XHJcbiAgICogaXMgdGhlbiB1c2VkIHRvIGxvYWQgYW5kIGFjdGl2YXRlIHRoZSBmZWF0dXJlcy5cclxuICAgKi9cclxuICBnZXRFbmFibGVkRmVhdHVyZXMoKTogU2V0PEZlYXR1cmU+IHtcclxuICAgIC8vIHdlIGtub3cgZW5hYmxlZEZlYXR1cmVHcm91cHMgbXVzdCBiZSA/QXJyYXksIGFuZCB1c2VGZWF0dXJlUnVsZXMgbXVzdCBiZSA/VXNlRmVhdHVyZVJ1bGVzLFxyXG4gICAgLy8gc2luY2UgaXQncyBpbiBvdXIgc2NoZW1hLiBIb3dldmVyLCBmbG93IHRoaW5rcyBpdCdzIGEgbWl4ZWQgdHlwZSwgc2luY2UgaXQgZG9lc24ndCBrbm93IGFib3V0XHJcbiAgICAvLyB0aGUgc2NoZW1hIGVuZm9yY2VtZW50cy5cclxuICAgIGNvbnN0IHVzZUZlYXR1cmVSdWxlczogP1VzZUZlYXR1cmVSdWxlcyA9IChhdG9tLmNvbmZpZy5nZXQoXHJcbiAgICAgIHRoaXMuZ2V0VXNlS2V5UGF0aCgpLFxyXG4gICAgKTogYW55KTtcclxuICAgIGNvbnN0IGVuYWJsZWRGZWF0dXJlR3JvdXBzOiA/QXJyYXk8c3RyaW5nPiA9IChhdG9tLmNvbmZpZy5nZXQoXHJcbiAgICAgIHRoaXMuZ2V0RW5hYmxlZEZlYXR1cmVHcm91cHNLZXlQYXRoKCksXHJcbiAgICApOiBhbnkpO1xyXG5cclxuICAgIGNvbnN0IGZlYXR1cmVzSW5FbmFibGVkR3JvdXBzID1cclxuICAgICAgZW5hYmxlZEZlYXR1cmVHcm91cHMgPT0gbnVsbFxyXG4gICAgICAgID8gbmV3IFNldCh0aGlzLl9mZWF0dXJlcykgLy8gSWYgZmVhdHVyZWdyb3VwcyBpcyB1bmRlZmluZWQsIGFzc3VtZSBhbGwgZmVhdHVyZXMgc2hvdWxkIGJlIGVuYWJsZWQuXHJcbiAgICAgICAgOiBzZXRVbmlvbihcclxuICAgICAgICAgICAgLi4uZW5hYmxlZEZlYXR1cmVHcm91cHMubWFwKGZlYXR1cmVHcm91cCA9PlxyXG4gICAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVHcm91cHMuZ2V0KGZlYXR1cmVHcm91cCksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgIGNvbnN0IHJlcXVpcmVkRmVhdHVyZXMgPVxyXG4gICAgICB0aGlzLl9mZWF0dXJlR3JvdXBzLmdldChSRVFVSVJFRF9GRUFUVVJFX0dST1VQKSB8fCBuZXcgU2V0KCk7XHJcblxyXG4gICAgLy8gSWYgYSBmZWF0dXJlIGlzIFwiYWx3YXlzIGVuYWJsZWRcIiwgaXQgc2hvdWxkIGJlIG9uIHdoZXRoZXIgb3Igbm90IGEgZmVhdHVyZS1ncm91cCBpbmNsdWRlcyBpdC5cclxuICAgIC8vIElmIGEgZmVhdHVyZSBpcyBcImRlZmF1bHRcIiwgaXQgc2hvdWxkIGJlIG9uIGlmIGFuZCBvbmx5IGlmIGEgZmVhdHVyZS1ncm91cCBpbmNsdWRlcyBpdC5cclxuICAgIHJldHVybiBuZXcgU2V0KFxyXG4gICAgICB0aGlzLl9mZWF0dXJlcy5maWx0ZXIoZmVhdHVyZSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmVhdHVyZU5hbWUgPSBwYWNrYWdlTmFtZUZyb21QYXRoKGZlYXR1cmUucGF0aCk7XHJcbiAgICAgICAgY29uc3QgcmF3UnVsZSA9IGlkeCh1c2VGZWF0dXJlUnVsZXMsIF8gPT4gX1tmZWF0dXJlTmFtZV0pO1xyXG4gICAgICAgIGNvbnN0IHJ1bGUgPVxyXG4gICAgICAgICAgcmF3UnVsZSA9PSBudWxsID8gZ2V0RmVhdHVyZURlZmF1bHRWYWx1ZShmZWF0dXJlKSA6IHJhd1J1bGU7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIHJ1bGUgPT09IEFMV0FZU19FTkFCTEVEIHx8XHJcbiAgICAgICAgICBydWxlID09PSB0cnVlIHx8XHJcbiAgICAgICAgICAoZmVhdHVyZXNJbkVuYWJsZWRHcm91cHMuaGFzKGZlYXR1cmUpICYmIHJ1bGUgPT09IERFRkFVTFQpIHx8XHJcbiAgICAgICAgICByZXF1aXJlZEZlYXR1cmVzLmhhcyhmZWF0dXJlKVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldENvbmZpZygpOiBPYmplY3Qge1xyXG4gICAgaW52YXJpYW50KHRoaXMuX2NvbmZpZyAhPSBudWxsKTtcclxuICAgIHJldHVybiB0aGlzLl9jb25maWc7XHJcbiAgfVxyXG5cclxuICBzZXJpYWxpemUoKTogdm9pZCB7XHJcbiAgICAvLyBXaGVuIHRoZSByb290IHBhY2thZ2UgaXMgc2VyaWFsaXplZCwgYWxsIG9mIGl0cyBmZWF0dXJlcyBuZWVkIHRvIGJlIHNlcmlhbGl6ZWQuIFRoaXMgaXMgYW4gYWJ1c2Ugb2ZcclxuICAgIC8vIGBzZXJpYWxpemUoKWAgc2luY2Ugd2UncmUgdXNpbmcgaXQgdG8gZG8gc2lkZSBlZmZlY3RzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZSBzZXJpYWxpemF0aW9uLFxyXG4gICAgLy8gYnV0IGl0IGVuc3VyZXMgdGhhdCBzZXJpYWxpemF0aW9uIG9mIHRoZSBBdG9tIHBhY2thZ2VzIGhhcHBlbnMgYXQgdGhlIHJpZ2h0IHBvaW50IGluIHRoZVxyXG4gICAgLy8gcGFja2FnZSBsaWZlY3ljbGUuIFVuZm9ydHVuYXRlbHksIGl0IGFsc28gbWVhbnMgdGhhdCBOdWNsaWRlIGZlYXR1cmVzIHdpbGwgYmUgc2VyaWFsaXplZCB0d2ljZVxyXG4gICAgLy8gb24gZGVhY3RpdmF0aW9uLlxyXG4gICAgdGhpcy5fZmVhdHVyZXMuZm9yRWFjaChzYWZlU2VyaWFsaXplKTtcclxuICB9XHJcblxyXG4gIGdldFVzZUtleVBhdGgoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgJHt0aGlzLl9wa2dOYW1lfS51c2VgO1xyXG4gIH1cclxuXHJcbiAgZ2V0RW5hYmxlZEZlYXR1cmVHcm91cHNLZXlQYXRoKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gYCR7dGhpcy5fcGtnTmFtZX0uZW5hYmxlZEZlYXR1cmVHcm91cHNgO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2FmZURlYWN0aXZhdGUoXHJcbiAgZmVhdHVyZTogRmVhdHVyZSxcclxuICBzdXBwcmVzc1NlcmlhbGl6YXRpb246IGJvb2xlYW4gPSBmYWxzZSxcclxuKSB7XHJcbiAgY29uc3QgbmFtZSA9IHBhY2thZ2VOYW1lRnJvbVBhdGgoZmVhdHVyZS5wYXRoKTtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcGFjayA9IGF0b20ucGFja2FnZXMuZ2V0TG9hZGVkUGFja2FnZShuYW1lKTtcclxuICAgIGlmIChwYWNrICE9IG51bGwpIHtcclxuICAgICAgYXRvbS5wYWNrYWdlcy5kZWFjdGl2YXRlUGFja2FnZShuYW1lLCBzdXBwcmVzc1NlcmlhbGl6YXRpb24pO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlYWN0aXZhdGluZyBcIiR7bmFtZX1cIjogJHtlcnIubWVzc2FnZX1gKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEZlYXR1cmVEZWZhdWx0VmFsdWUoZmVhdHVyZTogRmVhdHVyZSk6IHN0cmluZyB7XHJcbiAgY29uc3QgbmFtZSA9IHBhY2thZ2VOYW1lRnJvbVBhdGgoZmVhdHVyZS5wYXRoKTtcclxuICByZXR1cm4gbmFtZS5zdGFydHNXaXRoKCdzYW1wbGUtJykgfHwgbmFtZS5zdGFydHNXaXRoKCdmYi1zYW1wbGUtJylcclxuICAgID8gTkVWRVJfRU5BQkxFRFxyXG4gICAgOiBERUZBVUxUO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzYWZlU2VyaWFsaXplKGZlYXR1cmU6IEZlYXR1cmUpIHtcclxuICBjb25zdCBuYW1lID0gcGFja2FnZU5hbWVGcm9tUGF0aChmZWF0dXJlLnBhdGgpO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBwYWNrID0gYXRvbS5wYWNrYWdlcy5nZXRBY3RpdmVQYWNrYWdlKG5hbWUpO1xyXG4gICAgaWYgKHBhY2sgIT0gbnVsbCkge1xyXG4gICAgICAvLyBTZXJpYWxpemUgdGhlIHBhY2thZ2VcclxuICAgICAgYXRvbS5wYWNrYWdlcy5zZXJpYWxpemVQYWNrYWdlKHBhY2spO1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycikge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNlcmlhbGl6aW5nIFwiJHtuYW1lfVwiOiAke2Vyci5tZXNzYWdlfWApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gdGhpcyBjb3VsZCBiZSBpbmxpbmVkIGludG8gaXRzIHVzZSBhYm92ZSwgYnV0IHRoaXMgbWFrZXMgdGhlIGludGVudCBtb3JlXHJcbi8vIGV4cGxpY2l0LCBhbmQgdW5pZmllcyBpdCBpbiB0aGUgY2FzZSB0aGlzIGV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxyXG5mdW5jdGlvbiBwYWNrYWdlTmFtZUZyb21QYXRoKHBrZ1BhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHBhdGguYmFzZW5hbWUocGtnUGF0aCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhY2thZ2VJc1JlcG9zaXRvcnlQcm92aWRlcihwa2c6IEZlYXR1cmVQa2cpOiBib29sZWFuIHtcclxuICByZXR1cm4gQm9vbGVhbihpZHgocGtnLCBfID0+IF8ucHJvdmlkZWRTZXJ2aWNlc1snYXRvbS5yZXBvc2l0b3J5LXByb3ZpZGVyJ10pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRDb25maWcoZmVhdHVyZXM6IEFycmF5PEZlYXR1cmU+KTogT2JqZWN0IHtcclxuICBjb25zdCBjb25maWcgPSB7XHJcbiAgICB1c2U6IHtcclxuICAgICAgdGl0bGU6ICdFbmFibGVkIEZlYXR1cmVzJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdFbmFibGUgYW5kIGRpc2FibGUgaW5kaXZpZHVhbCBmZWF0dXJlcycsXHJcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxyXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXHJcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XHJcbiAgICBjb25zdCBmZWF0dXJlUGtnID0gZmVhdHVyZS5wa2c7XHJcbiAgICBjb25zdCBuYW1lID0gcGFja2FnZU5hbWVGcm9tUGF0aChmZWF0dXJlLnBhdGgpO1xyXG5cclxuICAgIGNvbnN0IHNldHRpbmcgPSB7XHJcbiAgICAgIHRpdGxlOlxyXG4gICAgICAgIGZlYXR1cmVQa2cuZGlzcGxheU5hbWUgPT0gbnVsbFxyXG4gICAgICAgICAgPyBgRW5hYmxlIHRoZSBcIiR7bmFtZX1cIiBmZWF0dXJlYFxyXG4gICAgICAgICAgOiBgRW5hYmxlICR7ZmVhdHVyZVBrZy5kaXNwbGF5TmFtZX1gLFxyXG4gICAgICBkZXNjcmlwdGlvbjogZmVhdHVyZVBrZy5kZXNjcmlwdGlvbiB8fCAnJyxcclxuICAgICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICAgIGVudW06IFtcclxuICAgICAgICB7dmFsdWU6IEFMV0FZU19FTkFCTEVELCBkZXNjcmlwdGlvbjogJ0Fsd2F5cyBlbmFibGVkJ30sXHJcbiAgICAgICAge3ZhbHVlOiBORVZFUl9FTkFCTEVELCBkZXNjcmlwdGlvbjogJ05ldmVyIGVuYWJsZWQnfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB2YWx1ZTogREVGQVVMVCxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnT25seSB3aGVuIGluIGFuIGVuYWJsZWQgcGFja2FnZSBncm91cCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgZGVmYXVsdDogZ2V0RmVhdHVyZURlZmF1bHRWYWx1ZShmZWF0dXJlKSxcclxuICAgIH07XHJcblxyXG4gICAgaWYgKGRldk1vZGUpIHtcclxuICAgICAgaWYgKGZlYXR1cmVQa2cucHJvdmlkZWRTZXJ2aWNlcykge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVzID0gT2JqZWN0LmtleXMoZmVhdHVyZVBrZy5wcm92aWRlZFNlcnZpY2VzKS5qb2luKCcsICcpO1xyXG4gICAgICAgIHNldHRpbmcuZGVzY3JpcHRpb24gKz0gYDxici8+KipQcm92aWRlczoqKiBfJHtwcm92aWRlc31fYDtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZmVhdHVyZVBrZy5jb25zdW1lZFNlcnZpY2VzKSB7XHJcbiAgICAgICAgY29uc3QgY29uc3VtZXMgPSBPYmplY3Qua2V5cyhmZWF0dXJlUGtnLmNvbnN1bWVkU2VydmljZXMpLmpvaW4oJywgJyk7XHJcbiAgICAgICAgc2V0dGluZy5kZXNjcmlwdGlvbiArPSBgPGJyLz4qKkNvbnN1bWVzOioqIF8ke2NvbnN1bWVzfV9gO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uZmlnLnVzZS5wcm9wZXJ0aWVzW25hbWVdID0gc2V0dGluZztcclxuXHJcbiAgICAvLyBNZXJnZSBpbiB0aGUgZmVhdHVyZSdzIGNvbmZpZ1xyXG4gICAgY29uc3QgZmVhdHVyZVBrZ0NvbmZpZyA9XHJcbiAgICAgIGZlYXR1cmVQa2cuYXRvbUNvbmZpZyB8fFxyXG4gICAgICAoZmVhdHVyZVBrZy5udWNsaWRlICYmIGZlYXR1cmVQa2cubnVjbGlkZS5jb25maWcpO1xyXG5cclxuICAgIGlmIChmZWF0dXJlUGtnQ29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZ1tuYW1lXSA9IHtcclxuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcclxuICAgICAgICB0aXRsZTogZmVhdHVyZVBrZy5kaXNwbGF5TmFtZSxcclxuICAgICAgICBkZXNjcmlwdGlvbjogZmVhdHVyZVBrZy5kZXNjcmlwdGlvbixcclxuICAgICAgICBjb2xsYXBzZWQ6IHRydWUsXHJcbiAgICAgICAgcHJvcGVydGllczoge30sXHJcbiAgICAgIH07XHJcbiAgICAgIE9iamVjdC5rZXlzKGZlYXR1cmVQa2dDb25maWcpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICBjb25maWdbbmFtZV0ucHJvcGVydGllc1trZXldID0ge1xyXG4gICAgICAgICAgLi4uZmVhdHVyZVBrZ0NvbmZpZ1trZXldLFxyXG4gICAgICAgICAgdGl0bGU6IGZlYXR1cmVQa2dDb25maWdba2V5XS50aXRsZSB8fCBrZXksXHJcbiAgICAgICAgfTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGNvbmZpZztcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhY2sgdGltZSEhIEF0b20ncyByZXBvc2l0b3J5IEFQSXMgYXJlIHN5bmNocm9ub3VzLiBBbnkgcGFja2FnZSB0aGF0IHRyaWVzIHRvIHVzZSB0aGVtIGJlZm9yZVxyXG4gKiB3ZSd2ZSBoYWQgYSBjaGFuY2UgdG8gcHJvdmlkZSBvdXIgaW1wbGVtZW50YXRpb24gYXJlIGdvaW5nIHRvIGdldCB3cm9uZyBhbnN3ZXJzLiBUaGUgY29ycmVjdFxyXG4gKiB0aGluZyB0byBkbyB3b3VsZCBiZSB0byBhbHdheXMgZ28gdGhyb3VnaCBhbiBhc3luYyBBUEkgdGhhdCBhd2FpdHMgdW50aWxcclxuICogYGF0b20ucGFja2FnZXMub25EaWRBY3RpdmF0ZUluaXRpYWxQYWNrYWdlcygpYCBjb21wbGV0ZXMuIEhvd2V2ZXIsIHdlIGhhdmUgc29tZSBsZWdhY3kgc3luY1xyXG4gKiBjb2RlcGF0aHMgdGhhdCBtYWtlIHRoYXQgZGlmZmljdWx0LiBBcyBhIHRlbXBvcmFyeSAoSSBob3BlKSB3b3JrYXJvdW5kLCB3ZSBwcmlvcml0aXplXHJcbiAqIGFjdGl2YXRpb24gb2YgdGhlIGZlYXR1cmVzIHRoYXQgcHJvdmlkZSB0aGlzIHNlcnZpY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW9yZGVyRmVhdHVyZXMoZmVhdHVyZXNfOiBBcnJheTxGZWF0dXJlPik6IEFycmF5PEZlYXR1cmU+IHtcclxuICBjb25zdCBmZWF0dXJlcyA9IGZlYXR1cmVzXy5zbGljZSgpO1xyXG4gIGNvbnN0IG9yaWdpbmFsT3JkZXIgPSBuZXcgTWFwKGZlYXR1cmVzLm1hcCgoZmVhdHVyZSwgaSkgPT4gW2ZlYXR1cmUsIGldKSk7XHJcbiAgZmVhdHVyZXMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgY29uc3QgYUlzUmVwb1Byb3ZpZGVyID0gcGFja2FnZUlzUmVwb3NpdG9yeVByb3ZpZGVyKGEucGtnKTtcclxuICAgIGNvbnN0IGJJc1JlcG9Qcm92aWRlciA9IHBhY2thZ2VJc1JlcG9zaXRvcnlQcm92aWRlcihiLnBrZyk7XHJcbiAgICBpZiAoYUlzUmVwb1Byb3ZpZGVyICE9PSBiSXNSZXBvUHJvdmlkZXIpIHtcclxuICAgICAgcmV0dXJuIGFJc1JlcG9Qcm92aWRlciA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFJbmRleCA9IG51bGx0aHJvd3Mob3JpZ2luYWxPcmRlci5nZXQoYSkpO1xyXG4gICAgY29uc3QgYkluZGV4ID0gbnVsbHRocm93cyhvcmlnaW5hbE9yZGVyLmdldChiKSk7XHJcbiAgICByZXR1cm4gYUluZGV4IC0gYkluZGV4O1xyXG4gIH0pO1xyXG4gIHJldHVybiBmZWF0dXJlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdCBhIG1hcCB3aG9zZSBrZXlzIGFyZSBmZWF0dXJlIGdyb3VwIG5hbWVzIGFuZCB2YWx1ZXMgYXJlIHNldHMgb2YgZmVhdHVyZXMgYmVsb25naW5nIHRvXHJcbiAqIHRoZSBncm91cC5cclxuICovXHJcbmZ1bmN0aW9uIGdyb3VwRmVhdHVyZXMoXHJcbiAgZmVhdHVyZXM6IEFycmF5PEZlYXR1cmU+LFxyXG4gIHJhd0ZlYXR1cmVHcm91cHM6IHtcclxuICAgIFtzdHJpbmddOiBBcnJheTxzdHJpbmc+LFxyXG4gIH0sXHJcbik6IE11bHRpTWFwPHN0cmluZywgRmVhdHVyZT4ge1xyXG4gIGNvbnN0IG5hbWVzVG9GZWF0dXJlcyA9IG5ldyBNYXAoKTtcclxuICBmZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xyXG4gICAgbmFtZXNUb0ZlYXR1cmVzLnNldChwYXRoLmJhc2VuYW1lKGZlYXR1cmUucGF0aCksIGZlYXR1cmUpO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCBmZWF0dXJlR3JvdXBzID0gbmV3IE11bHRpTWFwKCk7XHJcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmF3RmVhdHVyZUdyb3VwcykpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0ZlYXR1cmVHcm91cHNba2V5XSkpIHtcclxuICAgICAgY29uc3QgZmVhdHVyZXNGb3JLZXkgPSByYXdGZWF0dXJlR3JvdXBzW2tleV1cclxuICAgICAgICAubWFwKGZlYXR1cmVOYW1lID0+IG5hbWVzVG9GZWF0dXJlcy5nZXQoZmVhdHVyZU5hbWUpKVxyXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICAgIGlmIChmZWF0dXJlc0ZvcktleSAhPSBudWxsKSB7XHJcbiAgICAgICAgZmVhdHVyZUdyb3Vwcy5zZXQoa2V5LCBmZWF0dXJlc0ZvcktleSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZlYXR1cmVHcm91cHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXRjaCB0aGUgcGFja2FnZSBtYW5hZ2VyIGFuZCBwYWNrYWdlcyB0byAoMSkgaW1wbGVtZW50IGBvbldpbGxJbml0aWFsaXplUGFja2FnZWAgYW5kICgyKSBjYWxsXHJcbiAqIGByZWdpc3RlckNvbmZpZ1NjaGVtYUZyb21NYWluTW9kdWxlKClgIHdoZW4gYSBwYWNrYWdlIGlzIGluaXRpYWxpemVkICh0byBndWFyYW50ZWUgaXRzIGNvbmZpZ1xyXG4gKiBzY2hlbWEgaXMgcmVhZHkgd2hlbiBpdHMgZGVzZXJpYWxpemVycyBhcmUgY2FsbGVkKS4gVGhpcyBzaG91bGQgYmUgcmVtb3ZlZCBvbmNlIHRoZXNlIGNoYW5nZXNcclxuICogYXJlIHVwc3RyZWFtZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRjaFBhY2thZ2VNYW5hZ2VyKCk6IHZvaWQge1xyXG4gIGlmIChcclxuICAgIChhdG9tLnBhY2thZ2VzOiBhbnkpLm9uV2lsbEluaXRpYWxpemVQYWNrYWdlID09IG51bGwgJiZcclxuICAgICEoYXRvbS5wYWNrYWdlczogYW55KS5fX29uV2lsbEluaXRpYWxpemVQYWNrYWdlUGF0Y2hlZFxyXG4gICkge1xyXG4gICAgKGF0b20ucGFja2FnZXM6IGFueSkub25XaWxsSW5pdGlhbGl6ZVBhY2thZ2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICAoYXRvbS5wYWNrYWdlczogYW55KS5fX29uV2lsbEluaXRpYWxpemVQYWNrYWdlUGF0Y2hlZCA9IHRydWU7XHJcbiAgICAgIHJldHVybiB0aGlzLmVtaXR0ZXIub24oJ3dpbGwtaW5pdGlhbGl6ZS1wYWNrYWdlJywgY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGlmICghKGF0b20ucGFja2FnZXM6IGFueSkuX19wYWNrYWdlTG9va3VwUGF0Y2hlZCkge1xyXG4gICAgKGF0b20ucGFja2FnZXM6IGFueSkuX19wYWNrYWdlTG9va3VwUGF0Y2hlZCA9IHRydWU7XHJcbiAgICBjb25zdCBsb2FkUGFja2FnZSA9IGF0b20ucGFja2FnZXMubG9hZFBhY2thZ2U7XHJcbiAgICAoYXRvbS5wYWNrYWdlczogYW55KS5sb2FkUGFja2FnZSA9IGZ1bmN0aW9uKG5hbWVPclBhdGgsIC4uLmFyZ3MpIHtcclxuICAgICAgY29uc3QgcGFjayA9IGxvYWRQYWNrYWdlLmNhbGwodGhpcywgbmFtZU9yUGF0aCwgLi4uYXJncyk7XHJcbiAgICAgIGlmIChwYWNrID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBwYXRjaFBhY2thZ2UocGFjayk7XHJcbiAgICAgIHJldHVybiBwYWNrO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBnZXRMb2FkZWRQYWNrYWdlID0gYXRvbS5wYWNrYWdlcy5nZXRMb2FkZWRQYWNrYWdlO1xyXG4gICAgKGF0b20ucGFja2FnZXM6IGFueSkuZ2V0TG9hZGVkUGFja2FnZSA9IGZ1bmN0aW9uKG5hbWUsIC4uLmFyZ3MpIHtcclxuICAgICAgY29uc3QgcGFjayA9IGdldExvYWRlZFBhY2thZ2UuY2FsbCh0aGlzLCBuYW1lLCAuLi5hcmdzKTtcclxuICAgICAgaWYgKHBhY2sgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHBhdGNoUGFja2FnZShwYWNrKTtcclxuICAgICAgcmV0dXJuIHBhY2s7XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcGF0Y2hQYWNrYWdlKHBhY2spOiB2b2lkIHtcclxuICBpZiAoKHBhY2s6IGFueSkuX19pbml0aWFsaXplSWZOZWVkZWRQYXRjaGVkKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIChwYWNrOiBhbnkpLl9faW5pdGlhbGl6ZUlmTmVlZGVkUGF0Y2hlZCA9IHRydWU7XHJcblxyXG4gIGNvbnN0IGluaXRpYWxpemVJZk5lZWRlZCA9IChwYWNrOiBhbnkpLmluaXRpYWxpemVJZk5lZWRlZDtcclxuICAocGFjazogYW55KS5pbml0aWFsaXplSWZOZWVkZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLm1haW5Jbml0aWFsaXplZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoKGF0b20ucGFja2FnZXM6IGFueSkuX19vbldpbGxJbml0aWFsaXplUGFja2FnZVBhdGNoZWQpIHtcclxuICAgICAgLy8gSWYgd2UgZGlkbid0IGFwcGx5IG91ciBwYXRjaCBmb3IgdGhpcywgQXRvbSBpcyBhbHJlYWR5IGRpc3BhdGNoaW5nIHRoZSBldmVudC5cclxuICAgICAgYXRvbS5wYWNrYWdlcy5lbWl0dGVyLmVtaXQoJ3dpbGwtaW5pdGlhbGl6ZS1wYWNrYWdlJywgcGFjayk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlZ2lzdGVyQ29uZmlnU2NoZW1hRnJvbU1haW5Nb2R1bGUoKTtcclxuICAgIHJldHVybiBpbml0aWFsaXplSWZOZWVkZWQuY2FsbCh0aGlzKTtcclxuICB9O1xyXG59XHJcblxyXG5jb25zdCBkaWRMb2FkUGFja2FnZSA9IChwa2dOYW1lOiBzdHJpbmcpID0+XHJcbiAgb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihjYiA9PiBhdG9tLnBhY2thZ2VzLm9uRGlkTG9hZFBhY2thZ2UoY2IpKVxyXG4gICAgLnN0YXJ0V2l0aChudWxsKVxyXG4gICAgLmZpbHRlcigoKSA9PiBhdG9tLnBhY2thZ2VzLmdldExvYWRlZFBhY2thZ2UocGtnTmFtZSkgIT0gbnVsbClcclxuICAgIC50YWtlKDEpO1xyXG5cclxuY29uc3QgZGlkQWRkRmlyc3RQYXRoID0gb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihjYiA9PlxyXG4gIGF0b20ucHJvamVjdC5vbkRpZENoYW5nZVBhdGhzKGNiKSxcclxuKVxyXG4gIC5zdGFydFdpdGgobnVsbClcclxuICAuZmlsdGVyKCgpID0+IGF0b20ucHJvamVjdC5nZXREaXJlY3RvcmllcygpLmxlbmd0aCA+IDApXHJcbiAgLnRha2UoMSk7XHJcblxyXG5jb25zdCBkaWRBZGRGaXJzdFRleHRFZGl0b3IgPSBvYnNlcnZhYmxlRnJvbVN1YnNjcmliZUZ1bmN0aW9uKGNiID0+XHJcbiAgYXRvbS53b3Jrc3BhY2UuZ2V0Q2VudGVyKCkub25EaWRBZGRUZXh0RWRpdG9yKGNiKSxcclxuKVxyXG4gIC5zdGFydFdpdGgobnVsbClcclxuICAuZmlsdGVyKCgpID0+IGF0b20ud29ya3NwYWNlLmdldENlbnRlcigpLmdldFRleHRFZGl0b3JzKCkubGVuZ3RoID4gMClcclxuICAudGFrZSgxKTtcclxuIl19