"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerOnWillSave = registerOnWillSave;
exports.observeTextEditors = observeTextEditors;

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _analytics = require("@atom-ide-community/nuclide-commons/analytics");

var _ProviderRegistry = _interopRequireDefault(require("./ProviderRegistry"));

var _textEdit = require("./text-edit");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// Timeouts if providers don't all finish in 5 seconds.
const GLOBAL_SAVE_TIMEOUT_MS = 5000;
const onWillSaveProviders = new _ProviderRegistry.default(); // Returns an observable of booleans, each of which indicates whether the
// formatting text edits from a given provider was successfully applied or not.

function onWillSave(editor) {
  if (editor.getPath() == null) {
    return _rxjsCompatUmdMin.Observable.empty();
  }

  const providers = Array.from(onWillSaveProviders.getAllProvidersForEditor(editor)); // NOTE: concat() is used here to subscribe to providers sequentially and
  // apply their text edits in order.

  return _rxjsCompatUmdMin.Observable.concat(...providers.map(provider => provider.callback(editor).toArray().race(_rxjsCompatUmdMin.Observable.of([]).delay(provider.timeout)).map(edits => {
    const success = (0, _textEdit.applyTextEditsToBuffer)(editor.getBuffer(), edits);
    return success;
  })));
} // HACK: intercept the real TextEditor.save and handle it ourselves.
// Atom has no way of injecting content into the buffer asynchronously
// before a save operation.
// If we try to format after the save, and then save again,
// it's a poor user experience (and also races the text buffer's reload).


function patchEditorSave(editor) {
  const realSave = editor.save;
  const editor_ = editor;

  editor_.save = async () => {
    const timeout = new Date();
    timeout.setTime(timeout.getTime() + GLOBAL_SAVE_TIMEOUT_MS);

    try {
      await onWillSave(editor_).timeout(timeout).toPromise();
    } catch (e) {
      const providers = Array.from(onWillSaveProviders.getAllProvidersForEditor(editor_));
      (0, _analytics.track)('timeout-on-save', {
        uri: editor.getPath(),
        providers
      });
    } finally {
      await realSave.call(editor);
    }
  };

  return new _UniversalDisposable.default(() => {
    editor_.save = realSave;
  });
}

function registerOnWillSave(provider) {
  return onWillSaveProviders.addProvider(provider);
}

function observeTextEditors() {
  const disposables = new _UniversalDisposable.default();
  disposables.add(atom.workspace.observeTextEditors(editor => {
    disposables.add(patchEditorSave(editor));
  }));
  return disposables;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vRmlsZUV2ZW50SGFuZGxlcnMuanMiXSwibmFtZXMiOlsiR0xPQkFMX1NBVkVfVElNRU9VVF9NUyIsIm9uV2lsbFNhdmVQcm92aWRlcnMiLCJQcm92aWRlclJlZ2lzdHJ5Iiwib25XaWxsU2F2ZSIsImVkaXRvciIsImdldFBhdGgiLCJPYnNlcnZhYmxlIiwiZW1wdHkiLCJwcm92aWRlcnMiLCJBcnJheSIsImZyb20iLCJnZXRBbGxQcm92aWRlcnNGb3JFZGl0b3IiLCJjb25jYXQiLCJtYXAiLCJwcm92aWRlciIsImNhbGxiYWNrIiwidG9BcnJheSIsInJhY2UiLCJvZiIsImRlbGF5IiwidGltZW91dCIsImVkaXRzIiwic3VjY2VzcyIsImdldEJ1ZmZlciIsInBhdGNoRWRpdG9yU2F2ZSIsInJlYWxTYXZlIiwic2F2ZSIsImVkaXRvcl8iLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1Byb21pc2UiLCJlIiwidXJpIiwiY2FsbCIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJyZWdpc3Rlck9uV2lsbFNhdmUiLCJhZGRQcm92aWRlciIsIm9ic2VydmVUZXh0RWRpdG9ycyIsImRpc3Bvc2FibGVzIiwiYWRkIiwiYXRvbSIsIndvcmtzcGFjZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFlQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0JBO0FBQ0EsTUFBTUEsc0JBQXNCLEdBQUcsSUFBL0I7QUFDQSxNQUFNQyxtQkFFTCxHQUFHLElBQUlDLHlCQUFKLEVBRkosQyxDQUlBO0FBQ0E7O0FBQ0EsU0FBU0MsVUFBVCxDQUFvQkMsTUFBcEIsRUFBa0U7QUFDaEUsTUFBSUEsTUFBTSxDQUFDQyxPQUFQLE1BQW9CLElBQXhCLEVBQThCO0FBQzVCLFdBQU9DLDZCQUFXQyxLQUFYLEVBQVA7QUFDRDs7QUFFRCxRQUFNQyxTQUFTLEdBQUdDLEtBQUssQ0FBQ0MsSUFBTixDQUNoQlQsbUJBQW1CLENBQUNVLHdCQUFwQixDQUE2Q1AsTUFBN0MsQ0FEZ0IsQ0FBbEIsQ0FMZ0UsQ0FRaEU7QUFDQTs7QUFDQSxTQUFPRSw2QkFBV00sTUFBWCxDQUNMLEdBQUdKLFNBQVMsQ0FBQ0ssR0FBVixDQUFlQyxRQUFELElBQ2ZBLFFBQVEsQ0FDTEMsUUFESCxDQUNZWCxNQURaLEVBRUdZLE9BRkgsR0FHR0MsSUFISCxDQUdRWCw2QkFBV1ksRUFBWCxDQUFjLEVBQWQsRUFBa0JDLEtBQWxCLENBQXdCTCxRQUFRLENBQUNNLE9BQWpDLENBSFIsRUFJR1AsR0FKSCxDQUlPUSxLQUFLLElBQUk7QUFDWixVQUFNQyxPQUFPLEdBQUcsc0NBQXVCbEIsTUFBTSxDQUFDbUIsU0FBUCxFQUF2QixFQUEyQ0YsS0FBM0MsQ0FBaEI7QUFDQSxXQUFPQyxPQUFQO0FBQ0QsR0FQSCxDQURDLENBREUsQ0FBUDtBQVlELEMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTRSxlQUFULENBQXlCcEIsTUFBekIsRUFBK0Q7QUFDN0QsUUFBTXFCLFFBQVEsR0FBR3JCLE1BQU0sQ0FBQ3NCLElBQXhCO0FBQ0EsUUFBTUMsT0FBTyxHQUFJdkIsTUFBakI7O0FBQ0F1QixFQUFBQSxPQUFPLENBQUNELElBQVIsR0FBZSxZQUFZO0FBQ3pCLFVBQU1OLE9BQU8sR0FBRyxJQUFJUSxJQUFKLEVBQWhCO0FBQ0FSLElBQUFBLE9BQU8sQ0FBQ1MsT0FBUixDQUFnQlQsT0FBTyxDQUFDVSxPQUFSLEtBQW9COUIsc0JBQXBDOztBQUNBLFFBQUk7QUFDRixZQUFNRyxVQUFVLENBQUN3QixPQUFELENBQVYsQ0FDSFAsT0FERyxDQUNLQSxPQURMLEVBRUhXLFNBRkcsRUFBTjtBQUdELEtBSkQsQ0FJRSxPQUFPQyxDQUFQLEVBQVU7QUFDVixZQUFNeEIsU0FBUyxHQUFHQyxLQUFLLENBQUNDLElBQU4sQ0FDaEJULG1CQUFtQixDQUFDVSx3QkFBcEIsQ0FBNkNnQixPQUE3QyxDQURnQixDQUFsQjtBQUdBLDRCQUFNLGlCQUFOLEVBQXlCO0FBQ3ZCTSxRQUFBQSxHQUFHLEVBQUU3QixNQUFNLENBQUNDLE9BQVAsRUFEa0I7QUFFdkJHLFFBQUFBO0FBRnVCLE9BQXpCO0FBSUQsS0FaRCxTQVlVO0FBQ1IsWUFBTWlCLFFBQVEsQ0FBQ1MsSUFBVCxDQUFjOUIsTUFBZCxDQUFOO0FBQ0Q7QUFDRixHQWxCRDs7QUFtQkEsU0FBTyxJQUFJK0IsNEJBQUosQ0FBd0IsTUFBTTtBQUNuQ1IsSUFBQUEsT0FBTyxDQUFDRCxJQUFSLEdBQWVELFFBQWY7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFTSxTQUFTVyxrQkFBVCxDQUE0QnRCLFFBQTVCLEVBQXVFO0FBQzVFLFNBQU9iLG1CQUFtQixDQUFDb0MsV0FBcEIsQ0FBZ0N2QixRQUFoQyxDQUFQO0FBQ0Q7O0FBRU0sU0FBU3dCLGtCQUFULEdBQTJDO0FBQ2hELFFBQU1DLFdBQVcsR0FBRyxJQUFJSiw0QkFBSixFQUFwQjtBQUNBSSxFQUFBQSxXQUFXLENBQUNDLEdBQVosQ0FDRUMsSUFBSSxDQUFDQyxTQUFMLENBQWVKLGtCQUFmLENBQWtDbEMsTUFBTSxJQUFJO0FBQzFDbUMsSUFBQUEsV0FBVyxDQUFDQyxHQUFaLENBQWdCaEIsZUFBZSxDQUFDcEIsTUFBRCxDQUEvQjtBQUNELEdBRkQsQ0FERjtBQUtBLFNBQU9tQyxXQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7UHJvdmlkZXJ9IGZyb20gJy4vUHJvdmlkZXJSZWdpc3RyeSc7XHJcbmltcG9ydCB0eXBlIHtUZXh0RWRpdH0gZnJvbSAnLi90ZXh0LWVkaXQnO1xyXG5cclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQge3RyYWNrfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9hbmFseXRpY3MnO1xyXG5pbXBvcnQgUHJvdmlkZXJSZWdpc3RyeSBmcm9tICcuL1Byb3ZpZGVyUmVnaXN0cnknO1xyXG5pbXBvcnQge2FwcGx5VGV4dEVkaXRzVG9CdWZmZXJ9IGZyb20gJy4vdGV4dC1lZGl0JztcclxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvVW5pdmVyc2FsRGlzcG9zYWJsZSc7XHJcblxyXG5leHBvcnQgdHlwZSBGaWxlRXZlbnRIYW5kbGVyc0NvbmZpZyA9IHt8XHJcbiAgc3VwcG9ydHNPbldpbGxTYXZlOiBib29sZWFuLFxyXG4gIG9uV2lsbFNhdmVUaW1lb3V0PzogbnVtYmVyLFxyXG4gIG9uV2lsbFNhdmVQcmlvcml0eT86IG51bWJlcixcclxufH07XHJcblxyXG50eXBlIE9uV2lsbFNhdmVQcm92aWRlciA9IFByb3ZpZGVyICYge1xyXG4gIHRpbWVvdXQ6IG51bWJlcixcclxuICBjYWxsYmFjazogKGU6IGF0b20kVGV4dEVkaXRvcikgPT4gT2JzZXJ2YWJsZTxUZXh0RWRpdD4sXHJcbn07XHJcblxyXG4vLyBUaW1lb3V0cyBpZiBwcm92aWRlcnMgZG9uJ3QgYWxsIGZpbmlzaCBpbiA1IHNlY29uZHMuXHJcbmNvbnN0IEdMT0JBTF9TQVZFX1RJTUVPVVRfTVMgPSA1MDAwO1xyXG5jb25zdCBvbldpbGxTYXZlUHJvdmlkZXJzOiBQcm92aWRlclJlZ2lzdHJ5PFxyXG4gIE9uV2lsbFNhdmVQcm92aWRlcixcclxuPiA9IG5ldyBQcm92aWRlclJlZ2lzdHJ5KCk7XHJcblxyXG4vLyBSZXR1cm5zIGFuIG9ic2VydmFibGUgb2YgYm9vbGVhbnMsIGVhY2ggb2Ygd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlXHJcbi8vIGZvcm1hdHRpbmcgdGV4dCBlZGl0cyBmcm9tIGEgZ2l2ZW4gcHJvdmlkZXIgd2FzIHN1Y2Nlc3NmdWxseSBhcHBsaWVkIG9yIG5vdC5cclxuZnVuY3Rpb24gb25XaWxsU2F2ZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gIGlmIChlZGl0b3IuZ2V0UGF0aCgpID09IG51bGwpIHtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlLmVtcHR5KCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBwcm92aWRlcnMgPSBBcnJheS5mcm9tKFxyXG4gICAgb25XaWxsU2F2ZVByb3ZpZGVycy5nZXRBbGxQcm92aWRlcnNGb3JFZGl0b3IoZWRpdG9yKSxcclxuICApO1xyXG4gIC8vIE5PVEU6IGNvbmNhdCgpIGlzIHVzZWQgaGVyZSB0byBzdWJzY3JpYmUgdG8gcHJvdmlkZXJzIHNlcXVlbnRpYWxseSBhbmRcclxuICAvLyBhcHBseSB0aGVpciB0ZXh0IGVkaXRzIGluIG9yZGVyLlxyXG4gIHJldHVybiBPYnNlcnZhYmxlLmNvbmNhdChcclxuICAgIC4uLnByb3ZpZGVycy5tYXAoKHByb3ZpZGVyOiBPbldpbGxTYXZlUHJvdmlkZXIpID0+XHJcbiAgICAgIHByb3ZpZGVyXHJcbiAgICAgICAgLmNhbGxiYWNrKGVkaXRvcilcclxuICAgICAgICAudG9BcnJheSgpXHJcbiAgICAgICAgLnJhY2UoT2JzZXJ2YWJsZS5vZihbXSkuZGVsYXkocHJvdmlkZXIudGltZW91dCkpXHJcbiAgICAgICAgLm1hcChlZGl0cyA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXBwbHlUZXh0RWRpdHNUb0J1ZmZlcihlZGl0b3IuZ2V0QnVmZmVyKCksIGVkaXRzKTtcclxuICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgICAgIH0pLFxyXG4gICAgKSxcclxuICApO1xyXG59XHJcblxyXG4vLyBIQUNLOiBpbnRlcmNlcHQgdGhlIHJlYWwgVGV4dEVkaXRvci5zYXZlIGFuZCBoYW5kbGUgaXQgb3Vyc2VsdmVzLlxyXG4vLyBBdG9tIGhhcyBubyB3YXkgb2YgaW5qZWN0aW5nIGNvbnRlbnQgaW50byB0aGUgYnVmZmVyIGFzeW5jaHJvbm91c2x5XHJcbi8vIGJlZm9yZSBhIHNhdmUgb3BlcmF0aW9uLlxyXG4vLyBJZiB3ZSB0cnkgdG8gZm9ybWF0IGFmdGVyIHRoZSBzYXZlLCBhbmQgdGhlbiBzYXZlIGFnYWluLFxyXG4vLyBpdCdzIGEgcG9vciB1c2VyIGV4cGVyaWVuY2UgKGFuZCBhbHNvIHJhY2VzIHRoZSB0ZXh0IGJ1ZmZlcidzIHJlbG9hZCkuXHJcbmZ1bmN0aW9uIHBhdGNoRWRpdG9yU2F2ZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IElEaXNwb3NhYmxlIHtcclxuICBjb25zdCByZWFsU2F2ZSA9IGVkaXRvci5zYXZlO1xyXG4gIGNvbnN0IGVkaXRvcl8gPSAoZWRpdG9yOiBhbnkpO1xyXG4gIGVkaXRvcl8uc2F2ZSA9IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgdGltZW91dC5zZXRUaW1lKHRpbWVvdXQuZ2V0VGltZSgpICsgR0xPQkFMX1NBVkVfVElNRU9VVF9NUyk7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBvbldpbGxTYXZlKGVkaXRvcl8pXHJcbiAgICAgICAgLnRpbWVvdXQodGltZW91dClcclxuICAgICAgICAudG9Qcm9taXNlKCk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVycyA9IEFycmF5LmZyb20oXHJcbiAgICAgICAgb25XaWxsU2F2ZVByb3ZpZGVycy5nZXRBbGxQcm92aWRlcnNGb3JFZGl0b3IoZWRpdG9yXyksXHJcbiAgICAgICk7XHJcbiAgICAgIHRyYWNrKCd0aW1lb3V0LW9uLXNhdmUnLCB7XHJcbiAgICAgICAgdXJpOiBlZGl0b3IuZ2V0UGF0aCgpLFxyXG4gICAgICAgIHByb3ZpZGVycyxcclxuICAgICAgfSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBhd2FpdCByZWFsU2F2ZS5jYWxsKGVkaXRvcik7XHJcbiAgICB9XHJcbiAgfTtcclxuICByZXR1cm4gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoKCkgPT4ge1xyXG4gICAgZWRpdG9yXy5zYXZlID0gcmVhbFNhdmU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlck9uV2lsbFNhdmUocHJvdmlkZXI6IE9uV2lsbFNhdmVQcm92aWRlcik6IElEaXNwb3NhYmxlIHtcclxuICByZXR1cm4gb25XaWxsU2F2ZVByb3ZpZGVycy5hZGRQcm92aWRlcihwcm92aWRlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlVGV4dEVkaXRvcnMoKTogSURpc3Bvc2FibGUge1xyXG4gIGNvbnN0IGRpc3Bvc2FibGVzID0gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoKTtcclxuICBkaXNwb3NhYmxlcy5hZGQoXHJcbiAgICBhdG9tLndvcmtzcGFjZS5vYnNlcnZlVGV4dEVkaXRvcnMoZWRpdG9yID0+IHtcclxuICAgICAgZGlzcG9zYWJsZXMuYWRkKHBhdGNoRWRpdG9yU2F2ZShlZGl0b3IpKTtcclxuICAgIH0pLFxyXG4gICk7XHJcbiAgcmV0dXJuIGRpc3Bvc2FibGVzO1xyXG59XHJcbiJdfQ==