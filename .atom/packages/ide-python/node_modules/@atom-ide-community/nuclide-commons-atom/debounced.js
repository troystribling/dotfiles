"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeActivePaneItemDebounced = observeActivePaneItemDebounced;
exports.observeActiveEditorsDebounced = observeActiveEditorsDebounced;
exports.editorChangesDebounced = editorChangesDebounced;
exports.editorScrollTopDebounced = editorScrollTopDebounced;
exports.observeTextEditorsPositions = observeTextEditorsPositions;

var _observable = require("@atom-ide-community/nuclide-commons/observable");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _event = require("@atom-ide-community/nuclide-commons/event");

var _textEditor = require("./text-editor");

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Often, we may want to respond to Atom events, but only after a buffer period
 * of no change.
 * For example, Atom provides Workspace::onDidChangeActivePaneItem, but we may
 * want to know not when the active pane item has changed, buth when it has
 * stopped changing.
 * This file provides methods to do this.
 */
const DEFAULT_PANE_DEBOUNCE_INTERVAL_MS = 100;
const DEFAULT_EDITOR_DEBOUNCE_INTERVAL_MS = 300;
const DEFAULT_POSITION_DEBOUNCE_INTERVAL_MS = 300;

function observeActivePaneItemDebounced(debounceInterval = DEFAULT_PANE_DEBOUNCE_INTERVAL_MS) {
  return (0, _event.observableFromSubscribeFunction)(callback => {
    if (atom.workspace.getCenter != null) {
      return atom.workspace.getCenter().observeActivePaneItem(callback);
    }

    return atom.workspace.observeActivePaneItem(callback);
  }).let((0, _observable.fastDebounce)(debounceInterval));
}

function observeActiveEditorsDebounced(debounceInterval = DEFAULT_PANE_DEBOUNCE_INTERVAL_MS) {
  return observeActivePaneItemDebounced(debounceInterval).map(paneItem => {
    return (0, _textEditor.isValidTextEditor)(paneItem) ? paneItem : null;
  });
}

function editorChangesDebounced(editor, debounceInterval = DEFAULT_EDITOR_DEBOUNCE_INTERVAL_MS) {
  return (0, _event.observableFromSubscribeFunction)(callback => editor.getBuffer().onDidChangeText(() => callback())) // Debounce manually rather than using editor.onDidStopChanging so that the debounce time is
  // configurable.
  .let((0, _observable.fastDebounce)(debounceInterval));
}

function editorScrollTopDebounced(editor, debounceInterval = DEFAULT_EDITOR_DEBOUNCE_INTERVAL_MS) {
  return (0, _event.observableFromSubscribeFunction)(callback => atom.views.getView(editor).onDidChangeScrollTop(callback)).let((0, _observable.fastDebounce)(debounceInterval));
}

// Yields null when the current pane is not an editor,
// otherwise yields events on each move of the primary cursor within any Editor.
function observeTextEditorsPositions(editorDebounceInterval = DEFAULT_EDITOR_DEBOUNCE_INTERVAL_MS, positionDebounceInterval = DEFAULT_POSITION_DEBOUNCE_INTERVAL_MS) {
  return observeActiveEditorsDebounced(editorDebounceInterval).switchMap(editor => {
    return editor == null ? _rxjsCompatUmdMin.Observable.of(null) : (0, _textEditor.getCursorPositions)(editor).let((0, _observable.fastDebounce)(positionDebounceInterval)).map(position => {
      (0, _assert.default)(editor != null);
      return {
        editor,
        position
      };
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vZGVib3VuY2VkLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfUEFORV9ERUJPVU5DRV9JTlRFUlZBTF9NUyIsIkRFRkFVTFRfRURJVE9SX0RFQk9VTkNFX0lOVEVSVkFMX01TIiwiREVGQVVMVF9QT1NJVElPTl9ERUJPVU5DRV9JTlRFUlZBTF9NUyIsIm9ic2VydmVBY3RpdmVQYW5lSXRlbURlYm91bmNlZCIsImRlYm91bmNlSW50ZXJ2YWwiLCJjYWxsYmFjayIsImF0b20iLCJ3b3Jrc3BhY2UiLCJnZXRDZW50ZXIiLCJvYnNlcnZlQWN0aXZlUGFuZUl0ZW0iLCJsZXQiLCJvYnNlcnZlQWN0aXZlRWRpdG9yc0RlYm91bmNlZCIsIm1hcCIsInBhbmVJdGVtIiwiZWRpdG9yQ2hhbmdlc0RlYm91bmNlZCIsImVkaXRvciIsImdldEJ1ZmZlciIsIm9uRGlkQ2hhbmdlVGV4dCIsImVkaXRvclNjcm9sbFRvcERlYm91bmNlZCIsInZpZXdzIiwiZ2V0VmlldyIsIm9uRGlkQ2hhbmdlU2Nyb2xsVG9wIiwib2JzZXJ2ZVRleHRFZGl0b3JzUG9zaXRpb25zIiwiZWRpdG9yRGVib3VuY2VJbnRlcnZhbCIsInBvc2l0aW9uRGVib3VuY2VJbnRlcnZhbCIsInN3aXRjaE1hcCIsIk9ic2VydmFibGUiLCJvZiIsInBvc2l0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQXFCQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQTFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQSxNQUFNQSxpQ0FBaUMsR0FBRyxHQUExQztBQUNBLE1BQU1DLG1DQUFtQyxHQUFHLEdBQTVDO0FBQ0EsTUFBTUMscUNBQXFDLEdBQUcsR0FBOUM7O0FBRU8sU0FBU0MsOEJBQVQsQ0FDTEMsZ0JBQXdCLEdBQUdKLGlDQUR0QixFQUVjO0FBQ25CLFNBQU8sNENBQWdDSyxRQUFRLElBQUk7QUFDakQsUUFBSUMsSUFBSSxDQUFDQyxTQUFMLENBQWVDLFNBQWYsSUFBNEIsSUFBaEMsRUFBc0M7QUFDcEMsYUFBT0YsSUFBSSxDQUFDQyxTQUFMLENBQWVDLFNBQWYsR0FBMkJDLHFCQUEzQixDQUFpREosUUFBakQsQ0FBUDtBQUNEOztBQUNELFdBQU9DLElBQUksQ0FBQ0MsU0FBTCxDQUFlRSxxQkFBZixDQUFxQ0osUUFBckMsQ0FBUDtBQUNELEdBTE0sRUFLSkssR0FMSSxDQUtBLDhCQUFhTixnQkFBYixDQUxBLENBQVA7QUFNRDs7QUFFTSxTQUFTTyw2QkFBVCxDQUNMUCxnQkFBd0IsR0FBR0osaUNBRHRCLEVBRXlCO0FBQzlCLFNBQU9HLDhCQUE4QixDQUFDQyxnQkFBRCxDQUE5QixDQUFpRFEsR0FBakQsQ0FBcURDLFFBQVEsSUFBSTtBQUN0RSxXQUFPLG1DQUFrQkEsUUFBbEIsSUFBOEJBLFFBQTlCLEdBQXlDLElBQWhEO0FBQ0QsR0FGTSxDQUFQO0FBR0Q7O0FBRU0sU0FBU0Msc0JBQVQsQ0FDTEMsTUFESyxFQUVMWCxnQkFBd0IsR0FBR0gsbUNBRnRCLEVBR2E7QUFDbEIsU0FDRSw0Q0FBZ0NJLFFBQVEsSUFDdENVLE1BQU0sQ0FBQ0MsU0FBUCxHQUFtQkMsZUFBbkIsQ0FBbUMsTUFBTVosUUFBUSxFQUFqRCxDQURGLEVBR0U7QUFDQTtBQUpGLEdBS0dLLEdBTEgsQ0FLTyw4QkFBYU4sZ0JBQWIsQ0FMUCxDQURGO0FBUUQ7O0FBRU0sU0FBU2Msd0JBQVQsQ0FDTEgsTUFESyxFQUVMWCxnQkFBd0IsR0FBR0gsbUNBRnRCLEVBR2U7QUFDcEIsU0FBTyw0Q0FBZ0NJLFFBQVEsSUFDN0NDLElBQUksQ0FBQ2EsS0FBTCxDQUFXQyxPQUFYLENBQW1CTCxNQUFuQixFQUEyQk0sb0JBQTNCLENBQWdEaEIsUUFBaEQsQ0FESyxFQUVMSyxHQUZLLENBRUQsOEJBQWFOLGdCQUFiLENBRkMsQ0FBUDtBQUdEOztBQU9EO0FBQ0E7QUFDTyxTQUFTa0IsMkJBQVQsQ0FDTEMsc0JBQThCLEdBQUd0QixtQ0FENUIsRUFFTHVCLHdCQUFnQyxHQUFHdEIscUNBRjlCLEVBR3dCO0FBQzdCLFNBQU9TLDZCQUE2QixDQUFDWSxzQkFBRCxDQUE3QixDQUFzREUsU0FBdEQsQ0FDTFYsTUFBTSxJQUFJO0FBQ1IsV0FBT0EsTUFBTSxJQUFJLElBQVYsR0FDSFcsNkJBQVdDLEVBQVgsQ0FBYyxJQUFkLENBREcsR0FFSCxvQ0FBbUJaLE1BQW5CLEVBQ0dMLEdBREgsQ0FDTyw4QkFBYWMsd0JBQWIsQ0FEUCxFQUVHWixHQUZILENBRU9nQixRQUFRLElBQUk7QUFDZiwyQkFBVWIsTUFBTSxJQUFJLElBQXBCO0FBQ0EsYUFBTztBQUFDQSxRQUFBQSxNQUFEO0FBQVNhLFFBQUFBO0FBQVQsT0FBUDtBQUNELEtBTEgsQ0FGSjtBQVFELEdBVkksQ0FBUDtBQVlEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE9mdGVuLCB3ZSBtYXkgd2FudCB0byByZXNwb25kIHRvIEF0b20gZXZlbnRzLCBidXQgb25seSBhZnRlciBhIGJ1ZmZlciBwZXJpb2RcclxuICogb2Ygbm8gY2hhbmdlLlxyXG4gKiBGb3IgZXhhbXBsZSwgQXRvbSBwcm92aWRlcyBXb3Jrc3BhY2U6Om9uRGlkQ2hhbmdlQWN0aXZlUGFuZUl0ZW0sIGJ1dCB3ZSBtYXlcclxuICogd2FudCB0byBrbm93IG5vdCB3aGVuIHRoZSBhY3RpdmUgcGFuZSBpdGVtIGhhcyBjaGFuZ2VkLCBidXRoIHdoZW4gaXQgaGFzXHJcbiAqIHN0b3BwZWQgY2hhbmdpbmcuXHJcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBtZXRob2RzIHRvIGRvIHRoaXMuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtmYXN0RGVib3VuY2V9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL29ic2VydmFibGUnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcblxyXG5pbXBvcnQge29ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb259IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2V2ZW50JztcclxuaW1wb3J0IHtnZXRDdXJzb3JQb3NpdGlvbnMsIGlzVmFsaWRUZXh0RWRpdG9yfSBmcm9tICcuL3RleHQtZWRpdG9yJztcclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5cclxuY29uc3QgREVGQVVMVF9QQU5FX0RFQk9VTkNFX0lOVEVSVkFMX01TID0gMTAwO1xyXG5jb25zdCBERUZBVUxUX0VESVRPUl9ERUJPVU5DRV9JTlRFUlZBTF9NUyA9IDMwMDtcclxuY29uc3QgREVGQVVMVF9QT1NJVElPTl9ERUJPVU5DRV9JTlRFUlZBTF9NUyA9IDMwMDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlQWN0aXZlUGFuZUl0ZW1EZWJvdW5jZWQoXHJcbiAgZGVib3VuY2VJbnRlcnZhbDogbnVtYmVyID0gREVGQVVMVF9QQU5FX0RFQk9VTkNFX0lOVEVSVkFMX01TLFxyXG4pOiBPYnNlcnZhYmxlPG1peGVkPiB7XHJcbiAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oY2FsbGJhY2sgPT4ge1xyXG4gICAgaWYgKGF0b20ud29ya3NwYWNlLmdldENlbnRlciAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBhdG9tLndvcmtzcGFjZS5nZXRDZW50ZXIoKS5vYnNlcnZlQWN0aXZlUGFuZUl0ZW0oY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGF0b20ud29ya3NwYWNlLm9ic2VydmVBY3RpdmVQYW5lSXRlbShjYWxsYmFjayk7XHJcbiAgfSkubGV0KGZhc3REZWJvdW5jZShkZWJvdW5jZUludGVydmFsKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlQWN0aXZlRWRpdG9yc0RlYm91bmNlZChcclxuICBkZWJvdW5jZUludGVydmFsOiBudW1iZXIgPSBERUZBVUxUX1BBTkVfREVCT1VOQ0VfSU5URVJWQUxfTVMsXHJcbik6IE9ic2VydmFibGU8P2F0b20kVGV4dEVkaXRvcj4ge1xyXG4gIHJldHVybiBvYnNlcnZlQWN0aXZlUGFuZUl0ZW1EZWJvdW5jZWQoZGVib3VuY2VJbnRlcnZhbCkubWFwKHBhbmVJdGVtID0+IHtcclxuICAgIHJldHVybiBpc1ZhbGlkVGV4dEVkaXRvcihwYW5lSXRlbSkgPyBwYW5lSXRlbSA6IG51bGw7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlZGl0b3JDaGFuZ2VzRGVib3VuY2VkKFxyXG4gIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gIGRlYm91bmNlSW50ZXJ2YWw6IG51bWJlciA9IERFRkFVTFRfRURJVE9SX0RFQk9VTkNFX0lOVEVSVkFMX01TLFxyXG4pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICByZXR1cm4gKFxyXG4gICAgb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihjYWxsYmFjayA9PlxyXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkub25EaWRDaGFuZ2VUZXh0KCgpID0+IGNhbGxiYWNrKCkpLFxyXG4gICAgKVxyXG4gICAgICAvLyBEZWJvdW5jZSBtYW51YWxseSByYXRoZXIgdGhhbiB1c2luZyBlZGl0b3Iub25EaWRTdG9wQ2hhbmdpbmcgc28gdGhhdCB0aGUgZGVib3VuY2UgdGltZSBpc1xyXG4gICAgICAvLyBjb25maWd1cmFibGUuXHJcbiAgICAgIC5sZXQoZmFzdERlYm91bmNlKGRlYm91bmNlSW50ZXJ2YWwpKVxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlZGl0b3JTY3JvbGxUb3BEZWJvdW5jZWQoXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgZGVib3VuY2VJbnRlcnZhbDogbnVtYmVyID0gREVGQVVMVF9FRElUT1JfREVCT1VOQ0VfSU5URVJWQUxfTVMsXHJcbik6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oY2FsbGJhY2sgPT5cclxuICAgIGF0b20udmlld3MuZ2V0VmlldyhlZGl0b3IpLm9uRGlkQ2hhbmdlU2Nyb2xsVG9wKGNhbGxiYWNrKSxcclxuICApLmxldChmYXN0RGVib3VuY2UoZGVib3VuY2VJbnRlcnZhbCkpO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBFZGl0b3JQb3NpdGlvbiA9IHtcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICBwb3NpdGlvbjogYXRvbSRQb2ludCxcclxufTtcclxuXHJcbi8vIFlpZWxkcyBudWxsIHdoZW4gdGhlIGN1cnJlbnQgcGFuZSBpcyBub3QgYW4gZWRpdG9yLFxyXG4vLyBvdGhlcndpc2UgeWllbGRzIGV2ZW50cyBvbiBlYWNoIG1vdmUgb2YgdGhlIHByaW1hcnkgY3Vyc29yIHdpdGhpbiBhbnkgRWRpdG9yLlxyXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZVRleHRFZGl0b3JzUG9zaXRpb25zKFxyXG4gIGVkaXRvckRlYm91bmNlSW50ZXJ2YWw6IG51bWJlciA9IERFRkFVTFRfRURJVE9SX0RFQk9VTkNFX0lOVEVSVkFMX01TLFxyXG4gIHBvc2l0aW9uRGVib3VuY2VJbnRlcnZhbDogbnVtYmVyID0gREVGQVVMVF9QT1NJVElPTl9ERUJPVU5DRV9JTlRFUlZBTF9NUyxcclxuKTogT2JzZXJ2YWJsZTw/RWRpdG9yUG9zaXRpb24+IHtcclxuICByZXR1cm4gb2JzZXJ2ZUFjdGl2ZUVkaXRvcnNEZWJvdW5jZWQoZWRpdG9yRGVib3VuY2VJbnRlcnZhbCkuc3dpdGNoTWFwKFxyXG4gICAgZWRpdG9yID0+IHtcclxuICAgICAgcmV0dXJuIGVkaXRvciA9PSBudWxsXHJcbiAgICAgICAgPyBPYnNlcnZhYmxlLm9mKG51bGwpXHJcbiAgICAgICAgOiBnZXRDdXJzb3JQb3NpdGlvbnMoZWRpdG9yKVxyXG4gICAgICAgICAgICAubGV0KGZhc3REZWJvdW5jZShwb3NpdGlvbkRlYm91bmNlSW50ZXJ2YWwpKVxyXG4gICAgICAgICAgICAubWFwKHBvc2l0aW9uID0+IHtcclxuICAgICAgICAgICAgICBpbnZhcmlhbnQoZWRpdG9yICE9IG51bGwpO1xyXG4gICAgICAgICAgICAgIHJldHVybiB7ZWRpdG9yLCBwb3NpdGlvbn07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxuICApO1xyXG59XHJcbiJdfQ==