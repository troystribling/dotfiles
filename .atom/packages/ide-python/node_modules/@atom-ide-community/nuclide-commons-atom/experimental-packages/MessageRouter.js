"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _log4js = require("log4js");

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var jsonrpc = _interopRequireWildcard(require("vscode-jsonrpc"));

var _messageReader = require("vscode-jsonrpc/lib/messageReader");

var _messageWriter = require("vscode-jsonrpc/lib/messageWriter");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * In the new package model, communication between packages will be modeled as sockets.
 * For each producer <-> consumer pair, we will create a socket:
 * the consumer gets one end of the socket, while the producer gets the other end.
 */
class MessageRouter {
  constructor() {
    this._curSocketID = 1;
    this._sockets = new Map();
    this._buffer = new _collection.DefaultMap(Array);
  }

  /**
   * Returns a pair of sockets.
   */
  getSocket() {
    const socket = [this._curSocketID, -this._curSocketID];
    this._curSocketID++;
    return socket;
  }

  reverseSocket(socket) {
    return -socket;
  }

  send(message) {
    const {
      socket
    } = message;

    const subject = this._sockets.get(socket);

    if (subject == null) {
      this._buffer.get(socket).push(message);
    } else {
      subject.next(message);
    }
  }

  getMessages(socket) {
    let subject = this._sockets.get(socket);

    if (subject == null) {
      subject = new _rxjsCompatUmdMin.Subject();

      this._sockets.set(socket, subject);

      const buffered = this._buffer.get(socket);

      this._buffer.delete(socket);

      return _rxjsCompatUmdMin.Observable.from(buffered).concat(subject);
    }

    return subject;
  }

  createConnection(socket, config) {
    const connection = jsonrpc.createMessageConnection( // Messages intended for socket actually come through -socket.
    new SimpleReader(cb => this.getMessages(this.reverseSocket(socket)).subscribe(cb)), // Tag each message with the socket it originated from.
    new SimpleWriter(msg => this.send({ ...msg,
      socket
    })), (0, _log4js.getLogger)('ExperimentalMessageRouter-jsonrpc'));
    connection.config = config || {};
    connection.listen();
    return connection;
  }

}

exports.default = MessageRouter;

class SimpleReader extends _messageReader.AbstractMessageReader {
  constructor(subscribe) {
    super();
    this._subscribe = void 0;
    this._subscribe = subscribe;
  }

  listen(callback) {
    this._subscribe(callback);
  }

}

class SimpleWriter extends _messageWriter.AbstractMessageWriter {
  constructor(write) {
    super();
    this._write = void 0;
    this._write = write;
  }

  write(message) {
    this._write(message);
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vZXhwZXJpbWVudGFsLXBhY2thZ2VzL01lc3NhZ2VSb3V0ZXIuanMiXSwibmFtZXMiOlsiTWVzc2FnZVJvdXRlciIsIl9jdXJTb2NrZXRJRCIsIl9zb2NrZXRzIiwiTWFwIiwiX2J1ZmZlciIsIkRlZmF1bHRNYXAiLCJBcnJheSIsImdldFNvY2tldCIsInNvY2tldCIsInJldmVyc2VTb2NrZXQiLCJzZW5kIiwibWVzc2FnZSIsInN1YmplY3QiLCJnZXQiLCJwdXNoIiwibmV4dCIsImdldE1lc3NhZ2VzIiwiU3ViamVjdCIsInNldCIsImJ1ZmZlcmVkIiwiZGVsZXRlIiwiT2JzZXJ2YWJsZSIsImZyb20iLCJjb25jYXQiLCJjcmVhdGVDb25uZWN0aW9uIiwiY29uZmlnIiwiY29ubmVjdGlvbiIsImpzb25ycGMiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIlNpbXBsZVJlYWRlciIsImNiIiwic3Vic2NyaWJlIiwiU2ltcGxlV3JpdGVyIiwibXNnIiwibGlzdGVuIiwiQWJzdHJhY3RNZXNzYWdlUmVhZGVyIiwiY29uc3RydWN0b3IiLCJfc3Vic2NyaWJlIiwiY2FsbGJhY2siLCJBYnN0cmFjdE1lc3NhZ2VXcml0ZXIiLCJ3cml0ZSIsIl93cml0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU1BLGFBQU4sQ0FBb0I7QUFBQTtBQUFBLFNBQ2pDQyxZQURpQyxHQUNsQixDQURrQjtBQUFBLFNBRWpDQyxRQUZpQyxHQUVjLElBQUlDLEdBQUosRUFGZDtBQUFBLFNBTWpDQyxPQU5pQyxHQU1rQixJQUFJQyxzQkFBSixDQUFlQyxLQUFmLENBTmxCO0FBQUE7O0FBUWpD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O0FBQ0Q7O0FBVjhDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge1BpcGVkTWVzc2FnZSwgU2VydmljZUNvbm5lY3Rpb259IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtnZXRMb2dnZXJ9IGZyb20gJ2xvZzRqcyc7XHJcbmltcG9ydCB7RGVmYXVsdE1hcH0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvY29sbGVjdGlvbic7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3ViamVjdH0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0ICogYXMganNvbnJwYyBmcm9tICd2c2NvZGUtanNvbnJwYyc7XHJcbmltcG9ydCB7QWJzdHJhY3RNZXNzYWdlUmVhZGVyfSBmcm9tICd2c2NvZGUtanNvbnJwYy9saWIvbWVzc2FnZVJlYWRlcic7XHJcbmltcG9ydCB7QWJzdHJhY3RNZXNzYWdlV3JpdGVyfSBmcm9tICd2c2NvZGUtanNvbnJwYy9saWIvbWVzc2FnZVdyaXRlcic7XHJcblxyXG4vLyBXZSdsbCByZXByZXNlbnQgc29ja2V0cyBpbiBwYWlycyAobnVtYmVycyBhbmQgdGhlaXIgbmVnYXRpdmVzKS5cclxuLy8gQWZ0ZXIgd3JpdGluZyB0byBhIHNvY2tldCwgdGhlIG1lc3NhZ2UgbWF5IGJlIHJlYWQgdGhyb3VnaCBpdHMgbmVnYXRpdmUuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5leHBvcnQgb3BhcXVlIHR5cGUgU29ja2V0ID0gbnVtYmVyO1xyXG5cclxudHlwZSBEYXRhQ2FsbGJhY2sgPSAoZGF0YTogUGlwZWRNZXNzYWdlKSA9PiBtaXhlZDtcclxuXHJcbi8qKlxyXG4gKiBJbiB0aGUgbmV3IHBhY2thZ2UgbW9kZWwsIGNvbW11bmljYXRpb24gYmV0d2VlbiBwYWNrYWdlcyB3aWxsIGJlIG1vZGVsZWQgYXMgc29ja2V0cy5cclxuICogRm9yIGVhY2ggcHJvZHVjZXIgPC0+IGNvbnN1bWVyIHBhaXIsIHdlIHdpbGwgY3JlYXRlIGEgc29ja2V0OlxyXG4gKiB0aGUgY29uc3VtZXIgZ2V0cyBvbmUgZW5kIG9mIHRoZSBzb2NrZXQsIHdoaWxlIHRoZSBwcm9kdWNlciBnZXRzIHRoZSBvdGhlciBlbmQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZXNzYWdlUm91dGVyIHtcclxuICBfY3VyU29ja2V0SUQgPSAxO1xyXG4gIF9zb2NrZXRzOiBNYXA8U29ja2V0LCBTdWJqZWN0PFBpcGVkTWVzc2FnZT4+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAvLyBJZiBtZXNzYWdlcyBhcmUgc2VudCB0byBhIHNvY2tldCBiZWZvcmUgYSBsaXN0ZW5lciBnZXRzIGF0dGFjaGVkLFxyXG4gIC8vIGJ1ZmZlciBpdCB1cCBoZXJlLiBUaGUgYnVmZmVyIHdpbGwgYmUgY2xlYXJlZCBhZnRlciB0aGUgZmlyc3QgZ2V0TWVzc2FnZXMgY2FsbC5cclxuICBfYnVmZmVyOiBEZWZhdWx0TWFwPFNvY2tldCwgQXJyYXk8UGlwZWRNZXNzYWdlPj4gPSBuZXcgRGVmYXVsdE1hcChBcnJheSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBwYWlyIG9mIHNvY2tldHMuXHJcbiAgICovXHJcbiAgZ2V0U29ja2V0KCk6IFtTb2NrZXQsIFNvY2tldF0ge1xyXG4gICAgY29uc3Qgc29ja2V0ID0gW3RoaXMuX2N1clNvY2tldElELCAtdGhpcy5fY3VyU29ja2V0SURdO1xyXG4gICAgdGhpcy5fY3VyU29ja2V0SUQrKztcclxuICAgIHJldHVybiBzb2NrZXQ7XHJcbiAgfVxyXG5cclxuICByZXZlcnNlU29ja2V0KHNvY2tldDogU29ja2V0KTogU29ja2V0IHtcclxuICAgIHJldHVybiAtc29ja2V0O1xyXG4gIH1cclxuXHJcbiAgc2VuZChtZXNzYWdlOiBQaXBlZE1lc3NhZ2UpOiB2b2lkIHtcclxuICAgIGNvbnN0IHtzb2NrZXR9ID0gbWVzc2FnZTtcclxuICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLl9zb2NrZXRzLmdldChzb2NrZXQpO1xyXG4gICAgaWYgKHN1YmplY3QgPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9idWZmZXIuZ2V0KHNvY2tldCkucHVzaChtZXNzYWdlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN1YmplY3QubmV4dChtZXNzYWdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldE1lc3NhZ2VzKHNvY2tldDogU29ja2V0KTogT2JzZXJ2YWJsZTxQaXBlZE1lc3NhZ2U+IHtcclxuICAgIGxldCBzdWJqZWN0ID0gdGhpcy5fc29ja2V0cy5nZXQoc29ja2V0KTtcclxuICAgIGlmIChzdWJqZWN0ID09IG51bGwpIHtcclxuICAgICAgc3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgIHRoaXMuX3NvY2tldHMuc2V0KHNvY2tldCwgc3ViamVjdCk7XHJcbiAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy5fYnVmZmVyLmdldChzb2NrZXQpO1xyXG4gICAgICB0aGlzLl9idWZmZXIuZGVsZXRlKHNvY2tldCk7XHJcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb20oYnVmZmVyZWQpLmNvbmNhdChzdWJqZWN0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdWJqZWN0O1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlQ29ubmVjdGlvbihzb2NrZXQ6IFNvY2tldCwgY29uZmlnOiA/T2JqZWN0KTogU2VydmljZUNvbm5lY3Rpb24ge1xyXG4gICAgY29uc3QgY29ubmVjdGlvbjogU2VydmljZUNvbm5lY3Rpb24gPSAoanNvbnJwYy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihcclxuICAgICAgLy8gTWVzc2FnZXMgaW50ZW5kZWQgZm9yIHNvY2tldCBhY3R1YWxseSBjb21lIHRocm91Z2ggLXNvY2tldC5cclxuICAgICAgbmV3IFNpbXBsZVJlYWRlcihjYiA9PlxyXG4gICAgICAgIHRoaXMuZ2V0TWVzc2FnZXModGhpcy5yZXZlcnNlU29ja2V0KHNvY2tldCkpLnN1YnNjcmliZShjYiksXHJcbiAgICAgICksXHJcbiAgICAgIC8vIFRhZyBlYWNoIG1lc3NhZ2Ugd2l0aCB0aGUgc29ja2V0IGl0IG9yaWdpbmF0ZWQgZnJvbS5cclxuICAgICAgbmV3IFNpbXBsZVdyaXRlcihtc2cgPT4gdGhpcy5zZW5kKHsuLi5tc2csIHNvY2tldH0pKSxcclxuICAgICAgZ2V0TG9nZ2VyKCdFeHBlcmltZW50YWxNZXNzYWdlUm91dGVyLWpzb25ycGMnKSxcclxuICAgICk6IGFueSk7XHJcbiAgICBjb25uZWN0aW9uLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuICAgIGNvbm5lY3Rpb24ubGlzdGVuKCk7XHJcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcclxuICB9XHJcbn1cclxuXHJcbmNsYXNzIFNpbXBsZVJlYWRlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVJlYWRlciB7XHJcbiAgX3N1YnNjcmliZTogKGNhbGxiYWNrOiBEYXRhQ2FsbGJhY2spID0+IG1peGVkO1xyXG5cclxuICBjb25zdHJ1Y3RvcihzdWJzY3JpYmU6IChjYWxsYmFjazogRGF0YUNhbGxiYWNrKSA9PiBtaXhlZCk6IHZvaWQge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcclxuICB9XHJcblxyXG4gIGxpc3RlbihjYWxsYmFjazogKGRhdGE6IFBpcGVkTWVzc2FnZSkgPT4gbWl4ZWQpOiB2b2lkIHtcclxuICAgIHRoaXMuX3N1YnNjcmliZShjYWxsYmFjayk7XHJcbiAgfVxyXG59XHJcblxyXG5jbGFzcyBTaW1wbGVXcml0ZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xyXG4gIF93cml0ZTogKG1lc3NhZ2U6IFBpcGVkTWVzc2FnZSkgPT4gbWl4ZWQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHdyaXRlOiAobWVzc2FnZTogUGlwZWRNZXNzYWdlKSA9PiBtaXhlZCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX3dyaXRlID0gd3JpdGU7XHJcbiAgfVxyXG5cclxuICB3cml0ZShtZXNzYWdlOiBQaXBlZE1lc3NhZ2UpOiB2b2lkIHtcclxuICAgIHRoaXMuX3dyaXRlKG1lc3NhZ2UpO1xyXG4gIH1cclxufVxyXG4iXX0=