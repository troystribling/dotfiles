"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AtomPackageRunner = exports.ProcessPackageRunner = void 0;

var _process = require("@atom-ide-community/nuclide-commons/process");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _MessageRouter = _interopRequireDefault(require("./MessageRouter"));

var _activatePackage = _interopRequireDefault(require("./activatePackage"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
class ProcessPackageRunner {
  // $FlowFixMe (>=0.85.0) (T35986896) Flow upgrade suppress
  constructor(packages, messageRouter) {
    this._processStream = void 0;
    this._outputStream = void 0;
    this._disposed = new _rxjsCompatUmdMin.ReplaySubject(1);
    this._processStream = (0, _process.fork)(require.resolve('./run-package-entry.js'), [], {
      silent: true
    }).takeUntil(this._disposed).do(proc => {
      proc.on('message', msg => {
        messageRouter.send(msg);
      });
      const exposedSockets = getExposedSockets(packages, messageRouter);
      proc.send({
        packages,
        exposedSockets
      });
      exposedSockets.forEach(socket => {
        // Intercept incoming messages for each exposed socket.
        messageRouter.getMessages(messageRouter.reverseSocket(socket)).takeUntil(this._disposed).subscribe(msg => proc.send(msg));
      });
    }) // TODO: Error on early completion.
    .share().publishReplay(1); // Note: this won't start emitting anything activate() gets called.

    this._outputStream = this._processStream.switchMap(proc => (0, _process.getOutputStream)(proc)).publish();
  }

  activate() {
    this._processStream.connect();
  }

  onDidError(callback) {
    return new _UniversalDisposable.default(this._outputStream.refCount().subscribe({
      error: err => {
        callback(err);
      }
    }));
  }

  dispose() {
    this._disposed.next();
  }

} // Atom packages have to run in the same process.


exports.ProcessPackageRunner = ProcessPackageRunner;

class AtomPackageRunner {
  constructor(packages, messageRouter) {
    this._packages = void 0;
    this._messageRouter = void 0;
    this._disposables = void 0;
    this._packages = packages;
    this._messageRouter = messageRouter;
    this._disposables = new _UniversalDisposable.default();
  }

  activate() {
    this._disposables.add(...this._packages.map(params => {
      const pkg = (0, _activatePackage.default)(params, this._messageRouter);
      return () => {
        if (pkg.dispose != null) {
          pkg.dispose();
        }
      };
    }));
  }

  dispose() {
    this._disposables.dispose();
  }

  onDidError(callback) {
    return new _UniversalDisposable.default();
  }

}

exports.AtomPackageRunner = AtomPackageRunner;

function getExposedSockets(packages, messageRouter) {
  // Exposed sockets are those that are either:
  // 1) provided here but not consumed
  // 2) consumed here but not provided.
  const allSockets = new Set();
  packages.forEach(pkg => {
    Object.keys(pkg.consumedServices).forEach(key => {
      const {
        socket
      } = pkg.consumedServices[key];
      allSockets.add(socket);
    });
    Object.keys(pkg.providedServices).forEach(key => {
      pkg.providedServices[key].rawConnections.forEach(({
        socket
      }) => {
        allSockets.add(socket);
      });
    });
  });
  return Array.from(allSockets).filter(socket => !allSockets.has(messageRouter.reverseSocket(socket)));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vZXhwZXJpbWVudGFsLXBhY2thZ2VzL1BhY2thZ2VSdW5uZXJzLmpzIl0sIm5hbWVzIjpbIlByb2Nlc3NQYWNrYWdlUnVubmVyIiwiY29uc3RydWN0b3IiLCJwYWNrYWdlcyIsIm1lc3NhZ2VSb3V0ZXIiLCJfcHJvY2Vzc1N0cmVhbSIsIl9vdXRwdXRTdHJlYW0iLCJfZGlzcG9zZWQiLCJSZXBsYXlTdWJqZWN0IiwicmVxdWlyZSIsInJlc29sdmUiLCJzaWxlbnQiLCJ0YWtlVW50aWwiLCJkbyIsInByb2MiLCJvbiIsIm1zZyIsInNlbmQiLCJleHBvc2VkU29ja2V0cyIsImdldEV4cG9zZWRTb2NrZXRzIiwiZm9yRWFjaCIsInNvY2tldCIsImdldE1lc3NhZ2VzIiwicmV2ZXJzZVNvY2tldCIsInN1YnNjcmliZSIsInNoYXJlIiwicHVibGlzaFJlcGxheSIsInN3aXRjaE1hcCIsInB1Ymxpc2giLCJhY3RpdmF0ZSIsImNvbm5lY3QiLCJvbkRpZEVycm9yIiwiY2FsbGJhY2siLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwicmVmQ291bnQiLCJlcnJvciIsImVyciIsImRpc3Bvc2UiLCJuZXh0IiwiQXRvbVBhY2thZ2VSdW5uZXIiLCJfcGFja2FnZXMiLCJfbWVzc2FnZVJvdXRlciIsIl9kaXNwb3NhYmxlcyIsImFkZCIsIm1hcCIsInBhcmFtcyIsInBrZyIsImFsbFNvY2tldHMiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwiY29uc3VtZWRTZXJ2aWNlcyIsImtleSIsInByb3ZpZGVkU2VydmljZXMiLCJyYXdDb25uZWN0aW9ucyIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsImhhcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQXFCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQXpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaUJPLE1BQU1B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QUE0QkYsTUFBNUIsQ0FBZixDQUROLENBQVA7QUFHRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtQcm9jZXNzTWVzc2FnZX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvcHJvY2Vzcyc7XHJcbmltcG9ydCB0eXBlIHtDb25uZWN0YWJsZU9ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCB0eXBlIHtcclxuICBJbml0aWFsaXplTWVzc2FnZSxcclxuICBQYWNrYWdlUGFyYW1zLFxyXG4gIFBhY2thZ2VSdW5uZXIsXHJcbiAgU29ja2V0LFxyXG59IGZyb20gJy4vdHlwZXMnO1xyXG5cclxuaW1wb3J0IHtmb3JrLCBnZXRPdXRwdXRTdHJlYW19IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL3Byb2Nlc3MnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IHtSZXBsYXlTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgTWVzc2FnZVJvdXRlciBmcm9tICcuL01lc3NhZ2VSb3V0ZXInO1xyXG5pbXBvcnQgYWN0aXZhdGVQYWNrYWdlIGZyb20gJy4vYWN0aXZhdGVQYWNrYWdlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9jZXNzUGFja2FnZVJ1bm5lciBpbXBsZW1lbnRzIFBhY2thZ2VSdW5uZXIge1xyXG4gIF9wcm9jZXNzU3RyZWFtOiBDb25uZWN0YWJsZU9ic2VydmFibGU8Y2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M+O1xyXG4gIF9vdXRwdXRTdHJlYW06IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxQcm9jZXNzTWVzc2FnZT47XHJcbiAgLy8gJEZsb3dGaXhNZSAoPj0wLjg1LjApIChUMzU5ODY4OTYpIEZsb3cgdXBncmFkZSBzdXBwcmVzc1xyXG4gIF9kaXNwb3NlZCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHBhY2thZ2VzOiBBcnJheTxQYWNrYWdlUGFyYW1zPixcclxuICAgIG1lc3NhZ2VSb3V0ZXI6IE1lc3NhZ2VSb3V0ZXIsXHJcbiAgKTogdm9pZCB7XHJcbiAgICB0aGlzLl9wcm9jZXNzU3RyZWFtID0gZm9yayhyZXF1aXJlLnJlc29sdmUoJy4vcnVuLXBhY2thZ2UtZW50cnkuanMnKSwgW10sIHtcclxuICAgICAgc2lsZW50OiB0cnVlLFxyXG4gICAgfSlcclxuICAgICAgLnRha2VVbnRpbCh0aGlzLl9kaXNwb3NlZClcclxuICAgICAgLmRvKHByb2MgPT4ge1xyXG4gICAgICAgIHByb2Mub24oJ21lc3NhZ2UnLCBtc2cgPT4ge1xyXG4gICAgICAgICAgbWVzc2FnZVJvdXRlci5zZW5kKG1zZyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgZXhwb3NlZFNvY2tldHMgPSBnZXRFeHBvc2VkU29ja2V0cyhwYWNrYWdlcywgbWVzc2FnZVJvdXRlcik7XHJcbiAgICAgICAgcHJvYy5zZW5kKCh7cGFja2FnZXMsIGV4cG9zZWRTb2NrZXRzfTogSW5pdGlhbGl6ZU1lc3NhZ2UpKTtcclxuICAgICAgICBleHBvc2VkU29ja2V0cy5mb3JFYWNoKHNvY2tldCA9PiB7XHJcbiAgICAgICAgICAvLyBJbnRlcmNlcHQgaW5jb21pbmcgbWVzc2FnZXMgZm9yIGVhY2ggZXhwb3NlZCBzb2NrZXQuXHJcbiAgICAgICAgICBtZXNzYWdlUm91dGVyXHJcbiAgICAgICAgICAgIC5nZXRNZXNzYWdlcyhtZXNzYWdlUm91dGVyLnJldmVyc2VTb2NrZXQoc29ja2V0KSlcclxuICAgICAgICAgICAgLnRha2VVbnRpbCh0aGlzLl9kaXNwb3NlZClcclxuICAgICAgICAgICAgLnN1YnNjcmliZShtc2cgPT4gcHJvYy5zZW5kKG1zZykpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAvLyBUT0RPOiBFcnJvciBvbiBlYXJseSBjb21wbGV0aW9uLlxyXG4gICAgICAuc2hhcmUoKVxyXG4gICAgICAucHVibGlzaFJlcGxheSgxKTtcclxuXHJcbiAgICAvLyBOb3RlOiB0aGlzIHdvbid0IHN0YXJ0IGVtaXR0aW5nIGFueXRoaW5nIGFjdGl2YXRlKCkgZ2V0cyBjYWxsZWQuXHJcbiAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSB0aGlzLl9wcm9jZXNzU3RyZWFtXHJcbiAgICAgIC5zd2l0Y2hNYXAocHJvYyA9PiBnZXRPdXRwdXRTdHJlYW0ocHJvYykpXHJcbiAgICAgIC5wdWJsaXNoKCk7XHJcbiAgfVxyXG5cclxuICBhY3RpdmF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3Byb2Nlc3NTdHJlYW0uY29ubmVjdCgpO1xyXG4gIH1cclxuXHJcbiAgb25EaWRFcnJvcihjYWxsYmFjazogKGVycm9yOiBFcnJvcikgPT4gbWl4ZWQpOiBJRGlzcG9zYWJsZSB7XHJcbiAgICByZXR1cm4gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoXHJcbiAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5yZWZDb3VudCgpLnN1YnNjcmliZSh7XHJcbiAgICAgICAgZXJyb3I6IGVyciA9PiB7XHJcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXNwb3NlZC5uZXh0KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBdG9tIHBhY2thZ2VzIGhhdmUgdG8gcnVuIGluIHRoZSBzYW1lIHByb2Nlc3MuXHJcbmV4cG9ydCBjbGFzcyBBdG9tUGFja2FnZVJ1bm5lciBpbXBsZW1lbnRzIFBhY2thZ2VSdW5uZXIge1xyXG4gIF9wYWNrYWdlczogQXJyYXk8UGFja2FnZVBhcmFtcz47XHJcbiAgX21lc3NhZ2VSb3V0ZXI6IE1lc3NhZ2VSb3V0ZXI7XHJcbiAgX2Rpc3Bvc2FibGVzOiBVbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHBhY2thZ2VzOiBBcnJheTxQYWNrYWdlUGFyYW1zPixcclxuICAgIG1lc3NhZ2VSb3V0ZXI6IE1lc3NhZ2VSb3V0ZXIsXHJcbiAgKTogdm9pZCB7XHJcbiAgICB0aGlzLl9wYWNrYWdlcyA9IHBhY2thZ2VzO1xyXG4gICAgdGhpcy5fbWVzc2FnZVJvdXRlciA9IG1lc3NhZ2VSb3V0ZXI7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCk7XHJcbiAgfVxyXG5cclxuICBhY3RpdmF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmFkZChcclxuICAgICAgLi4udGhpcy5fcGFja2FnZXMubWFwKHBhcmFtcyA9PiB7XHJcbiAgICAgICAgY29uc3QgcGtnID0gYWN0aXZhdGVQYWNrYWdlKHBhcmFtcywgdGhpcy5fbWVzc2FnZVJvdXRlcik7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgIGlmIChwa2cuZGlzcG9zZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBrZy5kaXNwb3NlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZGlzcG9zZSgpIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIG9uRGlkRXJyb3IoY2FsbGJhY2s6IChlcnJvcjogRXJyb3IpID0+IG1peGVkKTogSURpc3Bvc2FibGUge1xyXG4gICAgcmV0dXJuIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRFeHBvc2VkU29ja2V0cyhcclxuICBwYWNrYWdlczogQXJyYXk8UGFja2FnZVBhcmFtcz4sXHJcbiAgbWVzc2FnZVJvdXRlcjogTWVzc2FnZVJvdXRlcixcclxuKTogQXJyYXk8U29ja2V0PiB7XHJcbiAgLy8gRXhwb3NlZCBzb2NrZXRzIGFyZSB0aG9zZSB0aGF0IGFyZSBlaXRoZXI6XHJcbiAgLy8gMSkgcHJvdmlkZWQgaGVyZSBidXQgbm90IGNvbnN1bWVkXHJcbiAgLy8gMikgY29uc3VtZWQgaGVyZSBidXQgbm90IHByb3ZpZGVkLlxyXG4gIGNvbnN0IGFsbFNvY2tldHMgPSBuZXcgU2V0KCk7XHJcbiAgcGFja2FnZXMuZm9yRWFjaChwa2cgPT4ge1xyXG4gICAgT2JqZWN0LmtleXMocGtnLmNvbnN1bWVkU2VydmljZXMpLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgY29uc3Qge3NvY2tldH0gPSBwa2cuY29uc3VtZWRTZXJ2aWNlc1trZXldO1xyXG4gICAgICBhbGxTb2NrZXRzLmFkZChzb2NrZXQpO1xyXG4gICAgfSk7XHJcbiAgICBPYmplY3Qua2V5cyhwa2cucHJvdmlkZWRTZXJ2aWNlcykuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAgICBwa2cucHJvdmlkZWRTZXJ2aWNlc1trZXldLnJhd0Nvbm5lY3Rpb25zLmZvckVhY2goKHtzb2NrZXR9KSA9PiB7XHJcbiAgICAgICAgYWxsU29ja2V0cy5hZGQoc29ja2V0KTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuICByZXR1cm4gQXJyYXkuZnJvbShhbGxTb2NrZXRzKS5maWx0ZXIoXHJcbiAgICBzb2NrZXQgPT4gIWFsbFNvY2tldHMuaGFzKG1lc3NhZ2VSb3V0ZXIucmV2ZXJzZVNvY2tldChzb2NrZXQpKSxcclxuICApO1xyXG59XHJcbiJdfQ==