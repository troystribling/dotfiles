"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _log4js = _interopRequireDefault(require("log4js"));

var _MessageRouter = _interopRequireDefault(require("./MessageRouter"));

var _activatePackage = _interopRequireDefault(require("./activatePackage"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// Send log4js errors to stderr for visibility from the main process.
_log4js.default.configure({
  appenders: [{
    type: 'stderr'
  }]
});

const logger = _log4js.default.getLogger('experimental-run-package');

process.on('uncaughtException', err => {
  logger.fatal('Uncaught exception:', err);

  _log4js.default.shutdown(() => process.abort());
});
process.on('unhandledRejection', err => {
  logger.warn('Unhandled rejection', err);
}); // Properly terminate if the parent server crashes.

process.on('disconnect', () => {
  process.exit();
});
process.once('message', ({
  packages,
  exposedSockets
}) => {
  const messageRouter = new _MessageRouter.default(); // Route incoming IPC messages into the message router.

  process.on('message', message => {
    messageRouter.send(message);
  }); // Messages to external sockets need to go over IPC.

  exposedSockets.forEach(socket => {
    messageRouter.getMessages(socket).mergeMap(message => new Promise(resolve => {
      (0, _assert.default)(process.send != null);
      process.send(message, resolve);
    }),
    /* Set concurrency to 1 to avoid blocking IPC. */
    1).subscribe();
  }); // Create connections for each provided service.

  const activatedPackages = packages.map(pkg => {
    return (0, _activatePackage.default)(pkg, messageRouter); // ??? Maybe there should be an explicit signal or shutdown message via IPC.
  });
  process.on('exit', () => {
    activatedPackages.forEach(pkg => {
      if (pkg.dispose != null) {
        pkg.dispose();
      }
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vZXhwZXJpbWVudGFsLXBhY2thZ2VzL3J1bi1wYWNrYWdlLmpzIl0sIm5hbWVzIjpbImxvZzRqcyIsImNvbmZpZ3VyZSIsImFwcGVuZGVycyIsInR5cGUiLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJwcm9jZXNzIiwib24iLCJlcnIiLCJmYXRhbCIsInNodXRkb3duIiwiYWJvcnQiLCJ3YXJuIiwiZXhpdCIsIm9uY2UiLCJwYWNrYWdlcyIsImV4cG9zZWRTb2NrZXRzIiwibWVzc2FnZVJvdXRlciIsIk1lc3NhZ2VSb3V0ZXIiLCJtZXNzYWdlIiwic2VuZCIsImZvckVhY2giLCJzb2NrZXQiLCJnZXRNZXNzYWdlcyIsIm1lcmdlTWFwIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdWJzY3JpYmUiLCJhY3RpdmF0ZWRQYWNrYWdlcyIsIm1hcCIsInBrZyIsImRpc3Bvc2UiXSwibWFwcGluZ3MiOiI7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0FBLGdCQUFPQyxTQUFQLENBQWlCO0FBQ2ZDLEVBQUFBLFNBQVMsRUFBRSxDQUFDO0FBQUNDLElBQUFBLElBQUksRUFBRTtBQUFQLEdBQUQ7QUFESSxDQUFqQjs7QUFJQSxNQUFNQyxNQUFNLEdBQUdKLGdCQUFPSyxTQUFQLENBQWlCLDBCQUFqQixDQUFmOztBQUNBQyxPQUFPLENBQUNDLEVBQVIsQ0FBVyxtQkFBWCxFQUFnQ0MsR0FBRyxJQUFJO0FBQ3JDSixFQUFBQSxNQUFNLENBQUNLLEtBQVAsQ0FBYSxxQkFBYixFQUFvQ0QsR0FBcEM7O0FBQ0FSLGtCQUFPVSxRQUFQLENBQWdCLE1BQU1KLE9BQU8sQ0FBQ0ssS0FBUixFQUF0QjtBQUNELENBSEQ7QUFLQUwsT0FBTyxDQUFDQyxFQUFSLENBQVcsb0JBQVgsRUFBaUNDLEdBQUcsSUFBSTtBQUN0Q0osRUFBQUEsTUFBTSxDQUFDUSxJQUFQLENBQVkscUJBQVosRUFBbUNKLEdBQW5DO0FBQ0QsQ0FGRCxFLENBSUE7O0FBQ0FGLE9BQU8sQ0FBQ0MsRUFBUixDQUFXLFlBQVgsRUFBeUIsTUFBTTtBQUM3QkQsRUFBQUEsT0FBTyxDQUFDTyxJQUFSO0FBQ0QsQ0FGRDtBQUlBUCxPQUFPLENBQUNRLElBQVIsQ0FBYSxTQUFiLEVBQXdCLENBQUM7QUFBQ0MsRUFBQUEsUUFBRDtBQUFXQyxFQUFBQTtBQUFYLENBQUQsS0FBbUQ7QUFDekUsUUFBTUMsYUFBYSxHQUFHLElBQUlDLHNCQUFKLEVBQXRCLENBRHlFLENBR3pFOztBQUNBWixFQUFBQSxPQUFPLENBQUNDLEVBQVIsQ0FBVyxTQUFYLEVBQXVCWSxPQUFELElBQTJCO0FBQy9DRixJQUFBQSxhQUFhLENBQUNHLElBQWQsQ0FBbUJELE9BQW5CO0FBQ0QsR0FGRCxFQUp5RSxDQVF6RTs7QUFDQUgsRUFBQUEsY0FBYyxDQUFDSyxPQUFmLENBQXVCQyxNQUFNLElBQUk7QUFDL0JMLElBQUFBLGFBQWEsQ0FDVk0sV0FESCxDQUNlRCxNQURmLEVBRUdFLFFBRkgsQ0FHSUwsT0FBTyxJQUNMLElBQUlNLE9BQUosQ0FBWUMsT0FBTyxJQUFJO0FBQ3JCLDJCQUFVcEIsT0FBTyxDQUFDYyxJQUFSLElBQWdCLElBQTFCO0FBQ0FkLE1BQUFBLE9BQU8sQ0FBQ2MsSUFBUixDQUFhRCxPQUFiLEVBQXNCTyxPQUF0QjtBQUNELEtBSEQsQ0FKTjtBQVFJO0FBQWtELEtBUnRELEVBVUdDLFNBVkg7QUFXRCxHQVpELEVBVHlFLENBdUJ6RTs7QUFDQSxRQUFNQyxpQkFBaUIsR0FBR2IsUUFBUSxDQUFDYyxHQUFULENBQWFDLEdBQUcsSUFBSTtBQUM1QyxXQUFPLDhCQUFnQkEsR0FBaEIsRUFBcUJiLGFBQXJCLENBQVAsQ0FENEMsQ0FFNUM7QUFDRCxHQUh5QixDQUExQjtBQUtBWCxFQUFBQSxPQUFPLENBQUNDLEVBQVIsQ0FBVyxNQUFYLEVBQW1CLE1BQU07QUFDdkJxQixJQUFBQSxpQkFBaUIsQ0FBQ1AsT0FBbEIsQ0FBMEJTLEdBQUcsSUFBSTtBQUMvQixVQUFJQSxHQUFHLENBQUNDLE9BQUosSUFBZSxJQUFuQixFQUF5QjtBQUN2QkQsUUFBQUEsR0FBRyxDQUFDQyxPQUFKO0FBQ0Q7QUFDRixLQUpEO0FBS0QsR0FORDtBQU9ELENBcENEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtJbml0aWFsaXplTWVzc2FnZSwgUGlwZWRNZXNzYWdlfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IGxvZzRqcyBmcm9tICdsb2c0anMnO1xyXG5pbXBvcnQgTWVzc2FnZVJvdXRlciBmcm9tICcuL01lc3NhZ2VSb3V0ZXInO1xyXG5pbXBvcnQgYWN0aXZhdGVQYWNrYWdlIGZyb20gJy4vYWN0aXZhdGVQYWNrYWdlJztcclxuXHJcbi8vIFNlbmQgbG9nNGpzIGVycm9ycyB0byBzdGRlcnIgZm9yIHZpc2liaWxpdHkgZnJvbSB0aGUgbWFpbiBwcm9jZXNzLlxyXG5sb2c0anMuY29uZmlndXJlKHtcclxuICBhcHBlbmRlcnM6IFt7dHlwZTogJ3N0ZGVycid9XSxcclxufSk7XHJcblxyXG5jb25zdCBsb2dnZXIgPSBsb2c0anMuZ2V0TG9nZ2VyKCdleHBlcmltZW50YWwtcnVuLXBhY2thZ2UnKTtcclxucHJvY2Vzcy5vbigndW5jYXVnaHRFeGNlcHRpb24nLCBlcnIgPT4ge1xyXG4gIGxvZ2dlci5mYXRhbCgnVW5jYXVnaHQgZXhjZXB0aW9uOicsIGVycik7XHJcbiAgbG9nNGpzLnNodXRkb3duKCgpID0+IHByb2Nlc3MuYWJvcnQoKSk7XHJcbn0pO1xyXG5cclxucHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgZXJyID0+IHtcclxuICBsb2dnZXIud2FybignVW5oYW5kbGVkIHJlamVjdGlvbicsIGVycik7XHJcbn0pO1xyXG5cclxuLy8gUHJvcGVybHkgdGVybWluYXRlIGlmIHRoZSBwYXJlbnQgc2VydmVyIGNyYXNoZXMuXHJcbnByb2Nlc3Mub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XHJcbiAgcHJvY2Vzcy5leGl0KCk7XHJcbn0pO1xyXG5cclxucHJvY2Vzcy5vbmNlKCdtZXNzYWdlJywgKHtwYWNrYWdlcywgZXhwb3NlZFNvY2tldHN9OiBJbml0aWFsaXplTWVzc2FnZSkgPT4ge1xyXG4gIGNvbnN0IG1lc3NhZ2VSb3V0ZXIgPSBuZXcgTWVzc2FnZVJvdXRlcigpO1xyXG5cclxuICAvLyBSb3V0ZSBpbmNvbWluZyBJUEMgbWVzc2FnZXMgaW50byB0aGUgbWVzc2FnZSByb3V0ZXIuXHJcbiAgcHJvY2Vzcy5vbignbWVzc2FnZScsIChtZXNzYWdlOiBQaXBlZE1lc3NhZ2UpID0+IHtcclxuICAgIG1lc3NhZ2VSb3V0ZXIuc2VuZChtZXNzYWdlKTtcclxuICB9KTtcclxuXHJcbiAgLy8gTWVzc2FnZXMgdG8gZXh0ZXJuYWwgc29ja2V0cyBuZWVkIHRvIGdvIG92ZXIgSVBDLlxyXG4gIGV4cG9zZWRTb2NrZXRzLmZvckVhY2goc29ja2V0ID0+IHtcclxuICAgIG1lc3NhZ2VSb3V0ZXJcclxuICAgICAgLmdldE1lc3NhZ2VzKHNvY2tldClcclxuICAgICAgLm1lcmdlTWFwKFxyXG4gICAgICAgIG1lc3NhZ2UgPT5cclxuICAgICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICBpbnZhcmlhbnQocHJvY2Vzcy5zZW5kICE9IG51bGwpO1xyXG4gICAgICAgICAgICBwcm9jZXNzLnNlbmQobWVzc2FnZSwgcmVzb2x2ZSk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAvKiBTZXQgY29uY3VycmVuY3kgdG8gMSB0byBhdm9pZCBibG9ja2luZyBJUEMuICovIDEsXHJcbiAgICAgIClcclxuICAgICAgLnN1YnNjcmliZSgpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgY29ubmVjdGlvbnMgZm9yIGVhY2ggcHJvdmlkZWQgc2VydmljZS5cclxuICBjb25zdCBhY3RpdmF0ZWRQYWNrYWdlcyA9IHBhY2thZ2VzLm1hcChwa2cgPT4ge1xyXG4gICAgcmV0dXJuIGFjdGl2YXRlUGFja2FnZShwa2csIG1lc3NhZ2VSb3V0ZXIpO1xyXG4gICAgLy8gPz8/IE1heWJlIHRoZXJlIHNob3VsZCBiZSBhbiBleHBsaWNpdCBzaWduYWwgb3Igc2h1dGRvd24gbWVzc2FnZSB2aWEgSVBDLlxyXG4gIH0pO1xyXG5cclxuICBwcm9jZXNzLm9uKCdleGl0JywgKCkgPT4ge1xyXG4gICAgYWN0aXZhdGVkUGFja2FnZXMuZm9yRWFjaChwa2cgPT4ge1xyXG4gICAgICBpZiAocGtnLmRpc3Bvc2UgIT0gbnVsbCkge1xyXG4gICAgICAgIHBrZy5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl19