"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__updateConfigSettingsListener = __updateConfigSettingsListener;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _electron = require("electron");

var _fs = _interopRequireDefault(require("fs"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _season = _interopRequireDefault(require("season"));

var _nuclideUri = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/nuclideUri"));

var _ConfigManager = _interopRequireDefault(require("./ConfigManager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
(0, _assert.default)(_electron.remote != null && _electron.remote.ipcMain != null && _electron.ipcRenderer != null);
/**
 * This module provides a wrapper around an atom$Config to be used for storing
 * data not intended to be accessed by Nuclide users (which should be accessed
 * using feature-config or atom.config). These config values are accessed/stored
 * on disk in the NUCLIDE_CONFIG_FILE and should only be modified via the
 * NuclideConfig / ConfigManager functions provided by this module's export
 */

const Config = atom.config.constructor;
const NUCLIDE_CONFIG_FILE = 'nuclide-config.cson';
const UPDATE_NUCLIDE_CONFIG_SETTINGS = 'nuclide-config-update-settings';

const nuclideConfigFilePath = _nuclideUri.default.join((0, _nullthrows.default)(process.env.ATOM_HOME), NUCLIDE_CONFIG_FILE);

function getConfigSettingsFromDisk() {
  let configSettings = {};

  if (_fs.default.existsSync(nuclideConfigFilePath)) {
    configSettings = _season.default.readFileSync(nuclideConfigFilePath);
  }

  return configSettings;
}

const config = new Config({
  mainSource: nuclideConfigFilePath,

  // Reuse applicationDelegate's saveCallback but with nuclideConfig's context.
  // This delegates saving to the config file to atom's main process, which
  // handles saving contention
  saveCallback() {
    atom.applicationDelegate.setUserSettings(this.settings, this.getUserConfigPath());
  }

}); // Reset the settings to match those stored in NUCLIDE_CONFIG_FILE. This sets
// settingsLoaded to true (allowing config to be saved using the saveCallback)

config.resetUserSettings(getConfigSettingsFromDisk());
/**
 * Emit nuclide-config's settings so that other processes can update their
 * config settings to reflect changes values
 */

function emitConfigSettings(settings) {
  _electron.ipcRenderer.send(UPDATE_NUCLIDE_CONFIG_SETTINGS, settings);
}
/**
 * Extend the ConfigManager to overload the set/unset functionality. This is
 * necessary for interprocess communication so that config changes in one window
 * (process) are reflected in the config objects of other windows (processes).
 * Since set/unset writes to disk, we only want one set/unset call to occur for
 * any single action done by a process. The initiating process will call set/unset
 * and then emit the event to other processes, which will update their config objects
 * without writing to disk (via resetUserSettings).
 * Instead of restricting the underlying config set/unset calls to a single "main"
 * process, we call it for any process that calls nuclideConfig.set/unset and rely
 * on Atom's main process to handle any disk writing contention
 */


class NuclideConfig extends _ConfigManager.default {
  // Set the nuclide-config value and emit event with updated config values to
  // push config changes to other processes
  set(keyPath, value, options) {
    const setSuccess = super.set(keyPath, value, options);

    if (setSuccess) {
      emitConfigSettings({
        settings: this._config.settings,
        options
      });
    }

    return setSuccess;
  } // Unset the nuclide-config key and emit event with updated config values to
  // push config changes to other processes


  unset(keyPath, options) {
    super.unset(keyPath, options);
    emitConfigSettings({
      settings: this._config.settings,
      options
    });
  }

}

const nuclideConfig = new NuclideConfig(config);
/**
 * Listen to incoming nuclide-config changes from other processes and reset
 * the current process's config to match that emitted by the emitting process.
 * Clobber the entire config settings object to have all the "latest" values,
 * instead of setting individual key/vals, which may produce a config of merged
 * values from different sources
 */

_electron.remote.ipcMain.on(UPDATE_NUCLIDE_CONFIG_SETTINGS, __updateConfigSettingsListener); // NB: This isn't described correctly in electron-flowtype-definitions, so we'll
// fake it out


// export for testing
function __updateConfigSettingsListener(event, {
  settings,
  options
}) {
  if (event.sender.getOwnerBrowserWindow().id !== _electron.remote.getCurrentWindow().id) {
    // Update all settings without saving to disk
    nuclideConfig.getConfig().resetUserSettings(settings, options);
  }
}

var _default = nuclideConfig;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vbnVjbGlkZS1jb25maWcuanMiXSwibmFtZXMiOlsicmVtb3RlIiwiaXBjTWFpbiIsImlwY1JlbmRlcmVyIiwiQ29uZmlnIiwiYXRvbSIsImNvbmZpZyIsImNvbnN0cnVjdG9yIiwiTlVDTElERV9DT05GSUdfRklMRSIsIlVQREFURV9OVUNMSURFX0NPTkZJR19TRVRUSU5HUyIsIm51Y2xpZGVDb25maWdGaWxlUGF0aCIsIm51Y2xpZGVVcmkiLCJqb2luIiwicHJvY2VzcyIsImVudiIsIkFUT01fSE9NRSIsImdldENvbmZpZ1NldHRpbmdzRnJvbURpc2siLCJjb25maWdTZXR0aW5ncyIsImZzIiwiZXhpc3RzU3luYyIsIkNTT04iLCJyZWFkRmlsZVN5bmMiLCJtYWluU291cmNlIiwic2F2ZUNhbGxiYWNrIiwiYXBwbGljYXRpb25EZWxlZ2F0ZSIsInNldFVzZXJTZXR0aW5ncyIsInNldHRpbmdzIiwiZ2V0VXNlckNvbmZpZ1BhdGgiLCJyZXNldFVzZXJTZXR0aW5ncyIsImVtaXRDb25maWdTZXR0aW5ncyIsInNlbmQiLCJOdWNsaWRlQ29uZmlnIiwiQ29uZmlnTWFuYWdlciIsInNldCIsImtleVBhdGgiLCJ2YWx1ZSIsIm9wdGlvbnMiLCJzZXRTdWNjZXNzIiwiX2NvbmZpZyIsInVuc2V0IiwibnVjbGlkZUNvbmZpZyIsIm9uIiwiX191cGRhdGVDb25maWdTZXR0aW5nc0xpc3RlbmVyIiwiZXZlbnQiLCJzZW5kZXIiLCJnZXRPd25lckJyb3dzZXJXaW5kb3ciLCJpZCIsImdldEN1cnJlbnRXaW5kb3ciLCJnZXRDb25maWciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBWUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWFBLHFCQUFVQSxvQkFBVSxJQUFWLElBQWtCQSxp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QU4sSUFBQUEsYUFBYSxDQUFDUSxTQUFkLEdBQTBCcEIsaUJBQTFCLENBQTRDRixRQUE1QyxFQUFzRFUsT0FBdEQ7QUFDRDtBQUNGOztlQUVjSSxhIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge3JlbW90ZSwgaXBjUmVuZGVyZXJ9IGZyb20gJ2VsZWN0cm9uJztcclxuXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcbmltcG9ydCBudWxsdGhyb3dzIGZyb20gJ251bGx0aHJvd3MnO1xyXG5pbXBvcnQgQ1NPTiBmcm9tICdzZWFzb24nO1xyXG5pbXBvcnQgbnVjbGlkZVVyaSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9udWNsaWRlVXJpJztcclxuaW1wb3J0IENvbmZpZ01hbmFnZXIgZnJvbSAnLi9Db25maWdNYW5hZ2VyJztcclxuXHJcbmltcG9ydCB0eXBlIHtCcm93c2VyV2luZG93LCBXZWJDb250ZW50c30gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZWxlY3Ryb24tcmVtb3RlJztcclxuXHJcbmludmFyaWFudChyZW1vdGUgIT0gbnVsbCAmJiByZW1vdGUuaXBjTWFpbiAhPSBudWxsICYmIGlwY1JlbmRlcmVyICE9IG51bGwpO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYW4gYXRvbSRDb25maWcgdG8gYmUgdXNlZCBmb3Igc3RvcmluZ1xyXG4gKiBkYXRhIG5vdCBpbnRlbmRlZCB0byBiZSBhY2Nlc3NlZCBieSBOdWNsaWRlIHVzZXJzICh3aGljaCBzaG91bGQgYmUgYWNjZXNzZWRcclxuICogdXNpbmcgZmVhdHVyZS1jb25maWcgb3IgYXRvbS5jb25maWcpLiBUaGVzZSBjb25maWcgdmFsdWVzIGFyZSBhY2Nlc3NlZC9zdG9yZWRcclxuICogb24gZGlzayBpbiB0aGUgTlVDTElERV9DT05GSUdfRklMRSBhbmQgc2hvdWxkIG9ubHkgYmUgbW9kaWZpZWQgdmlhIHRoZVxyXG4gKiBOdWNsaWRlQ29uZmlnIC8gQ29uZmlnTWFuYWdlciBmdW5jdGlvbnMgcHJvdmlkZWQgYnkgdGhpcyBtb2R1bGUncyBleHBvcnRcclxuICovXHJcblxyXG50eXBlIE51Y2xpZGVDb25maWdTZXRBcmdzID0ge1xyXG4gIHNldHRpbmdzOiBPYmplY3QsXHJcbiAgb3B0aW9ucz86IHtzb3VyY2U/OiBzdHJpbmd9LFxyXG59O1xyXG5cclxuY29uc3QgQ29uZmlnID0gYXRvbS5jb25maWcuY29uc3RydWN0b3I7XHJcbmNvbnN0IE5VQ0xJREVfQ09ORklHX0ZJTEUgPSAnbnVjbGlkZS1jb25maWcuY3Nvbic7XHJcbmNvbnN0IFVQREFURV9OVUNMSURFX0NPTkZJR19TRVRUSU5HUyA9ICdudWNsaWRlLWNvbmZpZy11cGRhdGUtc2V0dGluZ3MnO1xyXG5cclxuY29uc3QgbnVjbGlkZUNvbmZpZ0ZpbGVQYXRoID0gbnVjbGlkZVVyaS5qb2luKFxyXG4gIG51bGx0aHJvd3MocHJvY2Vzcy5lbnYuQVRPTV9IT01FKSxcclxuICBOVUNMSURFX0NPTkZJR19GSUxFLFxyXG4pO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q29uZmlnU2V0dGluZ3NGcm9tRGlzaygpIHtcclxuICBsZXQgY29uZmlnU2V0dGluZ3MgPSB7fTtcclxuXHJcbiAgaWYgKGZzLmV4aXN0c1N5bmMobnVjbGlkZUNvbmZpZ0ZpbGVQYXRoKSkge1xyXG4gICAgY29uZmlnU2V0dGluZ3MgPSBDU09OLnJlYWRGaWxlU3luYyhudWNsaWRlQ29uZmlnRmlsZVBhdGgpO1xyXG4gIH1cclxuICByZXR1cm4gY29uZmlnU2V0dGluZ3M7XHJcbn1cclxuXHJcbmNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWcoe1xyXG4gIG1haW5Tb3VyY2U6IG51Y2xpZGVDb25maWdGaWxlUGF0aCxcclxuICAvLyBSZXVzZSBhcHBsaWNhdGlvbkRlbGVnYXRlJ3Mgc2F2ZUNhbGxiYWNrIGJ1dCB3aXRoIG51Y2xpZGVDb25maWcncyBjb250ZXh0LlxyXG4gIC8vIFRoaXMgZGVsZWdhdGVzIHNhdmluZyB0byB0aGUgY29uZmlnIGZpbGUgdG8gYXRvbSdzIG1haW4gcHJvY2Vzcywgd2hpY2hcclxuICAvLyBoYW5kbGVzIHNhdmluZyBjb250ZW50aW9uXHJcbiAgc2F2ZUNhbGxiYWNrKCkge1xyXG4gICAgYXRvbS5hcHBsaWNhdGlvbkRlbGVnYXRlLnNldFVzZXJTZXR0aW5ncyhcclxuICAgICAgdGhpcy5zZXR0aW5ncyxcclxuICAgICAgdGhpcy5nZXRVc2VyQ29uZmlnUGF0aCgpLFxyXG4gICAgKTtcclxuICB9LFxyXG59KTtcclxuXHJcbi8vIFJlc2V0IHRoZSBzZXR0aW5ncyB0byBtYXRjaCB0aG9zZSBzdG9yZWQgaW4gTlVDTElERV9DT05GSUdfRklMRS4gVGhpcyBzZXRzXHJcbi8vIHNldHRpbmdzTG9hZGVkIHRvIHRydWUgKGFsbG93aW5nIGNvbmZpZyB0byBiZSBzYXZlZCB1c2luZyB0aGUgc2F2ZUNhbGxiYWNrKVxyXG5jb25maWcucmVzZXRVc2VyU2V0dGluZ3MoZ2V0Q29uZmlnU2V0dGluZ3NGcm9tRGlzaygpKTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IG51Y2xpZGUtY29uZmlnJ3Mgc2V0dGluZ3Mgc28gdGhhdCBvdGhlciBwcm9jZXNzZXMgY2FuIHVwZGF0ZSB0aGVpclxyXG4gKiBjb25maWcgc2V0dGluZ3MgdG8gcmVmbGVjdCBjaGFuZ2VzIHZhbHVlc1xyXG4gKi9cclxuZnVuY3Rpb24gZW1pdENvbmZpZ1NldHRpbmdzKHNldHRpbmdzOiBOdWNsaWRlQ29uZmlnU2V0QXJncykge1xyXG4gIGlwY1JlbmRlcmVyLnNlbmQoXHJcbiAgICBVUERBVEVfTlVDTElERV9DT05GSUdfU0VUVElOR1MsXHJcbiAgICAoc2V0dGluZ3M6IE51Y2xpZGVDb25maWdTZXRBcmdzKSxcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0ZW5kIHRoZSBDb25maWdNYW5hZ2VyIHRvIG92ZXJsb2FkIHRoZSBzZXQvdW5zZXQgZnVuY3Rpb25hbGl0eS4gVGhpcyBpc1xyXG4gKiBuZWNlc3NhcnkgZm9yIGludGVycHJvY2VzcyBjb21tdW5pY2F0aW9uIHNvIHRoYXQgY29uZmlnIGNoYW5nZXMgaW4gb25lIHdpbmRvd1xyXG4gKiAocHJvY2VzcykgYXJlIHJlZmxlY3RlZCBpbiB0aGUgY29uZmlnIG9iamVjdHMgb2Ygb3RoZXIgd2luZG93cyAocHJvY2Vzc2VzKS5cclxuICogU2luY2Ugc2V0L3Vuc2V0IHdyaXRlcyB0byBkaXNrLCB3ZSBvbmx5IHdhbnQgb25lIHNldC91bnNldCBjYWxsIHRvIG9jY3VyIGZvclxyXG4gKiBhbnkgc2luZ2xlIGFjdGlvbiBkb25lIGJ5IGEgcHJvY2Vzcy4gVGhlIGluaXRpYXRpbmcgcHJvY2VzcyB3aWxsIGNhbGwgc2V0L3Vuc2V0XHJcbiAqIGFuZCB0aGVuIGVtaXQgdGhlIGV2ZW50IHRvIG90aGVyIHByb2Nlc3Nlcywgd2hpY2ggd2lsbCB1cGRhdGUgdGhlaXIgY29uZmlnIG9iamVjdHNcclxuICogd2l0aG91dCB3cml0aW5nIHRvIGRpc2sgKHZpYSByZXNldFVzZXJTZXR0aW5ncykuXHJcbiAqIEluc3RlYWQgb2YgcmVzdHJpY3RpbmcgdGhlIHVuZGVybHlpbmcgY29uZmlnIHNldC91bnNldCBjYWxscyB0byBhIHNpbmdsZSBcIm1haW5cIlxyXG4gKiBwcm9jZXNzLCB3ZSBjYWxsIGl0IGZvciBhbnkgcHJvY2VzcyB0aGF0IGNhbGxzIG51Y2xpZGVDb25maWcuc2V0L3Vuc2V0IGFuZCByZWx5XHJcbiAqIG9uIEF0b20ncyBtYWluIHByb2Nlc3MgdG8gaGFuZGxlIGFueSBkaXNrIHdyaXRpbmcgY29udGVudGlvblxyXG4gKi9cclxuY2xhc3MgTnVjbGlkZUNvbmZpZyBleHRlbmRzIENvbmZpZ01hbmFnZXIge1xyXG4gIC8vIFNldCB0aGUgbnVjbGlkZS1jb25maWcgdmFsdWUgYW5kIGVtaXQgZXZlbnQgd2l0aCB1cGRhdGVkIGNvbmZpZyB2YWx1ZXMgdG9cclxuICAvLyBwdXNoIGNvbmZpZyBjaGFuZ2VzIHRvIG90aGVyIHByb2Nlc3Nlc1xyXG4gIHNldChcclxuICAgIGtleVBhdGg6IHN0cmluZyxcclxuICAgIHZhbHVlOiA/bWl4ZWQsXHJcbiAgICBvcHRpb25zPzoge1xyXG4gICAgICBzY29wZVNlbGVjdG9yPzogc3RyaW5nLFxyXG4gICAgICBzb3VyY2U/OiBzdHJpbmcsXHJcbiAgICB9LFxyXG4gICk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgc2V0U3VjY2VzcyA9IHN1cGVyLnNldChrZXlQYXRoLCB2YWx1ZSwgb3B0aW9ucyk7XHJcbiAgICBpZiAoc2V0U3VjY2Vzcykge1xyXG4gICAgICBlbWl0Q29uZmlnU2V0dGluZ3Moe1xyXG4gICAgICAgIHNldHRpbmdzOiB0aGlzLl9jb25maWcuc2V0dGluZ3MsXHJcbiAgICAgICAgb3B0aW9ucyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2V0U3VjY2VzcztcclxuICB9XHJcblxyXG4gIC8vIFVuc2V0IHRoZSBudWNsaWRlLWNvbmZpZyBrZXkgYW5kIGVtaXQgZXZlbnQgd2l0aCB1cGRhdGVkIGNvbmZpZyB2YWx1ZXMgdG9cclxuICAvLyBwdXNoIGNvbmZpZyBjaGFuZ2VzIHRvIG90aGVyIHByb2Nlc3Nlc1xyXG4gIHVuc2V0KFxyXG4gICAga2V5UGF0aDogc3RyaW5nLFxyXG4gICAgb3B0aW9ucz86IHtcclxuICAgICAgc2NvcGVTZWxlY3Rvcj86IHN0cmluZyxcclxuICAgICAgc291cmNlPzogc3RyaW5nLFxyXG4gICAgfSxcclxuICApOiB2b2lkIHtcclxuICAgIHN1cGVyLnVuc2V0KGtleVBhdGgsIG9wdGlvbnMpO1xyXG4gICAgZW1pdENvbmZpZ1NldHRpbmdzKHtcclxuICAgICAgc2V0dGluZ3M6IHRoaXMuX2NvbmZpZy5zZXR0aW5ncyxcclxuICAgICAgb3B0aW9ucyxcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgbnVjbGlkZUNvbmZpZyA9IG5ldyBOdWNsaWRlQ29uZmlnKGNvbmZpZyk7XHJcblxyXG4vKipcclxuICogTGlzdGVuIHRvIGluY29taW5nIG51Y2xpZGUtY29uZmlnIGNoYW5nZXMgZnJvbSBvdGhlciBwcm9jZXNzZXMgYW5kIHJlc2V0XHJcbiAqIHRoZSBjdXJyZW50IHByb2Nlc3MncyBjb25maWcgdG8gbWF0Y2ggdGhhdCBlbWl0dGVkIGJ5IHRoZSBlbWl0dGluZyBwcm9jZXNzLlxyXG4gKiBDbG9iYmVyIHRoZSBlbnRpcmUgY29uZmlnIHNldHRpbmdzIG9iamVjdCB0byBoYXZlIGFsbCB0aGUgXCJsYXRlc3RcIiB2YWx1ZXMsXHJcbiAqIGluc3RlYWQgb2Ygc2V0dGluZyBpbmRpdmlkdWFsIGtleS92YWxzLCB3aGljaCBtYXkgcHJvZHVjZSBhIGNvbmZpZyBvZiBtZXJnZWRcclxuICogdmFsdWVzIGZyb20gZGlmZmVyZW50IHNvdXJjZXNcclxuICovXHJcbnJlbW90ZS5pcGNNYWluLm9uKFxyXG4gIFVQREFURV9OVUNMSURFX0NPTkZJR19TRVRUSU5HUyxcclxuICBfX3VwZGF0ZUNvbmZpZ1NldHRpbmdzTGlzdGVuZXIsXHJcbik7XHJcblxyXG4vLyBOQjogVGhpcyBpc24ndCBkZXNjcmliZWQgY29ycmVjdGx5IGluIGVsZWN0cm9uLWZsb3d0eXBlLWRlZmluaXRpb25zLCBzbyB3ZSdsbFxyXG4vLyBmYWtlIGl0IG91dFxyXG50eXBlIFNlbmRlckdldEJyb3dzZXJXaW5kb3cgPSB7fFxyXG4gIGdldE93bmVyQnJvd3NlcldpbmRvdzogKCkgPT4gQnJvd3NlcldpbmRvdyxcclxufH07XHJcblxyXG4vLyBleHBvcnQgZm9yIHRlc3RpbmdcclxuZXhwb3J0IGZ1bmN0aW9uIF9fdXBkYXRlQ29uZmlnU2V0dGluZ3NMaXN0ZW5lcihcclxuICBldmVudDoge3JldHVyblZhbHVlOiBtaXhlZCwgc2VuZGVyOiBXZWJDb250ZW50cyAmIFNlbmRlckdldEJyb3dzZXJXaW5kb3d9LFxyXG4gIHtzZXR0aW5ncywgb3B0aW9uc306IE51Y2xpZGVDb25maWdTZXRBcmdzLFxyXG4pIHtcclxuICBpZiAoXHJcbiAgICBldmVudC5zZW5kZXIuZ2V0T3duZXJCcm93c2VyV2luZG93KCkuaWQgIT09IHJlbW90ZS5nZXRDdXJyZW50V2luZG93KCkuaWRcclxuICApIHtcclxuICAgIC8vIFVwZGF0ZSBhbGwgc2V0dGluZ3Mgd2l0aG91dCBzYXZpbmcgdG8gZGlza1xyXG4gICAgbnVjbGlkZUNvbmZpZy5nZXRDb25maWcoKS5yZXNldFVzZXJTZXR0aW5ncyhzZXR0aW5ncywgb3B0aW9ucyk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBudWNsaWRlQ29uZmlnO1xyXG4iXX0=