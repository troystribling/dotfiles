"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = observePaneItemVisibility;
exports.observeVisibleItems = observeVisibleItems;

var _event = require("@atom-ide-community/nuclide-commons/event");

var _memoizeUntilChanged = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/memoizeUntilChanged"));

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// TODO(T17495608): Currently, docks don't have a way of observing their visibility so this will
//   have some false positives when an item is its pane's active item but its dock is hidden.
function observePaneItemVisibility(item) {
  patchDocks();
  const workspaceEl = atom.workspace.getElement();
  return _rxjsCompatUmdMin.Observable.combineLatest( // atom.workspace.reset() (in tests) resets all the panes.
  // Pass in the workspace dom element to act as a cache-breaker.
  observeActiveItems(workspaceEl), observePaneContainerVisibilities(workspaceEl)).map(([activeItems, locationVisibilities]) => {
    // If it's not active, it's not visible.
    if (!activeItems.has(item)) {
      return false;
    } // If it's active, it's only visible if its container is.


    const paneContainer = atom.workspace.paneContainerForItem(item);
    return paneContainer == null ? false : locationVisibilities[paneContainer.getLocation()];
  }).distinctUntilChanged();
}

function observeVisibleItems() {
  patchDocks();
  const workspaceEl = atom.workspace.getElement();
  return _rxjsCompatUmdMin.Observable.combineLatest(observeActiveItems(workspaceEl), observePaneContainerVisibilities(workspaceEl)).map(([activeItems, locationVisibilities]) => {
    // If it's not active, it's not visible.
    // If it's active, it's only visible if its container is.
    // $FlowFixMe (>=0.85.0) (T35986896) Flow upgrade suppress
    return (0, _collection.setFilter)(activeItems, item => {
      const paneContainer = atom.workspace.paneContainerForItem(item);
      const location = paneContainer && paneContainer.getLocation();
      return location ? Boolean(locationVisibilities[location]) : false;
    });
  });
}

const observeActiveItems = (0, _memoizeUntilChanged.default)(_cacheKey => {
  // An observable that emits `{pane, item}` whenever the active item of a pane changes.
  const itemActivations = _rxjsCompatUmdMin.Observable.merge(...atom.workspace.getPaneContainers().map(paneContainer => {
    const observePanes = paneContainer.observePanes.bind(paneContainer);
    return (0, _event.observableFromSubscribeFunction)(observePanes).flatMap(pane => {
      const paneDestroyed = (0, _event.observableFromSubscribeFunction)(pane.onDidDestroy.bind(pane));
      const activeItems = (0, _event.observableFromSubscribeFunction)(pane.observeActiveItem.bind(pane)).takeUntil(paneDestroyed);
      return _rxjsCompatUmdMin.Observable.concat(activeItems.map(item => ({
        pane,
        item
      })), _rxjsCompatUmdMin.Observable.of({
        pane,
        item: null
      }));
    });
  })); // Create a map of panes to their active items. We could look this up by examining the workspace
  // every time; this is an optimization.


  const panesToActiveItem = itemActivations.scan((acc, {
    pane,
    item
  }) => {
    if (item == null) {
      acc.delete(pane);
    } else {
      acc.set(pane, item);
    }

    return acc;
  }, new Map());
  return panesToActiveItem // When dragging items between panes, they'll be quickly deactivated and activated again. To
  // avoid doing extra work, we debounce and use the rAF scheduler.
  .debounceTime(0, _rxjsCompatUmdMin.Scheduler.animationFrame).map(map => new Set(map.values())) // $FlowIgnore: this is just not listed in the flow-typed defs
  .shareReplay(1);
}); // Create an observable that contains the current visibility state of each dock, but where the
// "false" values are delayed to account for the time it takes to animate the dock closed.

const observePaneContainerVisibilities = (0, _memoizeUntilChanged.default)(_cacheKey => {
  const visibilitiesByDock = ['left', 'right', 'bottom'].map(loc => dockStateChanges.filter(({
    location
  }) => location === loc).switchMap(({
    location,
    visible
  }) => // Delay the "false" values so they don't occur while the dock is being animated closed.
  visible ? _rxjsCompatUmdMin.Observable.of({
    location,
    visible
  }) : _rxjsCompatUmdMin.Observable.of({
    location,
    visible
  }).delay(300)).distinctUntilKeyChanged('visible'));
  const initialVisibilities = {
    // The center is always visible.
    center: true,
    left: atom.workspace.getLeftDock().isVisible(),
    right: atom.workspace.getRightDock().isVisible(),
    bottom: atom.workspace.getBottomDock().isVisible()
  }; // Accumulate the dock visibilities.

  const visibilityStates = _rxjsCompatUmdMin.Observable.merge(...visibilitiesByDock).scan((acc, {
    location,
    visible
  }) => ({ ...acc,
    [location]: visible
  }), initialVisibilities).startWith(initialVisibilities).distinctUntilChanged(_shallowequal.default).publishReplay(1);

  visibilityStates.connect();
  return visibilityStates;
}); // HACK: Monkey-patch Docks in order to observe visibility toggling.
// TODO: Use `Dock::observeVisibility` once atom/atom#14736 is in our lowest-supported version

let docksPatched = false;
const dockStateChanges = new _rxjsCompatUmdMin.Subject();

function patchDocks() {
  if (docksPatched || typeof atom.workspace.getLeftDock !== 'function') {
    return;
  }

  docksPatched = true;
  const ctor = atom.workspace.getLeftDock().constructor;
  const proto = ctor.prototype; // $FlowIgnore

  const originalSetState = proto.setState; // $FlowIgnore

  proto.setState = function (newState, ...args) {
    originalSetState.call(this, newState, ...args);

    if (newState.hasOwnProperty('visible')) {
      dockStateChanges.next({
        location: this.getLocation(),
        visible: newState.visible
      });
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vb2JzZXJ2ZVBhbmVJdGVtVmlzaWJpbGl0eS5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlUGFuZUl0ZW1WaXNpYmlsaXR5IiwiaXRlbSIsInBhdGNoRG9ja3MiLCJ3b3Jrc3BhY2VFbCIsImF0b20iLCJ3b3Jrc3BhY2UiLCJnZXRFbGVtZW50IiwiT2JzZXJ2YWJsZSIsImNvbWJpbmVMYXRlc3QiLCJvYnNlcnZlQWN0aXZlSXRlbXMiLCJvYnNlcnZlUGFuZUNvbnRhaW5lclZpc2liaWxpdGllcyIsIm1hcCIsImFjdGl2ZUl0ZW1zIiwibG9jYXRpb25WaXNpYmlsaXRpZXMiLCJoYXMiLCJwYW5lQ29udGFpbmVyIiwicGFuZUNvbnRhaW5lckZvckl0ZW0iLCJnZXRMb2NhdGlvbiIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwib2JzZXJ2ZVZpc2libGVJdGVtcyIsImxvY2F0aW9uIiwiQm9vbGVhbiIsIl9jYWNoZUtleSIsIml0ZW1BY3RpdmF0aW9ucyIsIm1lcmdlIiwiZ2V0UGFuZUNvbnRhaW5lcnMiLCJvYnNlcnZlUGFuZXMiLCJiaW5kIiwiZmxhdE1hcCIsInBhbmUiLCJwYW5lRGVzdHJveWVkIiwib25EaWREZXN0cm95Iiwib2JzZXJ2ZUFjdGl2ZUl0ZW0iLCJ0YWtlVW50aWwiLCJjb25jYXQiLCJvZiIsInBhbmVzVG9BY3RpdmVJdGVtIiwic2NhbiIsImFjYyIsImRlbGV0ZSIsInNldCIsIk1hcCIsImRlYm91bmNlVGltZSIsIlNjaGVkdWxlciIsImFuaW1hdGlvbkZyYW1lIiwiU2V0IiwidmFsdWVzIiwic2hhcmVSZXBsYXkiLCJ2aXNpYmlsaXRpZXNCeURvY2siLCJsb2MiLCJkb2NrU3RhdGVDaGFuZ2VzIiwiZmlsdGVyIiwic3dpdGNoTWFwIiwidmlzaWJsZSIsImRlbGF5IiwiZGlzdGluY3RVbnRpbEtleUNoYW5nZWQiLCJpbml0aWFsVmlzaWJpbGl0aWVzIiwiY2VudGVyIiwibGVmdCIsImdldExlZnREb2NrIiwiaXNWaXNpYmxlIiwicmlnaHQiLCJnZXRSaWdodERvY2siLCJib3R0b20iLCJnZXRCb3R0b21Eb2NrIiwidmlzaWJpbGl0eVN0YXRlcyIsInN0YXJ0V2l0aCIsInNoYWxsb3dFcXVhbCIsInB1Ymxpc2hSZXBsYXkiLCJjb25uZWN0IiwiZG9ja3NQYXRjaGVkIiwiU3ViamVjdCIsImN0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvIiwicHJvdG90eXBlIiwib3JpZ2luYWxTZXRTdGF0ZSIsInNldFN0YXRlIiwibmV3U3RhdGUiLCJhcmdzIiwiY2FsbCIsImhhc093blByb3BlcnR5IiwibmV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNlLFNBQVNBLHlCQUFULENBQ2JDLElBRGEsRUFFUTtBQUNyQkMsRUFBQUEsVUFBVTtBQUVWLFFBQU1DLFdBQVcsR0FBR0MsSUFBSSxDQUFDQyxTQUFMLENBQWVDLFVBQWYsRUFBcEI7QUFDQSxTQUFPQyw2QkFBV0MsYUFBWCxFQUNMO0FBQ0E7QUFDQUMsRUFBQUEsa0JBQWtCLENBQUNOLFdBQUQsQ0FIYixFQUlMTyxnQ0FBZ0MsQ0FBQ1AsV0FBRCxDQUozQixFQU1KUSxHQU5JLENBTUEsQ0FBQyxDQUFDQyxXQUFELEVBQWNDLG9CQUFkLENBQUQsS0FBeUM7QUFDNUM7QUFDQSxRQUFJLENBQUNELFdBQVcsQ0FBQ0UsR0FBWixDQUFnQmIsSUFBaEIsQ0FBTCxFQUE0QjtBQUMxQixhQUFPLEtBQVA7QUFDRCxLQUoyQyxDQUs1Qzs7O0FBQ0EsVUFBTWMsYUFBYSxHQUFHWCxJQUFJLENBQUNDLFNBQUwsQ0FBZVcsb0JBQWYsQ0FBb0NmLElBQXBDLENBQXRCO0FBQ0EsV0FBT2MsYUFBYSxJQUFJLElBQWpCLEdBQ0gsS0FERyxHQUVIRixvQkFBb0IsQ0FBQ0UsYUFBYSxDQUFDRSxX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LENBQUNnQyxJQUFqQixDQUFzQjtBQUNwQjlELFFBQUFBLFFBQVEsRUFBRSxLQUFLSCxXQUFMLEVBRFU7QUFFcEJvQyxRQUFBQSxPQUFPLEVBQUV5QixRQUFRLENBQUN6QjtBQUZFLE9BQXRCO0FBSUQ7QUFDRixHQVJEO0FBU0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQge29ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb259IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2V2ZW50JztcclxuaW1wb3J0IG1lbW9pemVVbnRpbENoYW5nZWQgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvbWVtb2l6ZVVudGlsQ2hhbmdlZCc7XHJcbmltcG9ydCB7c2V0RmlsdGVyfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9jb2xsZWN0aW9uJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBTY2hlZHVsZXIsIFN1YmplY3R9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnc2hhbGxvd2VxdWFsJztcclxuXHJcbi8vIFRPRE8oVDE3NDk1NjA4KTogQ3VycmVudGx5LCBkb2NrcyBkb24ndCBoYXZlIGEgd2F5IG9mIG9ic2VydmluZyB0aGVpciB2aXNpYmlsaXR5IHNvIHRoaXMgd2lsbFxyXG4vLyAgIGhhdmUgc29tZSBmYWxzZSBwb3NpdGl2ZXMgd2hlbiBhbiBpdGVtIGlzIGl0cyBwYW5lJ3MgYWN0aXZlIGl0ZW0gYnV0IGl0cyBkb2NrIGlzIGhpZGRlbi5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb2JzZXJ2ZVBhbmVJdGVtVmlzaWJpbGl0eShcclxuICBpdGVtOiBPYmplY3QsXHJcbik6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gIHBhdGNoRG9ja3MoKTtcclxuXHJcbiAgY29uc3Qgd29ya3NwYWNlRWwgPSBhdG9tLndvcmtzcGFjZS5nZXRFbGVtZW50KCk7XHJcbiAgcmV0dXJuIE9ic2VydmFibGUuY29tYmluZUxhdGVzdChcclxuICAgIC8vIGF0b20ud29ya3NwYWNlLnJlc2V0KCkgKGluIHRlc3RzKSByZXNldHMgYWxsIHRoZSBwYW5lcy5cclxuICAgIC8vIFBhc3MgaW4gdGhlIHdvcmtzcGFjZSBkb20gZWxlbWVudCB0byBhY3QgYXMgYSBjYWNoZS1icmVha2VyLlxyXG4gICAgb2JzZXJ2ZUFjdGl2ZUl0ZW1zKHdvcmtzcGFjZUVsKSxcclxuICAgIG9ic2VydmVQYW5lQ29udGFpbmVyVmlzaWJpbGl0aWVzKHdvcmtzcGFjZUVsKSxcclxuICApXHJcbiAgICAubWFwKChbYWN0aXZlSXRlbXMsIGxvY2F0aW9uVmlzaWJpbGl0aWVzXSkgPT4ge1xyXG4gICAgICAvLyBJZiBpdCdzIG5vdCBhY3RpdmUsIGl0J3Mgbm90IHZpc2libGUuXHJcbiAgICAgIGlmICghYWN0aXZlSXRlbXMuaGFzKGl0ZW0pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIGl0J3MgYWN0aXZlLCBpdCdzIG9ubHkgdmlzaWJsZSBpZiBpdHMgY29udGFpbmVyIGlzLlxyXG4gICAgICBjb25zdCBwYW5lQ29udGFpbmVyID0gYXRvbS53b3Jrc3BhY2UucGFuZUNvbnRhaW5lckZvckl0ZW0oaXRlbSk7XHJcbiAgICAgIHJldHVybiBwYW5lQ29udGFpbmVyID09IG51bGxcclxuICAgICAgICA/IGZhbHNlXHJcbiAgICAgICAgOiBsb2NhdGlvblZpc2liaWxpdGllc1twYW5lQ29udGFpbmVyLmdldExvY2F0aW9uKCldO1xyXG4gICAgfSlcclxuICAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZVZpc2libGVJdGVtcygpIHtcclxuICBwYXRjaERvY2tzKCk7XHJcblxyXG4gIGNvbnN0IHdvcmtzcGFjZUVsID0gYXRvbS53b3Jrc3BhY2UuZ2V0RWxlbWVudCgpO1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoXHJcbiAgICBvYnNlcnZlQWN0aXZlSXRlbXMod29ya3NwYWNlRWwpLFxyXG4gICAgb2JzZXJ2ZVBhbmVDb250YWluZXJWaXNpYmlsaXRpZXMod29ya3NwYWNlRWwpLFxyXG4gICkubWFwKChbYWN0aXZlSXRlbXMsIGxvY2F0aW9uVmlzaWJpbGl0aWVzXSkgPT4ge1xyXG4gICAgLy8gSWYgaXQncyBub3QgYWN0aXZlLCBpdCdzIG5vdCB2aXNpYmxlLlxyXG4gICAgLy8gSWYgaXQncyBhY3RpdmUsIGl0J3Mgb25seSB2aXNpYmxlIGlmIGl0cyBjb250YWluZXIgaXMuXHJcbiAgICAvLyAkRmxvd0ZpeE1lICg+PTAuODUuMCkgKFQzNTk4Njg5NikgRmxvdyB1cGdyYWRlIHN1cHByZXNzXHJcbiAgICByZXR1cm4gc2V0RmlsdGVyKGFjdGl2ZUl0ZW1zLCBpdGVtID0+IHtcclxuICAgICAgY29uc3QgcGFuZUNvbnRhaW5lciA9IGF0b20ud29ya3NwYWNlLnBhbmVDb250YWluZXJGb3JJdGVtKGl0ZW0pO1xyXG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHBhbmVDb250YWluZXIgJiYgcGFuZUNvbnRhaW5lci5nZXRMb2NhdGlvbigpO1xyXG4gICAgICByZXR1cm4gbG9jYXRpb24gPyBCb29sZWFuKGxvY2F0aW9uVmlzaWJpbGl0aWVzW2xvY2F0aW9uXSkgOiBmYWxzZTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5jb25zdCBvYnNlcnZlQWN0aXZlSXRlbXMgPSBtZW1vaXplVW50aWxDaGFuZ2VkKF9jYWNoZUtleSA9PiB7XHJcbiAgLy8gQW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGB7cGFuZSwgaXRlbX1gIHdoZW5ldmVyIHRoZSBhY3RpdmUgaXRlbSBvZiBhIHBhbmUgY2hhbmdlcy5cclxuICBjb25zdCBpdGVtQWN0aXZhdGlvbnMgPSBPYnNlcnZhYmxlLm1lcmdlKFxyXG4gICAgLi4uYXRvbS53b3Jrc3BhY2UuZ2V0UGFuZUNvbnRhaW5lcnMoKS5tYXAocGFuZUNvbnRhaW5lciA9PiB7XHJcbiAgICAgIGNvbnN0IG9ic2VydmVQYW5lcyA9IHBhbmVDb250YWluZXIub2JzZXJ2ZVBhbmVzLmJpbmQocGFuZUNvbnRhaW5lcik7XHJcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbVN1YnNjcmliZUZ1bmN0aW9uKG9ic2VydmVQYW5lcykuZmxhdE1hcChwYW5lID0+IHtcclxuICAgICAgICBjb25zdCBwYW5lRGVzdHJveWVkID0gb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihcclxuICAgICAgICAgIHBhbmUub25EaWREZXN0cm95LmJpbmQocGFuZSksXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBhY3RpdmVJdGVtcyA9IG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oXHJcbiAgICAgICAgICBwYW5lLm9ic2VydmVBY3RpdmVJdGVtLmJpbmQocGFuZSksXHJcbiAgICAgICAgKS50YWtlVW50aWwocGFuZURlc3Ryb3llZCk7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY29uY2F0KFxyXG4gICAgICAgICAgYWN0aXZlSXRlbXMubWFwKGl0ZW0gPT4gKHtwYW5lLCBpdGVtfSkpLFxyXG4gICAgICAgICAgT2JzZXJ2YWJsZS5vZih7cGFuZSwgaXRlbTogbnVsbH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSksXHJcbiAgKTtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhbmVzIHRvIHRoZWlyIGFjdGl2ZSBpdGVtcy4gV2UgY291bGQgbG9vayB0aGlzIHVwIGJ5IGV4YW1pbmluZyB0aGUgd29ya3NwYWNlXHJcbiAgLy8gZXZlcnkgdGltZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24uXHJcbiAgY29uc3QgcGFuZXNUb0FjdGl2ZUl0ZW0gPSBpdGVtQWN0aXZhdGlvbnMuc2NhbigoYWNjLCB7cGFuZSwgaXRlbX0pID0+IHtcclxuICAgIGlmIChpdGVtID09IG51bGwpIHtcclxuICAgICAgYWNjLmRlbGV0ZShwYW5lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjYy5zZXQocGFuZSwgaXRlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWNjO1xyXG4gIH0sIG5ldyBNYXAoKSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICBwYW5lc1RvQWN0aXZlSXRlbVxyXG4gICAgICAvLyBXaGVuIGRyYWdnaW5nIGl0ZW1zIGJldHdlZW4gcGFuZXMsIHRoZXknbGwgYmUgcXVpY2tseSBkZWFjdGl2YXRlZCBhbmQgYWN0aXZhdGVkIGFnYWluLiBUb1xyXG4gICAgICAvLyBhdm9pZCBkb2luZyBleHRyYSB3b3JrLCB3ZSBkZWJvdW5jZSBhbmQgdXNlIHRoZSByQUYgc2NoZWR1bGVyLlxyXG4gICAgICAuZGVib3VuY2VUaW1lKDAsIFNjaGVkdWxlci5hbmltYXRpb25GcmFtZSlcclxuICAgICAgLm1hcChtYXAgPT4gbmV3IFNldChtYXAudmFsdWVzKCkpKVxyXG4gICAgICAvLyAkRmxvd0lnbm9yZTogdGhpcyBpcyBqdXN0IG5vdCBsaXN0ZWQgaW4gdGhlIGZsb3ctdHlwZWQgZGVmc1xyXG4gICAgICAuc2hhcmVSZXBsYXkoMSlcclxuICApO1xyXG59KTtcclxuXHJcbi8vIENyZWF0ZSBhbiBvYnNlcnZhYmxlIHRoYXQgY29udGFpbnMgdGhlIGN1cnJlbnQgdmlzaWJpbGl0eSBzdGF0ZSBvZiBlYWNoIGRvY2ssIGJ1dCB3aGVyZSB0aGVcclxuLy8gXCJmYWxzZVwiIHZhbHVlcyBhcmUgZGVsYXllZCB0byBhY2NvdW50IGZvciB0aGUgdGltZSBpdCB0YWtlcyB0byBhbmltYXRlIHRoZSBkb2NrIGNsb3NlZC5cclxuY29uc3Qgb2JzZXJ2ZVBhbmVDb250YWluZXJWaXNpYmlsaXRpZXMgPSBtZW1vaXplVW50aWxDaGFuZ2VkKF9jYWNoZUtleSA9PiB7XHJcbiAgY29uc3QgdmlzaWJpbGl0aWVzQnlEb2NrID0gWydsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddLm1hcChsb2MgPT5cclxuICAgIGRvY2tTdGF0ZUNoYW5nZXNcclxuICAgICAgLmZpbHRlcigoe2xvY2F0aW9ufSkgPT4gbG9jYXRpb24gPT09IGxvYylcclxuICAgICAgLnN3aXRjaE1hcChcclxuICAgICAgICAoe2xvY2F0aW9uLCB2aXNpYmxlfSkgPT5cclxuICAgICAgICAgIC8vIERlbGF5IHRoZSBcImZhbHNlXCIgdmFsdWVzIHNvIHRoZXkgZG9uJ3Qgb2NjdXIgd2hpbGUgdGhlIGRvY2sgaXMgYmVpbmcgYW5pbWF0ZWQgY2xvc2VkLlxyXG4gICAgICAgICAgdmlzaWJsZVxyXG4gICAgICAgICAgICA/IE9ic2VydmFibGUub2Yoe2xvY2F0aW9uLCB2aXNpYmxlfSlcclxuICAgICAgICAgICAgOiBPYnNlcnZhYmxlLm9mKHtsb2NhdGlvbiwgdmlzaWJsZX0pLmRlbGF5KDMwMCksXHJcbiAgICAgIClcclxuICAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCd2aXNpYmxlJyksXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgaW5pdGlhbFZpc2liaWxpdGllcyA9IHtcclxuICAgIC8vIFRoZSBjZW50ZXIgaXMgYWx3YXlzIHZpc2libGUuXHJcbiAgICBjZW50ZXI6IHRydWUsXHJcbiAgICBsZWZ0OiBhdG9tLndvcmtzcGFjZS5nZXRMZWZ0RG9jaygpLmlzVmlzaWJsZSgpLFxyXG4gICAgcmlnaHQ6IGF0b20ud29ya3NwYWNlLmdldFJpZ2h0RG9jaygpLmlzVmlzaWJsZSgpLFxyXG4gICAgYm90dG9tOiBhdG9tLndvcmtzcGFjZS5nZXRCb3R0b21Eb2NrKCkuaXNWaXNpYmxlKCksXHJcbiAgfTtcclxuXHJcbiAgLy8gQWNjdW11bGF0ZSB0aGUgZG9jayB2aXNpYmlsaXRpZXMuXHJcbiAgY29uc3QgdmlzaWJpbGl0eVN0YXRlcyA9IE9ic2VydmFibGUubWVyZ2UoLi4udmlzaWJpbGl0aWVzQnlEb2NrKVxyXG4gICAgLnNjYW4oXHJcbiAgICAgIChhY2MsIHtsb2NhdGlvbiwgdmlzaWJsZX0pID0+ICh7XHJcbiAgICAgICAgLi4uYWNjLFxyXG4gICAgICAgIFtsb2NhdGlvbl06IHZpc2libGUsXHJcbiAgICAgIH0pLFxyXG4gICAgICBpbml0aWFsVmlzaWJpbGl0aWVzLFxyXG4gICAgKVxyXG4gICAgLnN0YXJ0V2l0aChpbml0aWFsVmlzaWJpbGl0aWVzKVxyXG4gICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKHNoYWxsb3dFcXVhbClcclxuICAgIC5wdWJsaXNoUmVwbGF5KDEpO1xyXG4gIHZpc2liaWxpdHlTdGF0ZXMuY29ubmVjdCgpO1xyXG5cclxuICByZXR1cm4gdmlzaWJpbGl0eVN0YXRlcztcclxufSk7XHJcblxyXG4vLyBIQUNLOiBNb25rZXktcGF0Y2ggRG9ja3MgaW4gb3JkZXIgdG8gb2JzZXJ2ZSB2aXNpYmlsaXR5IHRvZ2dsaW5nLlxyXG4vLyBUT0RPOiBVc2UgYERvY2s6Om9ic2VydmVWaXNpYmlsaXR5YCBvbmNlIGF0b20vYXRvbSMxNDczNiBpcyBpbiBvdXIgbG93ZXN0LXN1cHBvcnRlZCB2ZXJzaW9uXHJcbmxldCBkb2Nrc1BhdGNoZWQgPSBmYWxzZTtcclxuY29uc3QgZG9ja1N0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XHJcbmZ1bmN0aW9uIHBhdGNoRG9ja3MoKSB7XHJcbiAgaWYgKGRvY2tzUGF0Y2hlZCB8fCB0eXBlb2YgYXRvbS53b3Jrc3BhY2UuZ2V0TGVmdERvY2sgIT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcbiAgZG9ja3NQYXRjaGVkID0gdHJ1ZTtcclxuICBjb25zdCBjdG9yID0gYXRvbS53b3Jrc3BhY2UuZ2V0TGVmdERvY2soKS5jb25zdHJ1Y3RvcjtcclxuICBjb25zdCBwcm90byA9IGN0b3IucHJvdG90eXBlO1xyXG4gIC8vICRGbG93SWdub3JlXHJcbiAgY29uc3Qgb3JpZ2luYWxTZXRTdGF0ZSA9IHByb3RvLnNldFN0YXRlO1xyXG4gIC8vICRGbG93SWdub3JlXHJcbiAgcHJvdG8uc2V0U3RhdGUgPSBmdW5jdGlvbihuZXdTdGF0ZSwgLi4uYXJncykge1xyXG4gICAgb3JpZ2luYWxTZXRTdGF0ZS5jYWxsKHRoaXMsIG5ld1N0YXRlLCAuLi5hcmdzKTtcclxuICAgIGlmIChuZXdTdGF0ZS5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XHJcbiAgICAgIGRvY2tTdGF0ZUNoYW5nZXMubmV4dCh7XHJcbiAgICAgICAgbG9jYXRpb246IHRoaXMuZ2V0TG9jYXRpb24oKSxcclxuICAgICAgICB2aXNpYmxlOiBuZXdTdGF0ZS52aXNpYmxlLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcbiJdfQ==