"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordAtPosition = wordAtPosition;
exports.trimRange = trimRange;
exports.getWordFromMouseEvent = getWordFromMouseEvent;
exports.getWordFromCursorOrSelection = getWordFromCursorOrSelection;

var _atom = require("atom");

var _assert = _interopRequireDefault(require("assert"));

var _range = require("@atom-ide-community/nuclide-commons/range");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Finds the word at the position. You can either provide a word regex yourself,
 * or have Atom use the word regex in force at the scopes at that position,
 * in which case it uses the optional includeNonWordCharacters, default true.
 * (I know that's a weird default but it follows Atom's convention...)
 */
function wordAtPosition(editor, position, wordRegex) {
  let wordRegex_;

  if (wordRegex instanceof RegExp) {
    wordRegex_ = wordRegex;
  } else {
    // What is the word regex associated with the position? We'd like to use
    // atom$Cursor.wordRegExp, except that function gets the regex associated
    // with the editor's current cursor while we want the regex associated with
    // the specific position. So we re-implement it ourselves...
    const nonWordChars = editor.getNonWordCharacters(position);
    const escaped = nonWordChars.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'); // We copied this escaping regex from atom$Cursor.wordRegexp, rather than
    // using the library function 'escapeStringRegExp'. That's because the
    // library function doesn't escape the hyphen character and so is
    // unsuitable for use inside a range.

    let r = `^[\t ]*$|[^\\s${escaped}]+`;

    if (wordRegex == null || wordRegex.includeNonWordCharacters) {
      r += `|[${escaped}]+`;
    }

    wordRegex_ = new RegExp(r, 'g');
  }

  return (0, _range.wordAtPositionFromBuffer)(editor.getBuffer(), position, wordRegex_);
}
/**
 * Gets the trimmed range from a given range, i.e. moves the start and end points
 * to the first and last non-whitespace characters (or specified regex)
 * within the range respectively.
 *
 * @param editor       the editor containing the range
 * @param rangeToTrim  the range to trim
 * @param stopRegex    stop trimming when the first match is found for this regex,
 *   defaults to first non-whitespace character
 * @return atom$Range  the trimmed range
 */


function trimRange(editor, rangeToTrim, stopRegex = /\S/) {
  const buffer = editor.getBuffer();
  let {
    start,
    end
  } = rangeToTrim;
  buffer.scanInRange(stopRegex, rangeToTrim, ({
    range,
    stop
  }) => {
    start = range.start;
    stop();
  });
  buffer.backwardsScanInRange(stopRegex, rangeToTrim, ({
    range,
    stop
  }) => {
    end = range.end;
    stop();
  });
  return new _atom.Range(start, end);
}

function getSingleWordAtPosition(editor, position) {
  const match = wordAtPosition(editor, position); // We should only receive a single identifier from a single point.

  if (match == null || match.wordMatch.length !== 1) {
    return null;
  }

  return match.wordMatch[0];
}
/**
 * Gets the word being right-clicked on in a MouseEvent. A good use case for
 * this is performing an action on a word from a context menu.
 *
 * @param editor  the editor containing the word where the MouseEvent occurred
 *   from
 * @param event   the MouseEvent containing the screen position of the click
 */


function getWordFromMouseEvent(editor, event) {
  // We can't immediately get the identifier right-clicked on from
  // the MouseEvent. Using its target element content would work in
  // some cases but wouldn't work if there was additional content
  // in the same element, such as in a comment.
  const component = editor.getElement().component;
  (0, _assert.default)(component); // This solution doesn't feel ideal but it is the way hyperclick does it.

  const point = component.screenPositionForMouseEvent(event);
  return getSingleWordAtPosition(editor, point);
}
/**
 * Attempts to get a word from the last selection or cursor. A good use case for
 * this is performing an action on an 'active' word after a command is triggered
 * via a keybinding.
 *
 * @param editor  the editor containing the 'active' word when the keybinding is
 *   triggered
 */


function getWordFromCursorOrSelection(editor) {
  const selection = editor.getSelectedText();

  if (selection && selection.length > 0) {
    return selection;
  } // There was no selection so we can go ahead and try the cursor position.


  const point = editor.getCursorScreenPosition();
  return getSingleWordAtPosition(editor, point);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vcmFuZ2UuanMiXSwibmFtZXMiOlsid29yZEF0UG9zaXRpb24iLCJlZGl0b3IiLCJwb3NpdGlvbiIsIndvcmRSZWdleCIsIndvcmRSZWdleF8iLCJSZWdFeHAiLCJub25Xb3JkQ2hhcnMiLCJnZXROb25Xb3JkQ2hhcmFjdGVycyIsImVzY2FwZWQiLCJyZXBsYWNlIiwiciIsImluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVycyIsImdldEJ1ZmZlciIsInRyaW1SYW5nZSIsInJhbmdlVG9UcmltIiwic3RvcFJlZ2V4IiwiYnVmZmVyIiwic3RhcnQiLCJlbmQiLCJzY2FuSW5SYW5nZSIsInJhbmdlIiwic3RvcCIsImJhY2t3YXJkc1NjYW5JblJhbmdlIiwiUmFuZ2UiLCJnZXRTaW5nbGVXb3JkQXRQb3NpdGlvbiIsIm1hdGNoIiwid29yZE1hdGNoIiwibGVuZ3RoIiwiZ2V0V29yZEZyb21Nb3VzZUV2ZW50IiwiZXZlbnQiLCJjb21wb25lbnQiLCJnZXRFbGVtZW50IiwicG9pbnQiLCJzY3JlZW5Qb3NpdGlvbkZvck1vdXNlRXZlbnQiLCJnZXRXb3JkRnJvbUN1cnNvck9yU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0ZWRUZXh0IiwiZ2V0Q3Vyc29yU2NyZWVuUG9zaXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7OztBQWRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsY0FBVCxDQUNMQyxNQURLLEVBRUxDLFFBRkssRUFHTEMsU0FISyxFQUkyQztBQUNoRCxNQUFJQyxVQUFKOztBQUNBLE1BQUlELFNBQVMsWUFBWUUsTUFBekIsRUFBaUM7QUFDL0JELElBQUFBLFVBQVUsR0FBR0QsU0FBYjtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0E7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QUFDUixNQUFWLEdBQW1CLENBQXBDLEVBQXVDO0FBQ3JDLFdBQU9RLFNBQVA7QUFDRCxHQUo0RSxDQU03RTs7O0FBQ0EsUUFBTUgsS0FBSyxHQUFHL0IsTUFBTSxDQUFDb0MsdUJBQVAsRUFBZDtBQUNBLFNBQU9iLHVCQUF1QixDQUFDdkIsTUFBRCxFQUFTK0IsS0FBVCxDQUE5QjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB7UmFuZ2V9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCB7d29yZEF0UG9zaXRpb25Gcm9tQnVmZmVyfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9yYW5nZSc7XHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIHdvcmQgYXQgdGhlIHBvc2l0aW9uLiBZb3UgY2FuIGVpdGhlciBwcm92aWRlIGEgd29yZCByZWdleCB5b3Vyc2VsZixcclxuICogb3IgaGF2ZSBBdG9tIHVzZSB0aGUgd29yZCByZWdleCBpbiBmb3JjZSBhdCB0aGUgc2NvcGVzIGF0IHRoYXQgcG9zaXRpb24sXHJcbiAqIGluIHdoaWNoIGNhc2UgaXQgdXNlcyB0aGUgb3B0aW9uYWwgaW5jbHVkZU5vbldvcmRDaGFyYWN0ZXJzLCBkZWZhdWx0IHRydWUuXHJcbiAqIChJIGtub3cgdGhhdCdzIGEgd2VpcmQgZGVmYXVsdCBidXQgaXQgZm9sbG93cyBBdG9tJ3MgY29udmVudGlvbi4uLilcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB3b3JkQXRQb3NpdGlvbihcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICBwb3NpdGlvbjogYXRvbSRQb2ludE9iamVjdCxcclxuICB3b3JkUmVnZXg/OiBSZWdFeHAgfCB7aW5jbHVkZU5vbldvcmRDaGFyYWN0ZXJzOiBib29sZWFufSxcclxuKTogP3t3b3JkTWF0Y2g6IEFycmF5PHN0cmluZz4sIHJhbmdlOiBhdG9tJFJhbmdlfSB7XHJcbiAgbGV0IHdvcmRSZWdleF87XHJcbiAgaWYgKHdvcmRSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgd29yZFJlZ2V4XyA9IHdvcmRSZWdleDtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gV2hhdCBpcyB0aGUgd29yZCByZWdleCBhc3NvY2lhdGVkIHdpdGggdGhlIHBvc2l0aW9uPyBXZSdkIGxpa2UgdG8gdXNlXHJcbiAgICAvLyBhdG9tJEN1cnNvci53b3JkUmVnRXhwLCBleGNlcHQgdGhhdCBmdW5jdGlvbiBnZXRzIHRoZSByZWdleCBhc3NvY2lhdGVkXHJcbiAgICAvLyB3aXRoIHRoZSBlZGl0b3IncyBjdXJyZW50IGN1cnNvciB3aGlsZSB3ZSB3YW50IHRoZSByZWdleCBhc3NvY2lhdGVkIHdpdGhcclxuICAgIC8vIHRoZSBzcGVjaWZpYyBwb3NpdGlvbi4gU28gd2UgcmUtaW1wbGVtZW50IGl0IG91cnNlbHZlcy4uLlxyXG4gICAgY29uc3Qgbm9uV29yZENoYXJzID0gZWRpdG9yLmdldE5vbldvcmRDaGFyYWN0ZXJzKHBvc2l0aW9uKTtcclxuICAgIGNvbnN0IGVzY2FwZWQgPSBub25Xb3JkQ2hhcnMucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG4gICAgLy8gV2UgY29waWVkIHRoaXMgZXNjYXBpbmcgcmVnZXggZnJvbSBhdG9tJEN1cnNvci53b3JkUmVnZXhwLCByYXRoZXIgdGhhblxyXG4gICAgLy8gdXNpbmcgdGhlIGxpYnJhcnkgZnVuY3Rpb24gJ2VzY2FwZVN0cmluZ1JlZ0V4cCcuIFRoYXQncyBiZWNhdXNlIHRoZVxyXG4gICAgLy8gbGlicmFyeSBmdW5jdGlvbiBkb2Vzbid0IGVzY2FwZSB0aGUgaHlwaGVuIGNoYXJhY3RlciBhbmQgc28gaXNcclxuICAgIC8vIHVuc3VpdGFibGUgZm9yIHVzZSBpbnNpZGUgYSByYW5nZS5cclxuICAgIGxldCByID0gYF5bXFx0IF0qJHxbXlxcXFxzJHtlc2NhcGVkfV0rYDtcclxuICAgIGlmICh3b3JkUmVnZXggPT0gbnVsbCB8fCB3b3JkUmVnZXguaW5jbHVkZU5vbldvcmRDaGFyYWN0ZXJzKSB7XHJcbiAgICAgIHIgKz0gYHxbJHtlc2NhcGVkfV0rYDtcclxuICAgIH1cclxuICAgIHdvcmRSZWdleF8gPSBuZXcgUmVnRXhwKHIsICdnJyk7XHJcbiAgfVxyXG4gIHJldHVybiB3b3JkQXRQb3NpdGlvbkZyb21CdWZmZXIoZWRpdG9yLmdldEJ1ZmZlcigpLCBwb3NpdGlvbiwgd29yZFJlZ2V4Xyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB0cmltbWVkIHJhbmdlIGZyb20gYSBnaXZlbiByYW5nZSwgaS5lLiBtb3ZlcyB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHNcclxuICogdG8gdGhlIGZpcnN0IGFuZCBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgKG9yIHNwZWNpZmllZCByZWdleClcclxuICogd2l0aGluIHRoZSByYW5nZSByZXNwZWN0aXZlbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZGl0b3IgICAgICAgdGhlIGVkaXRvciBjb250YWluaW5nIHRoZSByYW5nZVxyXG4gKiBAcGFyYW0gcmFuZ2VUb1RyaW0gIHRoZSByYW5nZSB0byB0cmltXHJcbiAqIEBwYXJhbSBzdG9wUmVnZXggICAgc3RvcCB0cmltbWluZyB3aGVuIHRoZSBmaXJzdCBtYXRjaCBpcyBmb3VuZCBmb3IgdGhpcyByZWdleCxcclxuICogICBkZWZhdWx0cyB0byBmaXJzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJcclxuICogQHJldHVybiBhdG9tJFJhbmdlICB0aGUgdHJpbW1lZCByYW5nZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyaW1SYW5nZShcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICByYW5nZVRvVHJpbTogYXRvbSRSYW5nZSxcclxuICBzdG9wUmVnZXg6IFJlZ0V4cCA9IC9cXFMvLFxyXG4pOiBhdG9tJFJhbmdlIHtcclxuICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKCk7XHJcbiAgbGV0IHtzdGFydCwgZW5kfSA9IHJhbmdlVG9UcmltO1xyXG4gIGJ1ZmZlci5zY2FuSW5SYW5nZShzdG9wUmVnZXgsIHJhbmdlVG9UcmltLCAoe3JhbmdlLCBzdG9wfSkgPT4ge1xyXG4gICAgc3RhcnQgPSByYW5nZS5zdGFydDtcclxuICAgIHN0b3AoKTtcclxuICB9KTtcclxuICBidWZmZXIuYmFja3dhcmRzU2NhbkluUmFuZ2Uoc3RvcFJlZ2V4LCByYW5nZVRvVHJpbSwgKHtyYW5nZSwgc3RvcH0pID0+IHtcclxuICAgIGVuZCA9IHJhbmdlLmVuZDtcclxuICAgIHN0b3AoKTtcclxuICB9KTtcclxuICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTaW5nbGVXb3JkQXRQb3NpdGlvbihcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICBwb3NpdGlvbjogYXRvbSRQb2ludCxcclxuKTogP3N0cmluZyB7XHJcbiAgY29uc3QgbWF0Y2ggPSB3b3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvc2l0aW9uKTtcclxuICAvLyBXZSBzaG91bGQgb25seSByZWNlaXZlIGEgc2luZ2xlIGlkZW50aWZpZXIgZnJvbSBhIHNpbmdsZSBwb2ludC5cclxuICBpZiAobWF0Y2ggPT0gbnVsbCB8fCBtYXRjaC53b3JkTWF0Y2gubGVuZ3RoICE9PSAxKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHJldHVybiBtYXRjaC53b3JkTWF0Y2hbMF07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSB3b3JkIGJlaW5nIHJpZ2h0LWNsaWNrZWQgb24gaW4gYSBNb3VzZUV2ZW50LiBBIGdvb2QgdXNlIGNhc2UgZm9yXHJcbiAqIHRoaXMgaXMgcGVyZm9ybWluZyBhbiBhY3Rpb24gb24gYSB3b3JkIGZyb20gYSBjb250ZXh0IG1lbnUuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZGl0b3IgIHRoZSBlZGl0b3IgY29udGFpbmluZyB0aGUgd29yZCB3aGVyZSB0aGUgTW91c2VFdmVudCBvY2N1cnJlZFxyXG4gKiAgIGZyb21cclxuICogQHBhcmFtIGV2ZW50ICAgdGhlIE1vdXNlRXZlbnQgY29udGFpbmluZyB0aGUgc2NyZWVuIHBvc2l0aW9uIG9mIHRoZSBjbGlja1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRGcm9tTW91c2VFdmVudChcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICBldmVudDogTW91c2VFdmVudCxcclxuKTogP3N0cmluZyB7XHJcbiAgLy8gV2UgY2FuJ3QgaW1tZWRpYXRlbHkgZ2V0IHRoZSBpZGVudGlmaWVyIHJpZ2h0LWNsaWNrZWQgb24gZnJvbVxyXG4gIC8vIHRoZSBNb3VzZUV2ZW50LiBVc2luZyBpdHMgdGFyZ2V0IGVsZW1lbnQgY29udGVudCB3b3VsZCB3b3JrIGluXHJcbiAgLy8gc29tZSBjYXNlcyBidXQgd291bGRuJ3Qgd29yayBpZiB0aGVyZSB3YXMgYWRkaXRpb25hbCBjb250ZW50XHJcbiAgLy8gaW4gdGhlIHNhbWUgZWxlbWVudCwgc3VjaCBhcyBpbiBhIGNvbW1lbnQuXHJcbiAgY29uc3QgY29tcG9uZW50ID0gZWRpdG9yLmdldEVsZW1lbnQoKS5jb21wb25lbnQ7XHJcbiAgaW52YXJpYW50KGNvbXBvbmVudCk7XHJcbiAgLy8gVGhpcyBzb2x1dGlvbiBkb2Vzbid0IGZlZWwgaWRlYWwgYnV0IGl0IGlzIHRoZSB3YXkgaHlwZXJjbGljayBkb2VzIGl0LlxyXG4gIGNvbnN0IHBvaW50ID0gY29tcG9uZW50LnNjcmVlblBvc2l0aW9uRm9yTW91c2VFdmVudChldmVudCk7XHJcbiAgcmV0dXJuIGdldFNpbmdsZVdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZ2V0IGEgd29yZCBmcm9tIHRoZSBsYXN0IHNlbGVjdGlvbiBvciBjdXJzb3IuIEEgZ29vZCB1c2UgY2FzZSBmb3JcclxuICogdGhpcyBpcyBwZXJmb3JtaW5nIGFuIGFjdGlvbiBvbiBhbiAnYWN0aXZlJyB3b3JkIGFmdGVyIGEgY29tbWFuZCBpcyB0cmlnZ2VyZWRcclxuICogdmlhIGEga2V5YmluZGluZy5cclxuICpcclxuICogQHBhcmFtIGVkaXRvciAgdGhlIGVkaXRvciBjb250YWluaW5nIHRoZSAnYWN0aXZlJyB3b3JkIHdoZW4gdGhlIGtleWJpbmRpbmcgaXNcclxuICogICB0cmlnZ2VyZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRXb3JkRnJvbUN1cnNvck9yU2VsZWN0aW9uKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogP3N0cmluZyB7XHJcbiAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGVkVGV4dCgpO1xyXG4gIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVybiBzZWxlY3Rpb247XHJcbiAgfVxyXG5cclxuICAvLyBUaGVyZSB3YXMgbm8gc2VsZWN0aW9uIHNvIHdlIGNhbiBnbyBhaGVhZCBhbmQgdHJ5IHRoZSBjdXJzb3IgcG9zaXRpb24uXHJcbiAgY29uc3QgcG9pbnQgPSBlZGl0b3IuZ2V0Q3Vyc29yU2NyZWVuUG9zaXRpb24oKTtcclxuICByZXR1cm4gZ2V0U2luZ2xlV29yZEF0UG9zaXRpb24oZWRpdG9yLCBwb2ludCk7XHJcbn1cclxuIl19