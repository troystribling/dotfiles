"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyTextEditsForMultipleFiles = applyTextEditsForMultipleFiles;
exports.applyTextEdits = applyTextEdits;
exports.applyTextEditsToBuffer = applyTextEditsToBuffer;

var _assert = _interopRequireDefault(require("assert"));

var _log4js = require("log4js");

var _textEditor = require("./text-editor");

var _goToLocation = require("./go-to-location");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Attempts to apply the given patches for multiple files. Accepts a Map as input
 * with file paths as keys and a corresponding array of TextEdits as values.
 *
 * It is an error to send overlapping text-edits. All text-edits describe changes
 * made to the initial document version. The order of the edits does not matter
 * as they will be sorted before they are applied.
 *
 * All changes will be applied to the buffers but not saved. If a file is not
 * currently open, it will be opened.
 *
 * If a change is undone (Cmd+Z), only the changes of the current
 * file will be undone. All of the changes for that file will be undone at once.
 *
 * Returns true if the application was successful, otherwise false. If any of
 * the changes fail, for ANY file, then none of the changes are applied.
 */
async function applyTextEditsForMultipleFiles(changes) {
  const paths = Array.from(changes.keys()); // NOTE: There is a race here. If the file contents change while the
  // editors are being opened, then the ranges of the TextEdits will be off.
  // However, currently this is only used to applyEdits to open files.

  const editors = await Promise.all(paths.map(async path => (0, _goToLocation.goToLocation)(path)));
  const checkpoints = editors.map(editor => {
    (0, _assert.default)(editor != null);
    const buffer = editor.getBuffer();
    return [buffer, buffer.createCheckpoint()];
  });
  const allOkay = paths.reduce((successSoFar, path) => {
    const edits = changes.get(path);
    return successSoFar && edits != null && applyTextEdits(path, ...edits);
  }, true);

  if (!allOkay) {
    checkpoints.forEach(([buffer, checkPoint]) => {
      buffer.revertToCheckpoint(checkPoint);
      return false;
    });
  }

  return allOkay;
}
/**
 * Attempts to apply the given patches to the given file.
 *
 * It is an error to send overlapping edits. The order of the edits does not
 * matter (they will be sorted before they are applied).
 *
 * The file must be currently open in Atom, and the changes will be applied to the buffer but not
 * saved.
 *
 * Returns true if the application was successful, otherwise false (e.g. if the oldText did not
 * match).
 */


function applyTextEdits(path, ...edits) {
  const sortedEdits = sortEdits(edits);
  const editor = (0, _textEditor.existingEditorForUri)(path);
  (0, _assert.default)(editor != null);
  return applySortedTextEditsToBuffer(editor.getBuffer(), sortedEdits);
}

function applyTextEditsToBuffer(buffer, edits) {
  return applySortedTextEditsToBuffer(buffer, sortEdits(edits));
}

function applySortedTextEditsToBuffer(buffer, edits) {
  // For every edit, the start of its range will be after the end of the
  // previous edit's range.
  if (editsOverlap(edits)) {
    (0, _log4js.getLogger)('text-edit').warn('applyTextEdits was called with overlapping edits.');
    return false;
  } // Special-case whole-buffer changes to minimize disruption.


  if (edits.length === 1 && edits[0].oldRange.isEqual(buffer.getRange())) {
    if (edits[0].oldText != null && edits[0].oldText !== buffer.getText()) {
      return false;
    }

    buffer.setTextViaDiff(edits[0].newText);
    return true;
  }

  const checkpoint = buffer.createCheckpoint(); // Iterate through in reverse order. Edits earlier in the file can move around text later in the
  // file, so to avoid conflicts edits should be applied last first.

  for (let i = edits.length - 1; i >= 0; i--) {
    const edit = edits[i];
    const success = applyToBuffer(buffer, edit);

    if (!success) {
      buffer.revertToCheckpoint(checkpoint);
      return false;
    }
  }

  buffer.groupChangesSinceCheckpoint(checkpoint);
  return true;
}

function applyToBuffer(buffer, edit) {
  if (edit.oldRange.start.row === edit.oldRange.end.row) {
    // A little extra validation when the old range spans only one line. In particular, this helps
    // when the old range is empty so there is no old text for us to compare against. We can at
    // least abort if the line isn't long enough.
    const lineLength = buffer.lineLengthForRow(edit.oldRange.start.row);

    if (edit.oldRange.end.column > lineLength) {
      return false;
    }
  }

  if (edit.oldText != null) {
    const currentText = buffer.getTextInRange(edit.oldRange);

    if (currentText !== edit.oldText) {
      return false;
    }
  }

  buffer.setTextInRange(edit.oldRange, edit.newText);
  return true;
} // Returns whether an array of sorted TextEdits contain an overlapping range.


function editsOverlap(sortedEdits) {
  for (let i = 0; i < sortedEdits.length - 1; i++) {
    if (sortedEdits[i].oldRange.end.isGreaterThan(sortedEdits[i + 1].oldRange.start)) {
      return true;
    }
  }

  return false;
}

function sortEdits(edits) {
  // stable sort (preserve order of edits starting in the same location)
  return edits.map((edit, i) => [edit, i]).sort(([e1, i1], [e2, i2]) => e1.oldRange.start.compare(e2.oldRange.start) || e1.oldRange.end.compare(e2.oldRange.end) || i1 - i2).map(([edit]) => edit);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vdGV4dC1lZGl0LmpzIl0sIm5hbWVzIjpbImFwcGx5VGV4dEVkaXRzRm9yTXVsdGlwbGVGaWxlcyIsImNoYW5nZXMiLCJwYXRocyIsIkFycmF5IiwiZnJvbSIsImtleXMiLCJlZGl0b3JzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInBhdGgiLCJjaGVja3BvaW50cyIsImVkaXRvciIsImJ1ZmZlciIsImdldEJ1ZmZlciIsImNyZWF0ZUNoZWNrcG9pbnQiLCJhbGxPa2F5IiwicmVkdWNlIiwic3VjY2Vzc1NvRmFyIiwiZWRpdHMiLCJnZXQiLCJhcHBseVRleHRFZGl0cyIsImZvckVhY2giLCJjaGVja1BvaW50IiwicmV2ZXJ0VG9DaGVja3BvaW50Iiwic29ydGVkRWRpdHMiLCJzb3J0RWRpdHMiLCJhcHBseVNvcnRlZFRleHRFZGl0c1RvQnVmZmVyIiwiYXBwbHlUZXh0RWRpdHNUb0J1ZmZlciIsImVkaXRzT3ZlcmxhcCIsIndhcm4iLCJsZW5ndGgiLCJvbGRSYW5nZSIsImlzRXF1YWwiLCJnZXRSYW5nZSIsIm9sZFRleHQiLCJnZXRUZXh0Iiwic2V0VGV4dFZpYURpZmYiLCJuZXdUZXh0IiwiY2hlY2twb2ludCIsImkiLCJlZGl0Iiwic3VjY2VzcyIsImFwcGx5VG9CdWZmZXIiLCJncm91cENoYW5nZXNTaW5jZUNoZWNrcG9pbnQiLCJzdGFydCIsInJvdyIsImVuZCIsImxpbmVMZW5ndGgiLCJsaW5lTGVuZ3RoRm9yUm93IiwiY29sdW1uIiwiY3VycmVudFRleHQiLCJnZXRUZXh0SW5SYW5nZSIsInNldFRleHRJblJhbmdlIiwiaXNHcmVhdGVyVGhhbiIsInNvcnQiLCJlMSIsImkxIiwiZTIiLCJpMiIsImNvbXBhcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWNBOztBQUNBOztBQUVBOztBQUNBOzs7O0FBbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDMUIsUUFBSCxDQUFZYSxLQUF0QyxLQUNBVyxFQUFFLENBQUN4QixRQUFILENBQVllLEdBQVosQ0FBZ0JhLE9BQWhCLENBQXdCRixFQUFFLENBQUMxQixRQUFILENBQVllLEdBQXBDLENBREEsSUFFQVUsRUFBRSxHQUFHRSxFQU5KLEVBUUpsRCxHQVJJLENBUUEsQ0FBQyxDQUFDZ0MsSUFBRCxDQUFELEtBQVlBLElBUlosQ0FBUDtBQVNEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtOdWNsaWRlVXJpfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9udWNsaWRlVXJpJztcclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IHtnZXRMb2dnZXJ9IGZyb20gJ2xvZzRqcyc7XHJcblxyXG5pbXBvcnQge2V4aXN0aW5nRWRpdG9yRm9yVXJpfSBmcm9tICcuL3RleHQtZWRpdG9yJztcclxuaW1wb3J0IHtnb1RvTG9jYXRpb259IGZyb20gJy4vZ28tdG8tbG9jYXRpb24nO1xyXG5cclxuZXhwb3J0IHR5cGUgVGV4dEVkaXQgPSB7XHJcbiAgb2xkUmFuZ2U6IGF0b20kUmFuZ2UsXHJcbiAgbmV3VGV4dDogc3RyaW5nLFxyXG4gIC8vIElmIGluY2x1ZGVkLCB0aGlzIHdpbGwgYmUgdXNlZCB0byB2ZXJpZnkgdGhhdCB0aGUgZWRpdCBzdGlsbCBhcHBsaWVzIGNsZWFubHkuXHJcbiAgb2xkVGV4dD86IHN0cmluZyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBhcHBseSB0aGUgZ2l2ZW4gcGF0Y2hlcyBmb3IgbXVsdGlwbGUgZmlsZXMuIEFjY2VwdHMgYSBNYXAgYXMgaW5wdXRcclxuICogd2l0aCBmaWxlIHBhdGhzIGFzIGtleXMgYW5kIGEgY29ycmVzcG9uZGluZyBhcnJheSBvZiBUZXh0RWRpdHMgYXMgdmFsdWVzLlxyXG4gKlxyXG4gKiBJdCBpcyBhbiBlcnJvciB0byBzZW5kIG92ZXJsYXBwaW5nIHRleHQtZWRpdHMuIEFsbCB0ZXh0LWVkaXRzIGRlc2NyaWJlIGNoYW5nZXNcclxuICogbWFkZSB0byB0aGUgaW5pdGlhbCBkb2N1bWVudCB2ZXJzaW9uLiBUaGUgb3JkZXIgb2YgdGhlIGVkaXRzIGRvZXMgbm90IG1hdHRlclxyXG4gKiBhcyB0aGV5IHdpbGwgYmUgc29ydGVkIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkLlxyXG4gKlxyXG4gKiBBbGwgY2hhbmdlcyB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGJ1ZmZlcnMgYnV0IG5vdCBzYXZlZC4gSWYgYSBmaWxlIGlzIG5vdFxyXG4gKiBjdXJyZW50bHkgb3BlbiwgaXQgd2lsbCBiZSBvcGVuZWQuXHJcbiAqXHJcbiAqIElmIGEgY2hhbmdlIGlzIHVuZG9uZSAoQ21kK1opLCBvbmx5IHRoZSBjaGFuZ2VzIG9mIHRoZSBjdXJyZW50XHJcbiAqIGZpbGUgd2lsbCBiZSB1bmRvbmUuIEFsbCBvZiB0aGUgY2hhbmdlcyBmb3IgdGhhdCBmaWxlIHdpbGwgYmUgdW5kb25lIGF0IG9uY2UuXHJcbiAqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZS4gSWYgYW55IG9mXHJcbiAqIHRoZSBjaGFuZ2VzIGZhaWwsIGZvciBBTlkgZmlsZSwgdGhlbiBub25lIG9mIHRoZSBjaGFuZ2VzIGFyZSBhcHBsaWVkLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFwcGx5VGV4dEVkaXRzRm9yTXVsdGlwbGVGaWxlcyhcclxuICBjaGFuZ2VzOiBNYXA8TnVjbGlkZVVyaSwgQXJyYXk8VGV4dEVkaXQ+PixcclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgY29uc3QgcGF0aHMgPSBBcnJheS5mcm9tKGNoYW5nZXMua2V5cygpKTtcclxuXHJcbiAgLy8gTk9URTogVGhlcmUgaXMgYSByYWNlIGhlcmUuIElmIHRoZSBmaWxlIGNvbnRlbnRzIGNoYW5nZSB3aGlsZSB0aGVcclxuICAvLyBlZGl0b3JzIGFyZSBiZWluZyBvcGVuZWQsIHRoZW4gdGhlIHJhbmdlcyBvZiB0aGUgVGV4dEVkaXRzIHdpbGwgYmUgb2ZmLlxyXG4gIC8vIEhvd2V2ZXIsIGN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB0byBhcHBseUVkaXRzIHRvIG9wZW4gZmlsZXMuXHJcbiAgY29uc3QgZWRpdG9ycyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgcGF0aHMubWFwKGFzeW5jIHBhdGggPT4gZ29Ub0xvY2F0aW9uKHBhdGgpKSxcclxuICApO1xyXG4gIGNvbnN0IGNoZWNrcG9pbnRzID0gZWRpdG9ycy5tYXAoZWRpdG9yID0+IHtcclxuICAgIGludmFyaWFudChlZGl0b3IgIT0gbnVsbCk7XHJcbiAgICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKCk7XHJcbiAgICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmNyZWF0ZUNoZWNrcG9pbnQoKV07XHJcbiAgfSk7XHJcbiAgY29uc3QgYWxsT2theSA9IHBhdGhzLnJlZHVjZSgoc3VjY2Vzc1NvRmFyLCBwYXRoKSA9PiB7XHJcbiAgICBjb25zdCBlZGl0cyA9IGNoYW5nZXMuZ2V0KHBhdGgpO1xyXG4gICAgcmV0dXJuIHN1Y2Nlc3NTb0ZhciAmJiBlZGl0cyAhPSBudWxsICYmIGFwcGx5VGV4dEVkaXRzKHBhdGgsIC4uLmVkaXRzKTtcclxuICB9LCB0cnVlKTtcclxuICBpZiAoIWFsbE9rYXkpIHtcclxuICAgIGNoZWNrcG9pbnRzLmZvckVhY2goKFtidWZmZXIsIGNoZWNrUG9pbnRdKSA9PiB7XHJcbiAgICAgIGJ1ZmZlci5yZXZlcnRUb0NoZWNrcG9pbnQoY2hlY2tQb2ludCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gYWxsT2theTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGVtcHRzIHRvIGFwcGx5IHRoZSBnaXZlbiBwYXRjaGVzIHRvIHRoZSBnaXZlbiBmaWxlLlxyXG4gKlxyXG4gKiBJdCBpcyBhbiBlcnJvciB0byBzZW5kIG92ZXJsYXBwaW5nIGVkaXRzLiBUaGUgb3JkZXIgb2YgdGhlIGVkaXRzIGRvZXMgbm90XHJcbiAqIG1hdHRlciAodGhleSB3aWxsIGJlIHNvcnRlZCBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCkuXHJcbiAqXHJcbiAqIFRoZSBmaWxlIG11c3QgYmUgY3VycmVudGx5IG9wZW4gaW4gQXRvbSwgYW5kIHRoZSBjaGFuZ2VzIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgYnVmZmVyIGJ1dCBub3RcclxuICogc2F2ZWQuXHJcbiAqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwsIG90aGVyd2lzZSBmYWxzZSAoZS5nLiBpZiB0aGUgb2xkVGV4dCBkaWQgbm90XHJcbiAqIG1hdGNoKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRleHRFZGl0cyhcclxuICBwYXRoOiBOdWNsaWRlVXJpLFxyXG4gIC4uLmVkaXRzOiBBcnJheTxUZXh0RWRpdD5cclxuKTogYm9vbGVhbiB7XHJcbiAgY29uc3Qgc29ydGVkRWRpdHMgPSBzb3J0RWRpdHMoZWRpdHMpO1xyXG4gIGNvbnN0IGVkaXRvciA9IGV4aXN0aW5nRWRpdG9yRm9yVXJpKHBhdGgpO1xyXG4gIGludmFyaWFudChlZGl0b3IgIT0gbnVsbCk7XHJcbiAgcmV0dXJuIGFwcGx5U29ydGVkVGV4dEVkaXRzVG9CdWZmZXIoZWRpdG9yLmdldEJ1ZmZlcigpLCBzb3J0ZWRFZGl0cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVRleHRFZGl0c1RvQnVmZmVyKFxyXG4gIGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyIHwgc2ltcGxlVGV4dEJ1ZmZlciRUZXh0QnVmZmVyLFxyXG4gIGVkaXRzOiBBcnJheTxUZXh0RWRpdD4sXHJcbik6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBhcHBseVNvcnRlZFRleHRFZGl0c1RvQnVmZmVyKGJ1ZmZlciwgc29ydEVkaXRzKGVkaXRzKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5U29ydGVkVGV4dEVkaXRzVG9CdWZmZXIoXHJcbiAgYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIgfCBzaW1wbGVUZXh0QnVmZmVyJFRleHRCdWZmZXIsXHJcbiAgZWRpdHM6IEFycmF5PFRleHRFZGl0PixcclxuKTogYm9vbGVhbiB7XHJcbiAgLy8gRm9yIGV2ZXJ5IGVkaXQsIHRoZSBzdGFydCBvZiBpdHMgcmFuZ2Ugd2lsbCBiZSBhZnRlciB0aGUgZW5kIG9mIHRoZVxyXG4gIC8vIHByZXZpb3VzIGVkaXQncyByYW5nZS5cclxuICBpZiAoZWRpdHNPdmVybGFwKGVkaXRzKSkge1xyXG4gICAgZ2V0TG9nZ2VyKCd0ZXh0LWVkaXQnKS53YXJuKFxyXG4gICAgICAnYXBwbHlUZXh0RWRpdHMgd2FzIGNhbGxlZCB3aXRoIG92ZXJsYXBwaW5nIGVkaXRzLicsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICAvLyBTcGVjaWFsLWNhc2Ugd2hvbGUtYnVmZmVyIGNoYW5nZXMgdG8gbWluaW1pemUgZGlzcnVwdGlvbi5cclxuICBpZiAoZWRpdHMubGVuZ3RoID09PSAxICYmIGVkaXRzWzBdLm9sZFJhbmdlLmlzRXF1YWwoYnVmZmVyLmdldFJhbmdlKCkpKSB7XHJcbiAgICBpZiAoZWRpdHNbMF0ub2xkVGV4dCAhPSBudWxsICYmIGVkaXRzWzBdLm9sZFRleHQgIT09IGJ1ZmZlci5nZXRUZXh0KCkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYnVmZmVyLnNldFRleHRWaWFEaWZmKGVkaXRzWzBdLm5ld1RleHQpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjaGVja3BvaW50ID0gYnVmZmVyLmNyZWF0ZUNoZWNrcG9pbnQoKTtcclxuXHJcbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGluIHJldmVyc2Ugb3JkZXIuIEVkaXRzIGVhcmxpZXIgaW4gdGhlIGZpbGUgY2FuIG1vdmUgYXJvdW5kIHRleHQgbGF0ZXIgaW4gdGhlXHJcbiAgLy8gZmlsZSwgc28gdG8gYXZvaWQgY29uZmxpY3RzIGVkaXRzIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QgZmlyc3QuXHJcbiAgZm9yIChsZXQgaSA9IGVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICBjb25zdCBlZGl0ID0gZWRpdHNbaV07XHJcbiAgICBjb25zdCBzdWNjZXNzID0gYXBwbHlUb0J1ZmZlcihidWZmZXIsIGVkaXQpO1xyXG4gICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgIGJ1ZmZlci5yZXZlcnRUb0NoZWNrcG9pbnQoY2hlY2twb2ludCk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGJ1ZmZlci5ncm91cENoYW5nZXNTaW5jZUNoZWNrcG9pbnQoY2hlY2twb2ludCk7XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9CdWZmZXIoXHJcbiAgYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIgfCBzaW1wbGVUZXh0QnVmZmVyJFRleHRCdWZmZXIsXHJcbiAgZWRpdDogVGV4dEVkaXQsXHJcbik6IGJvb2xlYW4ge1xyXG4gIGlmIChlZGl0Lm9sZFJhbmdlLnN0YXJ0LnJvdyA9PT0gZWRpdC5vbGRSYW5nZS5lbmQucm93KSB7XHJcbiAgICAvLyBBIGxpdHRsZSBleHRyYSB2YWxpZGF0aW9uIHdoZW4gdGhlIG9sZCByYW5nZSBzcGFucyBvbmx5IG9uZSBsaW5lLiBJbiBwYXJ0aWN1bGFyLCB0aGlzIGhlbHBzXHJcbiAgICAvLyB3aGVuIHRoZSBvbGQgcmFuZ2UgaXMgZW1wdHkgc28gdGhlcmUgaXMgbm8gb2xkIHRleHQgZm9yIHVzIHRvIGNvbXBhcmUgYWdhaW5zdC4gV2UgY2FuIGF0XHJcbiAgICAvLyBsZWFzdCBhYm9ydCBpZiB0aGUgbGluZSBpc24ndCBsb25nIGVub3VnaC5cclxuICAgIGNvbnN0IGxpbmVMZW5ndGggPSBidWZmZXIubGluZUxlbmd0aEZvclJvdyhlZGl0Lm9sZFJhbmdlLnN0YXJ0LnJvdyk7XHJcbiAgICBpZiAoZWRpdC5vbGRSYW5nZS5lbmQuY29sdW1uID4gbGluZUxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChlZGl0Lm9sZFRleHQgIT0gbnVsbCkge1xyXG4gICAgY29uc3QgY3VycmVudFRleHQgPSBidWZmZXIuZ2V0VGV4dEluUmFuZ2UoZWRpdC5vbGRSYW5nZSk7XHJcbiAgICBpZiAoY3VycmVudFRleHQgIT09IGVkaXQub2xkVGV4dCkge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGJ1ZmZlci5zZXRUZXh0SW5SYW5nZShlZGl0Lm9sZFJhbmdlLCBlZGl0Lm5ld1RleHQpO1xyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vLyBSZXR1cm5zIHdoZXRoZXIgYW4gYXJyYXkgb2Ygc29ydGVkIFRleHRFZGl0cyBjb250YWluIGFuIG92ZXJsYXBwaW5nIHJhbmdlLlxyXG5mdW5jdGlvbiBlZGl0c092ZXJsYXAoc29ydGVkRWRpdHM6IEFycmF5PFRleHRFZGl0Pik6IGJvb2xlYW4ge1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkRWRpdHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHNvcnRlZEVkaXRzW2ldLm9sZFJhbmdlLmVuZC5pc0dyZWF0ZXJUaGFuKFxyXG4gICAgICAgIHNvcnRlZEVkaXRzW2kgKyAxXS5vbGRSYW5nZS5zdGFydCxcclxuICAgICAgKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNvcnRFZGl0cyhlZGl0czogQXJyYXk8VGV4dEVkaXQ+KTogQXJyYXk8VGV4dEVkaXQ+IHtcclxuICAvLyBzdGFibGUgc29ydCAocHJlc2VydmUgb3JkZXIgb2YgZWRpdHMgc3RhcnRpbmcgaW4gdGhlIHNhbWUgbG9jYXRpb24pXHJcbiAgcmV0dXJuIGVkaXRzXHJcbiAgICAubWFwKChlZGl0LCBpKSA9PiBbZWRpdCwgaV0pXHJcbiAgICAuc29ydChcclxuICAgICAgKFtlMSwgaTFdLCBbZTIsIGkyXSkgPT5cclxuICAgICAgICBlMS5vbGRSYW5nZS5zdGFydC5jb21wYXJlKGUyLm9sZFJhbmdlLnN0YXJ0KSB8fFxyXG4gICAgICAgIGUxLm9sZFJhbmdlLmVuZC5jb21wYXJlKGUyLm9sZFJhbmdlLmVuZCkgfHxcclxuICAgICAgICBpMSAtIGkyLFxyXG4gICAgKVxyXG4gICAgLm1hcCgoW2VkaXRdKSA9PiBlZGl0KTtcclxufVxyXG4iXX0=