"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.existingEditorForUri = existingEditorForUri;
exports.existingEditorForBuffer = existingEditorForBuffer;
exports.getViewOfEditor = getViewOfEditor;
exports.getScrollTop = getScrollTop;
exports.setScrollTop = setScrollTop;
exports.setPositionAndScroll = setPositionAndScroll;
exports.getCursorPositions = getCursorPositions;
exports.observeEditorDestroy = observeEditorDestroy;
exports.enforceReadOnlyEditor = enforceReadOnlyEditor;
exports.enforceSoftWrap = enforceSoftWrap;
exports.isValidTextEditor = isValidTextEditor;
exports.centerScrollToBufferLine = centerScrollToBufferLine;

var _assert = _interopRequireDefault(require("assert"));

var _atom = require("atom");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _event = require("@atom-ide-community/nuclide-commons/event");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Returns a text editor that has the given path open, or null if none exists. If there are multiple
 * text editors for this path, one is chosen arbitrarily.
 */
function existingEditorForUri(path) {
  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a
  // real problem. And if you have more than a few hundred you probably have bigger problems.
  for (const editor of atom.workspace.getTextEditors()) {
    if (editor.getPath() === path) {
      return editor;
    }
  }

  return null;
}
/**
 * Returns a text editor that has the given buffer open, or null if none exists. If there are
 * multiple text editors for this buffer, one is chosen arbitrarily.
 */


function existingEditorForBuffer(buffer) {
  // This isn't ideal but realistically iterating through even a few hundred editors shouldn't be a
  // real problem. And if you have more than a few hundred you probably have bigger problems.
  for (const editor of atom.workspace.getTextEditors()) {
    if (editor.getBuffer() === buffer) {
      return editor;
    }
  }

  return null;
}

function getViewOfEditor(editor) {
  return atom.views.getView(editor);
}

function getScrollTop(editor) {
  return getViewOfEditor(editor).getScrollTop();
}

function setScrollTop(editor, scrollTop) {
  getViewOfEditor(editor).setScrollTop(scrollTop);
}
/**
 * Does a best effort to set an editor pane to a given cursor position & scroll.
 * Does not ensure that the current cursor position is visible.
 *
 * Can be used with editor.getCursorBufferPosition() & getScrollTop() to restore
 * an editors cursor and scroll.
 */


function setPositionAndScroll(editor, position, scrollTop) {
  editor.setCursorBufferPosition(position, {
    autoscroll: false
  });
  setScrollTop(editor, scrollTop);
}

function getCursorPositions(editor) {
  return _rxjsCompatUmdMin.Observable.defer(() => {
    // This will behave strangely in the face of multiple cursors. Consider supporting multiple
    // cursors in the future.
    const cursor = editor.getCursors()[0];
    (0, _assert.default)(cursor != null);
    return _rxjsCompatUmdMin.Observable.merge(_rxjsCompatUmdMin.Observable.of(cursor.getBufferPosition()), (0, _event.observableFromSubscribeFunction)(cursor.onDidChangePosition.bind(cursor)).map(event => event.newBufferPosition));
  });
}

function observeEditorDestroy(editor) {
  return (0, _event.observableFromSubscribeFunction)(editor.onDidDestroy.bind(editor)).map(event => editor).take(1);
} // Use atom readOnly attribute to set read-only state.


function enforceReadOnlyEditor(textEditor, readOnlyExceptions = ['append', 'setText']) {
  textEditor.getElement().setAttribute('readonly', '');
  return {
    dispose() {
      textEditor.getElement().removeAttribute('readonly');
    }

  };
} // Turn off soft wrap setting for these editors so diffs properly align.
// Some text editor register sometimes override the set soft wrapping
// after mounting an editor to the workspace - here, that's watched and reset to `false`.


function enforceSoftWrap(editor, enforcedSoftWrap) {
  editor.setSoftWrapped(enforcedSoftWrap);
  return editor.onDidChangeSoftWrapped(softWrapped => {
    if (softWrapped !== enforcedSoftWrap) {
      // Reset the overridden softWrap to `false` once the operation completes.
      process.nextTick(() => {
        if (!editor.isDestroyed()) {
          editor.setSoftWrapped(enforcedSoftWrap);
        }
      });
    }
  });
}
/**
 * Checks if an object (typically an Atom pane) is a TextEditor.
 * Could be replaced with atom.workspace.isValidTextEditor,
 * but Flow doesn't support %checks in methods yet.
 */


function isValidTextEditor(item) {
  return item instanceof _atom.TextEditor;
}

function centerScrollToBufferLine(textEditorElement, bufferLineNumber) {
  const textEditor = textEditorElement.getModel();
  const pixelPositionTop = textEditorElement.pixelPositionForBufferPosition([bufferLineNumber, 0]).top; // Manually calculate the scroll location, instead of using
  // `textEditor.scrollToBufferPosition([lineNumber, 0], {center: true})`
  // because that API to wouldn't center the line if it was in the visible screen range.

  const scrollTop = pixelPositionTop + textEditor.getLineHeightInPixels() / 2 - textEditorElement.clientHeight / 2;
  textEditorElement.setScrollTop(Math.max(scrollTop, 1));
  textEditorElement.focus();
  textEditor.setCursorBufferPosition([bufferLineNumber, 0], {
    autoscroll: false
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vdGV4dC1lZGl0b3IuanMiXSwibmFtZXMiOlsiZXhpc3RpbmdFZGl0b3JGb3JVcmkiLCJwYXRoIiwiZWRpdG9yIiwiYXRvbSIsIndvcmtzcGFjZSIsImdldFRleHRFZGl0b3JzIiwiZ2V0UGF0aCIsImV4aXN0aW5nRWRpdG9yRm9yQnVmZmVyIiwiYnVmZmVyIiwiZ2V0QnVmZmVyIiwiZ2V0Vmlld09mRWRpdG9yIiwidmlld3MiLCJnZXRWaWV3IiwiZ2V0U2Nyb2xsVG9wIiwic2V0U2Nyb2xsVG9wIiwic2Nyb2xsVG9wIiwic2V0UG9zaXRpb25BbmRTY3JvbGwiLCJwb3NpdGlvbiIsInNldEN1cnNvckJ1ZmZlclBvc2l0aW9uIiwiYXV0b3Njcm9sbCIsImdldEN1cnNvclBvc2l0aW9ucyIsIk9ic2VydmFibGUiLCJkZWZlciIsImN1cnNvciIsImdldEN1cnNvcnMiLCJtZXJnZSIsIm9mIiwiZ2V0QnVmZmVyUG9zaXRpb24iLCJvbkRpZENoYW5nZVBvc2l0aW9uIiwiYmluZCIsIm1hcCIsImV2ZW50IiwibmV3QnVmZmVyUG9zaXRpb24iLCJvYnNlcnZlRWRpdG9yRGVzdHJveSIsIm9uRGlkRGVzdHJveSIsInRha2UiLCJlbmZvcmNlUmVhZE9ubHlFZGl0b3IiLCJ0ZXh0RWRpdG9yIiwicmVhZE9ubHlFeGNlcHRpb25zIiwiZ2V0RWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImRpc3Bvc2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJlbmZvcmNlU29mdFdyYXAiLCJlbmZvcmNlZFNvZnRXcmFwIiwic2V0U29mdFdyYXBwZWQiLCJvbkRpZENoYW5nZVNvZnRXcmFwcGVkIiwic29mdFdyYXBwZWQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJpc0Rlc3Ryb3llZCIsImlzVmFsaWRUZXh0RWRpdG9yIiwiaXRlbSIsIlRleHRFZGl0b3IiLCJjZW50ZXJTY3JvbGxUb0J1ZmZlckxpbmUiLCJ0ZXh0RWRpdG9yRWxlbWVudCIsImJ1ZmZlckxpbmVOdW1iZXIiLCJnZXRNb2RlbCIsInBpeGVsUG9zaXRpb25Ub3AiLCJwaXhlbFBvc2l0aW9uRm9yQnVmZmVyUG9zaXRpb24iLCJ0b3AiLCJnZXRMaW5lSGVpZ2h0SW5QaXhlbHMiLCJjbGllbnRIZWlnaHQiLCJNYXRoIiwibWF4IiwiZm9jdXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTQSxvQkFBVCxDQUE4QkMsSUFBOUIsRUFBa0U7QUFDdkU7QUFDQTtBQUNBLE9BQUssTUFBTUMsTUFBWCxJQUFxQkMsSUFBSSxDQUFDQyxTQUFMLENBQWVDLGNBQWYsRUFBckIsRUFBc0Q7QUFDcEQsUUFBSUgsTUFBTSxDQUFDSSxPQUFQLE9BQXFCTCxJQUF6QixFQUErQjtBQUM3QixhQUFPQyxNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTSyx1QkFBVCxDQUNMQyxNQURLLEVBRWE7QUFDbEI7QUFDQTtBQUNBLE9BQUssTUFBTU4sTUFBWCxJQUFxQkMsSUFBSSxDQUFDQyxTQUFMLENBQWVDLGNBQWYsRUFBckIsRUFBc0Q7QUFDcEQsUUFBSUgsTUFBTSxDQUFDTyxTQUFQLE9BQXVCRCxNQUEzQixFQUFtQztBQUNqQyxhQUFPTixNQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFTSxTQUFTUSxlQUFULENBQ0xSLE1BREssRUFFbUI7QUFDeEIsU0FBT0MsSUFBSSxDQUFDUSxLQUFMLENBQVdDLE9BQVgsQ0FBbUJWLE1BQW5CLENBQVA7QUFDRDs7QUFFTSxTQUFTVyxZQUFULENBQXNCWCxNQUF0QixFQUF1RDtBQUM1RCxTQUFPUSxlQUFlLENBQUNSLE1BQUQsQ0FBZixDQUF3QlcsWUFBeEIs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R3RCSSxHQUhILENBRk0sQ0FNTjtBQUNBO0FBQ0E7O0FBQ0EsUUFBTTdDLFNBQVMsR0FDYjJDLGdCQUFnQixHQUNoQnJCLFVBQVUsQ0FBQ3dCLHFCQUFYLEtBQXFDLENBRHJDLEdBRUFOLGlCQUFpQixDQUFDTyxZQUFsQixHQUFpQyxDQUhuQztBQUlBUCxFQUFBQSxpQkFBaUIsQ0FBQ3pDLFlBQWxCLENBQStCaUQsSUFBSSxDQUFDQyxHQUFMLENBQVNqRCxTQUFULEVBQW9CLENBQXBCLENBQS9CO0FBRUF3QyxFQUFBQSxpQkFBaUIsQ0FBQ1UsS0FBbEI7QUFFQTVCLEVBQUFBLFVBQVUsQ0FBQ25CLHVCQUFYLENBQW1DLENBQUNzQyxnQkFBRCxFQUFtQixDQUFuQixDQUFuQyxFQUEwRDtBQUN4RHJDLElBQUFBLFVBQVUsRUFBRTtBQUQ0QyxHQUExRDtBQUdEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL251Y2xpZGVVcmknO1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcblxyXG5pbXBvcnQge29ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb259IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2V2ZW50JztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdGV4dCBlZGl0b3IgdGhhdCBoYXMgdGhlIGdpdmVuIHBhdGggb3Blbiwgb3IgbnVsbCBpZiBub25lIGV4aXN0cy4gSWYgdGhlcmUgYXJlIG11bHRpcGxlXHJcbiAqIHRleHQgZWRpdG9ycyBmb3IgdGhpcyBwYXRoLCBvbmUgaXMgY2hvc2VuIGFyYml0cmFyaWx5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0aW5nRWRpdG9yRm9yVXJpKHBhdGg6IE51Y2xpZGVVcmkpOiA/YXRvbSRUZXh0RWRpdG9yIHtcclxuICAvLyBUaGlzIGlzbid0IGlkZWFsIGJ1dCByZWFsaXN0aWNhbGx5IGl0ZXJhdGluZyB0aHJvdWdoIGV2ZW4gYSBmZXcgaHVuZHJlZCBlZGl0b3JzIHNob3VsZG4ndCBiZSBhXHJcbiAgLy8gcmVhbCBwcm9ibGVtLiBBbmQgaWYgeW91IGhhdmUgbW9yZSB0aGFuIGEgZmV3IGh1bmRyZWQgeW91IHByb2JhYmx5IGhhdmUgYmlnZ2VyIHByb2JsZW1zLlxyXG4gIGZvciAoY29uc3QgZWRpdG9yIG9mIGF0b20ud29ya3NwYWNlLmdldFRleHRFZGl0b3JzKCkpIHtcclxuICAgIGlmIChlZGl0b3IuZ2V0UGF0aCgpID09PSBwYXRoKSB7XHJcbiAgICAgIHJldHVybiBlZGl0b3I7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB0ZXh0IGVkaXRvciB0aGF0IGhhcyB0aGUgZ2l2ZW4gYnVmZmVyIG9wZW4sIG9yIG51bGwgaWYgbm9uZSBleGlzdHMuIElmIHRoZXJlIGFyZVxyXG4gKiBtdWx0aXBsZSB0ZXh0IGVkaXRvcnMgZm9yIHRoaXMgYnVmZmVyLCBvbmUgaXMgY2hvc2VuIGFyYml0cmFyaWx5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0aW5nRWRpdG9yRm9yQnVmZmVyKFxyXG4gIGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyLFxyXG4pOiA/YXRvbSRUZXh0RWRpdG9yIHtcclxuICAvLyBUaGlzIGlzbid0IGlkZWFsIGJ1dCByZWFsaXN0aWNhbGx5IGl0ZXJhdGluZyB0aHJvdWdoIGV2ZW4gYSBmZXcgaHVuZHJlZCBlZGl0b3JzIHNob3VsZG4ndCBiZSBhXHJcbiAgLy8gcmVhbCBwcm9ibGVtLiBBbmQgaWYgeW91IGhhdmUgbW9yZSB0aGFuIGEgZmV3IGh1bmRyZWQgeW91IHByb2JhYmx5IGhhdmUgYmlnZ2VyIHByb2JsZW1zLlxyXG4gIGZvciAoY29uc3QgZWRpdG9yIG9mIGF0b20ud29ya3NwYWNlLmdldFRleHRFZGl0b3JzKCkpIHtcclxuICAgIGlmIChlZGl0b3IuZ2V0QnVmZmVyKCkgPT09IGJ1ZmZlcikge1xyXG4gICAgICByZXR1cm4gZWRpdG9yO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3T2ZFZGl0b3IoXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbik6IGF0b20kVGV4dEVkaXRvckVsZW1lbnQge1xyXG4gIHJldHVybiBhdG9tLnZpZXdzLmdldFZpZXcoZWRpdG9yKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbFRvcChlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IG51bWJlciB7XHJcbiAgcmV0dXJuIGdldFZpZXdPZkVkaXRvcihlZGl0b3IpLmdldFNjcm9sbFRvcCgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0U2Nyb2xsVG9wKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBzY3JvbGxUb3A6IG51bWJlcik6IHZvaWQge1xyXG4gIGdldFZpZXdPZkVkaXRvcihlZGl0b3IpLnNldFNjcm9sbFRvcChzY3JvbGxUb3ApO1xyXG59XHJcblxyXG4vKipcclxuICogRG9lcyBhIGJlc3QgZWZmb3J0IHRvIHNldCBhbiBlZGl0b3IgcGFuZSB0byBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiAmIHNjcm9sbC5cclxuICogRG9lcyBub3QgZW5zdXJlIHRoYXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGlzIHZpc2libGUuXHJcbiAqXHJcbiAqIENhbiBiZSB1c2VkIHdpdGggZWRpdG9yLmdldEN1cnNvckJ1ZmZlclBvc2l0aW9uKCkgJiBnZXRTY3JvbGxUb3AoKSB0byByZXN0b3JlXHJcbiAqIGFuIGVkaXRvcnMgY3Vyc29yIGFuZCBzY3JvbGwuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9zaXRpb25BbmRTY3JvbGwoXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgcG9zaXRpb246IGF0b20kUG9pbnQsXHJcbiAgc2Nyb2xsVG9wOiBudW1iZXIsXHJcbik6IHZvaWQge1xyXG4gIGVkaXRvci5zZXRDdXJzb3JCdWZmZXJQb3NpdGlvbihwb3NpdGlvbiwge2F1dG9zY3JvbGw6IGZhbHNlfSk7XHJcbiAgc2V0U2Nyb2xsVG9wKGVkaXRvciwgc2Nyb2xsVG9wKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnNvclBvc2l0aW9ucyhcclxuICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuKTogT2JzZXJ2YWJsZTxhdG9tJFBvaW50PiB7XHJcbiAgcmV0dXJuIE9ic2VydmFibGUuZGVmZXIoKCkgPT4ge1xyXG4gICAgLy8gVGhpcyB3aWxsIGJlaGF2ZSBzdHJhbmdlbHkgaW4gdGhlIGZhY2Ugb2YgbXVsdGlwbGUgY3Vyc29ycy4gQ29uc2lkZXIgc3VwcG9ydGluZyBtdWx0aXBsZVxyXG4gICAgLy8gY3Vyc29ycyBpbiB0aGUgZnV0dXJlLlxyXG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcnMoKVswXTtcclxuICAgIGludmFyaWFudChjdXJzb3IgIT0gbnVsbCk7XHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgICAgT2JzZXJ2YWJsZS5vZihjdXJzb3IuZ2V0QnVmZmVyUG9zaXRpb24oKSksXHJcbiAgICAgIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oXHJcbiAgICAgICAgY3Vyc29yLm9uRGlkQ2hhbmdlUG9zaXRpb24uYmluZChjdXJzb3IpLFxyXG4gICAgICApLm1hcChldmVudCA9PiBldmVudC5uZXdCdWZmZXJQb3NpdGlvbiksXHJcbiAgICApO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZUVkaXRvckRlc3Ryb3koXHJcbiAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbik6IE9ic2VydmFibGU8YXRvbSRUZXh0RWRpdG9yPiB7XHJcbiAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oZWRpdG9yLm9uRGlkRGVzdHJveS5iaW5kKGVkaXRvcikpXHJcbiAgICAubWFwKGV2ZW50ID0+IGVkaXRvcilcclxuICAgIC50YWtlKDEpO1xyXG59XHJcblxyXG4vLyBVc2UgYXRvbSByZWFkT25seSBhdHRyaWJ1dGUgdG8gc2V0IHJlYWQtb25seSBzdGF0ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuZm9yY2VSZWFkT25seUVkaXRvcihcclxuICB0ZXh0RWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgcmVhZE9ubHlFeGNlcHRpb25zPzogQXJyYXk8c3RyaW5nPiA9IFsnYXBwZW5kJywgJ3NldFRleHQnXSxcclxuKTogSURpc3Bvc2FibGUge1xyXG4gIHRleHRFZGl0b3IuZ2V0RWxlbWVudCgpLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XHJcbiAgcmV0dXJuIHtcclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIHRleHRFZGl0b3IuZ2V0RWxlbWVudCgpLnJlbW92ZUF0dHJpYnV0ZSgncmVhZG9ubHknKTtcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG5cclxuLy8gVHVybiBvZmYgc29mdCB3cmFwIHNldHRpbmcgZm9yIHRoZXNlIGVkaXRvcnMgc28gZGlmZnMgcHJvcGVybHkgYWxpZ24uXHJcbi8vIFNvbWUgdGV4dCBlZGl0b3IgcmVnaXN0ZXIgc29tZXRpbWVzIG92ZXJyaWRlIHRoZSBzZXQgc29mdCB3cmFwcGluZ1xyXG4vLyBhZnRlciBtb3VudGluZyBhbiBlZGl0b3IgdG8gdGhlIHdvcmtzcGFjZSAtIGhlcmUsIHRoYXQncyB3YXRjaGVkIGFuZCByZXNldCB0byBgZmFsc2VgLlxyXG5leHBvcnQgZnVuY3Rpb24gZW5mb3JjZVNvZnRXcmFwKFxyXG4gIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gIGVuZm9yY2VkU29mdFdyYXA6IGJvb2xlYW4sXHJcbik6IElEaXNwb3NhYmxlIHtcclxuICBlZGl0b3Iuc2V0U29mdFdyYXBwZWQoZW5mb3JjZWRTb2Z0V3JhcCk7XHJcbiAgcmV0dXJuIGVkaXRvci5vbkRpZENoYW5nZVNvZnRXcmFwcGVkKHNvZnRXcmFwcGVkID0+IHtcclxuICAgIGlmIChzb2Z0V3JhcHBlZCAhPT0gZW5mb3JjZWRTb2Z0V3JhcCkge1xyXG4gICAgICAvLyBSZXNldCB0aGUgb3ZlcnJpZGRlbiBzb2Z0V3JhcCB0byBgZmFsc2VgIG9uY2UgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXHJcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKCkpIHtcclxuICAgICAgICAgIGVkaXRvci5zZXRTb2Z0V3JhcHBlZChlbmZvcmNlZFNvZnRXcmFwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCAodHlwaWNhbGx5IGFuIEF0b20gcGFuZSkgaXMgYSBUZXh0RWRpdG9yLlxyXG4gKiBDb3VsZCBiZSByZXBsYWNlZCB3aXRoIGF0b20ud29ya3NwYWNlLmlzVmFsaWRUZXh0RWRpdG9yLFxyXG4gKiBidXQgRmxvdyBkb2Vzbid0IHN1cHBvcnQgJWNoZWNrcyBpbiBtZXRob2RzIHlldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVGV4dEVkaXRvcihpdGVtOiBtaXhlZCk6IGJvb2xlYW4gJWNoZWNrcyB7XHJcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBUZXh0RWRpdG9yO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2VudGVyU2Nyb2xsVG9CdWZmZXJMaW5lKFxyXG4gIHRleHRFZGl0b3JFbGVtZW50OiBhdG9tJFRleHRFZGl0b3JFbGVtZW50LFxyXG4gIGJ1ZmZlckxpbmVOdW1iZXI6IG51bWJlcixcclxuKTogdm9pZCB7XHJcbiAgY29uc3QgdGV4dEVkaXRvciA9IHRleHRFZGl0b3JFbGVtZW50LmdldE1vZGVsKCk7XHJcbiAgY29uc3QgcGl4ZWxQb3NpdGlvblRvcCA9IHRleHRFZGl0b3JFbGVtZW50LnBpeGVsUG9zaXRpb25Gb3JCdWZmZXJQb3NpdGlvbihbXHJcbiAgICBidWZmZXJMaW5lTnVtYmVyLFxyXG4gICAgMCxcclxuICBdKS50b3A7XHJcbiAgLy8gTWFudWFsbHkgY2FsY3VsYXRlIHRoZSBzY3JvbGwgbG9jYXRpb24sIGluc3RlYWQgb2YgdXNpbmdcclxuICAvLyBgdGV4dEVkaXRvci5zY3JvbGxUb0J1ZmZlclBvc2l0aW9uKFtsaW5lTnVtYmVyLCAwXSwge2NlbnRlcjogdHJ1ZX0pYFxyXG4gIC8vIGJlY2F1c2UgdGhhdCBBUEkgdG8gd291bGRuJ3QgY2VudGVyIHRoZSBsaW5lIGlmIGl0IHdhcyBpbiB0aGUgdmlzaWJsZSBzY3JlZW4gcmFuZ2UuXHJcbiAgY29uc3Qgc2Nyb2xsVG9wID1cclxuICAgIHBpeGVsUG9zaXRpb25Ub3AgK1xyXG4gICAgdGV4dEVkaXRvci5nZXRMaW5lSGVpZ2h0SW5QaXhlbHMoKSAvIDIgLVxyXG4gICAgdGV4dEVkaXRvckVsZW1lbnQuY2xpZW50SGVpZ2h0IC8gMjtcclxuICB0ZXh0RWRpdG9yRWxlbWVudC5zZXRTY3JvbGxUb3AoTWF0aC5tYXgoc2Nyb2xsVG9wLCAxKSk7XHJcblxyXG4gIHRleHRFZGl0b3JFbGVtZW50LmZvY3VzKCk7XHJcblxyXG4gIHRleHRFZGl0b3Iuc2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24oW2J1ZmZlckxpbmVOdW1iZXIsIDBdLCB7XHJcbiAgICBhdXRvc2Nyb2xsOiBmYWxzZSxcclxuICB9KTtcclxufVxyXG4iXX0=