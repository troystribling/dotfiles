"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.observeTextEditorEvents = observeTextEditorEvents;
exports.__TEST__ = exports.TextEventDispatcher = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _debounce = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/debounce"));

var _event = require("@atom-ide-community/nuclide-commons/event");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// A reload changes the text in the buffer, so it should trigger a refresh.
const FILE_CHANGE_EVENTS = ['did-change', 'did-reload', 'did-open']; // A reload basically indicates that an external program saved the file, so
// it should trigger a refresh.

const FILE_SAVE_EVENTS = ['did-save', 'did-reload', 'did-open'];
/**
 * Stores callbacks keyed on grammar and event, to allow for easy retrieval when
 * we need to dispatch to all callbacks registered for a given (grammar, event)
 * pair.
 */

class TextCallbackContainer {
  // grammar -> event -> callback
  // invariant: no empty maps or sets (they should be removed instead)
  // event -> callback
  // invariant: no keys mapping to empty sets (they should be removed instead)
  constructor() {
    this._callbacks = void 0;
    this._allGrammarCallbacks = void 0;
    this._callbacks = new Map();
    this._allGrammarCallbacks = new Map();
  }

  getCallbacks(grammar, event) {
    const eventMap = this._callbacks.get(grammar);

    const callbacksForGrammar = this._getCallbacksFromEventMap(eventMap, event);

    const callbacksForAll = this._getCallbacksFromEventMap(this._allGrammarCallbacks, event);

    const resultSet = new Set();

    const add = callback => {
      resultSet.add(callback);
    };

    callbacksForGrammar.forEach(add);
    callbacksForAll.forEach(add);
    return resultSet;
  }

  isEmpty() {
    return this._callbacks.size === 0 && this._allGrammarCallbacks.size === 0;
  }

  _getCallbacksFromEventMap(eventMap, event) {
    if (!eventMap) {
      return new Set();
    }

    const callbackSet = eventMap.get(event);

    if (!callbackSet) {
      return new Set();
    }

    return callbackSet;
  }

  addCallback(grammarScopes, events, callback) {
    if (grammarScopes === 'all') {
      this._addToEventMap(this._allGrammarCallbacks, events, callback);
    } else {
      for (const grammarScope of grammarScopes) {
        let eventMap = this._callbacks.get(grammarScope);

        if (!eventMap) {
          eventMap = new Map();

          this._callbacks.set(grammarScope, eventMap);
        }

        this._addToEventMap(eventMap, events, callback);
      }
    }
  } // remove the callbacks, maintaining the invariant that there should be no
  // empty maps or sets in this._callbacks


  removeCallback(grammarScopes, events, callback) {
    if (grammarScopes === 'all') {
      this._removeFromEventMap(this._allGrammarCallbacks, events, callback);
    } else {
      for (const grammarScope of grammarScopes) {
        const eventMap = this._callbacks.get(grammarScope);

        (0, _assert.default)(eventMap);

        this._removeFromEventMap(eventMap, events, callback);

        if (eventMap.size === 0) {
          this._callbacks.delete(grammarScope);
        }
      }
    }
  }

  _addToEventMap(eventMap, events, callback) {
    for (const event of events) {
      let callbackSet = eventMap.get(event);

      if (!callbackSet) {
        callbackSet = new Set();
        eventMap.set(event, callbackSet);
      }

      callbackSet.add(callback);
    }
  }

  _removeFromEventMap(eventMap, events, callback) {
    for (const event of events) {
      const callbackSet = eventMap.get(event);
      (0, _assert.default)(callbackSet);
      callbackSet.delete(callback);

      if (callbackSet.size === 0) {
        eventMap.delete(event);
      }
    }
  }

}
/**
 * Meant to make it simple and easy for a DiagnosticProvider to subscribe to
 * relevant events. Currently provides two methods, onFileChange and onFileSave.
 * A DiagnosticProvider will typically subscribe to only one, depending on
 * whether it wants to be notified whenever a file changes or only when it is
 * saved.
 *
 * Both methods take two arguments:
 * - An Iterable of grammars for which the DiagnosticProvider can provide
 * diagnostics.
 * - The callback to be called on a text event.
 *
 * A TextEventDispatcher will be subscribed to text events if and only if it has
 * subscribers of its own. If all subscribers unsubscribe, it will unsubscribe
 * from Atom's text events.
 *
 */


class TextEventDispatcher {
  constructor() {
    this._callbackContainer = void 0;
    this._editorListenerDisposable = void 0;
    this._pendingEvents = void 0;
    this._callbackContainer = new TextCallbackContainer();
    this._editorListenerDisposable = null;
    this._pendingEvents = new WeakMap();
  }

  _onEvents(grammarScopes, events, callback) {
    if (this._callbackContainer.isEmpty()) {
      this._registerEditorListeners();
    } // Sometimes these events get triggered several times in succession
    // (particularly on startup).


    const debouncedCallback = (0, _debounce.default)(callback, 50, true);

    this._callbackContainer.addCallback(grammarScopes, events, debouncedCallback);

    const disposables = new _UniversalDisposable.default(() => {
      this._callbackContainer.removeCallback(grammarScopes, events, debouncedCallback);

      if (this._callbackContainer.isEmpty()) {
        this._deregisterEditorListeners();
      }
    });
    return disposables;
  }

  onFileChange(grammarScopes, callback) {
    return this._onEvents(grammarScopes, FILE_CHANGE_EVENTS, callback);
  }

  onAnyFileChange(callback) {
    return this._onEvents('all', FILE_CHANGE_EVENTS, callback);
  }

  onFileSave(grammarScopes, callback) {
    return this._onEvents(grammarScopes, FILE_SAVE_EVENTS, callback);
  }

  onAnyFileSave(callback) {
    return this._onEvents('all', FILE_SAVE_EVENTS, callback);
  }

  _registerEditorListeners() {
    if (!this._editorListenerDisposable) {
      this._editorListenerDisposable = new _UniversalDisposable.default();
    } // Whenever the active pane item changes, we check to see if there are any
    // pending events for the newly-focused TextEditor.


    this._getEditorListenerDisposable().add(atom.workspace.onDidChangeActivePaneItem(() => {
      const currentEditor = atom.workspace.getActiveTextEditor();

      if (currentEditor) {
        const pendingEvents = this._pendingEvents.get(currentEditor.getBuffer());

        if (pendingEvents) {
          for (const event of pendingEvents) {
            this._dispatchEvents(currentEditor, event);
          }

          this._pendingEvents.delete(currentEditor.getBuffer());
        }
      }
    }));

    this._getEditorListenerDisposable().add(atom.workspace.observeTextEditors(editor => {
      const buffer = editor.getBuffer();

      const makeDispatch = event => {
        return () => {
          this._dispatchEvents(editor, event);
        };
      };

      this._getEditorListenerDisposable().addUntilDestroyed(editor, buffer.onDidStopChanging(makeDispatch('did-change')), buffer.onDidSave(makeDispatch('did-save')), buffer.onDidReload(makeDispatch('did-reload'))); // During reload, many text editors are opened simultaneously.
      // Due to the debounce on the event callback, this means that many editors never receive
      // a 'did-open' event. To work around this, defer editor open events so that simultaneous
      // open events are properly registered as pending.


      setImmediate(() => this._dispatchEvents(editor, 'did-open'));
    }));
  }

  _deregisterEditorListeners() {
    if (this._editorListenerDisposable) {
      this._getEditorListenerDisposable().dispose();

      this._editorListenerDisposable = null;
    }
  }

  _dispatchEvents(editor, event) {
    const currentEditor = atom.workspace.getActiveTextEditor();

    if (currentEditor && editor === currentEditor) {
      const callbacks = this._callbackContainer.getCallbacks(editor.getGrammar().scopeName, event);

      for (const callback of callbacks) {
        callback(editor);
      } // We want to avoid storing pending events if this event was generated by
      // the same buffer as the current editor, to avoid duplicating events when
      // multiple panes have the same file open.

    } else if (!currentEditor || editor.getBuffer() !== currentEditor.getBuffer()) {
      // Trigger this event next time we switch to an editor with this buffer.
      const buffer = editor.getBuffer();

      let events = this._pendingEvents.get(buffer);

      if (!events) {
        events = new Set();

        this._pendingEvents.set(buffer, events);
      }

      events.add(event);
    }
  }

  _getEditorListenerDisposable() {
    const disposable = this._editorListenerDisposable;
    (0, _assert.default)(disposable, 'TextEventDispatcher disposable is not initialized');
    return disposable;
  }

}

exports.TextEventDispatcher = TextEventDispatcher;

function observeTextEditorEvents(grammarScopes, events) {
  return _rxjsCompatUmdMin.Observable.defer(() => {
    const dispatcher = new TextEventDispatcher();

    if (events === 'changes') {
      if (grammarScopes === 'all') {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onAnyFileChange(cb));
      } else {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onFileChange(grammarScopes, cb));
      }
    } else {
      if (grammarScopes === 'all') {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onAnyFileSave(cb));
      } else {
        return (0, _event.observableFromSubscribeFunction)(cb => dispatcher.onFileSave(grammarScopes, cb));
      }
    }
  });
}

const __TEST__ = {
  TextCallbackContainer
};
exports.__TEST__ = __TEST__;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLWF0b20vdGV4dC1ldmVudC5qcyJdLCJuYW1lcyI6WyJGSUxFX0NIQU5HRV9FVkVOVFMiLCJGSUxFX1NBVkVfRVZFTlRTIiwiVGV4dENhbGxiYWNrQ29udGFpbmVyIiwiY29uc3RydWN0b3IiLCJfY2FsbGJhY2tzIiwiX2FsbEdyYW1tYXJDYWxsYmFja3MiLCJNYXAiLCJnZXRDYWxsYmFja3MiLCJncmFtbWFyIiwiZXZlbnQiLCJldmVudE1hcCIsImdldCIsImNhbGxiYWNrc0ZvckdyYW1tYXIiLCJfZ2V0Q2FsbGJhY2tzRnJvbUV2ZW50TWFwIiwiY2FsbGJhY2tzRm9yQWxsIiwicmVzdWx0U2V0IiwiU2V0IiwiYWRkIiwiY2FsbGJhY2siLCJmb3JFYWNoIiwiaXNFbXB0eSIsInNpemUiLCJjYWxsYmFja1NldCIsImFkZENhbGxiYWNrIiwiZ3JhbW1hclNjb3BlcyIsImV2ZW50cyIsIl9hZGRUb0V2ZW50TWFwIiwiZ3JhbW1hclNjb3BlIiwic2V0IiwicmVtb3ZlQ2FsbGJhY2siLCJfcmVtb3ZlRnJvbUV2ZW50TWFwIiwiZGVsZXRlIiwiVGV4dEV2ZW50RGlzcGF0Y2hlciIsIl9jYWxsYmFja0NvbnRhaW5lciIsIl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUiLCJfcGVuZGluZ0V2ZW50cyIsIldlYWtNYXAiLCJfb25FdmVudHMiLCJfcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMiLCJkZWJvdW5jZWRDYWxsYmFjayIsImRpc3Bvc2FibGVzIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsIl9kZXJlZ2lzdGVyRWRpdG9yTGlzdGVuZXJzIiwib25GaWxlQ2hhbmdlIiwib25BbnlGaWxlQ2hhbmdlIiwib25GaWxlU2F2ZSIsIm9uQW55RmlsZVNhdmUiLCJfZ2V0RWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlIiwiYXRvbSIsIndvcmtzcGFjZSIsIm9uRGlkQ2hhbmdlQWN0aXZlUGFuZUl0ZW0iLCJjdXJyZW50RWRpdG9yIiwiZ2V0QWN0aXZlVGV4dEVkaXRvciIsInBlbmRpbmdFdmVudHMiLCJnZXRCdWZmZXIiLCJfZGlzcGF0Y2hFdmVudHMiLCJvYnNlcnZlVGV4dEVkaXRvcnMiLCJlZGl0b3IiLCJidWZmZXIiLCJtYWtlRGlzcGF0Y2giLCJhZGRVbnRpbERlc3Ryb3llZCIsIm9uRGlkU3RvcENoYW5naW5nIiwib25EaWRTYXZlIiwib25EaWRSZWxvYWQiLCJzZXRJbW1lZGlhdGUiLCJkaXNwb3NlIiwiY2FsbGJhY2tzIiwiZ2V0R3JhbW1hciIsInNjb3BlTmFtZSIsImRpc3Bvc2FibGUiLCJvYnNlcnZlVGV4dEVkaXRvckV2ZW50cyIsIk9ic2VydmFibGUiLCJkZWZlciIsImRpc3BhdGNoZXIiLCJjYiIsIl9fVEVTVF9fIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQVlBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFZQTtBQUNBLE1BQU1BLGtCQUFrQixHQUFHLENBQUMsWUFBRCxFQUFlLFlBQWYsRUFBNkIsVUFBN0IsQ0FBM0IsQyxDQUVBO0FBQ0E7O0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsQ0FBQyxVQUFELEVBQWEsWUFBYixFQUEyQixVQUEzQixDQUF6QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUMscUJBQU4sQ0FBeUM7QUFDdkM7QUFDQTtBQUdBO0FBQ0E7QUFHQUMsRUFBQUEsV0FBVyxHQUFHO0FBQUEsU0FOZEMsVUFNYztBQUFBLFNBRmRDLG9CQUVjO0FBQ1osU0FBS0QsVUFBTCxHQUFrQixJQUFJRSxHQUFKLEVBQWxCO0FBQ0EsU0FBS0Qsb0JBQUwsR0FBNEIsSUFBSUMsR0FBSixFQUE1QjtBQUNEOztBQUVEQyxFQUFBQSxZQUFZLENBQ1ZDLE9BRFUsRUFFVkMsS0FGVSxFQUd3QjtBQUNsQyxVQUFNQyxRQUFRLEdBQUcsS0FBS04sVUFBTCxDQUFnQk8sR0FBaEIsQ0FBb0JILE9B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QUUsSUFDdkNELFVBQVUsQ0FBQzVCLFVBQVgsQ0FBc0JyQixhQUF0QixFQUFxQ2tELEVBQXJDLENBREssQ0FBUDtBQUdEO0FBQ0Y7QUFDRixHQXZCTSxDQUFQO0FBd0JEOztBQUVNLE1BQU1DLFFBQVEsR0FBRztBQUN0QnpFLEVBQUFBO0FBRHNCLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvZGVib3VuY2UnO1xyXG5pbXBvcnQge29ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb259IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2V2ZW50JztcclxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvVW5pdmVyc2FsRGlzcG9zYWJsZSc7XHJcblxyXG50eXBlIEV2ZW50Q2FsbGJhY2sgPSAoZWRpdG9yOiBUZXh0RWRpdG9yKSA9PiBtaXhlZDtcclxuXHJcbnR5cGUgRXZlbnQgPSAnZGlkLXJlbG9hZCcgfCAnZGlkLWNoYW5nZScgfCAnZGlkLXNhdmUnIHwgJ2RpZC1vcGVuJztcclxuXHJcbi8vIEEgcmVsb2FkIGNoYW5nZXMgdGhlIHRleHQgaW4gdGhlIGJ1ZmZlciwgc28gaXQgc2hvdWxkIHRyaWdnZXIgYSByZWZyZXNoLlxyXG5jb25zdCBGSUxFX0NIQU5HRV9FVkVOVFMgPSBbJ2RpZC1jaGFuZ2UnLCAnZGlkLXJlbG9hZCcsICdkaWQtb3BlbiddO1xyXG5cclxuLy8gQSByZWxvYWQgYmFzaWNhbGx5IGluZGljYXRlcyB0aGF0IGFuIGV4dGVybmFsIHByb2dyYW0gc2F2ZWQgdGhlIGZpbGUsIHNvXHJcbi8vIGl0IHNob3VsZCB0cmlnZ2VyIGEgcmVmcmVzaC5cclxuY29uc3QgRklMRV9TQVZFX0VWRU5UUyA9IFsnZGlkLXNhdmUnLCAnZGlkLXJlbG9hZCcsICdkaWQtb3BlbiddO1xyXG5cclxuLyoqXHJcbiAqIFN0b3JlcyBjYWxsYmFja3Mga2V5ZWQgb24gZ3JhbW1hciBhbmQgZXZlbnQsIHRvIGFsbG93IGZvciBlYXN5IHJldHJpZXZhbCB3aGVuXHJcbiAqIHdlIG5lZWQgdG8gZGlzcGF0Y2ggdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIChncmFtbWFyLCBldmVudClcclxuICogcGFpci5cclxuICovXHJcbmNsYXNzIFRleHRDYWxsYmFja0NvbnRhaW5lcjxDYWxsYmFja0FyZz4ge1xyXG4gIC8vIGdyYW1tYXIgLT4gZXZlbnQgLT4gY2FsbGJhY2tcclxuICAvLyBpbnZhcmlhbnQ6IG5vIGVtcHR5IG1hcHMgb3Igc2V0cyAodGhleSBzaG91bGQgYmUgcmVtb3ZlZCBpbnN0ZWFkKVxyXG4gIF9jYWxsYmFja3M6IE1hcDxzdHJpbmcsIE1hcDxFdmVudCwgU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4+PjtcclxuXHJcbiAgLy8gZXZlbnQgLT4gY2FsbGJhY2tcclxuICAvLyBpbnZhcmlhbnQ6IG5vIGtleXMgbWFwcGluZyB0byBlbXB0eSBzZXRzICh0aGV5IHNob3VsZCBiZSByZW1vdmVkIGluc3RlYWQpXHJcbiAgX2FsbEdyYW1tYXJDYWxsYmFja3M6IE1hcDxFdmVudCwgU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4+O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX2FsbEdyYW1tYXJDYWxsYmFja3MgPSBuZXcgTWFwKCk7XHJcbiAgfVxyXG5cclxuICBnZXRDYWxsYmFja3MoXHJcbiAgICBncmFtbWFyOiBzdHJpbmcsXHJcbiAgICBldmVudDogRXZlbnQsXHJcbiAgKTogU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4ge1xyXG4gICAgY29uc3QgZXZlbnRNYXAgPSB0aGlzLl9jYWxsYmFja3MuZ2V0KGdyYW1tYXIpO1xyXG4gICAgY29uc3QgY2FsbGJhY2tzRm9yR3JhbW1hciA9IHRoaXMuX2dldENhbGxiYWNrc0Zyb21FdmVudE1hcChldmVudE1hcCwgZXZlbnQpO1xyXG4gICAgY29uc3QgY2FsbGJhY2tzRm9yQWxsID0gdGhpcy5fZ2V0Q2FsbGJhY2tzRnJvbUV2ZW50TWFwKFxyXG4gICAgICB0aGlzLl9hbGxHcmFtbWFyQ2FsbGJhY2tzLFxyXG4gICAgICBldmVudCxcclxuICAgICk7XHJcbiAgICBjb25zdCByZXN1bHRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBhZGQgPSBjYWxsYmFjayA9PiB7XHJcbiAgICAgIHJlc3VsdFNldC5hZGQoY2FsbGJhY2spO1xyXG4gICAgfTtcclxuICAgIGNhbGxiYWNrc0ZvckdyYW1tYXIuZm9yRWFjaChhZGQpO1xyXG4gICAgY2FsbGJhY2tzRm9yQWxsLmZvckVhY2goYWRkKTtcclxuICAgIHJldHVybiByZXN1bHRTZXQ7XHJcbiAgfVxyXG5cclxuICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcy5zaXplID09PSAwICYmIHRoaXMuX2FsbEdyYW1tYXJDYWxsYmFja3Muc2l6ZSA9PT0gMDtcclxuICB9XHJcblxyXG4gIF9nZXRDYWxsYmFja3NGcm9tRXZlbnRNYXAoXHJcbiAgICBldmVudE1hcDogP01hcDxFdmVudCwgU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4+LFxyXG4gICAgZXZlbnQ6IEV2ZW50LFxyXG4gICk6IFNldDwoYXJnOiBDYWxsYmFja0FyZykgPT4gbWl4ZWQ+IHtcclxuICAgIGlmICghZXZlbnRNYXApIHtcclxuICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNhbGxiYWNrU2V0ID0gZXZlbnRNYXAuZ2V0KGV2ZW50KTtcclxuICAgIGlmICghY2FsbGJhY2tTZXQpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWxsYmFja1NldDtcclxuICB9XHJcblxyXG4gIGFkZENhbGxiYWNrKFxyXG4gICAgZ3JhbW1hclNjb3BlczogSXRlcmFibGU8c3RyaW5nPiB8ICdhbGwnLFxyXG4gICAgZXZlbnRzOiBJdGVyYWJsZTxFdmVudD4sXHJcbiAgICBjYWxsYmFjazogKGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkLFxyXG4gICk6IHZvaWQge1xyXG4gICAgaWYgKGdyYW1tYXJTY29wZXMgPT09ICdhbGwnKSB7XHJcbiAgICAgIHRoaXMuX2FkZFRvRXZlbnRNYXAodGhpcy5fYWxsR3JhbW1hckNhbGxiYWNrcywgZXZlbnRzLCBjYWxsYmFjayk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGNvbnN0IGdyYW1tYXJTY29wZSBvZiBncmFtbWFyU2NvcGVzKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50TWFwID0gdGhpcy5fY2FsbGJhY2tzLmdldChncmFtbWFyU2NvcGUpO1xyXG4gICAgICAgIGlmICghZXZlbnRNYXApIHtcclxuICAgICAgICAgIGV2ZW50TWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNldChncmFtbWFyU2NvcGUsIGV2ZW50TWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWRkVG9FdmVudE1hcChldmVudE1hcCwgZXZlbnRzLCBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSB0aGUgY2FsbGJhY2tzLCBtYWludGFpbmluZyB0aGUgaW52YXJpYW50IHRoYXQgdGhlcmUgc2hvdWxkIGJlIG5vXHJcbiAgLy8gZW1wdHkgbWFwcyBvciBzZXRzIGluIHRoaXMuX2NhbGxiYWNrc1xyXG4gIHJlbW92ZUNhbGxiYWNrKFxyXG4gICAgZ3JhbW1hclNjb3BlczogSXRlcmFibGU8c3RyaW5nPiB8ICdhbGwnLFxyXG4gICAgZXZlbnRzOiBJdGVyYWJsZTxFdmVudD4sXHJcbiAgICBjYWxsYmFjazogKGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkLFxyXG4gICk6IHZvaWQge1xyXG4gICAgaWYgKGdyYW1tYXJTY29wZXMgPT09ICdhbGwnKSB7XHJcbiAgICAgIHRoaXMuX3JlbW92ZUZyb21FdmVudE1hcCh0aGlzLl9hbGxHcmFtbWFyQ2FsbGJhY2tzLCBldmVudHMsIGNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGZvciAoY29uc3QgZ3JhbW1hclNjb3BlIG9mIGdyYW1tYXJTY29wZXMpIHtcclxuICAgICAgICBjb25zdCBldmVudE1hcCA9IHRoaXMuX2NhbGxiYWNrcy5nZXQoZ3JhbW1hclNjb3BlKTtcclxuICAgICAgICBpbnZhcmlhbnQoZXZlbnRNYXApO1xyXG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21FdmVudE1hcChldmVudE1hcCwgZXZlbnRzLCBjYWxsYmFjayk7XHJcbiAgICAgICAgaWYgKGV2ZW50TWFwLnNpemUgPT09IDApIHtcclxuICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kZWxldGUoZ3JhbW1hclNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9hZGRUb0V2ZW50TWFwKFxyXG4gICAgZXZlbnRNYXA6IE1hcDxFdmVudCwgU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4+LFxyXG4gICAgZXZlbnRzOiBJdGVyYWJsZTxFdmVudD4sXHJcbiAgICBjYWxsYmFjazogKGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkLFxyXG4gICk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcclxuICAgICAgbGV0IGNhbGxiYWNrU2V0ID0gZXZlbnRNYXAuZ2V0KGV2ZW50KTtcclxuICAgICAgaWYgKCFjYWxsYmFja1NldCkge1xyXG4gICAgICAgIGNhbGxiYWNrU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGV2ZW50TWFwLnNldChldmVudCwgY2FsbGJhY2tTZXQpO1xyXG4gICAgICB9XHJcbiAgICAgIGNhbGxiYWNrU2V0LmFkZChjYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfcmVtb3ZlRnJvbUV2ZW50TWFwKFxyXG4gICAgZXZlbnRNYXA6IE1hcDxFdmVudCwgU2V0PChhcmc6IENhbGxiYWNrQXJnKSA9PiBtaXhlZD4+LFxyXG4gICAgZXZlbnRzOiBJdGVyYWJsZTxFdmVudD4sXHJcbiAgICBjYWxsYmFjazogKGFyZzogQ2FsbGJhY2tBcmcpID0+IG1peGVkLFxyXG4gICk6IHZvaWQge1xyXG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcclxuICAgICAgY29uc3QgY2FsbGJhY2tTZXQgPSBldmVudE1hcC5nZXQoZXZlbnQpO1xyXG4gICAgICBpbnZhcmlhbnQoY2FsbGJhY2tTZXQpO1xyXG4gICAgICBjYWxsYmFja1NldC5kZWxldGUoY2FsbGJhY2spO1xyXG4gICAgICBpZiAoY2FsbGJhY2tTZXQuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIGV2ZW50TWFwLmRlbGV0ZShldmVudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZWFudCB0byBtYWtlIGl0IHNpbXBsZSBhbmQgZWFzeSBmb3IgYSBEaWFnbm9zdGljUHJvdmlkZXIgdG8gc3Vic2NyaWJlIHRvXHJcbiAqIHJlbGV2YW50IGV2ZW50cy4gQ3VycmVudGx5IHByb3ZpZGVzIHR3byBtZXRob2RzLCBvbkZpbGVDaGFuZ2UgYW5kIG9uRmlsZVNhdmUuXHJcbiAqIEEgRGlhZ25vc3RpY1Byb3ZpZGVyIHdpbGwgdHlwaWNhbGx5IHN1YnNjcmliZSB0byBvbmx5IG9uZSwgZGVwZW5kaW5nIG9uXHJcbiAqIHdoZXRoZXIgaXQgd2FudHMgdG8gYmUgbm90aWZpZWQgd2hlbmV2ZXIgYSBmaWxlIGNoYW5nZXMgb3Igb25seSB3aGVuIGl0IGlzXHJcbiAqIHNhdmVkLlxyXG4gKlxyXG4gKiBCb3RoIG1ldGhvZHMgdGFrZSB0d28gYXJndW1lbnRzOlxyXG4gKiAtIEFuIEl0ZXJhYmxlIG9mIGdyYW1tYXJzIGZvciB3aGljaCB0aGUgRGlhZ25vc3RpY1Byb3ZpZGVyIGNhbiBwcm92aWRlXHJcbiAqIGRpYWdub3N0aWNzLlxyXG4gKiAtIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gYSB0ZXh0IGV2ZW50LlxyXG4gKlxyXG4gKiBBIFRleHRFdmVudERpc3BhdGNoZXIgd2lsbCBiZSBzdWJzY3JpYmVkIHRvIHRleHQgZXZlbnRzIGlmIGFuZCBvbmx5IGlmIGl0IGhhc1xyXG4gKiBzdWJzY3JpYmVycyBvZiBpdHMgb3duLiBJZiBhbGwgc3Vic2NyaWJlcnMgdW5zdWJzY3JpYmUsIGl0IHdpbGwgdW5zdWJzY3JpYmVcclxuICogZnJvbSBBdG9tJ3MgdGV4dCBldmVudHMuXHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGV4dEV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgX2NhbGxiYWNrQ29udGFpbmVyOiBUZXh0Q2FsbGJhY2tDb250YWluZXI8VGV4dEVkaXRvcj47XHJcblxyXG4gIF9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGU6ID9Vbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG5cclxuICBfcGVuZGluZ0V2ZW50czogV2Vha01hcDxhdG9tJFRleHRCdWZmZXIsIFNldDxFdmVudD4+O1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrQ29udGFpbmVyID0gbmV3IFRleHRDYWxsYmFja0NvbnRhaW5lcigpO1xyXG4gICAgdGhpcy5fZWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlID0gbnVsbDtcclxuICAgIHRoaXMuX3BlbmRpbmdFdmVudHMgPSBuZXcgV2Vha01hcCgpO1xyXG4gIH1cclxuXHJcbiAgX29uRXZlbnRzKFxyXG4gICAgZ3JhbW1hclNjb3BlczogSXRlcmFibGU8c3RyaW5nPiB8ICdhbGwnLFxyXG4gICAgZXZlbnRzOiBJdGVyYWJsZTxFdmVudD4sXHJcbiAgICBjYWxsYmFjazogRXZlbnRDYWxsYmFjayxcclxuICApIHtcclxuICAgIGlmICh0aGlzLl9jYWxsYmFja0NvbnRhaW5lci5pc0VtcHR5KCkpIHtcclxuICAgICAgdGhpcy5fcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuICAgIC8vIFNvbWV0aW1lcyB0aGVzZSBldmVudHMgZ2V0IHRyaWdnZXJlZCBzZXZlcmFsIHRpbWVzIGluIHN1Y2Nlc3Npb25cclxuICAgIC8vIChwYXJ0aWN1bGFybHkgb24gc3RhcnR1cCkuXHJcbiAgICBjb25zdCBkZWJvdW5jZWRDYWxsYmFjayA9IGRlYm91bmNlKGNhbGxiYWNrLCA1MCwgdHJ1ZSk7XHJcbiAgICB0aGlzLl9jYWxsYmFja0NvbnRhaW5lci5hZGRDYWxsYmFjayhcclxuICAgICAgZ3JhbW1hclNjb3BlcyxcclxuICAgICAgZXZlbnRzLFxyXG4gICAgICBkZWJvdW5jZWRDYWxsYmFjayxcclxuICAgICk7XHJcbiAgICBjb25zdCBkaXNwb3NhYmxlcyA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCgpID0+IHtcclxuICAgICAgdGhpcy5fY2FsbGJhY2tDb250YWluZXIucmVtb3ZlQ2FsbGJhY2soXHJcbiAgICAgICAgZ3JhbW1hclNjb3BlcyxcclxuICAgICAgICBldmVudHMsXHJcbiAgICAgICAgZGVib3VuY2VkQ2FsbGJhY2ssXHJcbiAgICAgICk7XHJcbiAgICAgIGlmICh0aGlzLl9jYWxsYmFja0NvbnRhaW5lci5pc0VtcHR5KCkpIHtcclxuICAgICAgICB0aGlzLl9kZXJlZ2lzdGVyRWRpdG9yTGlzdGVuZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGRpc3Bvc2FibGVzO1xyXG4gIH1cclxuXHJcbiAgb25GaWxlQ2hhbmdlKFxyXG4gICAgZ3JhbW1hclNjb3BlczogSXRlcmFibGU8c3RyaW5nPixcclxuICAgIGNhbGxiYWNrOiBFdmVudENhbGxiYWNrLFxyXG4gICk6IElEaXNwb3NhYmxlIHtcclxuICAgIHJldHVybiB0aGlzLl9vbkV2ZW50cyhncmFtbWFyU2NvcGVzLCBGSUxFX0NIQU5HRV9FVkVOVFMsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIG9uQW55RmlsZUNoYW5nZShjYWxsYmFjazogRXZlbnRDYWxsYmFjayk6IElEaXNwb3NhYmxlIHtcclxuICAgIHJldHVybiB0aGlzLl9vbkV2ZW50cygnYWxsJywgRklMRV9DSEFOR0VfRVZFTlRTLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBvbkZpbGVTYXZlKFxyXG4gICAgZ3JhbW1hclNjb3BlczogSXRlcmFibGU8c3RyaW5nPixcclxuICAgIGNhbGxiYWNrOiBFdmVudENhbGxiYWNrLFxyXG4gICk6IElEaXNwb3NhYmxlIHtcclxuICAgIHJldHVybiB0aGlzLl9vbkV2ZW50cyhncmFtbWFyU2NvcGVzLCBGSUxFX1NBVkVfRVZFTlRTLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBvbkFueUZpbGVTYXZlKGNhbGxiYWNrOiBFdmVudENhbGxiYWNrKTogSURpc3Bvc2FibGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX29uRXZlbnRzKCdhbGwnLCBGSUxFX1NBVkVfRVZFTlRTLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBfcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2VkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSkge1xyXG4gICAgICB0aGlzLl9lZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFdoZW5ldmVyIHRoZSBhY3RpdmUgcGFuZSBpdGVtIGNoYW5nZXMsIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55XHJcbiAgICAvLyBwZW5kaW5nIGV2ZW50cyBmb3IgdGhlIG5ld2x5LWZvY3VzZWQgVGV4dEVkaXRvci5cclxuICAgIHRoaXMuX2dldEVkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSgpLmFkZChcclxuICAgICAgYXRvbS53b3Jrc3BhY2Uub25EaWRDaGFuZ2VBY3RpdmVQYW5lSXRlbSgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEVkaXRvciA9IGF0b20ud29ya3NwYWNlLmdldEFjdGl2ZVRleHRFZGl0b3IoKTtcclxuICAgICAgICBpZiAoY3VycmVudEVkaXRvcikge1xyXG4gICAgICAgICAgY29uc3QgcGVuZGluZ0V2ZW50cyA9IHRoaXMuX3BlbmRpbmdFdmVudHMuZ2V0KFxyXG4gICAgICAgICAgICBjdXJyZW50RWRpdG9yLmdldEJ1ZmZlcigpLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIGlmIChwZW5kaW5nRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgcGVuZGluZ0V2ZW50cykge1xyXG4gICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRzKGN1cnJlbnRFZGl0b3IsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nRXZlbnRzLmRlbGV0ZShjdXJyZW50RWRpdG9yLmdldEJ1ZmZlcigpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLl9nZXRFZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUoKS5hZGQoXHJcbiAgICAgIGF0b20ud29ya3NwYWNlLm9ic2VydmVUZXh0RWRpdG9ycyhlZGl0b3IgPT4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVkaXRvci5nZXRCdWZmZXIoKTtcclxuICAgICAgICBjb25zdCBtYWtlRGlzcGF0Y2ggPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50cyhlZGl0b3IsIGV2ZW50KTtcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9nZXRFZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUoKS5hZGRVbnRpbERlc3Ryb3llZChcclxuICAgICAgICAgIGVkaXRvcixcclxuICAgICAgICAgIGJ1ZmZlci5vbkRpZFN0b3BDaGFuZ2luZyhtYWtlRGlzcGF0Y2goJ2RpZC1jaGFuZ2UnKSksXHJcbiAgICAgICAgICBidWZmZXIub25EaWRTYXZlKG1ha2VEaXNwYXRjaCgnZGlkLXNhdmUnKSksXHJcbiAgICAgICAgICBidWZmZXIub25EaWRSZWxvYWQobWFrZURpc3BhdGNoKCdkaWQtcmVsb2FkJykpLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gRHVyaW5nIHJlbG9hZCwgbWFueSB0ZXh0IGVkaXRvcnMgYXJlIG9wZW5lZCBzaW11bHRhbmVvdXNseS5cclxuICAgICAgICAvLyBEdWUgdG8gdGhlIGRlYm91bmNlIG9uIHRoZSBldmVudCBjYWxsYmFjaywgdGhpcyBtZWFucyB0aGF0IG1hbnkgZWRpdG9ycyBuZXZlciByZWNlaXZlXHJcbiAgICAgICAgLy8gYSAnZGlkLW9wZW4nIGV2ZW50LiBUbyB3b3JrIGFyb3VuZCB0aGlzLCBkZWZlciBlZGl0b3Igb3BlbiBldmVudHMgc28gdGhhdCBzaW11bHRhbmVvdXNcclxuICAgICAgICAvLyBvcGVuIGV2ZW50cyBhcmUgcHJvcGVybHkgcmVnaXN0ZXJlZCBhcyBwZW5kaW5nLlxyXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9kaXNwYXRjaEV2ZW50cyhlZGl0b3IsICdkaWQtb3BlbicpKTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgX2RlcmVnaXN0ZXJFZGl0b3JMaXN0ZW5lcnMoKSB7XHJcbiAgICBpZiAodGhpcy5fZWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlKSB7XHJcbiAgICAgIHRoaXMuX2dldEVkaXRvckxpc3RlbmVyRGlzcG9zYWJsZSgpLmRpc3Bvc2UoKTtcclxuICAgICAgdGhpcy5fZWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9kaXNwYXRjaEV2ZW50cyhlZGl0b3I6IFRleHRFZGl0b3IsIGV2ZW50OiBFdmVudCk6IHZvaWQge1xyXG4gICAgY29uc3QgY3VycmVudEVkaXRvciA9IGF0b20ud29ya3NwYWNlLmdldEFjdGl2ZVRleHRFZGl0b3IoKTtcclxuICAgIGlmIChjdXJyZW50RWRpdG9yICYmIGVkaXRvciA9PT0gY3VycmVudEVkaXRvcikge1xyXG4gICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja0NvbnRhaW5lci5nZXRDYWxsYmFja3MoXHJcbiAgICAgICAgZWRpdG9yLmdldEdyYW1tYXIoKS5zY29wZU5hbWUsXHJcbiAgICAgICAgZXZlbnQsXHJcbiAgICAgICk7XHJcbiAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgY2FsbGJhY2soZWRpdG9yKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBXZSB3YW50IHRvIGF2b2lkIHN0b3JpbmcgcGVuZGluZyBldmVudHMgaWYgdGhpcyBldmVudCB3YXMgZ2VuZXJhdGVkIGJ5XHJcbiAgICAgIC8vIHRoZSBzYW1lIGJ1ZmZlciBhcyB0aGUgY3VycmVudCBlZGl0b3IsIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGV2ZW50cyB3aGVuXHJcbiAgICAgIC8vIG11bHRpcGxlIHBhbmVzIGhhdmUgdGhlIHNhbWUgZmlsZSBvcGVuLlxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgIWN1cnJlbnRFZGl0b3IgfHxcclxuICAgICAgZWRpdG9yLmdldEJ1ZmZlcigpICE9PSBjdXJyZW50RWRpdG9yLmdldEJ1ZmZlcigpXHJcbiAgICApIHtcclxuICAgICAgLy8gVHJpZ2dlciB0aGlzIGV2ZW50IG5leHQgdGltZSB3ZSBzd2l0Y2ggdG8gYW4gZWRpdG9yIHdpdGggdGhpcyBidWZmZXIuXHJcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGVkaXRvci5nZXRCdWZmZXIoKTtcclxuICAgICAgbGV0IGV2ZW50cyA9IHRoaXMuX3BlbmRpbmdFdmVudHMuZ2V0KGJ1ZmZlcik7XHJcbiAgICAgIGlmICghZXZlbnRzKSB7XHJcbiAgICAgICAgZXZlbnRzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMuc2V0KGJ1ZmZlciwgZXZlbnRzKTtcclxuICAgICAgfVxyXG4gICAgICBldmVudHMuYWRkKGV2ZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9nZXRFZGl0b3JMaXN0ZW5lckRpc3Bvc2FibGUoKTogVW5pdmVyc2FsRGlzcG9zYWJsZSB7XHJcbiAgICBjb25zdCBkaXNwb3NhYmxlID0gdGhpcy5fZWRpdG9yTGlzdGVuZXJEaXNwb3NhYmxlO1xyXG4gICAgaW52YXJpYW50KGRpc3Bvc2FibGUsICdUZXh0RXZlbnREaXNwYXRjaGVyIGRpc3Bvc2FibGUgaXMgbm90IGluaXRpYWxpemVkJyk7XHJcbiAgICByZXR1cm4gZGlzcG9zYWJsZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlVGV4dEVkaXRvckV2ZW50cyhcclxuICBncmFtbWFyU2NvcGVzOiBJdGVyYWJsZTxzdHJpbmc+IHwgJ2FsbCcsXHJcbiAgZXZlbnRzOiAnY2hhbmdlcycgfCAnc2F2ZXMnLFxyXG4pOiBPYnNlcnZhYmxlPGF0b20kVGV4dEVkaXRvcj4ge1xyXG4gIHJldHVybiBPYnNlcnZhYmxlLmRlZmVyKCgpID0+IHtcclxuICAgIGNvbnN0IGRpc3BhdGNoZXIgPSBuZXcgVGV4dEV2ZW50RGlzcGF0Y2hlcigpO1xyXG4gICAgaWYgKGV2ZW50cyA9PT0gJ2NoYW5nZXMnKSB7XHJcbiAgICAgIGlmIChncmFtbWFyU2NvcGVzID09PSAnYWxsJykge1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbVN1YnNjcmliZUZ1bmN0aW9uKGNiID0+XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLm9uQW55RmlsZUNoYW5nZShjYiksXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZUZyb21TdWJzY3JpYmVGdW5jdGlvbihjYiA9PlxyXG4gICAgICAgICAgZGlzcGF0Y2hlci5vbkZpbGVDaGFuZ2UoZ3JhbW1hclNjb3BlcywgY2IpLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChncmFtbWFyU2NvcGVzID09PSAnYWxsJykge1xyXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlRnJvbVN1YnNjcmliZUZ1bmN0aW9uKGNiID0+XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLm9uQW55RmlsZVNhdmUoY2IpLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24oY2IgPT5cclxuICAgICAgICAgIGRpc3BhdGNoZXIub25GaWxlU2F2ZShncmFtbWFyU2NvcGVzLCBjYiksXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgX19URVNUX18gPSB7XHJcbiAgVGV4dENhbGxiYWNrQ29udGFpbmVyLFxyXG59O1xyXG4iXX0=