"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AtomInput = void 0;

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _assert = _interopRequireDefault(require("assert"));

var _string = require("@atom-ide-community/nuclide-commons/string");

var _observable = require("@atom-ide-community/nuclide-commons/observable");

var _debounce = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/debounce"));

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _atomTabIndexForwarder = _interopRequireDefault(require("./atomTabIndexForwarder"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
const BLUR_FOCUS_DEBOUNCE_DELAY = 100;
/**
 * An input field rendered as an <atom-text-editor mini />.
 */

class AtomInput extends React.Component {
  static getDerivedStateFromProps(props) {
    const partialState = {};

    if (props.value != null) {
      partialState.value = props.value;
    }

    return partialState;
  }

  constructor(props) {
    var _props$value;

    super(props);
    this._disposables = void 0;
    this._rootNode = void 0;
    this._debouncedEditorBlur = void 0;
    this._debouncedEditorFocus = void 0;
    this._isFocused = void 0;
    this._tabIndexForwarding = void 0;

    this._onEditorFocus = () => {
      if (this.isFocused() && !this._isFocused) {
        this._isFocused = true;
        this.props.onFocus && this.props.onFocus();
      }
    };

    this._onEditorBlur = blurEvent => {
      if (!this.isFocused() && this._isFocused) {
        this._isFocused = false;
        this.props.onBlur && this.props.onBlur(blurEvent);
      }
    };

    this._textEditorRef = rootNode => {
      this._rootNode = rootNode;

      if (rootNode == null) {
        if (this._tabIndexForwarding != null) {
          this._tabIndexForwarding.dispose();

          this._tabIndexForwarding = null;
        }
      } else {
        this._tabIndexForwarding = (0, _atomTabIndexForwarder.default)(rootNode);
      }
    };

    this.state = {
      value: (_props$value = props.value) !== null && _props$value !== void 0 ? _props$value : props.initialValue
    };
    this._debouncedEditorFocus = (0, _debounce.default)(this._onEditorFocus, BLUR_FOCUS_DEBOUNCE_DELAY);
    this._debouncedEditorBlur = (0, _debounce.default)(this._onEditorBlur, BLUR_FOCUS_DEBOUNCE_DELAY);
  }

  componentDidMount() {
    const disposables = this._disposables = new _UniversalDisposable.default(); // There does not appear to be any sort of infinite loop where calling
    // setState({value}) in response to onDidChange() causes another change
    // event.

    const textEditor = this.getTextEditor();
    const textEditorElement = this.getTextEditorElement();

    if (this.props.autofocus) {
      this.focus();
    }

    (0, _assert.default)(!(this.props.startSelected && this.props.startSelectedRange != null), 'cannot have both startSelected (all) and startSelectedRange');

    if (this.props.startSelected) {
      // For some reason, selectAll() has no effect if called right now.
      disposables.add(_observable.microtask.subscribe(() => {
        if (!textEditor.isDestroyed()) {
          textEditor.selectAll();
        }
      }));
    }

    const startSelectedRange = this.props.startSelectedRange;

    if (startSelectedRange != null) {
      // For some reason, selectAll() has no effect if called right now.
      disposables.add(_observable.microtask.subscribe(() => {
        if (!textEditor.isDestroyed()) {
          textEditor.setSelectedBufferRange([[0, startSelectedRange[0]], [0, startSelectedRange[1]]]);
        }
      }));
    }

    disposables.add(atom.commands.add(textEditorElement, {
      'core:confirm': event => {
        if (this.props.onConfirm != null) {
          this.props.onConfirm(event);
        }
      },
      'core:cancel': event => {
        if (this.props.onCancel != null) {
          this.props.onCancel(event);
        }
      }
    }));
    const placeholderText = this.props.placeholderText;

    if (placeholderText != null) {
      textEditor.setPlaceholderText(placeholderText);
    }

    this.getTextEditorElement().setAttribute('tabindex', this.props.tabIndex);

    if (this.props.disabled) {
      this._updateDisabledState(true);
    } // Set the text editor's initial value and keep the cursor at the beginning of the line. Cursor
    // position was documented in a test and is retained here after changes to how text is set in
    // the text editor. (see focus-related spec in AtomInput-spec.js)


    this.setText(this.state.value);
    this.getTextEditor().moveToBeginningOfLine(); // Begin listening for changes only after initial value is set.

    disposables.add(textEditor.onDidChange(() => {
      this.setState({
        value: textEditor.getText()
      });
      this.props.onDidChange.call(null, textEditor.getText());
    }));

    if (this.props.onDidChangeSelectionRange != null) {
      disposables.add(textEditor.onDidChangeSelectionRange(this.props.onDidChangeSelectionRange));
    }

    this._updateWidth();
  }

  componentDidUpdate(prevProps, prevState) {
    this._updateWidth(prevProps.width);

    if (prevProps.disabled !== this.props.disabled) {
      this._updateDisabledState(this.props.disabled);
    }

    const newValue = this.props.value;

    if (newValue != null && prevProps.value !== newValue) {
      const editor = this.getTextEditor(); // Calling setText if the value did not change will redundantly call any
      // onDidChange listeners with the same input.

      if (editor.getText() !== newValue) {
        const cursorPosition = editor.getCursorBufferPosition();
        this.setText(newValue);
        editor.setCursorBufferPosition(cursorPosition);
      }
    }

    if (prevProps.placeholderText !== this.props.placeholderText) {
      this.getTextEditor().setPlaceholderText(this.props.placeholderText || '');
    }
  }

  componentWillUnmount() {
    // Note that destroy() is not part of TextEditor's public API.
    const editor = this.getTextEditor();
    process.nextTick(() => editor.destroy());

    if (this._disposables) {
      this._disposables.dispose();

      this._disposables = null;
    }
  }

  _updateDisabledState(isDisabled) {
    // Hack to set TextEditor to read-only mode, per https://github.com/atom/atom/issues/6880
    if (isDisabled) {
      this.getTextEditorElement().removeAttribute('tabindex');
    } else {
      this.getTextEditorElement().setAttribute('tabindex', this.props.tabIndex);
    }
  }

  isFocused() {
    return this._rootNode != null && this._rootNode.contains(document.activeElement);
  }

  render() {
    const className = (0, _classnames.default)(this.props.className, {
      'atom-text-editor-unstyled': this.props.unstyled,
      [`atom-text-editor-${(0, _string.maybeToString)(this.props.size)}`]: this.props.size != null,
      'atom-text-editor-invalid': this.props.invalid
    });
    return (
      /*#__PURE__*/
      // Because the contents of `<atom-text-editor>` elements are managed by its custom web
      // component class when "Use Shadow DOM" is disabled, this element should never have children.
      // If an element has no children, React guarantees it will never re-render the element (which
      // would wipe out the web component's work in this case).
      React.createElement("atom-text-editor", {
        class: className,
        mini: true,
        ref: this._textEditorRef,
        onClick: this.props.onClick,
        onFocus: this._debouncedEditorFocus,
        onBlur: this._debouncedEditorBlur,
        style: this.props.style
      })
    );
  }

  getText() {
    return this.state.value;
  }

  setText(text) {
    this.getTextEditor().setText(text);
  }

  getTextEditor() {
    return this.getTextEditorElement().getModel();
  }

  onDidChange(callback) {
    return this.getTextEditor().getBuffer().onDidChangeText(callback);
  }

  getTextEditorElement() {
    (0, _assert.default)(this._rootNode != null); // $FlowFixMe

    return this._rootNode;
  }

  _updateWidth(prevWidth) {
    if (this.props.width !== prevWidth) {
      const width = this.props.width == null ? undefined : this.props.width;
      this.getTextEditorElement().setWidth(width);
    }
  }

  focus() {
    this.getTextEditor().moveToEndOfLine();
    this.getTextEditorElement().focus();
  }

}

exports.AtomInput = AtomInput;
AtomInput.defaultProps = {
  disabled: false,
  autofocus: false,
  startSelected: false,
  initialValue: '',
  tabIndex: '0',
  // Default to all <AtomInput /> components being in tab order
  onClick: () => {},
  onDidChange: () => {},
  onFocus: () => {},
  onBlur: () => {},
  unstyled: false,
  style: null
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL0F0b21JbnB1dC5qcyJdLCJuYW1lcyI6WyJCTFVSX0ZPQ1VTX0RFQk9VTkNFX0RFTEFZIiwiQXRvbUlucHV0IiwiUmVhY3QiLCJDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcm9wcyIsInBhcnRpYWxTdGF0ZSIsInZhbHVlIiwiY29uc3RydWN0b3IiLCJfZGlzcG9zYWJsZXMiLCJfcm9vdE5vZGUiLCJfZGVib3VuY2VkRWRpdG9yQmx1ciIsIl9kZWJvdW5jZWRFZGl0b3JGb2N1cyIsIl9pc0ZvY3VzZWQiLCJfdGFiSW5kZXhGb3J3YXJkaW5nIiwiX29uRWRpdG9yRm9jdXMiLCJpc0ZvY3VzZWQiLCJvbkZvY3VzIiwiX29uRWRpdG9yQmx1ciIsImJsdXJFdmVudCIsIm9uQmx1ciIsIl90ZXh0RWRpdG9yUmVmIiwicm9vdE5vZGUiLCJkaXNwb3NlIiwic3RhdGUiLCJpbml0aWFsVmFsdWUiLCJjb21wb25lbnREaWRNb3VudCIsImRpc3Bvc2FibGVzIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsInRleHRFZGl0b3IiLCJnZXRUZXh0RWRpdG9yIiwidGV4dEVkaXRvckVsZW1lbnQiLCJnZXRUZXh0RWRpdG9yRWxlbWVudCIsImF1dG9mb2N1cyIsImZvY3VzIiwic3RhcnRTZWxlY3RlZCIsInN0YXJ0U2VsZWN0ZWRSYW5nZSIsImFkZCIsIm1pY3JvdGFzayIsInN1YnNjcmliZSIsImlzRGVzdHJveWVkIiwic2VsZWN0QWxsIiwic2V0U2VsZWN0ZWRCdWZmZXJSYW5nZSIsImF0b20iLCJjb21tYW5kcyIsImV2ZW50Iiwib25Db25maXJtIiwib25DYW5jZWwiLCJwbGFjZWhvbGRlclRleHQiLCJzZXRQbGFjZWhvbGRlclRleHQiLCJzZXRBdHRyaWJ1dGUiLCJ0YWJJbmRleCIsImRpc2FibGVkIiwiX3VwZGF0ZURpc2FibGVkU3RhdGUiLCJzZXRUZXh0IiwibW92ZVRvQmVnaW5uaW5nT2ZMaW5lIiwib25EaWRDaGFuZ2UiLCJzZXRTdGF0ZSIsImdldFRleHQiLCJjYWxsIiwib25EaWRDaGFuZ2VTZWxlY3Rpb25SYW5nZSIsIl91cGRhdGVXaWR0aCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsIndpZHRoIiwibmV3VmFsdWUiLCJlZGl0b3IiLCJjdXJzb3JQb3NpdGlvbiIsImdldEN1cnNvckJ1ZmZlclBvc2l0aW9uIiwic2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24iLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInByb2Nlc3MiLCJuZXh0VGljayIsImRlc3Ryb3kiLCJpc0Rpc2FibGVkIiwicmVtb3ZlQXR0cmlidXRlIiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJyZW5kZXIiLCJjbGFzc05hbWUiLCJ1bnN0eWxlZCIsInNpemUiLCJpbnZhbGlkIiwib25DbGljayIsInN0eWxlIiwidGV4dCIsImdldE1vZGVsIiwiY2FsbGJhY2siLCJnZXRCdWZmZXIiLCJvbkRpZENoYW5nZVRleHQiLCJwcmV2V2lkdGgiLCJ1bmRlZmluZWQiLCJzZXRXaWR0aCIsIm1vdmVUb0VuZE9mTGluZSIsImRlZmF1bHRQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVlBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMENBLE1BQU1BLHlCQUF5QixHQUFHLEdBQWxDO0FBRUE7QUFDQTtBQUNBOztBQUNPLE1BQU1DLFNBQU4sU0FBd0JDLEtBQUssQ0FBQ0MsU0FBOUIsQ0FBc0Q7QUFzQjVCLFNBQXhCQyx3QkFBd0IsQ0FBQ0MsS0FBRCxFQUFlO0FBQzVDLFVBQU1DLFlBQVksR0FBRyxFQUFyQjs7QUFDQSxRQUFJRCxLQUFLLENBQUNFLEtBQU4sSUFBZSxJQUFuQixFQUF5QjtBQUN2QkQsTUFBQUEsWUFB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SW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5cclxuaW1wb3J0IHttYXliZVRvU3RyaW5nfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9zdHJpbmcnO1xyXG5pbXBvcnQge21pY3JvdGFza30gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvb2JzZXJ2YWJsZSc7XHJcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9kZWJvdW5jZSc7XHJcbmltcG9ydCBVbml2ZXJzYWxEaXNwb3NhYmxlIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5pbXBvcnQgYXRvbVRhYkluZGV4Rm9yd2FyZGVyIGZyb20gJy4vYXRvbVRhYkluZGV4Rm9yd2FyZGVyJztcclxuXHJcbnR5cGUgUHJvcHMgPSB7XHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxyXG4gIGRpc2FibGVkOiBib29sZWFuLFxyXG4gIGF1dG9mb2N1czogYm9vbGVhbixcclxuICBzdGFydFNlbGVjdGVkOiBib29sZWFuLFxyXG4gIHN0YXJ0U2VsZWN0ZWRSYW5nZT86ID9bbnVtYmVyLCBudW1iZXJdLFxyXG4gIGluaXRpYWxWYWx1ZTogc3RyaW5nLFxyXG4gIGludmFsaWQ/OiBib29sZWFuLFxyXG4gIHBsYWNlaG9sZGVyVGV4dD86IHN0cmluZyxcclxuICB0YWJJbmRleDogc3RyaW5nLFxyXG4gIG9uRm9jdXM6ICgpID0+IG1peGVkLFxyXG4gIG9uQ2xpY2s6IChldmVudDogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiBtaXhlZCxcclxuICBvbkRpZENoYW5nZTogKHRleHQ6IHN0cmluZykgPT4gbWl4ZWQsXHJcbiAgb25EaWRDaGFuZ2VTZWxlY3Rpb25SYW5nZT86IChldmVudDogYXRvbSRDaGFuZ2VTZWxlY3Rpb25SYW5nZUV2ZW50KSA9PiBtaXhlZCxcclxuICBvbkNvbmZpcm0/OiAoZXZlbnQ/OiBhdG9tJEN1c3RvbUV2ZW50KSA9PiBtaXhlZCxcclxuICBvbkNhbmNlbD86IChldmVudD86IGF0b20kQ3VzdG9tRXZlbnQpID0+IG1peGVkLFxyXG4gIG9uQmx1cjogKGJsdXJFdmVudDogRXZlbnQpID0+IG1peGVkLFxyXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdsZycsXHJcbiAgdW5zdHlsZWQ6IGJvb2xlYW4sXHJcbiAgd2lkdGg/OiA/bnVtYmVyLFxyXG4gIC8vIElmIHRoZSBgdmFsdWVgIHByb3AgaXMgc3BlY2lmaWVkLCB0aGVuIHRoZSBjb21wb25lbnQncyBkaXNwbGF5ZWQgdGV4dCBpcyBjb250cm9sbGVkIGJ5IHRoaXNcclxuICAvLyBwcm9wLiAgT3RoZXJ3aXNlIGl0cyBkaXNwbGF5ZWQgdGV4dCBtdXN0IGJlIGltcGVyYXRpdmVseSBzZXQgb24gdGhlIGluc3RhbmNlLlxyXG4gIHZhbHVlPzogc3RyaW5nLFxyXG4gIHN0eWxlOiA/T2JqZWN0LFxyXG59O1xyXG5cclxudHlwZSBTdGF0ZSA9IHt8XHJcbiAgdmFsdWU6IHN0cmluZyxcclxufH07XHJcblxyXG5jb25zdCBCTFVSX0ZPQ1VTX0RFQk9VTkNFX0RFTEFZID0gMTAwO1xyXG5cclxuLyoqXHJcbiAqIEFuIGlucHV0IGZpZWxkIHJlbmRlcmVkIGFzIGFuIDxhdG9tLXRleHQtZWRpdG9yIG1pbmkgLz4uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXRvbUlucHV0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xyXG4gIF9kaXNwb3NhYmxlczogP1VuaXZlcnNhbERpc3Bvc2FibGU7XHJcbiAgX3Jvb3ROb2RlOiA/SFRNTEVsZW1lbnQ7XHJcbiAgX2RlYm91bmNlZEVkaXRvckJsdXI6IChibHVyRXZlbnQ6IEV2ZW50KSA9PiB2b2lkO1xyXG4gIF9kZWJvdW5jZWRFZGl0b3JGb2N1czogKCkgPT4gdm9pZDtcclxuICBfaXNGb2N1c2VkOiBib29sZWFuO1xyXG4gIF90YWJJbmRleEZvcndhcmRpbmc6ID9JRGlzcG9zYWJsZTtcclxuXHJcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIGRpc2FibGVkOiBmYWxzZSxcclxuICAgIGF1dG9mb2N1czogZmFsc2UsXHJcbiAgICBzdGFydFNlbGVjdGVkOiBmYWxzZSxcclxuICAgIGluaXRpYWxWYWx1ZTogJycsXHJcbiAgICB0YWJJbmRleDogJzAnLCAvLyBEZWZhdWx0IHRvIGFsbCA8QXRvbUlucHV0IC8+IGNvbXBvbmVudHMgYmVpbmcgaW4gdGFiIG9yZGVyXHJcbiAgICBvbkNsaWNrOiAoKSA9PiB7fSxcclxuICAgIG9uRGlkQ2hhbmdlOiAoKSA9PiB7fSxcclxuICAgIG9uRm9jdXM6ICgpID0+IHt9LFxyXG4gICAgb25CbHVyOiAoKSA9PiB7fSxcclxuICAgIHVuc3R5bGVkOiBmYWxzZSxcclxuICAgIHN0eWxlOiBudWxsLFxyXG4gIH07XHJcblxyXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHM6IFByb3BzKSB7XHJcbiAgICBjb25zdCBwYXJ0aWFsU3RhdGUgPSB7fTtcclxuICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgIHBhcnRpYWxTdGF0ZS52YWx1ZSA9IHByb3BzLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJ0aWFsU3RhdGU7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICB2YWx1ZTogcHJvcHMudmFsdWUgPz8gcHJvcHMuaW5pdGlhbFZhbHVlLFxyXG4gICAgfTtcclxuICAgIHRoaXMuX2RlYm91bmNlZEVkaXRvckZvY3VzID0gZGVib3VuY2UoXHJcbiAgICAgIHRoaXMuX29uRWRpdG9yRm9jdXMsXHJcbiAgICAgIEJMVVJfRk9DVVNfREVCT1VOQ0VfREVMQVksXHJcbiAgICApO1xyXG4gICAgdGhpcy5fZGVib3VuY2VkRWRpdG9yQmx1ciA9IGRlYm91bmNlKFxyXG4gICAgICB0aGlzLl9vbkVkaXRvckJsdXIsXHJcbiAgICAgIEJMVVJfRk9DVVNfREVCT1VOQ0VfREVMQVksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQoKTogdm9pZCB7XHJcbiAgICBjb25zdCBkaXNwb3NhYmxlcyA9ICh0aGlzLl9kaXNwb3NhYmxlcyA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCkpO1xyXG5cclxuICAgIC8vIFRoZXJlIGRvZXMgbm90IGFwcGVhciB0byBiZSBhbnkgc29ydCBvZiBpbmZpbml0ZSBsb29wIHdoZXJlIGNhbGxpbmdcclxuICAgIC8vIHNldFN0YXRlKHt2YWx1ZX0pIGluIHJlc3BvbnNlIHRvIG9uRGlkQ2hhbmdlKCkgY2F1c2VzIGFub3RoZXIgY2hhbmdlXHJcbiAgICAvLyBldmVudC5cclxuICAgIGNvbnN0IHRleHRFZGl0b3IgPSB0aGlzLmdldFRleHRFZGl0b3IoKTtcclxuICAgIGNvbnN0IHRleHRFZGl0b3JFbGVtZW50ID0gdGhpcy5nZXRUZXh0RWRpdG9yRWxlbWVudCgpO1xyXG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b2ZvY3VzKSB7XHJcbiAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnZhcmlhbnQoXHJcbiAgICAgICEodGhpcy5wcm9wcy5zdGFydFNlbGVjdGVkICYmIHRoaXMucHJvcHMuc3RhcnRTZWxlY3RlZFJhbmdlICE9IG51bGwpLFxyXG4gICAgICAnY2Fubm90IGhhdmUgYm90aCBzdGFydFNlbGVjdGVkIChhbGwpIGFuZCBzdGFydFNlbGVjdGVkUmFuZ2UnLFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodGhpcy5wcm9wcy5zdGFydFNlbGVjdGVkKSB7XHJcbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgc2VsZWN0QWxsKCkgaGFzIG5vIGVmZmVjdCBpZiBjYWxsZWQgcmlnaHQgbm93LlxyXG4gICAgICBkaXNwb3NhYmxlcy5hZGQoXHJcbiAgICAgICAgbWljcm90YXNrLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXRleHRFZGl0b3IuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICAgICAgICB0ZXh0RWRpdG9yLnNlbGVjdEFsbCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0U2VsZWN0ZWRSYW5nZSA9IHRoaXMucHJvcHMuc3RhcnRTZWxlY3RlZFJhbmdlO1xyXG4gICAgaWYgKHN0YXJ0U2VsZWN0ZWRSYW5nZSAhPSBudWxsKSB7XHJcbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgc2VsZWN0QWxsKCkgaGFzIG5vIGVmZmVjdCBpZiBjYWxsZWQgcmlnaHQgbm93LlxyXG4gICAgICBkaXNwb3NhYmxlcy5hZGQoXHJcbiAgICAgICAgbWljcm90YXNrLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXRleHRFZGl0b3IuaXNEZXN0cm95ZWQoKSkge1xyXG4gICAgICAgICAgICB0ZXh0RWRpdG9yLnNldFNlbGVjdGVkQnVmZmVyUmFuZ2UoW1xyXG4gICAgICAgICAgICAgIFswLCBzdGFydFNlbGVjdGVkUmFuZ2VbMF1dLFxyXG4gICAgICAgICAgICAgIFswLCBzdGFydFNlbGVjdGVkUmFuZ2VbMV1dLFxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNwb3NhYmxlcy5hZGQoXHJcbiAgICAgIGF0b20uY29tbWFuZHMuYWRkKHRleHRFZGl0b3JFbGVtZW50LCB7XHJcbiAgICAgICAgJ2NvcmU6Y29uZmlybSc6IGV2ZW50ID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ29uZmlybSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db25maXJtKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICdjb3JlOmNhbmNlbCc6IGV2ZW50ID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2FuY2VsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNhbmNlbChldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gICAgY29uc3QgcGxhY2Vob2xkZXJUZXh0ID0gdGhpcy5wcm9wcy5wbGFjZWhvbGRlclRleHQ7XHJcbiAgICBpZiAocGxhY2Vob2xkZXJUZXh0ICE9IG51bGwpIHtcclxuICAgICAgdGV4dEVkaXRvci5zZXRQbGFjZWhvbGRlclRleHQocGxhY2Vob2xkZXJUZXh0KTtcclxuICAgIH1cclxuICAgIHRoaXMuZ2V0VGV4dEVkaXRvckVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5wcm9wcy50YWJJbmRleCk7XHJcbiAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLl91cGRhdGVEaXNhYmxlZFN0YXRlKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCB0aGUgdGV4dCBlZGl0b3IncyBpbml0aWFsIHZhbHVlIGFuZCBrZWVwIHRoZSBjdXJzb3IgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZS4gQ3Vyc29yXHJcbiAgICAvLyBwb3NpdGlvbiB3YXMgZG9jdW1lbnRlZCBpbiBhIHRlc3QgYW5kIGlzIHJldGFpbmVkIGhlcmUgYWZ0ZXIgY2hhbmdlcyB0byBob3cgdGV4dCBpcyBzZXQgaW5cclxuICAgIC8vIHRoZSB0ZXh0IGVkaXRvci4gKHNlZSBmb2N1cy1yZWxhdGVkIHNwZWMgaW4gQXRvbUlucHV0LXNwZWMuanMpXHJcbiAgICB0aGlzLnNldFRleHQodGhpcy5zdGF0ZS52YWx1ZSk7XHJcbiAgICB0aGlzLmdldFRleHRFZGl0b3IoKS5tb3ZlVG9CZWdpbm5pbmdPZkxpbmUoKTtcclxuXHJcbiAgICAvLyBCZWdpbiBsaXN0ZW5pbmcgZm9yIGNoYW5nZXMgb25seSBhZnRlciBpbml0aWFsIHZhbHVlIGlzIHNldC5cclxuICAgIGRpc3Bvc2FibGVzLmFkZChcclxuICAgICAgdGV4dEVkaXRvci5vbkRpZENoYW5nZSgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHRleHRFZGl0b3IuZ2V0VGV4dCgpfSk7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkRpZENoYW5nZS5jYWxsKG51bGwsIHRleHRFZGl0b3IuZ2V0VGV4dCgpKTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gICAgaWYgKHRoaXMucHJvcHMub25EaWRDaGFuZ2VTZWxlY3Rpb25SYW5nZSAhPSBudWxsKSB7XHJcbiAgICAgIGRpc3Bvc2FibGVzLmFkZChcclxuICAgICAgICB0ZXh0RWRpdG9yLm9uRGlkQ2hhbmdlU2VsZWN0aW9uUmFuZ2UoXHJcbiAgICAgICAgICB0aGlzLnByb3BzLm9uRGlkQ2hhbmdlU2VsZWN0aW9uUmFuZ2UsXHJcbiAgICAgICAgKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGVXaWR0aCgpO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogT2JqZWN0LCBwcmV2U3RhdGU6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgdGhpcy5fdXBkYXRlV2lkdGgocHJldlByb3BzLndpZHRoKTtcclxuXHJcbiAgICBpZiAocHJldlByb3BzLmRpc2FibGVkICE9PSB0aGlzLnByb3BzLmRpc2FibGVkKSB7XHJcbiAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkU3RhdGUodGhpcy5wcm9wcy5kaXNhYmxlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlO1xyXG4gICAgaWYgKG5ld1ZhbHVlICE9IG51bGwgJiYgcHJldlByb3BzLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmdldFRleHRFZGl0b3IoKTtcclxuICAgICAgLy8gQ2FsbGluZyBzZXRUZXh0IGlmIHRoZSB2YWx1ZSBkaWQgbm90IGNoYW5nZSB3aWxsIHJlZHVuZGFudGx5IGNhbGwgYW55XHJcbiAgICAgIC8vIG9uRGlkQ2hhbmdlIGxpc3RlbmVycyB3aXRoIHRoZSBzYW1lIGlucHV0LlxyXG4gICAgICBpZiAoZWRpdG9yLmdldFRleHQoKSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IGVkaXRvci5nZXRDdXJzb3JCdWZmZXJQb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMuc2V0VGV4dChuZXdWYWx1ZSk7XHJcbiAgICAgICAgZWRpdG9yLnNldEN1cnNvckJ1ZmZlclBvc2l0aW9uKGN1cnNvclBvc2l0aW9uKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwcmV2UHJvcHMucGxhY2Vob2xkZXJUZXh0ICE9PSB0aGlzLnByb3BzLnBsYWNlaG9sZGVyVGV4dCkge1xyXG4gICAgICB0aGlzLmdldFRleHRFZGl0b3IoKS5zZXRQbGFjZWhvbGRlclRleHQodGhpcy5wcm9wcy5wbGFjZWhvbGRlclRleHQgfHwgJycpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQoKTogdm9pZCB7XHJcbiAgICAvLyBOb3RlIHRoYXQgZGVzdHJveSgpIGlzIG5vdCBwYXJ0IG9mIFRleHRFZGl0b3IncyBwdWJsaWMgQVBJLlxyXG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5nZXRUZXh0RWRpdG9yKCk7XHJcbiAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IGVkaXRvci5kZXN0cm95KCkpO1xyXG5cclxuICAgIGlmICh0aGlzLl9kaXNwb3NhYmxlcykge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlcy5kaXNwb3NlKCk7XHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF91cGRhdGVEaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIC8vIEhhY2sgdG8gc2V0IFRleHRFZGl0b3IgdG8gcmVhZC1vbmx5IG1vZGUsIHBlciBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9hdG9tL2lzc3Vlcy82ODgwXHJcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xyXG4gICAgICB0aGlzLmdldFRleHRFZGl0b3JFbGVtZW50KCkucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5nZXRUZXh0RWRpdG9yRWxlbWVudCgpLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLnByb3BzLnRhYkluZGV4KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vbkVkaXRvckZvY3VzID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgaWYgKHRoaXMuaXNGb2N1c2VkKCkgJiYgIXRoaXMuX2lzRm9jdXNlZCkge1xyXG4gICAgICB0aGlzLl9pc0ZvY3VzZWQgPSB0cnVlO1xyXG4gICAgICB0aGlzLnByb3BzLm9uRm9jdXMgJiYgdGhpcy5wcm9wcy5vbkZvY3VzKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX29uRWRpdG9yQmx1ciA9IChibHVyRXZlbnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICBpZiAoIXRoaXMuaXNGb2N1c2VkKCkgJiYgdGhpcy5faXNGb2N1c2VkKSB7XHJcbiAgICAgIHRoaXMuX2lzRm9jdXNlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnByb3BzLm9uQmx1ciAmJiB0aGlzLnByb3BzLm9uQmx1cihibHVyRXZlbnQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGlzRm9jdXNlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMuX3Jvb3ROb2RlICE9IG51bGwgJiYgdGhpcy5fcm9vdE5vZGUuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKTogUmVhY3QuTm9kZSB7XHJcbiAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzKHRoaXMucHJvcHMuY2xhc3NOYW1lLCB7XHJcbiAgICAgICdhdG9tLXRleHQtZWRpdG9yLXVuc3R5bGVkJzogdGhpcy5wcm9wcy51bnN0eWxlZCxcclxuICAgICAgW2BhdG9tLXRleHQtZWRpdG9yLSR7bWF5YmVUb1N0cmluZyh0aGlzLnByb3BzLnNpemUpfWBdOlxyXG4gICAgICAgIHRoaXMucHJvcHMuc2l6ZSAhPSBudWxsLFxyXG4gICAgICAnYXRvbS10ZXh0LWVkaXRvci1pbnZhbGlkJzogdGhpcy5wcm9wcy5pbnZhbGlkLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgLy8gQmVjYXVzZSB0aGUgY29udGVudHMgb2YgYDxhdG9tLXRleHQtZWRpdG9yPmAgZWxlbWVudHMgYXJlIG1hbmFnZWQgYnkgaXRzIGN1c3RvbSB3ZWJcclxuICAgICAgLy8gY29tcG9uZW50IGNsYXNzIHdoZW4gXCJVc2UgU2hhZG93IERPTVwiIGlzIGRpc2FibGVkLCB0aGlzIGVsZW1lbnQgc2hvdWxkIG5ldmVyIGhhdmUgY2hpbGRyZW4uXHJcbiAgICAgIC8vIElmIGFuIGVsZW1lbnQgaGFzIG5vIGNoaWxkcmVuLCBSZWFjdCBndWFyYW50ZWVzIGl0IHdpbGwgbmV2ZXIgcmUtcmVuZGVyIHRoZSBlbGVtZW50ICh3aGljaFxyXG4gICAgICAvLyB3b3VsZCB3aXBlIG91dCB0aGUgd2ViIGNvbXBvbmVudCdzIHdvcmsgaW4gdGhpcyBjYXNlKS5cclxuICAgICAgPGF0b20tdGV4dC1lZGl0b3JcclxuICAgICAgICBjbGFzcz17Y2xhc3NOYW1lfVxyXG4gICAgICAgIG1pbmlcclxuICAgICAgICByZWY9e3RoaXMuX3RleHRFZGl0b3JSZWZ9XHJcbiAgICAgICAgb25DbGljaz17dGhpcy5wcm9wcy5vbkNsaWNrfVxyXG4gICAgICAgIG9uRm9jdXM9e3RoaXMuX2RlYm91bmNlZEVkaXRvckZvY3VzfVxyXG4gICAgICAgIG9uQmx1cj17dGhpcy5fZGVib3VuY2VkRWRpdG9yQmx1cn1cclxuICAgICAgICBzdHlsZT17dGhpcy5wcm9wcy5zdHlsZX1cclxuICAgICAgLz5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBfdGV4dEVkaXRvclJlZiA9IChyb290Tm9kZTogP0hUTUxFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICB0aGlzLl9yb290Tm9kZSA9IHJvb3ROb2RlO1xyXG4gICAgaWYgKHJvb3ROb2RlID09IG51bGwpIHtcclxuICAgICAgaWYgKHRoaXMuX3RhYkluZGV4Rm9yd2FyZGluZyAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fdGFiSW5kZXhGb3J3YXJkaW5nLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLl90YWJJbmRleEZvcndhcmRpbmcgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl90YWJJbmRleEZvcndhcmRpbmcgPSBhdG9tVGFiSW5kZXhGb3J3YXJkZXIocm9vdE5vZGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGdldFRleHQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgc2V0VGV4dCh0ZXh0OiBzdHJpbmcpIHtcclxuICAgIHRoaXMuZ2V0VGV4dEVkaXRvcigpLnNldFRleHQodGV4dCk7XHJcbiAgfVxyXG5cclxuICBnZXRUZXh0RWRpdG9yKCk6IFRleHRFZGl0b3Ige1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0VGV4dEVkaXRvckVsZW1lbnQoKS5nZXRNb2RlbCgpO1xyXG4gIH1cclxuXHJcbiAgb25EaWRDaGFuZ2UoY2FsbGJhY2s6ICgpID0+IGFueSk6IElEaXNwb3NhYmxlIHtcclxuICAgIHJldHVybiB0aGlzLmdldFRleHRFZGl0b3IoKVxyXG4gICAgICAuZ2V0QnVmZmVyKClcclxuICAgICAgLm9uRGlkQ2hhbmdlVGV4dChjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICBnZXRUZXh0RWRpdG9yRWxlbWVudCgpOiBhdG9tJFRleHRFZGl0b3JFbGVtZW50IHtcclxuICAgIGludmFyaWFudCh0aGlzLl9yb290Tm9kZSAhPSBudWxsKTtcclxuICAgIC8vICRGbG93Rml4TWVcclxuICAgIHJldHVybiB0aGlzLl9yb290Tm9kZTtcclxuICB9XHJcblxyXG4gIF91cGRhdGVXaWR0aChwcmV2V2lkdGg/OiBudW1iZXIpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnByb3BzLndpZHRoICE9PSBwcmV2V2lkdGgpIHtcclxuICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnByb3BzLndpZHRoID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLnByb3BzLndpZHRoO1xyXG4gICAgICB0aGlzLmdldFRleHRFZGl0b3JFbGVtZW50KCkuc2V0V2lkdGgod2lkdGgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZm9jdXMoKTogdm9pZCB7XHJcbiAgICB0aGlzLmdldFRleHRFZGl0b3IoKS5tb3ZlVG9FbmRPZkxpbmUoKTtcclxuICAgIHRoaXMuZ2V0VGV4dEVkaXRvckVsZW1lbnQoKS5mb2N1cygpO1xyXG4gIH1cclxufVxyXG4iXX0=