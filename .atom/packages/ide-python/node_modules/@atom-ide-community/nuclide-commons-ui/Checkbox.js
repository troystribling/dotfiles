"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Checkbox = void 0;

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _addTooltip = _interopRequireDefault(require("./addTooltip"));

var _ignoreTextSelectionEvents = _interopRequireDefault(require("./ignoreTextSelectionEvents"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * A checkbox component with an input checkbox and a label. We restrict the label to a string
 * to ensure this component is pure.
 */
class Checkbox extends React.PureComponent {
  constructor(props) {
    super(props);
    this._input = void 0;
    this._onChange = this._onChange.bind(this);
  }

  componentDidMount() {
    this._setIndeterminate();
  }

  componentDidUpdate() {
    this._setIndeterminate();
  }

  _onChange(event) {
    const isChecked = event.target.checked;
    this.props.onChange.call(null, isChecked);
  }
  /*
   * Syncs the `indeterminate` prop to the underlying `<input>`. `indeterminate` is intentionally
   * not settable via HTML; it must be done on the `HTMLInputElement` instance in script.
   *
   * @see https://www.w3.org/TR/html5/forms.html#the-input-element
   */


  _setIndeterminate() {
    if (this._input == null) {
      return;
    }

    this._input.indeterminate = this.props.indeterminate;
  }

  render() {
    const {
      checked,
      className,
      disabled,
      // eslint-disable-next-line no-unused-vars
      indeterminate,
      // exclude `indeterminate` from `remainingProps`
      label,
      onClick,
      tooltip,
      title,
      onMouseDown
    } = this.props;
    const ref = tooltip ? (0, _addTooltip.default)(tooltip) : null;
    const text = label === '' ? null : /*#__PURE__*/React.createElement("span", {
      className: "nuclide-ui-checkbox-label-text"
    }, " ", label);
    return /*#__PURE__*/React.createElement("label", {
      className: (0, _classnames.default)(className, 'nuclide-ui-checkbox-label', {
        'nuclide-ui-checkbox-disabled': disabled
      }) // eslint-disable-next-line nuclide-internal/jsx-simple-callback-refs
      ,
      ref: ref,
      onClick: onClick && (0, _ignoreTextSelectionEvents.default)(onClick),
      title: title
    }, /*#__PURE__*/React.createElement("input", {
      checked: checked,
      className: "input-checkbox nuclide-ui-checkbox",
      disabled: disabled,
      onChange: this._onChange,
      onMouseDown: onMouseDown,
      ref: el => {
        this._input = el;
      },
      type: "checkbox"
    }), text);
  }

}

exports.Checkbox = Checkbox;
Checkbox.defaultProps = {
  disabled: false,
  indeterminate: false,
  label: '',

  onClick(event) {},

  onMouseDown(event) {}

};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL0NoZWNrYm94LmpzIl0sIm5hbWVzIjpbIkNoZWNrYm94IiwiUmVhY3QiLCJQdXJlQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIl9pbnB1dCIsIl9vbkNoYW5nZSIsImJpbmQiLCJjb21wb25lbnREaWRNb3VudCIsIl9zZXRJbmRldGVybWluYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZXZlbnQiLCJpc0NoZWNrZWQiLCJ0YXJnZXQiLCJjaGVja2VkIiwib25DaGFuZ2UiLCJjYWxsIiwiaW5kZXRlcm1pbmF0ZSIsInJlbmRlciIsImNsYXNzTmFtZSIsImRpc2FibGVkIiwibGFiZWwiLCJvbkNsaWNrIiwidG9vbHRpcCIsInRpdGxlIiwib25Nb3VzZURvd24iLCJyZWYiLCJ0ZXh0IiwiZWwiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNQSxRQUFOLFNBQXVCQyxLQUFLLENBQUNDLGFBQTdCLENBQWtEO0FBV3ZEQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBZTtBQUN4QixVQUFNQSxLQUFOO0FBRHdCLFNBVjFCQyxNQVUwQjtBQUV2QixRQUFELENBQVlDLFNBQVosR0FBd0IsS0FBS0EsU0FBTCxDQUFlQyxJQUFmLENBQW9CLElBQXBCLENBQXhCO0FBQ0Q7O0FBRURDLEVBQUFBLGlCQUFpQixHQUFHO0FBQ2xCLFNBQUtDLGlCQUFMO0FBQ0Q7O0FBRURDLEVBQUFBLGtCQUFrQixHQUFHO0FBQ25CLFNBQUtELGlCQUFMO0FBQ0Q7O0FBRURILEVBQUFBLFNBQVMsQ0FBQ0ssS0FBRCxFQUEwQjtBQUNqQyxVQUFNQyxTQUFTLEdBQUtELEtBQUssQ0FBQ0UsTUFBUixDQUF3Q0MsT0FBMUQ7QUFDQSxTQUFLVixLQUFMLENBQVdXLFFBQVgsQ0FBb0JDLElBQXBCLENBQXlCLElBQXpCLEVBQStCSixTQUEvQjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRUgsRUFBQUEsaUJBQWlCLEdBQVM7QUFDeEIsUUFBSSxLQUFLSixNQUFMLElBQWUsSUFBbkIsRUFBeUI7QUFDdkI7QUFDRDs7QUFDRCxTQUFLQSxNQUFMLENBQVlZLGFBQVosR0FBNEIsS0FBS2IsS0FBTCxDQUFXYSxhQUF2QztBQUNEOztBQUVEQyxFQUFBQSxNQUFNLEdBQWU7QUFDbkIsVUFBTTtBQUNKSixNQUFBQSxPQURJO0FBRUpLLE1BQUFBLFNBRkk7QUFHSkMsTUFBQUEsUUFISTtBQUlKO0FBQ0FILE1BQUFBLGFBTEk7QUFLVztBQUNmSSxNQUFBQSxLQU5JO0FBT0pDLE1BQUFBLE9BUEk7QUFRSkMsTUFBQUEsT0FSSTtBQVNKQyxNQUFBQSxLQVRJO0FBVUpDLE1BQUFBO0FBVkksUUFXRixLQUFLckIsS0FYVDtBQWFBLFVBQU1zQixHQUFHLEdBQUdILE9BQU8sR0FBRyx5QkFBV0EsT0FBWCxDQUFILEdBQXlCLElBQTVDO0FBQ0EsVUFBTUksSUFBSSxHQUNSTixLQUFLLEtBQUssRUFBVixHQUFlLElBQWYsZ0JBQ0U7QUFBTSxNQUFBLFNBQVMsRUFBQztBQUFoQixZQUFtREEsS0FBbkQsQ0FGSjtBQUlBLHdCQUNFO0FBQ0UsTUFBQSxTQUFTLEVBQUUseUJBQVdGLFNBQVgsRUFBc0IsMkJBQXRCLEVBQW1EO0FBQzVELHdDQUFnQ0M7QUFENEIsT0FBbkQsQ0FEYixDQUlFO0FBSkY7QUFLRSxNQUFBLEdBQUcsRUFBRU0sR0FMUDtBQU1FLE1BQUEsT0FBTyxFQUFFSixPQUFPLElBQUksd0NBQTBCQSxPQUExQixDQU50QjtBQU9FLE1BQUEsS0FBSyxFQUFFRTtBQVBULG9CQVFFO0FBQ0UsTUFBQSxPQUFPLEVBQUVWLE9BRFg7QUFFRSxNQUFBLFNBQVMsRUFBQyxvQ0FGWjtBQUdFLE1BQUEsUUFBUSxFQUFFTSxRQUhaO0FBSUUsTUFBQSxRQUFRLEVBQUUsS0FBS2QsU0FKakI7QUFLRSxNQUFBLFdBQVcsRUFBRW1CLFdBTGY7QUFNRSxNQUFBLEdBQUcsRUFBRUcsRUFBRSxJQUFJO0FBQ1QsYUFBS3ZCLE1BQUwsR0FBY3VCLEVBQWQ7QUFDRCxPQVJIO0FBU0UsTUFBQSxJQUFJLEVBQUM7QUFUUCxNQVJGLEVBbUJHRCxJQW5CSCxDQURGO0FBdUJEOztBQXBGc0Q7OztBQUE1QzNCLFEsQ0FHSjZCLFksR0FBNkI7QUFDbENULEVBQUFBLFFBQVEsRUFBRSxLQUR3QjtBQUVsQ0gsRUFBQUEsYUFBYSxFQUFFLEtBRm1CO0FBR2xDSSxFQUFBQSxLQUFLLEVBQUUsRUFIMkI7O0FBSWxDQyxFQUFBQSxPQUFPLENBQUNYLEtBQUQsRUFBUSxDQUFFLENBSmlCOztBQUtsQ2MsRUFBQUEsV0FBVyxDQUFDZCxLQUFELEVBQVEsQ0FBRTs7QUFMYSxDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IGFkZFRvb2x0aXAgZnJvbSAnLi9hZGRUb29sdGlwJztcclxuXHJcbmltcG9ydCBpZ25vcmVUZXh0U2VsZWN0aW9uRXZlbnRzIGZyb20gJy4vaWdub3JlVGV4dFNlbGVjdGlvbkV2ZW50cyc7XHJcblxyXG50eXBlIERlZmF1bHRQcm9wcyA9IHtcclxuICBkaXNhYmxlZDogYm9vbGVhbixcclxuICBpbmRldGVybWluYXRlOiBib29sZWFuLFxyXG4gIGxhYmVsOiBzdHJpbmcsXHJcbiAgb25DbGljazogKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IG1peGVkLFxyXG4gIG9uTW91c2VEb3duOiAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4gbWl4ZWQsXHJcbn07XHJcblxyXG50eXBlIFByb3BzID0ge1xyXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcclxuICBjaGVja2VkOiBib29sZWFuLFxyXG4gIGRpc2FibGVkOiBib29sZWFuLFxyXG4gIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4sXHJcbiAgbGFiZWw6IHN0cmluZyxcclxuICBvbkNoYW5nZTogKGlzQ2hlY2tlZDogYm9vbGVhbikgPT4gbWl4ZWQsXHJcbiAgb25DbGljazogKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IG1peGVkLFxyXG4gIHRvb2x0aXA/OiBhdG9tJFRvb2x0aXBzQWRkT3B0aW9ucyxcclxuICB0aXRsZT86ID9zdHJpbmcsXHJcbiAgb25Nb3VzZURvd246IChldmVudDogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiBtaXhlZCxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGNoZWNrYm94IGNvbXBvbmVudCB3aXRoIGFuIGlucHV0IGNoZWNrYm94IGFuZCBhIGxhYmVsLiBXZSByZXN0cmljdCB0aGUgbGFiZWwgdG8gYSBzdHJpbmdcclxuICogdG8gZW5zdXJlIHRoaXMgY29tcG9uZW50IGlzIHB1cmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzPiB7XHJcbiAgX2lucHV0OiA/SFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgc3RhdGljIGRlZmF1bHRQcm9wczogRGVmYXVsdFByb3BzID0ge1xyXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxyXG4gICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXHJcbiAgICBsYWJlbDogJycsXHJcbiAgICBvbkNsaWNrKGV2ZW50KSB7fSxcclxuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7fSxcclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcclxuICAgIHN1cGVyKHByb3BzKTtcclxuICAgICh0aGlzOiBhbnkpLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIHRoaXMuX3NldEluZGV0ZXJtaW5hdGUoKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcclxuICAgIHRoaXMuX3NldEluZGV0ZXJtaW5hdGUoKTtcclxuICB9XHJcblxyXG4gIF9vbkNoYW5nZShldmVudDogU3ludGhldGljRXZlbnQ8Pikge1xyXG4gICAgY29uc3QgaXNDaGVja2VkID0gKChldmVudC50YXJnZXQ6IGFueSk6IEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQ7XHJcbiAgICB0aGlzLnByb3BzLm9uQ2hhbmdlLmNhbGwobnVsbCwgaXNDaGVja2VkKTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogU3luY3MgdGhlIGBpbmRldGVybWluYXRlYCBwcm9wIHRvIHRoZSB1bmRlcmx5aW5nIGA8aW5wdXQ+YC4gYGluZGV0ZXJtaW5hdGVgIGlzIGludGVudGlvbmFsbHlcclxuICAgKiBub3Qgc2V0dGFibGUgdmlhIEhUTUw7IGl0IG11c3QgYmUgZG9uZSBvbiB0aGUgYEhUTUxJbnB1dEVsZW1lbnRgIGluc3RhbmNlIGluIHNjcmlwdC5cclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdGhlLWlucHV0LWVsZW1lbnRcclxuICAgKi9cclxuICBfc2V0SW5kZXRlcm1pbmF0ZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9pbnB1dCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuX2lucHV0LmluZGV0ZXJtaW5hdGUgPSB0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGU7XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKTogUmVhY3QuTm9kZSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGNoZWNrZWQsXHJcbiAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgZGlzYWJsZWQsXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gICAgICBpbmRldGVybWluYXRlLCAvLyBleGNsdWRlIGBpbmRldGVybWluYXRlYCBmcm9tIGByZW1haW5pbmdQcm9wc2BcclxuICAgICAgbGFiZWwsXHJcbiAgICAgIG9uQ2xpY2ssXHJcbiAgICAgIHRvb2x0aXAsXHJcbiAgICAgIHRpdGxlLFxyXG4gICAgICBvbk1vdXNlRG93bixcclxuICAgIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIGNvbnN0IHJlZiA9IHRvb2x0aXAgPyBhZGRUb29sdGlwKHRvb2x0aXApIDogbnVsbDtcclxuICAgIGNvbnN0IHRleHQgPVxyXG4gICAgICBsYWJlbCA9PT0gJycgPyBudWxsIDogKFxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm51Y2xpZGUtdWktY2hlY2tib3gtbGFiZWwtdGV4dFwiPiB7bGFiZWx9PC9zcGFuPlxyXG4gICAgICApO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGxhYmVsXHJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKGNsYXNzTmFtZSwgJ251Y2xpZGUtdWktY2hlY2tib3gtbGFiZWwnLCB7XHJcbiAgICAgICAgICAnbnVjbGlkZS11aS1jaGVja2JveC1kaXNhYmxlZCc6IGRpc2FibGVkLFxyXG4gICAgICAgIH0pfVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBudWNsaWRlLWludGVybmFsL2pzeC1zaW1wbGUtY2FsbGJhY2stcmVmc1xyXG4gICAgICAgIHJlZj17cmVmfVxyXG4gICAgICAgIG9uQ2xpY2s9e29uQ2xpY2sgJiYgaWdub3JlVGV4dFNlbGVjdGlvbkV2ZW50cyhvbkNsaWNrKX1cclxuICAgICAgICB0aXRsZT17dGl0bGV9PlxyXG4gICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cclxuICAgICAgICAgIGNsYXNzTmFtZT1cImlucHV0LWNoZWNrYm94IG51Y2xpZGUtdWktY2hlY2tib3hcIlxyXG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuX29uQ2hhbmdlfVxyXG4gICAgICAgICAgb25Nb3VzZURvd249e29uTW91c2VEb3dufVxyXG4gICAgICAgICAgcmVmPXtlbCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0ID0gZWw7XHJcbiAgICAgICAgICB9fVxyXG4gICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcclxuICAgICAgICAvPlxyXG4gICAgICAgIHt0ZXh0fVxyXG4gICAgICA8L2xhYmVsPlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19