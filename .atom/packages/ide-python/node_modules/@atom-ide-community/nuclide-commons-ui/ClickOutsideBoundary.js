"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _reactDom = require("react-dom");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
class ClickOutsideBoundary extends React.Component {
  constructor(props) {
    super(props);
    this._lastInternalEvent = void 0;
    this._node = void 0;

    this._handleDocumentClick = e => {
      // A more straight-forward approach would be to use
      // `this._node.contains(e.target)`, however that fails in the edge case were
      // some other event handler causes the target to be removed from the DOM
      // before the event reaches the document root. So instead, we use this
      // reference comparison approach which works for all cases where an event
      // passed trough the boundary node, and makes it all the way to the document
      // root.
      if (e !== this._lastInternalEvent) {
        if (this.props.onClickOutside != null) {
          this.props.onClickOutside();
        }
      }

      this._lastInternalEvent = null;
    };

    this._handleInternalClick = e => {
      this._lastInternalEvent = e;
    };

    this._lastInternalEvent = null;
    this._node = null;
  }

  componentDidMount() {
    const node = this._node = (0, _reactDom.findDOMNode)(this);

    if (node == null) {
      return;
    }

    window.document.addEventListener('click', this._handleDocumentClick); // We use an actual DOM node (via refs) because React does not gaurnetee
    // any particular event ordering between synthentic events and native
    // events, and we require that the internal event fire before the global event.
    // https://discuss.reactjs.org/t/ordering-of-native-and-react-events/829/2

    node.addEventListener('click', this._handleInternalClick);
  }

  componentWillUnmount() {
    window.document.removeEventListener('click', this._handleDocumentClick);

    if (this._node != null) {
      this._node.removeEventListener('click', this._handleInternalClick);
    }
  }

  render() {
    const {
      onClickOutside,
      ...passThroughProps
    } = this.props;
    return /*#__PURE__*/React.createElement("div", passThroughProps);
  }

}

exports.default = ClickOutsideBoundary;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL0NsaWNrT3V0c2lkZUJvdW5kYXJ5LmpzIl0sIm5hbWVzIjpbIkNsaWNrT3V0c2lkZUJvdW5kYXJ5IiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiX2xhc3RJbnRlcm5hbEV2ZW50IiwiX25vZGUiLCJfaGFuZGxlRG9jdW1lbnRDbGljayIsImUiLCJvbkNsaWNrT3V0c2lkZSIsIl9oYW5kbGVJbnRlcm5hbENsaWNrIiwiY29tcG9uZW50RGlkTW91bnQiLCJub2RlIiwid2luZG93IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVuZGVyIiwicGFzc1Rocm91Z2hQcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVlBOztBQUNBOzs7Ozs7QUFiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVWUsTUFBTUEsb0JBQU4sU0FBbUNDLEtBQUssQ0FBQ0MsU0FBekMsQ0FBMEQ7QUFJdkVDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFlO0FBQ3hCLFVBQU1BLEtBQU47QUFEd0IsU0FIMUJDLGtCQUcwQjtBQUFBLFNBRjFCQyxLQUUwQjs7QUFBQSxTQW1CMUJDLG9CQW5CMEIsR0FtQkZDLENBQUQsSUFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJQSxDQUFDLEtBQUssS0FBS0gsa0JBQWYsRUFBbUM7QUFDakMsWUFBSSxLQUFLRCxLQUFMLENBQVdLLGNBQVgsSUFBNkIsSUFBakMsRUFBdUM7QUFDckMsZUFBS0wsS0FBTCxDQUFXSyxjQUFYO0FBQ0Q7QUFDRjs7QUFDRCxXQUFLSixrQkFBTCxHQUEwQixJQUExQjtBQUNELEtBakN5Qjs7QUFBQSxTQW1DMUJLLG9CQW5DMEIsR0FtQ0ZGLENBQUQsSUFBbUI7QUFDeEMsV0FBS0gsa0JBQUwsR0FBMEJHLENBQTFCO0FBQ0QsS0FyQ3lCOztBQUV4QixTQUFLSCxrQkFBTCxHQUEwQixJQUExQjtBQUNBLFNBQUtDLEtBQUwsR0FBYSxJQUFiO0FBQ0Q7O0FBRURLLEVBQUFBLGlCQUFpQixHQUFHO0FBQ2xCLFVBQU1DLElBQUksR0FBSSxLQUFLTixLQUFMLEdBQWEsMkJBQVksSUFBWixDQUEzQjs7QUFDQSxRQUFJTSxJQUFJLElBQUksSUFBWixFQUFrQjtBQUNoQjtBQUNEOztBQUNEQyxJQUFBQSxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JDLGdCQUFoQixDQUFpQyxPQUFqQyxFQUEwQyxLQUFLUixvQkFBL0MsRUFMa0IsQ0FNbEI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FLLElBQUFBLElBQUksQ0FBQ0csZ0JBQUwsQ0FBc0IsT0FBdEIsRUFBK0IsS0FBS0wsb0JBQXBDO0FBQ0Q7O0FBc0JETSxFQUFBQSxvQkFBb0IsR0FBRztBQUNyQkgsSUFBQUEsTUFBTSxDQUFDQyxRQUFQLENBQWdCRyxtQkFBaEIsQ0FBb0MsT0FBcEMsRUFBNkMsS0FBS1Ysb0JBQWxEOztBQUNBLFFBQUksS0FBS0QsS0FBTCxJQUFjLElBQWxCLEVBQXdCO0FBQ3RCLFdBQUtBLEtBQUwsQ0FBV1csbUJBQVgsQ0FBK0IsT0FBL0IsRUFBd0MsS0FBS1Asb0JBQTdDO0FBQ0Q7QUFDRjs7QUFFRFEsRUFBQUEsTUFBTSxHQUFHO0FBQ1AsVUFBTTtBQUFDVCxNQUFBQSxjQUFEO0FBQWlCLFNBQUdVO0FBQXBCLFFBQXdDLEtBQUtmLEtBQW5EO0FBQ0Esd0JBQU8sMkJBQVNlLGdCQUFULENBQVA7QUFDRDs7QUFyRHNFIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQge2ZpbmRET01Ob2RlfSBmcm9tICdyZWFjdC1kb20nO1xyXG5cclxudHlwZSBQcm9wcyA9IHtcclxuICBvbkNsaWNrT3V0c2lkZTogPygpID0+IG1peGVkLFxyXG4gIGNoaWxkcmVuOiA/UmVhY3QuRWxlbWVudDxhbnk+LFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xpY2tPdXRzaWRlQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcclxuICBfbGFzdEludGVybmFsRXZlbnQ6ID9Nb3VzZUV2ZW50O1xyXG4gIF9ub2RlOiBudWxsIHwgRWxlbWVudCB8IFRleHQ7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5fbGFzdEludGVybmFsRXZlbnQgPSBudWxsO1xyXG4gICAgdGhpcy5fbm9kZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIGNvbnN0IG5vZGUgPSAodGhpcy5fbm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpKTtcclxuICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5faGFuZGxlRG9jdW1lbnRDbGljayk7XHJcbiAgICAvLyBXZSB1c2UgYW4gYWN0dWFsIERPTSBub2RlICh2aWEgcmVmcykgYmVjYXVzZSBSZWFjdCBkb2VzIG5vdCBnYXVybmV0ZWVcclxuICAgIC8vIGFueSBwYXJ0aWN1bGFyIGV2ZW50IG9yZGVyaW5nIGJldHdlZW4gc3ludGhlbnRpYyBldmVudHMgYW5kIG5hdGl2ZVxyXG4gICAgLy8gZXZlbnRzLCBhbmQgd2UgcmVxdWlyZSB0aGF0IHRoZSBpbnRlcm5hbCBldmVudCBmaXJlIGJlZm9yZSB0aGUgZ2xvYmFsIGV2ZW50LlxyXG4gICAgLy8gaHR0cHM6Ly9kaXNjdXNzLnJlYWN0anMub3JnL3Qvb3JkZXJpbmctb2YtbmF0aXZlLWFuZC1yZWFjdC1ldmVudHMvODI5LzJcclxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVJbnRlcm5hbENsaWNrKTtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVEb2N1bWVudENsaWNrID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgIC8vIEEgbW9yZSBzdHJhaWdodC1mb3J3YXJkIGFwcHJvYWNoIHdvdWxkIGJlIHRvIHVzZVxyXG4gICAgLy8gYHRoaXMuX25vZGUuY29udGFpbnMoZS50YXJnZXQpYCwgaG93ZXZlciB0aGF0IGZhaWxzIGluIHRoZSBlZGdlIGNhc2Ugd2VyZVxyXG4gICAgLy8gc29tZSBvdGhlciBldmVudCBoYW5kbGVyIGNhdXNlcyB0aGUgdGFyZ2V0IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXHJcbiAgICAvLyBiZWZvcmUgdGhlIGV2ZW50IHJlYWNoZXMgdGhlIGRvY3VtZW50IHJvb3QuIFNvIGluc3RlYWQsIHdlIHVzZSB0aGlzXHJcbiAgICAvLyByZWZlcmVuY2UgY29tcGFyaXNvbiBhcHByb2FjaCB3aGljaCB3b3JrcyBmb3IgYWxsIGNhc2VzIHdoZXJlIGFuIGV2ZW50XHJcbiAgICAvLyBwYXNzZWQgdHJvdWdoIHRoZSBib3VuZGFyeSBub2RlLCBhbmQgbWFrZXMgaXQgYWxsIHRoZSB3YXkgdG8gdGhlIGRvY3VtZW50XHJcbiAgICAvLyByb290LlxyXG4gICAgaWYgKGUgIT09IHRoaXMuX2xhc3RJbnRlcm5hbEV2ZW50KSB7XHJcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2tPdXRzaWRlICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2tPdXRzaWRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuX2xhc3RJbnRlcm5hbEV2ZW50ID0gbnVsbDtcclxuICB9O1xyXG5cclxuICBfaGFuZGxlSW50ZXJuYWxDbGljayA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICB0aGlzLl9sYXN0SW50ZXJuYWxFdmVudCA9IGU7XHJcbiAgfTtcclxuXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9oYW5kbGVEb2N1bWVudENsaWNrKTtcclxuICAgIGlmICh0aGlzLl9ub2RlICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2hhbmRsZUludGVybmFsQ2xpY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3Qge29uQ2xpY2tPdXRzaWRlLCAuLi5wYXNzVGhyb3VnaFByb3BzfSA9IHRoaXMucHJvcHM7XHJcbiAgICByZXR1cm4gPGRpdiB7Li4ucGFzc1Rocm91Z2hQcm9wc30gLz47XHJcbiAgfVxyXG59XHJcbiJdfQ==