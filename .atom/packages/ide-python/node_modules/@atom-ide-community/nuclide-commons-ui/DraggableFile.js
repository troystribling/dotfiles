"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dragEventCameFromDraggableFile = dragEventCameFromDraggableFile;
exports.default = void 0;

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var React = _interopRequireWildcard(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _analytics = require("@atom-ide-community/nuclide-commons/analytics");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const MAGIC_DATA_TRANSFER_KEY = 'nuclide-draggable-file';

class DraggableFile extends React.Component {
  constructor(...args) {
    super(...args);
    this._disposables = void 0;

    this._onDragStart = e => {
      const {
        dataTransfer
      } = e;

      if (dataTransfer != null) {
        dataTransfer.effectAllowed = 'move';
        dataTransfer.setData('initialPath', this.props.uri); // For security reasons, dragEnter events can't see the values of
        // `dataTransfer`, just the keys. So, we use a unique key to enable other
        // components to infer if a drag event contains a draggable file.

        dataTransfer.setData(MAGIC_DATA_TRANSFER_KEY, ''); // Allow draggable files to be dragged into the tab bar.

        dataTransfer.setData('text/plain', this.props.uri);
        dataTransfer.setData('atom-event', 'true');
        dataTransfer.setData('allow-all-locations', 'true');
        (0, _analytics.track)('draggable-file:drag-start', {
          source: this.props.trackingSource,
          uri: this.props.uri
        });
      }
    };
  }

  componentDidMount() {
    const el = _reactDom.default.findDOMNode(this);

    this._disposables = new _UniversalDisposable.default( // Because this element can be inside of an Atom panel (which adds its own drag and drop
    // handlers) we need to sidestep React's event delegation.
    _rxjsCompatUmdMin.Observable.fromEvent(el, 'dragstart').subscribe(this._onDragStart));
  }

  componentWillUnmount() {
    this._disposables.dispose();
  }

  render() {
    const {
      uri,
      trackingSource,
      draggable = true,
      ...restProps
    } = this.props; // https://discuss.atom.io/t/drag-drop/21262/14

    const tabIndex = -1;
    return /*#__PURE__*/React.createElement("div", _extends({
      draggable: draggable,
      tabIndex: tabIndex
    }, restProps));
  }

}

exports.default = DraggableFile;

function dragEventCameFromDraggableFile(event) {
  const {
    dataTransfer
  } = event;

  if (dataTransfer == null) {
    return false;
  }

  return dataTransfer.types.includes(MAGIC_DATA_TRANSFER_KEY);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL0RyYWdnYWJsZUZpbGUuanMiXSwibmFtZXMiOlsiTUFHSUNfREFUQV9UUkFOU0ZFUl9LRVkiLCJEcmFnZ2FibGVGaWxlIiwiUmVhY3QiLCJDb21wb25lbnQiLCJfZGlzcG9zYWJsZXMiLCJfb25EcmFnU3RhcnQiLCJlIiwiZGF0YVRyYW5zZmVyIiwiZWZmZWN0QWxsb3dlZCIsInNldERhdGEiLCJwcm9wcyIsInVyaSIsInNvdXJjZSIsInRyYWNraW5nU291cmNlIiwiY29tcG9uZW50RGlkTW91bnQiLCJlbCIsIlJlYWN0RE9NIiwiZmluZERPTU5vZGUiLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwiT2JzZXJ2YWJsZSIsImZyb21FdmVudCIsInN1YnNjcmliZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZGlzcG9zZSIsInJlbmRlciIsImRyYWdnYWJsZSIsInJlc3RQcm9wcyIsInRhYkluZGV4IiwiZHJhZ0V2ZW50Q2FtZUZyb21EcmFnZ2FibGVGaWxlIiwiZXZlbnQiLCJ0eXBlcyIsImluY2x1ZGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQWFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7Ozs7O0FBRUEsTUFBTUEsdUJBQXVCLEdBQUcsd0JBQWhDOztBQUVlLE1BQU1DLGFBQU4sU0FBNEJDLEtBQUssQ0FBQ0MsU0FBbEMsQ0FJWjtBQUFBO0FBQUE7QUFBQSxTQUNEQyxZQURDOztBQUFBLFNBaUJEQyxZQWpCQyxHQWlCZUMsQ0FBRCxJQUFrQjtBQUMvQixZQUFNO0FBQUNDLFFBQUFBO0FBQUQsVUFBaUJELENBQXZCOztBQUNBLFVBQUlDLFlBQVksSUFBSSxJQUFwQixFQUEwQjtBQUN4QkEsUUFBQUEsWUFBWSxDQUFDQyxhQUFiLEdBQTZCLE1BQTdCO0FBQ0FELFFBQUFBLFlBQVksQ0FBQ0UsT0FBYixDQUFxQixhQUFyQixFQUFvQyxLQUFLQyxLQUFMLENBQVdDLEdBQS9DLEVBRndCLENBR3hCO0FBQ0E7QUFDQTs7QUFDQUosUUFBQUEsWUFBWSxDQUFDRSxPQUFiLENBQXFCVCx1QkFBckIsRUFBOEMsRUFBOUMsRUFOd0IsQ0FReEI7O0FBQ0FPLFFBQUFBLFlBQVksQ0FBQ0UsT0FBYixDQUFxQixZQUFyQixFQUFtQyxLQUFLQyxLQUFMLENBQVdDLEdBQTlDO0FBQ0FKLFFBQUFBLFlBQVksQ0FBQ0UsT0FBYixDQUFxQixZQUFyQixFQUFtQyxNQUFuQztBQUNBRixRQUFBQSxZQUFZLENBQUNFLE9BQWIsQ0FBcUIscUJBQXJCLEVBQTRDLE1BQTVDO0FBQ0EsOEJBQU0sMkJBQU4sRUFBbUM7QUFDakNHLFVBQUFBLE1BQU0sRUFBRSxLQUFLRixLQUFMLENBQVdHLGNBRGM7QUFFakNGLFVBQUFBLEdBQUcsRUFBRSxLQUFLRCxLQUFMLENBQVdDO0FBRmlCLFNBQW5DO0FBSUQ7QUFDRixLQXBDQTtBQUFBOztBQUdERyxFQUFBQSxpQkFBaUIsR0FBRztBQUNsQixVQUFNQyxFQUFFLEdBQUdDLGtCQUFTQyxXQUFULENBQXFCLElBQXJCLENBQVg7O0FBRUEsU0FBS2IsWUFBTCxHQUFvQixJQUFJYyw0QkFBSixFQUNsQjtBQUNBO0FBQ0FDLGlDQUFXQyxTQUFYLENBQXFCTCxFQUFyQixFQUF5QixXQUF6QixFQUFzQ00sU0FBdEMsQ0FBZ0QsS0FBS2hCLFlBQXJELENBSGtCLENBQXBCO0FBS0Q7O0FBRURpQixFQUFBQSxvQkFBb0IsR0FBRztBQUNyQixTQUFLbEIsWUFBTCxDQUFrQm1CLE9BQWxCO0FBQ0Q7O0FBdUJEQyxFQUFBQSxNQUFNLEdBQUc7QUFDUCxVQUFNO0FBQUNiLE1BQUFBLEdBQUQ7QUFBTUUsTUFBQUEsY0FBTjtBQUFzQlksTUFBQUEsU0FBUyxHQUFHLElBQWxDO0FBQXdDLFNBQUdDO0FBQTNDLFFBQXdELEtBQUtoQixLQUFuRSxDQURPLENBRVA7O0FBQ0EsVUFBTWlCLFFBQVEsR0FBRyxDQUFDLENBQWxCO0FBQ0Esd0JBQU87QUFBSyxNQUFBLFNBQVMsRUFBRUYsU0FBaEI7QUFBMkIsTUFBQSxRQUFRLEVBQUVFO0FBQXJDLE9BQW1ERCxTQUFuRCxFQUFQO0FBQ0Q7O0FBM0NBOzs7O0FBOENJLFNBQVNFLDhCQUFULENBQXdDQyxLQUF4QyxFQUEwRDtBQUMvRCxRQUFNO0FBQUN0QixJQUFBQTtBQUFELE1BQWlCc0IsS0FBdkI7O0FBQ0EsTUFBSXRCLFlBQVksSUFBSSxJQUFwQixFQUEwQjtBQUN4QixXQUFPLEtBQVA7QUFDRDs7QUFDRCxTQUFPQSxZQUFZLENBQUN1QixLQUFiLENBQW1CQyxRQUFuQixDQUE0Qi9CLHVCQUE1QixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge051Y2xpZGVVcml9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL251Y2xpZGVVcmknO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQge3RyYWNrfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9hbmFseXRpY3MnO1xyXG5cclxuY29uc3QgTUFHSUNfREFUQV9UUkFOU0ZFUl9LRVkgPSAnbnVjbGlkZS1kcmFnZ2FibGUtZmlsZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcmFnZ2FibGVGaWxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHtcclxuICB1cmk6IE51Y2xpZGVVcmksXHJcbiAgdHJhY2tpbmdTb3VyY2U6IHN0cmluZyxcclxuICBkcmFnZ2FibGU/OiBib29sZWFuLFxyXG59PiB7XHJcbiAgX2Rpc3Bvc2FibGVzOiBVbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIGNvbnN0IGVsID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XHJcblxyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMgPSBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgICAgLy8gQmVjYXVzZSB0aGlzIGVsZW1lbnQgY2FuIGJlIGluc2lkZSBvZiBhbiBBdG9tIHBhbmVsICh3aGljaCBhZGRzIGl0cyBvd24gZHJhZyBhbmQgZHJvcFxyXG4gICAgICAvLyBoYW5kbGVycykgd2UgbmVlZCB0byBzaWRlc3RlcCBSZWFjdCdzIGV2ZW50IGRlbGVnYXRpb24uXHJcbiAgICAgIE9ic2VydmFibGUuZnJvbUV2ZW50KGVsLCAnZHJhZ3N0YXJ0Jykuc3Vic2NyaWJlKHRoaXMuX29uRHJhZ1N0YXJ0KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIF9vbkRyYWdTdGFydCA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgIGNvbnN0IHtkYXRhVHJhbnNmZXJ9ID0gZTtcclxuICAgIGlmIChkYXRhVHJhbnNmZXIgIT0gbnVsbCkge1xyXG4gICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcclxuICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ2luaXRpYWxQYXRoJywgdGhpcy5wcm9wcy51cmkpO1xyXG4gICAgICAvLyBGb3Igc2VjdXJpdHkgcmVhc29ucywgZHJhZ0VudGVyIGV2ZW50cyBjYW4ndCBzZWUgdGhlIHZhbHVlcyBvZlxyXG4gICAgICAvLyBgZGF0YVRyYW5zZmVyYCwganVzdCB0aGUga2V5cy4gU28sIHdlIHVzZSBhIHVuaXF1ZSBrZXkgdG8gZW5hYmxlIG90aGVyXHJcbiAgICAgIC8vIGNvbXBvbmVudHMgdG8gaW5mZXIgaWYgYSBkcmFnIGV2ZW50IGNvbnRhaW5zIGEgZHJhZ2dhYmxlIGZpbGUuXHJcbiAgICAgIGRhdGFUcmFuc2Zlci5zZXREYXRhKE1BR0lDX0RBVEFfVFJBTlNGRVJfS0VZLCAnJyk7XHJcblxyXG4gICAgICAvLyBBbGxvdyBkcmFnZ2FibGUgZmlsZXMgdG8gYmUgZHJhZ2dlZCBpbnRvIHRoZSB0YWIgYmFyLlxyXG4gICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dC9wbGFpbicsIHRoaXMucHJvcHMudXJpKTtcclxuICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ2F0b20tZXZlbnQnLCAndHJ1ZScpO1xyXG4gICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnYWxsb3ctYWxsLWxvY2F0aW9ucycsICd0cnVlJyk7XHJcbiAgICAgIHRyYWNrKCdkcmFnZ2FibGUtZmlsZTpkcmFnLXN0YXJ0Jywge1xyXG4gICAgICAgIHNvdXJjZTogdGhpcy5wcm9wcy50cmFja2luZ1NvdXJjZSxcclxuICAgICAgICB1cmk6IHRoaXMucHJvcHMudXJpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB7dXJpLCB0cmFja2luZ1NvdXJjZSwgZHJhZ2dhYmxlID0gdHJ1ZSwgLi4ucmVzdFByb3BzfSA9IHRoaXMucHJvcHM7XHJcbiAgICAvLyBodHRwczovL2Rpc2N1c3MuYXRvbS5pby90L2RyYWctZHJvcC8yMTI2Mi8xNFxyXG4gICAgY29uc3QgdGFiSW5kZXggPSAtMTtcclxuICAgIHJldHVybiA8ZGl2IGRyYWdnYWJsZT17ZHJhZ2dhYmxlfSB0YWJJbmRleD17dGFiSW5kZXh9IHsuLi5yZXN0UHJvcHN9IC8+O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRyYWdFdmVudENhbWVGcm9tRHJhZ2dhYmxlRmlsZShldmVudDogRHJhZ0V2ZW50KSB7XHJcbiAgY29uc3Qge2RhdGFUcmFuc2Zlcn0gPSBldmVudDtcclxuICBpZiAoZGF0YVRyYW5zZmVyID09IG51bGwpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIGRhdGFUcmFuc2Zlci50eXBlcy5pbmNsdWRlcyhNQUdJQ19EQVRBX1RSQU5TRkVSX0tFWSk7XHJcbn1cclxuIl19