"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.highlightCode = highlightCode;
exports.highlightCodeHtml = highlightCodeHtml;
exports.HighlightedCode = HighlightedCode;
exports.HighlightedLines = HighlightedLines;

var _classnames = _interopRequireDefault(require("classnames"));

var _escapeHtml = _interopRequireDefault(require("escape-html"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var React = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const scopeToClassNameCache = new Map();

function scopeToClassName(scope) {
  let className = scopeToClassNameCache.get(scope);

  if (className == null) {
    className = 'syntax--' + scope.replace(/\./g, ' syntax--');
    scopeToClassNameCache.set(scope, className);
  }

  return className;
}
/**
 * Re-uses an Atom grammar's tokenization functions to produce syntax-higlighted text
 * without the overhead of creating a new TextEditor / TextBuffer.
 */


function highlightCode(grammar, code) {
  return grammar.tokenizeLines(code).map(highlightTokens);
}

function highlightTokens(line) {
  const resultLine = [];
  const scopeStack = [];

  for (const token of line) {
    const diffIndex = scopeStack.findIndex((stackEntry, i) => token.scopes[i] !== stackEntry);

    if (diffIndex !== -1) {
      while (diffIndex < scopeStack.length) {
        resultLine.push({
          type: 'end'
        });
        scopeStack.pop();
      }
    }

    while (scopeStack.length < token.scopes.length) {
      const scope = token.scopes[scopeStack.length];
      resultLine.push({
        type: 'start',
        className: scopeToClassName(scope)
      });
      scopeStack.push(scope);
    }

    resultLine.push({
      type: 'value',
      value: token.value
    });
  }

  while (scopeStack.length) {
    resultLine.push({
      type: 'end'
    });
    scopeStack.pop();
  }

  return resultLine;
}
/**
 * Converts the grammar/code directly to HTML (using highlightCode above).
 */


function highlightCodeHtml(grammar, code) {
  const tokens = highlightCode(grammar, code);
  return tokens.map(tokensToHtml).join('\n');
}

function tokensToHtml(tokens) {
  let html = '';

  for (const token of tokens) {
    switch (token.type) {
      case 'start':
        html += `<span class=${JSON.stringify(token.className)}>`;
        break;

      case 'end':
        html += '</span>';
        break;

      case 'value':
        html += (0, _escapeHtml.default)(token.value);
        break;
    }
  }

  return html;
}
/**
 * Ready-to-render component for highlighted code.
 * Can be used with React's experimental AsyncMode component for
 * asynchronous highlighting.
 */


function HighlightedCode({
  grammar,
  code,
  className,
  ...otherProps
}) {
  return /*#__PURE__*/React.createElement("pre", _extends({
    className: (0, _classnames.default)(className, 'nuclide-highlighted-code', 'native-key-bindings'),
    tabIndex: -1
  }, otherProps), /*#__PURE__*/React.createElement("code", null, /*#__PURE__*/React.createElement(HighlightedLines, {
    grammar: grammar,
    code: code
  })));
}
/**
 * Renders only the raw highlighted tokens used in HighlightedCode.
 * (you'll need to provide the styling yourself.)
 */


function HighlightedLines({
  grammar,
  code
}) {
  const lines = code.split('\n'); // This is really hacky but we need a way to pass the parsed rule stack from one line to the next.
  // We'll give each component a shared array of rule stacks that can be written / read from.
  // React needs to render each line in order to make this work (but this assumption seems safe).

  const ruleStacks = new Array(lines.length);
  return lines.map((line, i) => {
    return /*#__PURE__*/React.createElement(HighlightedLine, {
      key: i,
      grammar: grammar,
      line: line,
      lineNumber: i,
      ruleStacks: ruleStacks
    });
  });
}

function HighlightedLine({
  grammar,
  line,
  lineNumber,
  ruleStacks
}) {
  // $FlowIgnore
  const {
    tokens,
    ruleStack
  } = grammar.tokenizeLine(line, // Throws if the lines haven't been rendered in order.
  lineNumber > 0 ? (0, _nullthrows.default)(ruleStacks[lineNumber - 1]) : null,
  /* firstLine */
  lineNumber === 0);
  ruleStacks[lineNumber] = ruleStack;
  return /*#__PURE__*/React.createElement("span", {
    dangerouslySetInnerHTML: {
      __html: tokensToHtml(highlightTokens(tokens)) + '\n'
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL0hpZ2hsaWdodGVkQ29kZS5qcyJdLCJuYW1lcyI6WyJzY29wZVRvQ2xhc3NOYW1lQ2FjaGUiLCJNYXAiLCJzY29wZVRvQ2xhc3NOYW1lIiwic2NvcGUiLCJjbGFzc05hbWUiLCJnZXQiLCJyZXBsYWNlIiwic2V0IiwiaGlnaGxpZ2h0Q29kZSIsImdyYW1tYXIiLCJjb2RlIiwidG9rZW5pemVMaW5lcyIsIm1hcCIsImhpZ2hsaWdodFRva2VucyIsImxpbmUiLCJyZXN1bHRMaW5lIiwic2NvcGVTdGFjayIsInRva2VuIiwiZGlmZkluZGV4IiwiZmluZEluZGV4Iiwic3RhY2tFbnRyeSIsImkiLCJzY29wZXMiLCJsZW5ndGgiLCJwdXNoIiwidHlwZSIsInBvcCIsInZhbHVlIiwiaGlnaGxpZ2h0Q29kZUh0bWwiLCJ0b2tlbnMiLCJ0b2tlbnNUb0h0bWwiLCJqb2luIiwiaHRtbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJIaWdobGlnaHRlZENvZGUiLCJvdGhlclByb3BzIiwiSGlnaGxpZ2h0ZWRMaW5lcyIsImxpbmVzIiwic3BsaXQiLCJydWxlU3RhY2tzIiwiQXJyYXkiLCJIaWdobGlnaHRlZExpbmUiLCJsaW5lTnVtYmVyIiwicnVsZVN0YWNrIiwidG9rZW5pemVMaW5lIiwiX19odG1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBWUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFpQkEsTUFBTUEscUJBQXFCLEdBQUcsSUFBSUMsR0FBSixFQUE5Qjs7QUFFQSxTQUFTQyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUQ7QUFDL0MsTUFBSUMsU0FBUyxHQUFHSixxQkFBcUIsQ0FBQ0ssR0FBdEIsQ0FBMEJGLEtBQTFCLENBQWhCOztBQUNBLE1BQUlDLFNBQVMsSUFBSSxJQUFqQixFQUF1QjtBQUNyQkEsSUFBQUEsU0FBUyxHQUFHLGFBQWFELEtBQUssQ0FBQ0csT0FBTixDQUFjLEtBQWQsRUFBcUIs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QUFBVUssRUFBQUEsSUFBVjtBQUFnQjZCLEVBQUFBLFVBQWhCO0FBQTRCSCxFQUFBQTtBQUE1QixDQUF6QixFQUE4RTtBQUM1RTtBQUNBLFFBQU07QUFBQ1gsSUFBQUEsTUFBRDtBQUFTZSxJQUFBQTtBQUFULE1BQXNCbkMsT0FBTyxDQUFDb0MsWUFBUixDQUMxQi9CLElBRDBCLEVBRTFCO0FBQ0E2QixFQUFBQSxVQUFVLEdBQUcsQ0FBYixHQUFpQix5QkFBV0gsVUFBVSxDQUFDRyxVQUFVLEdBQUcsQ0FBZCxDQUFyQixDQUFqQixHQUEwRCxJQUhoQztBQUkxQjtBQUFnQkEsRUFBQUEsVUFBVSxLQUFLLENBSkwsQ0FBNUI7QUFNQUgsRUFBQUEsVUFBVSxDQUFDRyxVQUFELENBQVYsR0FBeUJDLFNBQXpCO0FBQ0Esc0JBQ0U7QUFDRSxJQUFBLHVCQUF1QixFQUFFO0FBQ3ZCRSxNQUFBQSxNQUFNLEVBQUVoQixZQUFZLENBQUNqQixlQUFlLENBQUNnQixNQUFELENBQWhCLENBQVosR0FBd0M7QUFEekI7QUFEM0IsSUFERjtBQU9EIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBlc2NhcGVIdG1sIGZyb20gJ2VzY2FwZS1odG1sJztcclxuaW1wb3J0IG51bGx0aHJvd3MgZnJvbSAnbnVsbHRocm93cyc7XHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCB0eXBlIEhpZ2hsaWdodGVkVG9rZW4gPVxyXG4gIHwge3xcclxuICAgICAgdHlwZTogJ3N0YXJ0JyxcclxuICAgICAgY2xhc3NOYW1lOiBzdHJpbmcsXHJcbiAgICB8fVxyXG4gIHwge3xcclxuICAgICAgdHlwZTogJ2VuZCcsXHJcbiAgICB8fVxyXG4gIHwge3xcclxuICAgICAgdHlwZTogJ3ZhbHVlJyxcclxuICAgICAgdmFsdWU6IHN0cmluZyxcclxuICAgIHx9O1xyXG5cclxuZXhwb3J0IHR5cGUgSGlnaGxpZ2h0ZWRUb2tlbnMgPSBBcnJheTxBcnJheTxIaWdobGlnaHRlZFRva2VuPj47XHJcblxyXG5jb25zdCBzY29wZVRvQ2xhc3NOYW1lQ2FjaGUgPSBuZXcgTWFwKCk7XHJcblxyXG5mdW5jdGlvbiBzY29wZVRvQ2xhc3NOYW1lKHNjb3BlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGxldCBjbGFzc05hbWUgPSBzY29wZVRvQ2xhc3NOYW1lQ2FjaGUuZ2V0KHNjb3BlKTtcclxuICBpZiAoY2xhc3NOYW1lID09IG51bGwpIHtcclxuICAgIGNsYXNzTmFtZSA9ICdzeW50YXgtLScgKyBzY29wZS5yZXBsYWNlKC9cXC4vZywgJyBzeW50YXgtLScpO1xyXG4gICAgc2NvcGVUb0NsYXNzTmFtZUNhY2hlLnNldChzY29wZSwgY2xhc3NOYW1lKTtcclxuICB9XHJcbiAgcmV0dXJuIGNsYXNzTmFtZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlLXVzZXMgYW4gQXRvbSBncmFtbWFyJ3MgdG9rZW5pemF0aW9uIGZ1bmN0aW9ucyB0byBwcm9kdWNlIHN5bnRheC1oaWdsaWdodGVkIHRleHRcclxuICogd2l0aG91dCB0aGUgb3ZlcmhlYWQgb2YgY3JlYXRpbmcgYSBuZXcgVGV4dEVkaXRvciAvIFRleHRCdWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaGlnaGxpZ2h0Q29kZShcclxuICBncmFtbWFyOiBhdG9tJEdyYW1tYXIsXHJcbiAgY29kZTogc3RyaW5nLFxyXG4pOiBIaWdobGlnaHRlZFRva2VucyB7XHJcbiAgcmV0dXJuIGdyYW1tYXIudG9rZW5pemVMaW5lcyhjb2RlKS5tYXAoaGlnaGxpZ2h0VG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGlnaGxpZ2h0VG9rZW5zKFxyXG4gIGxpbmU6IEFycmF5PGF0b20kR3JhbW1hclRva2VuPixcclxuKTogQXJyYXk8SGlnaGxpZ2h0ZWRUb2tlbj4ge1xyXG4gIGNvbnN0IHJlc3VsdExpbmUgPSBbXTtcclxuICBjb25zdCBzY29wZVN0YWNrID0gW107XHJcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBsaW5lKSB7XHJcbiAgICBjb25zdCBkaWZmSW5kZXggPSBzY29wZVN0YWNrLmZpbmRJbmRleChcclxuICAgICAgKHN0YWNrRW50cnksIGkpID0+IHRva2VuLnNjb3Blc1tpXSAhPT0gc3RhY2tFbnRyeSxcclxuICAgICk7XHJcbiAgICBpZiAoZGlmZkluZGV4ICE9PSAtMSkge1xyXG4gICAgICB3aGlsZSAoZGlmZkluZGV4IDwgc2NvcGVTdGFjay5sZW5ndGgpIHtcclxuICAgICAgICByZXN1bHRMaW5lLnB1c2goe3R5cGU6ICdlbmQnfSk7XHJcbiAgICAgICAgc2NvcGVTdGFjay5wb3AoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2hpbGUgKHNjb3BlU3RhY2subGVuZ3RoIDwgdG9rZW4uc2NvcGVzLmxlbmd0aCkge1xyXG4gICAgICBjb25zdCBzY29wZSA9IHRva2VuLnNjb3Blc1tzY29wZVN0YWNrLmxlbmd0aF07XHJcbiAgICAgIHJlc3VsdExpbmUucHVzaCh7XHJcbiAgICAgICAgdHlwZTogJ3N0YXJ0JyxcclxuICAgICAgICBjbGFzc05hbWU6IHNjb3BlVG9DbGFzc05hbWUoc2NvcGUpLFxyXG4gICAgICB9KTtcclxuICAgICAgc2NvcGVTdGFjay5wdXNoKHNjb3BlKTtcclxuICAgIH1cclxuICAgIHJlc3VsdExpbmUucHVzaCh7dHlwZTogJ3ZhbHVlJywgdmFsdWU6IHRva2VuLnZhbHVlfSk7XHJcbiAgfVxyXG4gIHdoaWxlIChzY29wZVN0YWNrLmxlbmd0aCkge1xyXG4gICAgcmVzdWx0TGluZS5wdXNoKHt0eXBlOiAnZW5kJ30pO1xyXG4gICAgc2NvcGVTdGFjay5wb3AoKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdExpbmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZ3JhbW1hci9jb2RlIGRpcmVjdGx5IHRvIEhUTUwgKHVzaW5nIGhpZ2hsaWdodENvZGUgYWJvdmUpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodENvZGVIdG1sKGdyYW1tYXI6IGF0b20kR3JhbW1hciwgY29kZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICBjb25zdCB0b2tlbnMgPSBoaWdobGlnaHRDb2RlKGdyYW1tYXIsIGNvZGUpO1xyXG4gIHJldHVybiB0b2tlbnMubWFwKHRva2Vuc1RvSHRtbCkuam9pbignXFxuJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRva2Vuc1RvSHRtbCh0b2tlbnM6IEFycmF5PEhpZ2hsaWdodGVkVG9rZW4+KTogc3RyaW5nIHtcclxuICBsZXQgaHRtbCA9ICcnO1xyXG4gIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XHJcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcclxuICAgICAgY2FzZSAnc3RhcnQnOlxyXG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGNsYXNzPSR7SlNPTi5zdHJpbmdpZnkodG9rZW4uY2xhc3NOYW1lKX0+YDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnZW5kJzpcclxuICAgICAgICBodG1sICs9ICc8L3NwYW4+JztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAndmFsdWUnOlxyXG4gICAgICAgIGh0bWwgKz0gZXNjYXBlSHRtbCh0b2tlbi52YWx1ZSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBodG1sO1xyXG59XHJcblxyXG4vKipcclxuICogUmVhZHktdG8tcmVuZGVyIGNvbXBvbmVudCBmb3IgaGlnaGxpZ2h0ZWQgY29kZS5cclxuICogQ2FuIGJlIHVzZWQgd2l0aCBSZWFjdCdzIGV4cGVyaW1lbnRhbCBBc3luY01vZGUgY29tcG9uZW50IGZvclxyXG4gKiBhc3luY2hyb25vdXMgaGlnaGxpZ2h0aW5nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEhpZ2hsaWdodGVkQ29kZSh7XHJcbiAgZ3JhbW1hcixcclxuICBjb2RlLFxyXG4gIGNsYXNzTmFtZSxcclxuICAuLi5vdGhlclByb3BzXHJcbn06IHtcclxuICBncmFtbWFyOiBhdG9tJEdyYW1tYXIsXHJcbiAgY29kZTogc3RyaW5nLFxyXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcclxufSk6IFJlYWN0Lk5vZGUge1xyXG4gIHJldHVybiAoXHJcbiAgICA8cHJlXHJcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhcclxuICAgICAgICBjbGFzc05hbWUsXHJcbiAgICAgICAgJ251Y2xpZGUtaGlnaGxpZ2h0ZWQtY29kZScsXHJcbiAgICAgICAgJ25hdGl2ZS1rZXktYmluZGluZ3MnLFxyXG4gICAgICApfVxyXG4gICAgICB0YWJJbmRleD17LTF9XHJcbiAgICAgIHsuLi5vdGhlclByb3BzfT5cclxuICAgICAgPGNvZGU+XHJcbiAgICAgICAgPEhpZ2hsaWdodGVkTGluZXMgZ3JhbW1hcj17Z3JhbW1hcn0gY29kZT17Y29kZX0gLz5cclxuICAgICAgPC9jb2RlPlxyXG4gICAgPC9wcmU+XHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgb25seSB0aGUgcmF3IGhpZ2hsaWdodGVkIHRva2VucyB1c2VkIGluIEhpZ2hsaWdodGVkQ29kZS5cclxuICogKHlvdSdsbCBuZWVkIHRvIHByb3ZpZGUgdGhlIHN0eWxpbmcgeW91cnNlbGYuKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIEhpZ2hsaWdodGVkTGluZXMoe1xyXG4gIGdyYW1tYXIsXHJcbiAgY29kZSxcclxufToge1xyXG4gIGdyYW1tYXI6IGF0b20kR3JhbW1hcixcclxuICBjb2RlOiBzdHJpbmcsXHJcbn0pOiBSZWFjdC5Ob2RlIHtcclxuICBjb25zdCBsaW5lcyA9IGNvZGUuc3BsaXQoJ1xcbicpO1xyXG4gIC8vIFRoaXMgaXMgcmVhbGx5IGhhY2t5IGJ1dCB3ZSBuZWVkIGEgd2F5IHRvIHBhc3MgdGhlIHBhcnNlZCBydWxlIHN0YWNrIGZyb20gb25lIGxpbmUgdG8gdGhlIG5leHQuXHJcbiAgLy8gV2UnbGwgZ2l2ZSBlYWNoIGNvbXBvbmVudCBhIHNoYXJlZCBhcnJheSBvZiBydWxlIHN0YWNrcyB0aGF0IGNhbiBiZSB3cml0dGVuIC8gcmVhZCBmcm9tLlxyXG4gIC8vIFJlYWN0IG5lZWRzIHRvIHJlbmRlciBlYWNoIGxpbmUgaW4gb3JkZXIgdG8gbWFrZSB0aGlzIHdvcmsgKGJ1dCB0aGlzIGFzc3VtcHRpb24gc2VlbXMgc2FmZSkuXHJcbiAgY29uc3QgcnVsZVN0YWNrcyA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xyXG4gIHJldHVybiBsaW5lcy5tYXAoKGxpbmUsIGkpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxIaWdobGlnaHRlZExpbmVcclxuICAgICAgICBrZXk9e2l9XHJcbiAgICAgICAgZ3JhbW1hcj17Z3JhbW1hcn1cclxuICAgICAgICBsaW5lPXtsaW5lfVxyXG4gICAgICAgIGxpbmVOdW1iZXI9e2l9XHJcbiAgICAgICAgcnVsZVN0YWNrcz17cnVsZVN0YWNrc31cclxuICAgICAgLz5cclxuICAgICk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEhpZ2hsaWdodGVkTGluZSh7Z3JhbW1hciwgbGluZSwgbGluZU51bWJlciwgcnVsZVN0YWNrc30pOiBSZWFjdC5Ob2RlIHtcclxuICAvLyAkRmxvd0lnbm9yZVxyXG4gIGNvbnN0IHt0b2tlbnMsIHJ1bGVTdGFja30gPSBncmFtbWFyLnRva2VuaXplTGluZShcclxuICAgIGxpbmUsXHJcbiAgICAvLyBUaHJvd3MgaWYgdGhlIGxpbmVzIGhhdmVuJ3QgYmVlbiByZW5kZXJlZCBpbiBvcmRlci5cclxuICAgIGxpbmVOdW1iZXIgPiAwID8gbnVsbHRocm93cyhydWxlU3RhY2tzW2xpbmVOdW1iZXIgLSAxXSkgOiBudWxsLFxyXG4gICAgLyogZmlyc3RMaW5lICovIGxpbmVOdW1iZXIgPT09IDAsXHJcbiAgKTtcclxuICBydWxlU3RhY2tzW2xpbmVOdW1iZXJdID0gcnVsZVN0YWNrO1xyXG4gIHJldHVybiAoXHJcbiAgICA8c3BhblxyXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTD17e1xyXG4gICAgICAgIF9faHRtbDogdG9rZW5zVG9IdG1sKGhpZ2hsaWdodFRva2Vucyh0b2tlbnMpKSArICdcXG4nLFxyXG4gICAgICB9fVxyXG4gICAgLz5cclxuICApO1xyXG59XHJcbiJdfQ==