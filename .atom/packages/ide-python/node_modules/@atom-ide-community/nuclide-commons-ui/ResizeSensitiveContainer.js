"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeSensitiveContainer = void 0;

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _observable = require("@atom-ide-community/nuclide-commons/observable");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
const EXPANSION_BUFFER = 50;
/**
 * Hidden set of DOM nodes that are used to detect resizes through onScroll events.
 *
 * This component works by injecting two sets of divs, one for detecting expansions
 * and one for detecting shrinking. They are sized and have their scroll positions
 * set in a specific way so that a resize of the container will trigger an onScroll
 * event. This is used as the basis for the "onResize" event.
 *
 * The scroll position of the inner divs can be reset when DOM nodes are shuffled
 * around, which will break the resize detection. To handle this case, the sensor
 * uses a CSS animation and listens for onAnimationStart to know when to reset the
 * scroll positions.
 *
 * This strategy is derived from https://github.com/wnr/element-resize-detector
 */

class ResizeSensor extends React.Component {
  constructor(...args) {
    super(...args);
    this._expand = void 0;
    this._shrink = void 0;

    this._handleScroll = () => {
      this._resetScrollbars();

      this.props.onDetectedResize();
    };

    this._handleExpandRef = el => {
      this._expand = el;
    };

    this._handleShrinkRef = el => {
      this._shrink = el;
    };
  }

  componentDidMount() {
    this._resetScrollbars();
  }

  componentDidUpdate(prevProps) {
    const {
      targetWidth,
      targetHeight
    } = this.props;

    if (prevProps.targetWidth !== targetWidth || prevProps.targetHeight !== targetHeight) {
      this._resetScrollbars();
    }
  }

  _resetScrollbars() {
    if (this._expand == null || this._shrink == null) {
      return;
    }

    this._expand.scrollLeft = this._expand.scrollWidth;
    this._expand.scrollTop = this._expand.scrollHeight;
    this._shrink.scrollLeft = this._shrink.scrollWidth;
    this._shrink.scrollTop = this._shrink.scrollHeight;
  }

  render() {
    const {
      targetWidth,
      targetHeight
    } = this.props;
    const expandInnerStyle = {
      width: targetWidth + EXPANSION_BUFFER,
      height: targetHeight + EXPANSION_BUFFER
    };
    return /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-sensor",
      onAnimationStart: this._handleScroll
    }, /*#__PURE__*/React.createElement("div", {
      // $FlowFixMe(>=0.53.0) Flow suppress
      ref: this._handleExpandRef,
      className: "nuclide-resize-sensitive-container-expand",
      onScroll: this._handleScroll
    }, /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-expand-inner",
      style: expandInnerStyle
    })), /*#__PURE__*/React.createElement("div", {
      // $FlowFixMe(>=0.53.0) Flow suppress
      ref: this._handleShrinkRef,
      className: "nuclide-resize-sensitive-container-shrink",
      onScroll: this._handleScroll
    }, /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-shrink-inner"
    })));
  }

}

/**
 * Size-sensitive container that provides an onResize callback that
 * is invoked with the container's width and height whenever it changes.
 *
 * NOTE: This component is meant to be used to detect size changes that
 *       are not a result of a DOM mutation. If you only care about size
 *       changes as a result of a DOM mutation, use MeasuredComponent
 *       instead.
 */
class ResizeSensitiveContainer extends React.Component {
  constructor(props) {
    super(props);
    this._container = void 0;
    this._resizeEvents = new _rxjsCompatUmdMin.Subject();
    this._resizeSubscription = void 0;

    this._handleContainer = el => {
      this._container = el;

      this._updateContainerSize();
    };

    this._updateContainerSize = () => {
      if (this._container == null) {
        return;
      }

      const {
        offsetHeight,
        offsetWidth
      } = this._container;
      const {
        height,
        width
      } = this.state;

      if (offsetHeight === height && offsetWidth === width) {
        return;
      }

      this.setState({
        height: offsetHeight,
        width: offsetWidth
      });
      this.props.onResize(offsetHeight, offsetWidth);
    };

    this._handleResize = () => {
      this._resizeEvents.next();
    };

    this.state = {
      height: -1,
      width: -1
    };
  }

  componentDidMount() {
    this._resizeSubscription = this._resizeEvents.switchMap(() => _observable.nextAnimationFrame).subscribe(() => {
      this._updateContainerSize();
    });
  }

  componentWillUnmount() {
    (0, _nullthrows.default)(this._resizeSubscription).unsubscribe();
  }

  _containerRendered() {
    return this.state.height !== -1 && this.state.width !== -1;
  }

  render() {
    const {
      children,
      className,
      tabIndex
    } = this.props;
    const {
      height,
      width
    } = this.state;
    const containerClasses = (0, _classnames.default)('nuclide-resize-sensitive-container', className);
    return /*#__PURE__*/React.createElement("div", {
      className: "nuclide-resize-sensitive-container-wrapper"
    }, /*#__PURE__*/React.createElement("div", {
      ref: this._handleContainer,
      className: containerClasses,
      tabIndex: tabIndex
    }, children), this._containerRendered() ? /*#__PURE__*/React.createElement(ResizeSensor, {
      targetHeight: height,
      targetWidth: width,
      onDetectedResize: this._handleResize
    }) : null);
  }

}

exports.ResizeSensitiveContainer = ResizeSensitiveContainer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1Jlc2l6ZVNlbnNpdGl2ZUNvbnRhaW5lci5qcyJdLCJuYW1lcyI6WyJFWFBBTlNJT05fQlVGRkVSIiwiUmVzaXplU2Vuc29yIiwiUmVhY3QiLCJDb21wb25lbnQiLCJfZXhwYW5kIiwiX3NocmluayIsIl9oYW5kbGVTY3JvbGwiLCJfcmVzZXRTY3JvbGxiYXJzIiwicHJvcHMiLCJvbkRldGVjdGVkUmVzaXplIiwiX2hhbmRsZUV4cGFuZFJlZiIsImVsIiwiX2hhbmRsZVNocmlua1JlZiIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxUb3AiLCJzY3JvbGxIZWlnaHQiLCJyZW5kZXIiLCJleHBhbmRJbm5lclN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJSZXNpemVTZW5zaXRpdmVDb250YWluZXIiLCJjb25zdHJ1Y3RvciIsIl9jb250YWluZXIiLCJfcmVzaXplRXZlbnRzIiwiU3ViamVjdCIsIl9yZXNpemVTdWJzY3JpcHRpb24iLCJfaGFuZGxlQ29udGFpbmVyIiwiX3VwZGF0ZUNvbnRhaW5lclNpemUiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInN0YXRlIiwic2V0U3RhdGUiLCJvblJlc2l6ZSIsIl9oYW5kbGVSZXNpemUiLCJuZXh0Iiwic3dpdGNoTWFwIiwibmV4dEFuaW1hdGlvbkZyYW1lIiwic3Vic2NyaWJlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJ1bnN1YnNjcmliZSIsIl9jb250YWluZXJSZW5kZXJlZCIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwidGFiSW5kZXgiLCJjb250YWluZXJDbGFzc2VzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBaEJB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Q3hCWSxTQUR3QixDQUNkLE1BQU1DLDhCQURRLEVBRXhCQyxTQUZ3QixDQUVkLE1BQU07QUFDZixXQUFLVixvQkFBTDtBQUNELEtBSndCLENBQTNCO0FBS0Q7O0FBRURXLEVBQUFBLG9CQUFvQixHQUFTO0FBQzNCLDZCQUFXLEtBQUtiLG1CQUFoQixFQUFxQ2MsV0FBckM7QUFDRDs7QUFFREMsRUFBQUEsa0JBQWtCLEdBQVk7QUFDNUIsV0FBTyxLQUFLVixLQUFMLENBQVdYLE1BQVgsS0FBc0IsQ0FBQyxDQUF2QixJQUE0QixLQUFLVyxLQUFMLENBQVdaLEtBQVgsS0FBcUIsQ0FBQyxDQUF6RDtBQUNEOztBQTZCREYsRUFBQUEsTUFBTSxHQUFlO0FBQ25CLFVBQU07QUFBQ3lCLE1BQUFBLFFBQUQ7QUFBV0MsTUFBQUEsU0FBWDtBQUFzQkMsTUFBQUE7QUFBdEIsUUFBa0MsS0FBS3pDLEtBQTdDO0FBQ0EsVUFBTTtBQUFDaUIsTUFBQUEsTUFBRDtBQUFTRCxNQUFBQTtBQUFULFFBQWtCLEtBQUtZLEtBQTdCO0FBQ0EsVUFBTWMsZ0JBQWdCLEdBQUcseUJBQ3ZCLG9DQUR1QixFQUV2QkYsU0FGdUIsQ0FBekI7QUFJQSx3QkFDRTtBQUFLLE1BQUEsU0FBUyxFQUFDO0FBQWYsb0JBQ0U7QUFDRSxNQUFBLEdBQUcsRUFBRSxLQUFLaEIsZ0JBRFo7QUFFRSxNQUFBLFNBQVMsRUFBRWtCLGdCQUZiO0FBR0UsTUFBQSxRQUFRLEVBQUVEO0FBSFosT0FJR0YsUUFKSCxDQURGLEVBT0csS0FBS0Qsa0JBQUwsa0JBQ0Msb0JBQUMsWUFBRDtBQUNFLE1BQUEsWUFBWSxFQUFFckIsTUFEaEI7QUFFRSxNQUFBLFdBQVcsRUFBRUQsS0FGZjtBQUdFLE1BQUEsZ0JBQWdCLEVBQUUsS0FBS2U7QUFIekIsTUFERCxHQU1HLElBYk4sQ0FERjtBQWlCRDs7QUFoRnlFIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IG51bGx0aHJvd3MgZnJvbSAnbnVsbHRocm93cyc7XHJcbmltcG9ydCB7bmV4dEFuaW1hdGlvbkZyYW1lfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9vYnNlcnZhYmxlJztcclxuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5cclxudHlwZSBTZW5zb3JQcm9wcyA9IHtcclxuICB0YXJnZXRIZWlnaHQ6IG51bWJlcixcclxuICB0YXJnZXRXaWR0aDogbnVtYmVyLFxyXG4gIG9uRGV0ZWN0ZWRSZXNpemU6ICgpID0+IHZvaWQsXHJcbn07XHJcblxyXG5jb25zdCBFWFBBTlNJT05fQlVGRkVSID0gNTA7XHJcblxyXG4vKipcclxuICogSGlkZGVuIHNldCBvZiBET00gbm9kZXMgdGhhdCBhcmUgdXNlZCB0byBkZXRlY3QgcmVzaXplcyB0aHJvdWdoIG9uU2Nyb2xsIGV2ZW50cy5cclxuICpcclxuICogVGhpcyBjb21wb25lbnQgd29ya3MgYnkgaW5qZWN0aW5nIHR3byBzZXRzIG9mIGRpdnMsIG9uZSBmb3IgZGV0ZWN0aW5nIGV4cGFuc2lvbnNcclxuICogYW5kIG9uZSBmb3IgZGV0ZWN0aW5nIHNocmlua2luZy4gVGhleSBhcmUgc2l6ZWQgYW5kIGhhdmUgdGhlaXIgc2Nyb2xsIHBvc2l0aW9uc1xyXG4gKiBzZXQgaW4gYSBzcGVjaWZpYyB3YXkgc28gdGhhdCBhIHJlc2l6ZSBvZiB0aGUgY29udGFpbmVyIHdpbGwgdHJpZ2dlciBhbiBvblNjcm9sbFxyXG4gKiBldmVudC4gVGhpcyBpcyB1c2VkIGFzIHRoZSBiYXNpcyBmb3IgdGhlIFwib25SZXNpemVcIiBldmVudC5cclxuICpcclxuICogVGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgaW5uZXIgZGl2cyBjYW4gYmUgcmVzZXQgd2hlbiBET00gbm9kZXMgYXJlIHNodWZmbGVkXHJcbiAqIGFyb3VuZCwgd2hpY2ggd2lsbCBicmVhayB0aGUgcmVzaXplIGRldGVjdGlvbi4gVG8gaGFuZGxlIHRoaXMgY2FzZSwgdGhlIHNlbnNvclxyXG4gKiB1c2VzIGEgQ1NTIGFuaW1hdGlvbiBhbmQgbGlzdGVucyBmb3Igb25BbmltYXRpb25TdGFydCB0byBrbm93IHdoZW4gdG8gcmVzZXQgdGhlXHJcbiAqIHNjcm9sbCBwb3NpdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgc3RyYXRlZ3kgaXMgZGVyaXZlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93bnIvZWxlbWVudC1yZXNpemUtZGV0ZWN0b3JcclxuICovXHJcbmNsYXNzIFJlc2l6ZVNlbnNvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxTZW5zb3JQcm9wcz4ge1xyXG4gIF9leHBhbmQ6ID9IVE1MRWxlbWVudDtcclxuICBfc2hyaW5rOiA/SFRNTEVsZW1lbnQ7XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcmVzZXRTY3JvbGxiYXJzKCk7XHJcbiAgfVxyXG5cclxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBTZW5zb3JQcm9wcyk6IHZvaWQge1xyXG4gICAgY29uc3Qge3RhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHR9ID0gdGhpcy5wcm9wcztcclxuICAgIGlmIChcclxuICAgICAgcHJldlByb3BzLnRhcmdldFdpZHRoICE9PSB0YXJnZXRXaWR0aCB8fFxyXG4gICAgICBwcmV2UHJvcHMudGFyZ2V0SGVpZ2h0ICE9PSB0YXJnZXRIZWlnaHRcclxuICAgICkge1xyXG4gICAgICB0aGlzLl9yZXNldFNjcm9sbGJhcnMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9yZXNldFNjcm9sbGJhcnMoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fZXhwYW5kID09IG51bGwgfHwgdGhpcy5fc2hyaW5rID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2V4cGFuZC5zY3JvbGxMZWZ0ID0gdGhpcy5fZXhwYW5kLnNjcm9sbFdpZHRoO1xyXG4gICAgdGhpcy5fZXhwYW5kLnNjcm9sbFRvcCA9IHRoaXMuX2V4cGFuZC5zY3JvbGxIZWlnaHQ7XHJcblxyXG4gICAgdGhpcy5fc2hyaW5rLnNjcm9sbExlZnQgPSB0aGlzLl9zaHJpbmsuc2Nyb2xsV2lkdGg7XHJcbiAgICB0aGlzLl9zaHJpbmsuc2Nyb2xsVG9wID0gdGhpcy5fc2hyaW5rLnNjcm9sbEhlaWdodDtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVTY3JvbGwgPSAoKTogdm9pZCA9PiB7XHJcbiAgICB0aGlzLl9yZXNldFNjcm9sbGJhcnMoKTtcclxuICAgIHRoaXMucHJvcHMub25EZXRlY3RlZFJlc2l6ZSgpO1xyXG4gIH07XHJcblxyXG4gIF9oYW5kbGVFeHBhbmRSZWYgPSAoZWw6IEhUTUxFbGVtZW50KTogdm9pZCA9PiB7XHJcbiAgICB0aGlzLl9leHBhbmQgPSBlbDtcclxuICB9O1xyXG5cclxuICBfaGFuZGxlU2hyaW5rUmVmID0gKGVsOiBIVE1MRWxlbWVudCk6IHZvaWQgPT4ge1xyXG4gICAgdGhpcy5fc2hyaW5rID0gZWw7XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCk6IFJlYWN0Lk5vZGUge1xyXG4gICAgY29uc3Qge3RhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHR9ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IGV4cGFuZElubmVyU3R5bGUgPSB7XHJcbiAgICAgIHdpZHRoOiB0YXJnZXRXaWR0aCArIEVYUEFOU0lPTl9CVUZGRVIsXHJcbiAgICAgIGhlaWdodDogdGFyZ2V0SGVpZ2h0ICsgRVhQQU5TSU9OX0JVRkZFUixcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdlxyXG4gICAgICAgIGNsYXNzTmFtZT1cIm51Y2xpZGUtcmVzaXplLXNlbnNpdGl2ZS1jb250YWluZXItc2Vuc29yXCJcclxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0PXt0aGlzLl9oYW5kbGVTY3JvbGx9PlxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIC8vICRGbG93Rml4TWUoPj0wLjUzLjApIEZsb3cgc3VwcHJlc3NcclxuICAgICAgICAgIHJlZj17dGhpcy5faGFuZGxlRXhwYW5kUmVmfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwibnVjbGlkZS1yZXNpemUtc2Vuc2l0aXZlLWNvbnRhaW5lci1leHBhbmRcIlxyXG4gICAgICAgICAgb25TY3JvbGw9e3RoaXMuX2hhbmRsZVNjcm9sbH0+XHJcbiAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm51Y2xpZGUtcmVzaXplLXNlbnNpdGl2ZS1jb250YWluZXItZXhwYW5kLWlubmVyXCJcclxuICAgICAgICAgICAgc3R5bGU9e2V4cGFuZElubmVyU3R5bGV9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXZcclxuICAgICAgICAgIC8vICRGbG93Rml4TWUoPj0wLjUzLjApIEZsb3cgc3VwcHJlc3NcclxuICAgICAgICAgIHJlZj17dGhpcy5faGFuZGxlU2hyaW5rUmVmfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwibnVjbGlkZS1yZXNpemUtc2Vuc2l0aXZlLWNvbnRhaW5lci1zaHJpbmtcIlxyXG4gICAgICAgICAgb25TY3JvbGw9e3RoaXMuX2hhbmRsZVNjcm9sbH0+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51Y2xpZGUtcmVzaXplLXNlbnNpdGl2ZS1jb250YWluZXItc2hyaW5rLWlubmVyXCIgLz5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxudHlwZSBQcm9wcyA9IHtcclxuICBjbGFzc05hbWU/OiBzdHJpbmcsXHJcbiAgdGFiSW5kZXg/OiBzdHJpbmcsXHJcbiAgY2hpbGRyZW4/OiBSZWFjdC5FbGVtZW50PGFueT4sXHJcbiAgb25SZXNpemU6IChoZWlnaHQ6IG51bWJlciwgd2lkdGg6IG51bWJlcikgPT4gdm9pZCxcclxufTtcclxuXHJcbnR5cGUgU3RhdGUgPSB7XHJcbiAgaGVpZ2h0OiBudW1iZXIsXHJcbiAgd2lkdGg6IG51bWJlcixcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaXplLXNlbnNpdGl2ZSBjb250YWluZXIgdGhhdCBwcm92aWRlcyBhbiBvblJlc2l6ZSBjYWxsYmFjayB0aGF0XHJcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgY29udGFpbmVyJ3Mgd2lkdGggYW5kIGhlaWdodCB3aGVuZXZlciBpdCBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBOT1RFOiBUaGlzIGNvbXBvbmVudCBpcyBtZWFudCB0byBiZSB1c2VkIHRvIGRldGVjdCBzaXplIGNoYW5nZXMgdGhhdFxyXG4gKiAgICAgICBhcmUgbm90IGEgcmVzdWx0IG9mIGEgRE9NIG11dGF0aW9uLiBJZiB5b3Ugb25seSBjYXJlIGFib3V0IHNpemVcclxuICogICAgICAgY2hhbmdlcyBhcyBhIHJlc3VsdCBvZiBhIERPTSBtdXRhdGlvbiwgdXNlIE1lYXN1cmVkQ29tcG9uZW50XHJcbiAqICAgICAgIGluc3RlYWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUmVzaXplU2Vuc2l0aXZlQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xyXG4gIF9jb250YWluZXI6ID9IVE1MRWxlbWVudDtcclxuICBfcmVzaXplRXZlbnRzOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcclxuICBfcmVzaXplU3Vic2NyaXB0aW9uOiA/cnhqcyRTdWJzY3JpcHRpb247XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgaGVpZ2h0OiAtMSxcclxuICAgICAgd2lkdGg6IC0xLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fcmVzaXplU3Vic2NyaXB0aW9uID0gdGhpcy5fcmVzaXplRXZlbnRzXHJcbiAgICAgIC5zd2l0Y2hNYXAoKCkgPT4gbmV4dEFuaW1hdGlvbkZyYW1lKVxyXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICB0aGlzLl91cGRhdGVDb250YWluZXJTaXplKCk7XHJcbiAgICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQoKTogdm9pZCB7XHJcbiAgICBudWxsdGhyb3dzKHRoaXMuX3Jlc2l6ZVN1YnNjcmlwdGlvbikudW5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIF9jb250YWluZXJSZW5kZXJlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXRlLmhlaWdodCAhPT0gLTEgJiYgdGhpcy5zdGF0ZS53aWR0aCAhPT0gLTE7XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlQ29udGFpbmVyID0gKGVsOiA/SFRNTEVsZW1lbnQpOiB2b2lkID0+IHtcclxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGVsO1xyXG4gICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xyXG4gIH07XHJcblxyXG4gIF91cGRhdGVDb250YWluZXJTaXplID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgaWYgKHRoaXMuX2NvbnRhaW5lciA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7b2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aH0gPSB0aGlzLl9jb250YWluZXI7XHJcbiAgICBjb25zdCB7aGVpZ2h0LCB3aWR0aH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgaWYgKG9mZnNldEhlaWdodCA9PT0gaGVpZ2h0ICYmIG9mZnNldFdpZHRoID09PSB3aWR0aCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgIGhlaWdodDogb2Zmc2V0SGVpZ2h0LFxyXG4gICAgICB3aWR0aDogb2Zmc2V0V2lkdGgsXHJcbiAgICB9KTtcclxuICAgIHRoaXMucHJvcHMub25SZXNpemUob2Zmc2V0SGVpZ2h0LCBvZmZzZXRXaWR0aCk7XHJcbiAgfTtcclxuXHJcbiAgX2hhbmRsZVJlc2l6ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgIHRoaXMuX3Jlc2l6ZUV2ZW50cy5uZXh0KCk7XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCk6IFJlYWN0Lk5vZGUge1xyXG4gICAgY29uc3Qge2NoaWxkcmVuLCBjbGFzc05hbWUsIHRhYkluZGV4fSA9IHRoaXMucHJvcHM7XHJcbiAgICBjb25zdCB7aGVpZ2h0LCB3aWR0aH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgY29uc3QgY29udGFpbmVyQ2xhc3NlcyA9IGNsYXNzbmFtZXMoXHJcbiAgICAgICdudWNsaWRlLXJlc2l6ZS1zZW5zaXRpdmUtY29udGFpbmVyJyxcclxuICAgICAgY2xhc3NOYW1lLFxyXG4gICAgKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibnVjbGlkZS1yZXNpemUtc2Vuc2l0aXZlLWNvbnRhaW5lci13cmFwcGVyXCI+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgcmVmPXt0aGlzLl9oYW5kbGVDb250YWluZXJ9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2NvbnRhaW5lckNsYXNzZXN9XHJcbiAgICAgICAgICB0YWJJbmRleD17dGFiSW5kZXh9PlxyXG4gICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIHt0aGlzLl9jb250YWluZXJSZW5kZXJlZCgpID8gKFxyXG4gICAgICAgICAgPFJlc2l6ZVNlbnNvclxyXG4gICAgICAgICAgICB0YXJnZXRIZWlnaHQ9e2hlaWdodH1cclxuICAgICAgICAgICAgdGFyZ2V0V2lkdGg9e3dpZHRofVxyXG4gICAgICAgICAgICBvbkRldGVjdGVkUmVzaXplPXt0aGlzLl9oYW5kbGVSZXNpemV9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICkgOiBudWxsfVxyXG4gICAgICA8L2Rpdj5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==