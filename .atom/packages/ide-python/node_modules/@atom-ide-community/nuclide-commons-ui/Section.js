"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Section = void 0;

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/** A vertical divider with a title.
 * Specifying `collapsable` prop as true will add a clickable chevron icon that
 * collapses the component children. Optionally specify collapsedByDefault
 * (defaults to false)
 */
class Section extends React.Component {
  constructor(props) {
    super(props);

    this._toggleCollapsed = () => {
      if (this.props.collapsed == null) {
        // uncontrolled mode
        // TODO: (wbinnssmith) T30771435 this setState depends on current state
        // and should use an updater function rather than an object
        // eslint-disable-next-line react/no-access-state-in-setstate
        this.setState({
          isCollapsed: !this.state.isCollapsed
        });
      } else {
        // controlled mode
        if (typeof this.props.onChange === 'function') {
          this.props.onChange(!this.props.collapsed);
        }
      }
    };

    const initialIsCollapsed = this.props.collapsable != null && this.props.collapsable && this.props.collapsedByDefault != null && this.props.collapsedByDefault;
    this.state = {
      isCollapsed: initialIsCollapsed
    };
  }

  render() {
    const collapsable = this.props.collapsable != null ? this.props.collapsable : false;
    const collapsed = this.props.collapsed == null ? this.state.isCollapsed : this.props.collapsed; // Only include classes if the component is collapsable

    const iconClass = (0, _classnames.default)({
      icon: collapsable,
      'icon-chevron-down': collapsable && !collapsed,
      'icon-chevron-right': collapsable && collapsed,
      'nuclide-ui-section-collapsable': collapsable
    });
    const conditionalProps = {};

    if (collapsable) {
      conditionalProps.onClick = this._toggleCollapsed;
      conditionalProps.title = collapsed ? 'Click to expand' : 'Click to collapse';
    } // Any custom title prop should override the default title.


    if (this.props.title != null) {
      conditionalProps.title = this.props.title;
    }

    const HeadlineComponent = getHeadlineComponent(this.props.size);
    return /*#__PURE__*/React.createElement("div", {
      className: this.props.className
    }, /*#__PURE__*/React.createElement(HeadlineComponent, _extends({
      className: iconClass
    }, conditionalProps), this.props.headline), /*#__PURE__*/React.createElement("div", {
      style: collapsed ? {
        display: 'none'
      } : {},
      className: "nuclide-ui-section-body"
    }, this.props.children));
  }

}

exports.Section = Section;

function getHeadlineComponent(size) {
  switch (size) {
    case 'small':
      return 'h6';

    case 'medium':
      return 'h5';

    default:
      return 'h3';
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1NlY3Rpb24uanMiXSwibmFtZXMiOlsiU2VjdGlvbiIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIl90b2dnbGVDb2xsYXBzZWQiLCJjb2xsYXBzZWQiLCJzZXRTdGF0ZSIsImlzQ29sbGFwc2VkIiwic3RhdGUiLCJvbkNoYW5nZSIsImluaXRpYWxJc0NvbGxhcHNlZCIsImNvbGxhcHNhYmxlIiwiY29sbGFwc2VkQnlEZWZhdWx0IiwicmVuZGVyIiwiaWNvbkNsYXNzIiwiaWNvbiIsImNvbmRpdGlvbmFsUHJvcHMiLCJvbkNsaWNrIiwidGl0bGUiLCJIZWFkbGluZUNvbXBvbmVudCIsImdldEhlYWRsaW5lQ29tcG9uZW50Iiwic2l6ZSIsImNsYXNzTmFtZSIsImhlYWRsaW5lIiwiZGlzcGxheSIsImNoaWxkcmVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBQ0E7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1BLE9BQU4sU0FBc0JDLEtBQUssQ0FBQ0MsU0FBNUIsQ0FBb0Q7QUFDekRDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFlO0FBQ3hCLFVBQU1BLEtBQU47O0FBRHdCLFNBWTFCQyxnQkFaMEIsR0FZUCxNQUFZO0FBQzdCLFVBQUksS0FBS0QsS0FBTCxDQUFXRSxTQUFYLElBQXdCLElBQTVCLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBS0MsUUFBTCxDQUFjO0FBQUNDLFVBQUFBLFdBQVcsRUFBRSxDQUFDLEtBQUtDLEtBQUwsQ0FBV0Q7QUFBMUIsU0FBZDtBQUNELE9BTkQsTUFNTztBQUNMO0FBQ0EsWUFBSSxPQUFPLEtBQUtKLEtBQUwsQ0FBV00sUUFBbEIsS0FBK0IsVUFBbkMsRUFBK0M7QUFDN0MsZUFBS04sS0FBTCxDQUFXTSxRQUFYLENBQW9CLENBQUMsS0FBS04sS0FBTCxDQUFXRSxTQUFoQztBQUNEO0FBQ0Y7QUFDRixLQXpCeUI7O0FBRXhCLFVBQU1LLGtCQUEyQixHQUMvQixLQUFLUCxLQUFMLENBQVdRLFdBQVgsSUFBMEIsSUFBMUIsSUFDQSxLQUFLUixLQUFMLENBQVdRLFdBRFgsSUFFQSxLQUFLUixLQUFMLENBQVdTLGtCQUFYLElBQWlDLElBRmpDLElBR0EsS0FBS1QsS0FBTCxDQUFXUyxrQkFKYjtBQUtBLFNBQUtKLEtBQUwsR0FBYTtBQUNYRCxNQUFBQSxXQUFXLEVBQUVHO0FBREYsS0FBYjtBQUdEOztBQWlCREcsRUFBQUEsTUFBTSxHQUFlO0FBQ25CLFVBQU1GLFdBQW9CLEdBQ3hCLEtBQUtSLEtBQUwsQ0FBV1EsV0FBWCxJQUEwQixJQUExQixHQUFpQyxLQUFLUixLQUFMLENBQVdRLFdBQTVDLEdBQTBELEtBRDVEO0FBRUEsVUFBTU4sU0FBUyxHQUNiLEtBQUtGLEtBQUwsQ0FBV0UsU0FBWCxJQUF3QixJQUF4QixHQUNJLEtBQUtHLEtBQUwsQ0FBV0QsV0FEZixHQUVJLEtBQUtKLEtBQUwsQ0FBV0UsU0FIakIsQ0FIbUIsQ0FPbkI7O0FBQ0EsVUFBTVMsU0FBUyxHQUFHLHlCQUFXO0FBQzNCQyxNQUFBQSxJQUFJLEVBQUVKLFdBRHFCO0FBRTNCLDJCQUFxQkEsV0FBVyxJQUFJLENBQUNOLFNBRlY7QUFHM0IsNEJBQXNCTSxXQUFXLElBQUlOLFNBSFY7QUFJM0Isd0NBQWtDTTtBQUpQLEtBQVgsQ0FBbEI7QUFNQSxVQUFNSyxnQkFBZ0IsR0FBRyxFQUF6Qjs7QUFDQSxRQUFJTCxXQUFKLEVBQWlCO0FBQ2ZLLE1BQUFBLGdCQUFnQixDQUFDQyxPQUFqQixHQUEyQixLQUFLYixnQkFBaEM7QUFDQVksTUFBQUEsZ0JBQWdCLENBQUNFLEtBQWpCLEdBQXlCYixTQUFTLEdBQzlCLGlCQUQ4QixHQUU5QixtQkFGSjtBQUdELEtBcEJrQixDQXFCbkI7OztBQUNBLFFBQUksS0FBS0YsS0FBTCxDQUFXZSxLQUFYLElBQW9CLElBQXhCLEVBQThCO0FBQzVCRixNQUFBQSxnQkFBZ0IsQ0FBQ0UsS0FBakIsR0FBeUIsS0FBS2YsS0FBTCxDQUFXZSxLQUFwQztBQUNEOztBQUNELFVBQU1DLGlCQUFpQixHQUFHQyxvQkFBb0IsQ0FBQyxLQUFLakIsS0FBTCxDQUFXa0IsSUFBWixDQUE5QztBQUNBLHdCQUNFO0FBQUssTUFBQSxTQUFTLEVBQUUsS0FBS2xCLEtBQUwsQ0FBV21CO0FBQTNCLG9CQUNFLG9CQUFDLGlCQUFEO0FBQW1CLE1BQUEsU0FBUyxFQUFFUjtBQUE5QixPQUE2Q0UsZ0JBQTdDLEdBQ0csS0FBS2IsS0FBTCxDQUFXb0IsUUFEZCxDQURGLGVBSUU7QUFDRSxNQUFBLEtBQUssRUFBRWxCLFNBQVMsR0FBRztBQUFDbUIsUUFBQUEsT0FBTyxFQUFFO0FBQVYsT0FBSCxHQUF1QixFQUR6QztBQUVFLE1BQUEsU0FBUyxFQUFDO0FBRlosT0FHRyxLQUFLckIsS0FBTCxDQUFXc0IsUUFIZCxDQUpGLENBREY7QUFZRDs7QUFsRXdEOzs7O0FBcUUzRCxTQUFTTCxvQkFBVCxDQUE4QkMsSUFBOUIsRUFBaUU7QUFDL0QsVUFBUUEsSUFBUjtBQUNFLFNBQUssT0FBTDtBQUNFLGFBQU8sSUFBUDs7QUFDRixTQUFLLFFBQUw7QUFDRSxhQUFPLElBQVA7O0FBQ0Y7QUFDRSxhQUFPLElBQVA7QUFOSjtBQVFEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3RcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcblxyXG50eXBlIFNlY3Rpb25TaXplID0gJ2xhcmdlJyB8ICdtZWRpdW0nIHwgJ3NtYWxsJztcclxudHlwZSBQcm9wcyA9IHtcclxuICBoZWFkbGluZTogUmVhY3QuTm9kZSxcclxuICBjbGFzc05hbWU/OiBzdHJpbmcsXHJcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxyXG4gIC8vIE9wdGlvbiBBOiBTcGVjaWZ5IGp1c3QgYGNvbGxhcHNhYmxlYCBmb3IgdW5jb250cm9sbGVkIHRvZ2dsZSBiZWhhdmlvci5cclxuICBjb2xsYXBzYWJsZT86IGJvb2xlYW4sXHJcbiAgLy8gYGNvbGxhcHNhYmxlYCBvdmVycmlkZXMgdGhpcyB3aGVuIHNwZWNpZmllZC5cclxuICBjb2xsYXBzZWRCeURlZmF1bHQ/OiBib29sZWFuLFxyXG5cclxuICAvLyBPcHRpb24gQjogQWxzbyBzcGVjaWZ5IGBjb2xsYXBzZWRgIGFuZCBgb25DaGFuZ2VgIGZvciBjb250cm9sbGVkIHRvZ2dsZSBiZWhhdmlvci5cclxuICBjb2xsYXBzZWQ/OiBib29sZWFuLFxyXG4gIG9uQ2hhbmdlPzogKGlzQ29sbGFwc2VkOiBib29sZWFuKSA9PiBtaXhlZCxcclxuXHJcbiAgc2l6ZT86IFNlY3Rpb25TaXplLFxyXG4gIHRpdGxlPzogc3RyaW5nLFxyXG59O1xyXG5cclxudHlwZSBTdGF0ZSA9IHtcclxuICBpc0NvbGxhcHNlZDogYm9vbGVhbixcclxufTtcclxuXHJcbi8qKiBBIHZlcnRpY2FsIGRpdmlkZXIgd2l0aCBhIHRpdGxlLlxyXG4gKiBTcGVjaWZ5aW5nIGBjb2xsYXBzYWJsZWAgcHJvcCBhcyB0cnVlIHdpbGwgYWRkIGEgY2xpY2thYmxlIGNoZXZyb24gaWNvbiB0aGF0XHJcbiAqIGNvbGxhcHNlcyB0aGUgY29tcG9uZW50IGNoaWxkcmVuLiBPcHRpb25hbGx5IHNwZWNpZnkgY29sbGFwc2VkQnlEZWZhdWx0XHJcbiAqIChkZWZhdWx0cyB0byBmYWxzZSlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZWN0aW9uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wcykge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgY29uc3QgaW5pdGlhbElzQ29sbGFwc2VkOiBib29sZWFuID1cclxuICAgICAgdGhpcy5wcm9wcy5jb2xsYXBzYWJsZSAhPSBudWxsICYmXHJcbiAgICAgIHRoaXMucHJvcHMuY29sbGFwc2FibGUgJiZcclxuICAgICAgdGhpcy5wcm9wcy5jb2xsYXBzZWRCeURlZmF1bHQgIT0gbnVsbCAmJlxyXG4gICAgICB0aGlzLnByb3BzLmNvbGxhcHNlZEJ5RGVmYXVsdDtcclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGlzQ29sbGFwc2VkOiBpbml0aWFsSXNDb2xsYXBzZWQsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgX3RvZ2dsZUNvbGxhcHNlZCA9ICgpOiB2b2lkID0+IHtcclxuICAgIGlmICh0aGlzLnByb3BzLmNvbGxhcHNlZCA9PSBudWxsKSB7XHJcbiAgICAgIC8vIHVuY29udHJvbGxlZCBtb2RlXHJcbiAgICAgIC8vIFRPRE86ICh3YmlubnNzbWl0aCkgVDMwNzcxNDM1IHRoaXMgc2V0U3RhdGUgZGVwZW5kcyBvbiBjdXJyZW50IHN0YXRlXHJcbiAgICAgIC8vIGFuZCBzaG91bGQgdXNlIGFuIHVwZGF0ZXIgZnVuY3Rpb24gcmF0aGVyIHRoYW4gYW4gb2JqZWN0XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1hY2Nlc3Mtc3RhdGUtaW4tc2V0c3RhdGVcclxuICAgICAgdGhpcy5zZXRTdGF0ZSh7aXNDb2xsYXBzZWQ6ICF0aGlzLnN0YXRlLmlzQ29sbGFwc2VkfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBjb250cm9sbGVkIG1vZGVcclxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSghdGhpcy5wcm9wcy5jb2xsYXBzZWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCk6IFJlYWN0Lk5vZGUge1xyXG4gICAgY29uc3QgY29sbGFwc2FibGU6IGJvb2xlYW4gPVxyXG4gICAgICB0aGlzLnByb3BzLmNvbGxhcHNhYmxlICE9IG51bGwgPyB0aGlzLnByb3BzLmNvbGxhcHNhYmxlIDogZmFsc2U7XHJcbiAgICBjb25zdCBjb2xsYXBzZWQgPVxyXG4gICAgICB0aGlzLnByb3BzLmNvbGxhcHNlZCA9PSBudWxsXHJcbiAgICAgICAgPyB0aGlzLnN0YXRlLmlzQ29sbGFwc2VkXHJcbiAgICAgICAgOiB0aGlzLnByb3BzLmNvbGxhcHNlZDtcclxuICAgIC8vIE9ubHkgaW5jbHVkZSBjbGFzc2VzIGlmIHRoZSBjb21wb25lbnQgaXMgY29sbGFwc2FibGVcclxuICAgIGNvbnN0IGljb25DbGFzcyA9IGNsYXNzbmFtZXMoe1xyXG4gICAgICBpY29uOiBjb2xsYXBzYWJsZSxcclxuICAgICAgJ2ljb24tY2hldnJvbi1kb3duJzogY29sbGFwc2FibGUgJiYgIWNvbGxhcHNlZCxcclxuICAgICAgJ2ljb24tY2hldnJvbi1yaWdodCc6IGNvbGxhcHNhYmxlICYmIGNvbGxhcHNlZCxcclxuICAgICAgJ251Y2xpZGUtdWktc2VjdGlvbi1jb2xsYXBzYWJsZSc6IGNvbGxhcHNhYmxlLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBjb25kaXRpb25hbFByb3BzID0ge307XHJcbiAgICBpZiAoY29sbGFwc2FibGUpIHtcclxuICAgICAgY29uZGl0aW9uYWxQcm9wcy5vbkNsaWNrID0gdGhpcy5fdG9nZ2xlQ29sbGFwc2VkO1xyXG4gICAgICBjb25kaXRpb25hbFByb3BzLnRpdGxlID0gY29sbGFwc2VkXHJcbiAgICAgICAgPyAnQ2xpY2sgdG8gZXhwYW5kJ1xyXG4gICAgICAgIDogJ0NsaWNrIHRvIGNvbGxhcHNlJztcclxuICAgIH1cclxuICAgIC8vIEFueSBjdXN0b20gdGl0bGUgcHJvcCBzaG91bGQgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgdGl0bGUuXHJcbiAgICBpZiAodGhpcy5wcm9wcy50aXRsZSAhPSBudWxsKSB7XHJcbiAgICAgIGNvbmRpdGlvbmFsUHJvcHMudGl0bGUgPSB0aGlzLnByb3BzLnRpdGxlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgSGVhZGxpbmVDb21wb25lbnQgPSBnZXRIZWFkbGluZUNvbXBvbmVudCh0aGlzLnByb3BzLnNpemUpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfT5cclxuICAgICAgICA8SGVhZGxpbmVDb21wb25lbnQgY2xhc3NOYW1lPXtpY29uQ2xhc3N9IHsuLi5jb25kaXRpb25hbFByb3BzfT5cclxuICAgICAgICAgIHt0aGlzLnByb3BzLmhlYWRsaW5lfVxyXG4gICAgICAgIDwvSGVhZGxpbmVDb21wb25lbnQ+XHJcbiAgICAgICAgPGRpdlxyXG4gICAgICAgICAgc3R5bGU9e2NvbGxhcHNlZCA/IHtkaXNwbGF5OiAnbm9uZSd9IDoge319XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJudWNsaWRlLXVpLXNlY3Rpb24tYm9keVwiPlxyXG4gICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhlYWRsaW5lQ29tcG9uZW50KHNpemU/OiBzdHJpbmcpOiAnaDYnIHwgJ2g1JyB8ICdoMycge1xyXG4gIHN3aXRjaCAoc2l6ZSkge1xyXG4gICAgY2FzZSAnc21hbGwnOlxyXG4gICAgICByZXR1cm4gJ2g2JztcclxuICAgIGNhc2UgJ21lZGl1bSc6XHJcbiAgICAgIHJldHVybiAnaDUnO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuICdoMyc7XHJcbiAgfVxyXG59XHJcbiJdfQ==