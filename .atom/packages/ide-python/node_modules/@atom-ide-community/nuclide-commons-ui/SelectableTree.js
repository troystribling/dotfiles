"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tree = void 0;

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var React = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _assert = _interopRequireDefault(require("assert"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _scrollIntoView = require("./scrollIntoView");

var _Tree = require("./Tree");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */
class Tree extends React.Component {
  constructor(...args) {
    super(...args);
    this._rootNode = void 0;
    this._subscriptions = void 0;
    this.state = {
      isFocused: false,
      focusedPath: null
    };

    this._selectNext = () => {
      let nextNodePath;

      if (this.state.focusedPath == null) {
        nextNodePath = [0];
      } else {
        nextNodePath = getNextNodePath(this.props.items, this.state.focusedPath, this.props.collapsedPaths);
      }

      if (nextNodePath != null) {
        this.props.onSelect(nextNodePath);
        this.setState({
          focusedPath: nextNodePath
        });
      }
    };

    this._selectPrev = () => {
      let prevNodePath;

      if (this.state.focusedPath == null) {
        prevNodePath = [0];
      } else {
        prevNodePath = getPrevNodePath(this.props.items, this.state.focusedPath, this.props.collapsedPaths);
      }

      if (prevNodePath != null) {
        this.props.onSelect(prevNodePath);
      }
    };

    this._collapseNodeViaKeyboard = e => {
      if (this.state.focusedPath == null) {
        return;
      }

      let collapsablePath = [...this.state.focusedPath];
      let collapsableNode = selectNodeAtPath(this.props.items, collapsablePath);

      while (collapsableNode != null && collapsableNode.type !== 'NESTED') {
        collapsablePath = collapsablePath.slice(0, collapsablePath.length - 1);
        collapsableNode = selectNodeAtPath(this.props.items, collapsablePath);
      }

      if (collapsableNode == null) {
        return;
      }

      this.props.onCollapse(collapsablePath); // if a descendant of this node was selected when this node was collapsed,
      // moving selection to this node seems like intuitive behavior (see Chrome's
      // Elements tree)

      this.props.onSelect(collapsablePath);
    };

    this._expandNodeViaKeyboard = e => {
      const {
        focusedPath
      } = this.state;

      if (focusedPath == null) {
        return;
      }

      const focusedNode = selectNodeAtPath(this.props.items, focusedPath);

      if (focusedNode != null && focusedNode.type === 'NESTED') {
        this.props.onExpand(focusedPath);
      }
    };

    this._handleSelect = path => {
      this.props.onSelect(path);
    };

    this._handleConfirm = path => {
      this.props.onConfirm(path);
    };
  }

  componentDidMount() {
    const rootNode = (0, _nullthrows.default)(this._rootNode);
    this._subscriptions = new _UniversalDisposable.default(atom.commands.add(rootNode, {
      'core:move-up': this._selectPrev,
      'core:move-down': this._selectNext,
      'core:move-left': this._collapseNodeViaKeyboard,
      'core:move-right': this._expandNodeViaKeyboard,
      'core:confirm': () => this.state.focusedPath && this._handleConfirm(this.state.focusedPath)
    }), _rxjsCompatUmdMin.Observable.merge(_rxjsCompatUmdMin.Observable.fromEvent(rootNode, 'focusin').mapTo(true), _rxjsCompatUmdMin.Observable.fromEvent(rootNode, 'focusout').mapTo(false)).subscribe(isFocused => this.setState({
      isFocused
    })));
  }

  componentWillUnmount() {
    this._subscriptions.dispose();
  }

  UNSAFE_componentWillReceiveProps() {
    this.setState((state, props) => ({
      focusedPath: props.selectedPaths[props.selectedPaths.length - 1]
    }));
  }

  render() {
    const {
      className,
      collapsedPaths,
      itemClassName,
      items: nodes,
      selectedPaths
    } = this.props;
    const {
      focusedPath,
      isFocused
    } = this.state;
    return /*#__PURE__*/React.createElement("ol", {
      className: (0, _classnames.default)('list-tree', 'nuclide-selectable-tree', 'has-collapsable-children', className, {
        focused: isFocused
      }),
      ref: node => this._rootNode = node,
      role: "tree",
      style: {
        position: 'relative'
      },
      tabIndex: "0"
    }, nodes.map((node, i) => /*#__PURE__*/React.createElement(AbstractTreeItem, {
      key: i,
      node: node,
      path: [i],
      focusedPath: focusedPath,
      collapsedPaths: collapsedPaths,
      selectedPaths: selectedPaths,
      className: itemClassName,
      onSelect: this._handleSelect,
      onConfirm: this._handleConfirm,
      onTripleClick: this.props.onTripleClick,
      onCollapse: this.props.onCollapse,
      onExpand: this.props.onExpand
    })));
  }

}

exports.Tree = Tree;

function AbstractTreeItem({
  className,
  collapsedPaths,
  focusedPath,
  onConfirm,
  onSelect,
  onTripleClick,
  onCollapse,
  onExpand,
  node,
  path,
  selectedPaths
}) {
  if (node.hidden) {
    return null;
  }

  if (node.type === 'LEAF') {
    return (
      /*#__PURE__*/
      // $FlowIgnore
      React.createElement(TreeItem, {
        className: className,
        isFocused: focusedPath && (0, _collection.arrayEqual)(focusedPath, path),
        onConfirm: onConfirm,
        onSelect: onSelect,
        onTripleClick: onTripleClick,
        path: path,
        selectedPaths: selectedPaths
      }, node.label)
    );
  }

  const hasFlatChildren = node.children.every(child => child.type === 'LEAF');
  return (
    /*#__PURE__*/
    // $FlowIgnore
    React.createElement(NestedTreeItem, {
      className: className,
      collapsed: false,
      hasFlatChildren: hasFlatChildren,
      focusedPath: focusedPath,
      onConfirm: onConfirm,
      onSelect: onSelect,
      onTripleClick: onTripleClick,
      onCollapse: onCollapse,
      onExpand: onExpand,
      path: path,
      collapsedPaths: collapsedPaths,
      selectedPaths: selectedPaths,
      label: node.label
    }, node.children.map((child, i) => {
      const childPath = path.concat([i]);
      return /*#__PURE__*/React.createElement(AbstractTreeItem, {
        className: className,
        collapsedPaths: collapsedPaths,
        focusedPath: focusedPath,
        key: childPath.join('.'),
        node: child,
        onConfirm: onConfirm,
        onSelect: onSelect,
        onTripleClick: onTripleClick,
        onCollapse: onCollapse,
        onExpand: onExpand,
        path: childPath,
        selectedPaths: selectedPaths
      });
    }))
  );
}

class TreeItem extends React.Component {
  constructor(...args) {
    super(...args);
    this._liNode = void 0;

    this._handleClick = e => {
      const {
        onSelect,
        onConfirm,
        onTripleClick
      } = this.props;
      const numberOfClicks = e.detail;

      switch (numberOfClicks) {
        case 1:
          onSelect && onSelect(this.props.path);
          break;

        case 2:
          onConfirm && onConfirm(this.props.path);
          break;

        case 3:
          onTripleClick && onTripleClick(this.props.path);
          break;

        default:
          break;
      }
    };
  }

  scrollIntoView() {
    if (this._liNode != null) {
      (0, _scrollIntoView.scrollIntoView)(this._liNode);
    }
  }

  render() {
    const {
      className,
      isFocused,
      path,
      selectedPaths,
      children
    } = this.props;
    const isSelected = selectedPaths.some(selectedPath => (0, _shallowequal.default)(path, selectedPath));

    if (isSelected) {
      process.nextTick(() => {
        // We *are* using `scrollIntoView()` instead of the raw DOM API
        // eslint-disable-next-line nuclide-internal/dom-apis
        this.scrollIntoView();
      });
    }

    return /*#__PURE__*/React.createElement("li", {
      "aria-activedescendant": isFocused,
      "aria-selected": isSelected,
      className: (0, _classnames.default)('list-item', className, {
        selected: isSelected
      }),
      onClick: this._handleClick,
      ref: liNode => this._liNode = liNode,
      role: "treeitem"
    }, isSelected && typeof children === 'string' ?
    /*#__PURE__*/
    // String children must be wrapped to receive correct styles when selected.
    React.createElement("span", null, children) : children);
  }

}

class NestedTreeItem extends React.Component {
  constructor(...args) {
    super(...args);
    this._itemNode = void 0;
    this._subscriptions = void 0;

    this._handleClick = e => {
      const itemNode = this._itemNode;

      if (itemNode == null) {
        return;
      }

      (0, _assert.default)(e.target instanceof Element);

      if (e.target.closest('.list-item') !== itemNode) {
        // this was a click on a descendant node in the inner list
        return;
      } // TODO: This is gross. It assumes that the expand chevron is present in the
      // `before` pseudoelement (as is with most themes), and measures the space
      // it occupies using computed style properties, not actual measurements.
      // The toggle chevron should be reimplemented as a true dom node instead,
      // bypassing themes. Though this is more visually consistent, it's probably
      // not worth the hassle.


      const beforeStyle = window.getComputedStyle(this._itemNode, ':before');
      const itemStyle = window.getComputedStyle(this._itemNode);
      const chevronWidth = parsePx(itemStyle.paddingLeft) + parsePx(beforeStyle.paddingLeft) + parsePx(beforeStyle.paddingRight) + parsePx(beforeStyle.marginLeft) + parsePx(beforeStyle.marginRight) + parsePx(beforeStyle.width) + parsePx(beforeStyle.left);
      const {
        path,
        collapsedPaths
      } = this.props;
      (0, _assert.default)(e.nativeEvent instanceof MouseEvent);

      if (e.nativeEvent.offsetX <= chevronWidth) {
        if (collapsedPaths.some(collapsedPath => (0, _collection.arrayEqual)(path, collapsedPath))) {
          this.props.onExpand(path);
        } else {
          this.props.onCollapse(path);
        }

        return;
      }

      const {
        onSelect,
        onConfirm,
        onTripleClick
      } = this.props;
      const numberOfClicks = e.detail;

      if (numberOfClicks === 1 && onSelect != null) {
        onSelect(path);
      } else if (numberOfClicks === 2 && onConfirm != null) {
        onConfirm(path);
      } else if (numberOfClicks === 3 && onTripleClick != null) {
        onTripleClick(path);
      }
    };
  }

  render() {
    const {
      className,
      hasFlatChildren,
      focusedPath,
      selectedPaths,
      collapsedPaths,
      path,
      label,
      children
    } = this.props;
    const isFocused = focusedPath && (0, _collection.arrayEqual)(path, focusedPath);
    const isSelected = selectedPaths.some(selectedPath => (0, _shallowequal.default)(path, selectedPath));
    const isCollapsed = collapsedPaths.some(collapsedPath => (0, _shallowequal.default)(path, collapsedPath));
    return /*#__PURE__*/React.createElement("li", {
      "aria-activedescendant": isFocused,
      "aria-selected": isSelected,
      "aria-expanded": !isCollapsed,
      className: (0, _classnames.default)('list-nested-item', className, {
        collapsed: isCollapsed,
        selected: isSelected
      }),
      onClick: this._handleClick,
      role: "treeitem"
    }, label == null ? null : /*#__PURE__*/React.createElement("div", {
      className: "list-item",
      ref: node => this._itemNode = node
    }, label), /*#__PURE__*/React.createElement(_Tree.TreeList, {
      hasFlatChildren: hasFlatChildren
    }, children));
  }

}

function selectNodeAtPath(roots, path) {
  if (path.length === 0) {
    return;
  }

  let node = roots[path[0]];

  for (let i = 1; i < path.length; i++) {
    (0, _assert.default)(node.type === 'NESTED');
    node = node.children[path[i]];
  }

  return node;
}

function getNextNodePath(roots, path, collapsedPaths) {
  if (path.length === 0) {
    return null;
  }

  const currentNode = selectNodeAtPath(roots, path);

  if (currentNode == null) {
    return;
  }

  if (currentNode.type === 'NESTED' && currentNode.children.length > 0 && // don't traverse children of collapsed nodes
  !collapsedPaths.find(collapsedPath => (0, _collection.arrayEqual)(collapsedPath, path))) {
    // 'down' was pressed on a nested item. most of the time we want go to its
    // first child, but we need to make sure it's not hidden (eg filtered by
    // a search) first
    const firstVisibleChildIndex = currentNode.children.findIndex(n => !n.hidden);

    if (firstVisibleChildIndex >= 0) {
      return path.concat([firstVisibleChildIndex]);
    }
  }

  return findNextSibling(roots, path, collapsedPaths);
}

function findNextSibling(roots, path, collapsedPaths) {
  if (path.length === 0) {
    return null;
  }

  const leadingIndexes = path.slice(0, path.length - 1);
  const tailIndex = path[path.length - 1];
  const nextSiblingPath = [...leadingIndexes, tailIndex + 1];
  const nextSibling = selectNodeAtPath(roots, nextSiblingPath);

  if (nextSibling != null) {
    if (nextSibling.hidden) {
      // skip over next hidden nodes by finding *their* next sibling
      return findNextSibling(roots, nextSiblingPath, collapsedPaths);
    }

    return nextSiblingPath;
  } // there's no next sibling. let's navigate to this node's parent's siblings


  return findNextSibling(roots, leadingIndexes, collapsedPaths);
}

function getPrevNodePath(roots, path, collapsedPaths) {
  if (path.length === 0) {
    return null;
  }

  const leadingIndexes = path.slice(0, path.length - 1);
  const tailIndex = path[path.length - 1];
  const prevSiblingPath = [...leadingIndexes, tailIndex - 1];
  const prevSibling = selectNodeAtPath(roots, prevSiblingPath);

  if (prevSibling != null) {
    if (prevSibling.hidden) {
      return getPrevNodePath(roots, prevSiblingPath, collapsedPaths);
    }

    if (prevSibling.type === 'NESTED' && prevSibling.children.length > 0 && // don't traverse children of collapsed nodes
    !collapsedPaths.find(collapsedPath => (0, _collection.arrayEqual)(collapsedPath, prevSiblingPath))) {
      // pressed 'up' on a node just after an expanded nested item. Normally this
      // should take us to the last item inside the expanded node, but some may
      // be hidden. Find the last in the list that's visible.
      const lastVisibleChildIndex = (0, _collection.arrayFindLastIndex)(prevSibling.children, n => !n.hidden);

      if (lastVisibleChildIndex >= 0) {
        return prevSiblingPath.concat([lastVisibleChildIndex]);
      }
    }

    return prevSiblingPath;
  } // return the parent if it's a valid path


  if (leadingIndexes.length > 0) {
    return leadingIndexes;
  }
}

function parsePx(px) {
  return px.length === 0 ? 0 : Number(px.replace('px', ''));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1NlbGVjdGFibGVUcmVlLmpzIl0sIm5hbWVzIjpbIlRyZWUiLCJSZWFjdCIsIkNvbXBvbmVudCIsIl9yb290Tm9kZSIsIl9zdWJzY3JpcHRpb25zIiwic3RhdGUiLCJpc0ZvY3VzZWQiLCJmb2N1c2VkUGF0aCIsIl9zZWxlY3ROZXh0IiwibmV4dE5vZGVQYXRoIiwiZ2V0TmV4dE5vZGVQYXRoIiwicHJvcHMiLCJpdGVtcyIsImNvbGxhcHNlZFBhdGhzIiwib25TZWxlY3QiLCJzZXRTdGF0ZSIsIl9zZWxlY3RQcmV2IiwicHJldk5vZGVQYXRoIiwiZ2V0UHJldk5vZGVQYXRoIiwiX2NvbGxhcHNlTm9kZVZpYUtleWJvYXJkIiwiZSIsImNvbGxhcHNhYmxlUGF0aCIsImNvbGxhcHNhYmxlTm9kZSIsInNlbGVjdE5vZGVBdFBhdGgiLCJ0eXBlIiwic2xpY2UiLCJsZW5ndGgiLCJvbkNvbGxhcHNlIiwiX2V4cGFuZE5vZGVWaWFLZXlib2FyZCIsImZvY3VzZWROb2RlIiwib25FeHBhbmQiLCJfaGFuZGxlU2VsZWN0IiwicGF0aCIsIl9oYW5kbGVDb25maXJtIiwib25Db25maXJtIiwiY29tcG9uZW50RGlkTW91bnQiLCJyb290Tm9kZSIsIlVuaXZlcnNhbERpc3Bvc2FibGUiLCJhdG9tIiwiY29tbWFuZHMiLCJhZGQiLCJPYnNlcnZhYmxlIiwibWVyZ2UiLCJmcm9tRXZlbnQiLCJtYXBUbyIsInN1YnNjcmliZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZGlzcG9zZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2VsZWN0ZWRQYXRocyIsInJlbmRlciIsImNsYXNzTmFtZSIsIml0ZW1DbGFzc05hbWUiLCJub2RlcyIsImZvY3VzZWQiLCJub2RlIiwicG9zaXRpb24iLCJtYXAiLCJpIiwib25UcmlwbGVDbGljayIsIkFic3RyYWN0VHJlZUl0ZW0iLCJoaWRkZW4iLCJsYWJlbCIsImhhc0ZsYXRDaGlsZHJlbiIsImNoaWxkcmVuIiwiZXZlcnkiLCJjaGlsZCIsImNoaWxkUGF0aCIsImNvbmNhdCIsImpvaW4iLCJUcmVlSXRlbSIsIl9saU5vZGUiLCJfaGFuZGxlQ2xpY2siLCJudW1iZXJPZkNsaWNrcyIsImRldGFpbCIsInNjcm9sbEludG9WaWV3IiwiaXNTZWxlY3RlZCIsInNvbWUiLCJzZWxlY3RlZFBhdGgiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJzZWxlY3RlZCIsImxpTm9kZSIsIk5lc3RlZFRyZWVJdGVtIiwiX2l0ZW1Ob2RlIiwiaXRlbU5vZGUiLCJ0YXJnZXQiLCJFbGVtZW50IiwiY2xvc2VzdCIsImJlZm9yZVN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIml0ZW1TdHlsZSIsImNoZXZyb25XaWR0aCIsInBhcnNlUHgiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsIndpZHRoIiwibGVmdCIsIm5hdGl2ZUV2ZW50IiwiTW91c2VFdmVudCIsIm9mZnNldFgiLCJjb2xsYXBzZWRQYXRoIiwiaXNDb2xsYXBzZWQiLCJjb2xsYXBzZWQiLCJyb290cyIsImN1cnJlbnROb2RlIiwiZmluZCIsImZpcnN0VmlzaWJsZUNoaWxkSW5kZXgiLCJmaW5kSW5kZXgiLCJuIiwiZmluZE5leHRTaWJsaW5nIiwibGVhZGluZ0luZGV4ZXMiLCJ0YWlsSW5kZXgiLCJuZXh0U2libGluZ1BhdGgiLCJuZXh0U2libGluZyIsInByZXZTaWJsaW5nUGF0aCIsInByZXZTaWJsaW5nIiwibGFzdFZpc2libGVDaGlsZEluZGV4IiwicHgiLCJOdW1iZXIiLCJyZXBsYWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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bnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuLyogZXNsaW50LWVudiBicm93c2VyICovXHJcblxyXG5pbXBvcnQge2FycmF5RXF1YWwsIGFycmF5RmluZExhc3RJbmRleH0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvY29sbGVjdGlvbic7XHJcbmltcG9ydCBVbml2ZXJzYWxEaXNwb3NhYmxlIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcy1jb21wYXQvYnVuZGxlcy9yeGpzLWNvbXBhdC51bWQubWluLmpzJztcclxuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICdzaGFsbG93ZXF1YWwnO1xyXG5pbXBvcnQgbnVsbHRocm93cyBmcm9tICdudWxsdGhyb3dzJztcclxuaW1wb3J0IHtzY3JvbGxJbnRvVmlld30gZnJvbSAnLi9zY3JvbGxJbnRvVmlldyc7XHJcbmltcG9ydCB7VHJlZUxpc3R9IGZyb20gJy4vVHJlZSc7XHJcblxyXG5leHBvcnQgdHlwZSBOb2RlUGF0aCA9IEFycmF5PG51bWJlcj47XHJcbmV4cG9ydCB0eXBlIFRyZWVOb2RlID0gVHJlZUxlYWZOb2RlIHwgVHJlZU5lc3RlZE5vZGU7XHJcblxyXG50eXBlIFRyZWVMZWFmTm9kZSA9IHt8XHJcbiAgdHlwZTogJ0xFQUYnLFxyXG4gIGxhYmVsOiBSZWFjdC5Ob2RlLFxyXG4gIGhpZGRlbj86IGJvb2xlYW4sXHJcbnx9O1xyXG5cclxudHlwZSBUcmVlTmVzdGVkTm9kZSA9IHt8XHJcbiAgdHlwZTogJ05FU1RFRCcsXHJcbiAgY2hpbGRyZW46IEFycmF5PFRyZWVOb2RlPixcclxuICBsYWJlbDogUmVhY3QuTm9kZSxcclxuICBoaWRkZW4/OiBib29sZWFuLFxyXG58fTtcclxuXHJcbnR5cGUgVHJlZVByb3BzID0ge3xcclxuICBjbGFzc05hbWU/OiBzdHJpbmcsXHJcbiAgaXRlbUNsYXNzTmFtZT86IHN0cmluZyxcclxuICBpdGVtczogQXJyYXk8VHJlZU5vZGU+LFxyXG4gIG9uU2VsZWN0OiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uQ29uZmlybTogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvblRyaXBsZUNsaWNrOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIHNlbGVjdGVkUGF0aHM6IEFycmF5PE5vZGVQYXRoPixcclxuICBjb2xsYXBzZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG4gIG9uQ29sbGFwc2U6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25FeHBhbmQ6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbnx9O1xyXG5cclxudHlwZSBUcmVlU3RhdGUgPSB7fFxyXG4gIGZvY3VzZWRQYXRoOiA/Tm9kZVBhdGgsXHJcbiAgaXNGb2N1c2VkOiBib29sZWFuLFxyXG58fTtcclxuXHJcbmV4cG9ydCBjbGFzcyBUcmVlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFRyZWVQcm9wcywgVHJlZVN0YXRlPiB7XHJcbiAgX3Jvb3ROb2RlOiA/SFRNTE9MaXN0RWxlbWVudDtcclxuICBfc3Vic2NyaXB0aW9uczogVW5pdmVyc2FsRGlzcG9zYWJsZTtcclxuICBzdGF0ZSA9IHtcclxuICAgIGlzRm9jdXNlZDogZmFsc2UsXHJcbiAgICBmb2N1c2VkUGF0aDogbnVsbCxcclxuICB9O1xyXG5cclxuICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIGNvbnN0IHJvb3ROb2RlID0gbnVsbHRocm93cyh0aGlzLl9yb290Tm9kZSk7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoXHJcbiAgICAgIGF0b20uY29tbWFuZHMuYWRkKHJvb3ROb2RlLCB7XHJcbiAgICAgICAgJ2NvcmU6bW92ZS11cCc6IHRoaXMuX3NlbGVjdFByZXYsXHJcbiAgICAgICAgJ2NvcmU6bW92ZS1kb3duJzogdGhpcy5fc2VsZWN0TmV4dCxcclxuICAgICAgICAnY29yZTptb3ZlLWxlZnQnOiB0aGlzLl9jb2xsYXBzZU5vZGVWaWFLZXlib2FyZCxcclxuICAgICAgICAnY29yZTptb3ZlLXJpZ2h0JzogdGhpcy5fZXhwYW5kTm9kZVZpYUtleWJvYXJkLFxyXG4gICAgICAgICdjb3JlOmNvbmZpcm0nOiAoKSA9PlxyXG4gICAgICAgICAgdGhpcy5zdGF0ZS5mb2N1c2VkUGF0aCAmJiB0aGlzLl9oYW5kbGVDb25maXJtKHRoaXMuc3RhdGUuZm9jdXNlZFBhdGgpLFxyXG4gICAgICB9KSxcclxuICAgICAgT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudChyb290Tm9kZSwgJ2ZvY3VzaW4nKS5tYXBUbyh0cnVlKSxcclxuICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudChyb290Tm9kZSwgJ2ZvY3Vzb3V0JykubWFwVG8oZmFsc2UpLFxyXG4gICAgICApLnN1YnNjcmliZShpc0ZvY3VzZWQgPT4gdGhpcy5zZXRTdGF0ZSh7aXNGb2N1c2VkfSkpLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpIHtcclxuICAgIHRoaXMuc2V0U3RhdGUoKHN0YXRlLCBwcm9wcykgPT4gKHtcclxuICAgICAgZm9jdXNlZFBhdGg6IHByb3BzLnNlbGVjdGVkUGF0aHNbcHJvcHMuc2VsZWN0ZWRQYXRocy5sZW5ndGggLSAxXSxcclxuICAgIH0pKTtcclxuICB9XHJcblxyXG4gIF9zZWxlY3ROZXh0ID0gKCkgPT4ge1xyXG4gICAgbGV0IG5leHROb2RlUGF0aDtcclxuICAgIGlmICh0aGlzLnN0YXRlLmZvY3VzZWRQYXRoID09IG51bGwpIHtcclxuICAgICAgbmV4dE5vZGVQYXRoID0gWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbmV4dE5vZGVQYXRoID0gZ2V0TmV4dE5vZGVQYXRoKFxyXG4gICAgICAgIHRoaXMucHJvcHMuaXRlbXMsXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5mb2N1c2VkUGF0aCxcclxuICAgICAgICB0aGlzLnByb3BzLmNvbGxhcHNlZFBhdGhzLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKG5leHROb2RlUGF0aCAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMucHJvcHMub25TZWxlY3QobmV4dE5vZGVQYXRoKTtcclxuICAgICAgdGhpcy5zZXRTdGF0ZSh7Zm9jdXNlZFBhdGg6IG5leHROb2RlUGF0aH0pO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9zZWxlY3RQcmV2ID0gKCkgPT4ge1xyXG4gICAgbGV0IHByZXZOb2RlUGF0aDtcclxuICAgIGlmICh0aGlzLnN0YXRlLmZvY3VzZWRQYXRoID09IG51bGwpIHtcclxuICAgICAgcHJldk5vZGVQYXRoID0gWzBdO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJldk5vZGVQYXRoID0gZ2V0UHJldk5vZGVQYXRoKFxyXG4gICAgICAgIHRoaXMucHJvcHMuaXRlbXMsXHJcbiAgICAgICAgdGhpcy5zdGF0ZS5mb2N1c2VkUGF0aCxcclxuICAgICAgICB0aGlzLnByb3BzLmNvbGxhcHNlZFBhdGhzLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZXZOb2RlUGF0aCAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMucHJvcHMub25TZWxlY3QocHJldk5vZGVQYXRoKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBfY29sbGFwc2VOb2RlVmlhS2V5Ym9hcmQgPSAoZTogYXRvbSRDdXN0b21FdmVudCkgPT4ge1xyXG4gICAgaWYgKHRoaXMuc3RhdGUuZm9jdXNlZFBhdGggPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNvbGxhcHNhYmxlUGF0aCA9IFsuLi50aGlzLnN0YXRlLmZvY3VzZWRQYXRoXTtcclxuICAgIGxldCBjb2xsYXBzYWJsZU5vZGUgPSBzZWxlY3ROb2RlQXRQYXRoKHRoaXMucHJvcHMuaXRlbXMsIGNvbGxhcHNhYmxlUGF0aCk7XHJcbiAgICB3aGlsZSAoY29sbGFwc2FibGVOb2RlICE9IG51bGwgJiYgY29sbGFwc2FibGVOb2RlLnR5cGUgIT09ICdORVNURUQnKSB7XHJcbiAgICAgIGNvbGxhcHNhYmxlUGF0aCA9IGNvbGxhcHNhYmxlUGF0aC5zbGljZSgwLCBjb2xsYXBzYWJsZVBhdGgubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGNvbGxhcHNhYmxlTm9kZSA9IHNlbGVjdE5vZGVBdFBhdGgodGhpcy5wcm9wcy5pdGVtcywgY29sbGFwc2FibGVQYXRoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29sbGFwc2FibGVOb2RlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucHJvcHMub25Db2xsYXBzZShjb2xsYXBzYWJsZVBhdGgpO1xyXG4gICAgLy8gaWYgYSBkZXNjZW5kYW50IG9mIHRoaXMgbm9kZSB3YXMgc2VsZWN0ZWQgd2hlbiB0aGlzIG5vZGUgd2FzIGNvbGxhcHNlZCxcclxuICAgIC8vIG1vdmluZyBzZWxlY3Rpb24gdG8gdGhpcyBub2RlIHNlZW1zIGxpa2UgaW50dWl0aXZlIGJlaGF2aW9yIChzZWUgQ2hyb21lJ3NcclxuICAgIC8vIEVsZW1lbnRzIHRyZWUpXHJcbiAgICB0aGlzLnByb3BzLm9uU2VsZWN0KGNvbGxhcHNhYmxlUGF0aCk7XHJcbiAgfTtcclxuXHJcbiAgX2V4cGFuZE5vZGVWaWFLZXlib2FyZCA9IChlOiBhdG9tJEN1c3RvbUV2ZW50KSA9PiB7XHJcbiAgICBjb25zdCB7Zm9jdXNlZFBhdGh9ID0gdGhpcy5zdGF0ZTtcclxuICAgIGlmIChmb2N1c2VkUGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb2N1c2VkTm9kZSA9IHNlbGVjdE5vZGVBdFBhdGgodGhpcy5wcm9wcy5pdGVtcywgZm9jdXNlZFBhdGgpO1xyXG4gICAgaWYgKGZvY3VzZWROb2RlICE9IG51bGwgJiYgZm9jdXNlZE5vZGUudHlwZSA9PT0gJ05FU1RFRCcpIHtcclxuICAgICAgdGhpcy5wcm9wcy5vbkV4cGFuZChmb2N1c2VkUGF0aCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgX2hhbmRsZVNlbGVjdCA9IChwYXRoOiBOb2RlUGF0aCkgPT4ge1xyXG4gICAgdGhpcy5wcm9wcy5vblNlbGVjdChwYXRoKTtcclxuICB9O1xyXG5cclxuICBfaGFuZGxlQ29uZmlybSA9IChwYXRoOiBOb2RlUGF0aCkgPT4ge1xyXG4gICAgdGhpcy5wcm9wcy5vbkNvbmZpcm0ocGF0aCk7XHJcbiAgfTtcclxuXHJcbiAgcmVuZGVyKCkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBjbGFzc05hbWUsXHJcbiAgICAgIGNvbGxhcHNlZFBhdGhzLFxyXG4gICAgICBpdGVtQ2xhc3NOYW1lLFxyXG4gICAgICBpdGVtczogbm9kZXMsXHJcbiAgICAgIHNlbGVjdGVkUGF0aHMsXHJcbiAgICB9ID0gdGhpcy5wcm9wcztcclxuICAgIGNvbnN0IHtmb2N1c2VkUGF0aCwgaXNGb2N1c2VkfSA9IHRoaXMuc3RhdGU7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPG9sXHJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKFxyXG4gICAgICAgICAgJ2xpc3QtdHJlZScsXHJcbiAgICAgICAgICAnbnVjbGlkZS1zZWxlY3RhYmxlLXRyZWUnLFxyXG4gICAgICAgICAgJ2hhcy1jb2xsYXBzYWJsZS1jaGlsZHJlbicsXHJcbiAgICAgICAgICBjbGFzc05hbWUsXHJcbiAgICAgICAgICB7Zm9jdXNlZDogaXNGb2N1c2VkfSxcclxuICAgICAgICApfVxyXG4gICAgICAgIHJlZj17bm9kZSA9PiAodGhpcy5fcm9vdE5vZGUgPSBub2RlKX1cclxuICAgICAgICByb2xlPVwidHJlZVwiXHJcbiAgICAgICAgc3R5bGU9e3twb3NpdGlvbjogJ3JlbGF0aXZlJ319XHJcbiAgICAgICAgdGFiSW5kZXg9XCIwXCI+XHJcbiAgICAgICAge25vZGVzLm1hcCgobm9kZSwgaSkgPT4gKFxyXG4gICAgICAgICAgPEFic3RyYWN0VHJlZUl0ZW1cclxuICAgICAgICAgICAga2V5PXtpfVxyXG4gICAgICAgICAgICBub2RlPXtub2RlfVxyXG4gICAgICAgICAgICBwYXRoPXtbaV19XHJcbiAgICAgICAgICAgIGZvY3VzZWRQYXRoPXtmb2N1c2VkUGF0aH1cclxuICAgICAgICAgICAgY29sbGFwc2VkUGF0aHM9e2NvbGxhcHNlZFBhdGhzfVxyXG4gICAgICAgICAgICBzZWxlY3RlZFBhdGhzPXtzZWxlY3RlZFBhdGhzfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2l0ZW1DbGFzc05hbWV9XHJcbiAgICAgICAgICAgIG9uU2VsZWN0PXt0aGlzLl9oYW5kbGVTZWxlY3R9XHJcbiAgICAgICAgICAgIG9uQ29uZmlybT17dGhpcy5faGFuZGxlQ29uZmlybX1cclxuICAgICAgICAgICAgb25UcmlwbGVDbGljaz17dGhpcy5wcm9wcy5vblRyaXBsZUNsaWNrfVxyXG4gICAgICAgICAgICBvbkNvbGxhcHNlPXt0aGlzLnByb3BzLm9uQ29sbGFwc2V9XHJcbiAgICAgICAgICAgIG9uRXhwYW5kPXt0aGlzLnByb3BzLm9uRXhwYW5kfVxyXG4gICAgICAgICAgLz5cclxuICAgICAgICApKX1cclxuICAgICAgPC9vbD5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBBYnN0cmFjdFRyZWVJdGVtKHtcclxuICBjbGFzc05hbWUsXHJcbiAgY29sbGFwc2VkUGF0aHMsXHJcbiAgZm9jdXNlZFBhdGgsXHJcbiAgb25Db25maXJtLFxyXG4gIG9uU2VsZWN0LFxyXG4gIG9uVHJpcGxlQ2xpY2ssXHJcbiAgb25Db2xsYXBzZSxcclxuICBvbkV4cGFuZCxcclxuICBub2RlLFxyXG4gIHBhdGgsXHJcbiAgc2VsZWN0ZWRQYXRocyxcclxufToge1xyXG4gIGNsYXNzTmFtZTogP3N0cmluZyxcclxuICBjb2xsYXBzZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG4gIGZvY3VzZWRQYXRoOiA/Tm9kZVBhdGgsXHJcbiAgb25Db25maXJtOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uU2VsZWN0OiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uVHJpcGxlQ2xpY2s6IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25Db2xsYXBzZTogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvbkV4cGFuZDogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBub2RlOiBUcmVlTm9kZSxcclxuICBwYXRoOiBOb2RlUGF0aCxcclxuICBzZWxlY3RlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbn0pOiBSZWFjdC5Ob2RlIHtcclxuICBpZiAobm9kZS5oaWRkZW4pIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ0xFQUYnKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAvLyAkRmxvd0lnbm9yZVxyXG4gICAgICA8VHJlZUl0ZW1cclxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cclxuICAgICAgICBpc0ZvY3VzZWQ9e2ZvY3VzZWRQYXRoICYmIGFycmF5RXF1YWwoZm9jdXNlZFBhdGgsIHBhdGgpfVxyXG4gICAgICAgIG9uQ29uZmlybT17b25Db25maXJtfVxyXG4gICAgICAgIG9uU2VsZWN0PXtvblNlbGVjdH1cclxuICAgICAgICBvblRyaXBsZUNsaWNrPXtvblRyaXBsZUNsaWNrfVxyXG4gICAgICAgIHBhdGg9e3BhdGh9XHJcbiAgICAgICAgc2VsZWN0ZWRQYXRocz17c2VsZWN0ZWRQYXRoc30+XHJcbiAgICAgICAge25vZGUubGFiZWx9XHJcbiAgICAgIDwvVHJlZUl0ZW0+XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFzRmxhdENoaWxkcmVuID0gbm9kZS5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiBjaGlsZC50eXBlID09PSAnTEVBRicpO1xyXG4gIHJldHVybiAoXHJcbiAgICAvLyAkRmxvd0lnbm9yZVxyXG4gICAgPE5lc3RlZFRyZWVJdGVtXHJcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxyXG4gICAgICBjb2xsYXBzZWQ9e2ZhbHNlfVxyXG4gICAgICBoYXNGbGF0Q2hpbGRyZW49e2hhc0ZsYXRDaGlsZHJlbn1cclxuICAgICAgZm9jdXNlZFBhdGg9e2ZvY3VzZWRQYXRofVxyXG4gICAgICBvbkNvbmZpcm09e29uQ29uZmlybX1cclxuICAgICAgb25TZWxlY3Q9e29uU2VsZWN0fVxyXG4gICAgICBvblRyaXBsZUNsaWNrPXtvblRyaXBsZUNsaWNrfVxyXG4gICAgICBvbkNvbGxhcHNlPXtvbkNvbGxhcHNlfVxyXG4gICAgICBvbkV4cGFuZD17b25FeHBhbmR9XHJcbiAgICAgIHBhdGg9e3BhdGh9XHJcbiAgICAgIGNvbGxhcHNlZFBhdGhzPXtjb2xsYXBzZWRQYXRoc31cclxuICAgICAgc2VsZWN0ZWRQYXRocz17c2VsZWN0ZWRQYXRoc31cclxuICAgICAgbGFiZWw9e25vZGUubGFiZWx9PlxyXG4gICAgICB7bm9kZS5jaGlsZHJlbi5tYXAoKGNoaWxkLCBpKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5jb25jYXQoW2ldKTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgPEFic3RyYWN0VHJlZUl0ZW1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XHJcbiAgICAgICAgICAgIGNvbGxhcHNlZFBhdGhzPXtjb2xsYXBzZWRQYXRoc31cclxuICAgICAgICAgICAgZm9jdXNlZFBhdGg9e2ZvY3VzZWRQYXRofVxyXG4gICAgICAgICAgICBrZXk9e2NoaWxkUGF0aC5qb2luKCcuJyl9XHJcbiAgICAgICAgICAgIG5vZGU9e2NoaWxkfVxyXG4gICAgICAgICAgICBvbkNvbmZpcm09e29uQ29uZmlybX1cclxuICAgICAgICAgICAgb25TZWxlY3Q9e29uU2VsZWN0fVxyXG4gICAgICAgICAgICBvblRyaXBsZUNsaWNrPXtvblRyaXBsZUNsaWNrfVxyXG4gICAgICAgICAgICBvbkNvbGxhcHNlPXtvbkNvbGxhcHNlfVxyXG4gICAgICAgICAgICBvbkV4cGFuZD17b25FeHBhbmR9XHJcbiAgICAgICAgICAgIHBhdGg9e2NoaWxkUGF0aH1cclxuICAgICAgICAgICAgc2VsZWN0ZWRQYXRocz17c2VsZWN0ZWRQYXRoc31cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKTtcclxuICAgICAgfSl9XHJcbiAgICA8L05lc3RlZFRyZWVJdGVtPlxyXG4gICk7XHJcbn1cclxuXHJcbnR5cGUgVHJlZUl0ZW1Qcm9wcyA9IHt8XHJcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxyXG4gIGNsYXNzTmFtZT86ID9zdHJpbmcsXHJcbiAgaXNGb2N1c2VkOiBib29sZWFuLFxyXG4gIG9uU2VsZWN0OiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uQ29uZmlybTogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvblRyaXBsZUNsaWNrOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIHBhdGg6IE5vZGVQYXRoLFxyXG4gIHNlbGVjdGVkUGF0aHM6IEFycmF5PE5vZGVQYXRoPixcclxufH07XHJcblxyXG5jbGFzcyBUcmVlSXRlbSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxUcmVlSXRlbVByb3BzPiB7XHJcbiAgX2xpTm9kZTogP0hUTUxMSUVsZW1lbnQ7XHJcbiAgX2hhbmRsZUNsaWNrID0gKGU6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4ge1xyXG4gICAgY29uc3Qge29uU2VsZWN0LCBvbkNvbmZpcm0sIG9uVHJpcGxlQ2xpY2t9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICBjb25zdCBudW1iZXJPZkNsaWNrcyA9IGUuZGV0YWlsO1xyXG4gICAgc3dpdGNoIChudW1iZXJPZkNsaWNrcykge1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgb25TZWxlY3QgJiYgb25TZWxlY3QodGhpcy5wcm9wcy5wYXRoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAyOlxyXG4gICAgICAgIG9uQ29uZmlybSAmJiBvbkNvbmZpcm0odGhpcy5wcm9wcy5wYXRoKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIG9uVHJpcGxlQ2xpY2sgJiYgb25UcmlwbGVDbGljayh0aGlzLnByb3BzLnBhdGgpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHNjcm9sbEludG9WaWV3KCkge1xyXG4gICAgaWYgKHRoaXMuX2xpTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgIHNjcm9sbEludG9WaWV3KHRoaXMuX2xpTm9kZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKSB7XHJcbiAgICBjb25zdCB7Y2xhc3NOYW1lLCBpc0ZvY3VzZWQsIHBhdGgsIHNlbGVjdGVkUGF0aHMsIGNoaWxkcmVufSA9IHRoaXMucHJvcHM7XHJcbiAgICBjb25zdCBpc1NlbGVjdGVkID0gc2VsZWN0ZWRQYXRocy5zb21lKHNlbGVjdGVkUGF0aCA9PlxyXG4gICAgICBzaGFsbG93RXF1YWwocGF0aCwgc2VsZWN0ZWRQYXRoKSxcclxuICAgICk7XHJcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xyXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcclxuICAgICAgICAvLyBXZSAqYXJlKiB1c2luZyBgc2Nyb2xsSW50b1ZpZXcoKWAgaW5zdGVhZCBvZiB0aGUgcmF3IERPTSBBUElcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbnVjbGlkZS1pbnRlcm5hbC9kb20tYXBpc1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8bGlcclxuICAgICAgICBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9e2lzRm9jdXNlZH1cclxuICAgICAgICBhcmlhLXNlbGVjdGVkPXtpc1NlbGVjdGVkfVxyXG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcygnbGlzdC1pdGVtJywgY2xhc3NOYW1lLCB7XHJcbiAgICAgICAgICBzZWxlY3RlZDogaXNTZWxlY3RlZCxcclxuICAgICAgICB9KX1cclxuICAgICAgICBvbkNsaWNrPXt0aGlzLl9oYW5kbGVDbGlja31cclxuICAgICAgICByZWY9e2xpTm9kZSA9PiAodGhpcy5fbGlOb2RlID0gbGlOb2RlKX1cclxuICAgICAgICByb2xlPVwidHJlZWl0ZW1cIj5cclxuICAgICAgICB7aXNTZWxlY3RlZCAmJiB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gKFxyXG4gICAgICAgICAgLy8gU3RyaW5nIGNoaWxkcmVuIG11c3QgYmUgd3JhcHBlZCB0byByZWNlaXZlIGNvcnJlY3Qgc3R5bGVzIHdoZW4gc2VsZWN0ZWQuXHJcbiAgICAgICAgICA8c3Bhbj57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgICkgOiAoXHJcbiAgICAgICAgICBjaGlsZHJlblxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvbGk+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxudHlwZSBOZXN0ZWRUcmVlSXRlbVByb3BzID0ge1xyXG4gIGxhYmVsPzogUmVhY3QuTm9kZSxcclxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXHJcbiAgY2xhc3NOYW1lPzogP3N0cmluZyxcclxuICBoYXNGbGF0Q2hpbGRyZW4/OiBib29sZWFuLCAvLyBwYXNzdGhyb3VnaCB0byBpbm5lciBUcmVlTGlzdFxyXG4gIGZvY3VzZWRQYXRoOiBOb2RlUGF0aCxcclxuICBvblNlbGVjdDogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvbkNvbmZpcm06IChwYXRoOiBOb2RlUGF0aCkgPT4gbWl4ZWQsXHJcbiAgb25UcmlwbGVDbGljazogKHBhdGg6IE5vZGVQYXRoKSA9PiBtaXhlZCxcclxuICBvbkNvbGxhcHNlOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIG9uRXhwYW5kOiAocGF0aDogTm9kZVBhdGgpID0+IG1peGVkLFxyXG4gIHBhdGg6IE5vZGVQYXRoLFxyXG4gIHNlbGVjdGVkUGF0aHM6IEFycmF5PE5vZGVQYXRoPixcclxuICBjb2xsYXBzZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG59O1xyXG5cclxuY2xhc3MgTmVzdGVkVHJlZUl0ZW0gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8TmVzdGVkVHJlZUl0ZW1Qcm9wcz4ge1xyXG4gIF9pdGVtTm9kZTogP0hUTUxEaXZFbGVtZW50O1xyXG4gIF9zdWJzY3JpcHRpb25zOiBVbml2ZXJzYWxEaXNwb3NhYmxlO1xyXG5cclxuICBfaGFuZGxlQ2xpY2sgPSAoZTogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB7XHJcbiAgICBjb25zdCBpdGVtTm9kZSA9IHRoaXMuX2l0ZW1Ob2RlO1xyXG4gICAgaWYgKGl0ZW1Ob2RlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGludmFyaWFudChlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpO1xyXG4gICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoJy5saXN0LWl0ZW0nKSAhPT0gaXRlbU5vZGUpIHtcclxuICAgICAgLy8gdGhpcyB3YXMgYSBjbGljayBvbiBhIGRlc2NlbmRhbnQgbm9kZSBpbiB0aGUgaW5uZXIgbGlzdFxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogVGhpcyBpcyBncm9zcy4gSXQgYXNzdW1lcyB0aGF0IHRoZSBleHBhbmQgY2hldnJvbiBpcyBwcmVzZW50IGluIHRoZVxyXG4gICAgLy8gYGJlZm9yZWAgcHNldWRvZWxlbWVudCAoYXMgaXMgd2l0aCBtb3N0IHRoZW1lcyksIGFuZCBtZWFzdXJlcyB0aGUgc3BhY2VcclxuICAgIC8vIGl0IG9jY3VwaWVzIHVzaW5nIGNvbXB1dGVkIHN0eWxlIHByb3BlcnRpZXMsIG5vdCBhY3R1YWwgbWVhc3VyZW1lbnRzLlxyXG4gICAgLy8gVGhlIHRvZ2dsZSBjaGV2cm9uIHNob3VsZCBiZSByZWltcGxlbWVudGVkIGFzIGEgdHJ1ZSBkb20gbm9kZSBpbnN0ZWFkLFxyXG4gICAgLy8gYnlwYXNzaW5nIHRoZW1lcy4gVGhvdWdoIHRoaXMgaXMgbW9yZSB2aXN1YWxseSBjb25zaXN0ZW50LCBpdCdzIHByb2JhYmx5XHJcbiAgICAvLyBub3Qgd29ydGggdGhlIGhhc3NsZS5cclxuICAgIGNvbnN0IGJlZm9yZVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5faXRlbU5vZGUsICc6YmVmb3JlJyk7XHJcbiAgICBjb25zdCBpdGVtU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9pdGVtTm9kZSk7XHJcbiAgICBjb25zdCBjaGV2cm9uV2lkdGggPVxyXG4gICAgICBwYXJzZVB4KGl0ZW1TdHlsZS5wYWRkaW5nTGVmdCkgK1xyXG4gICAgICBwYXJzZVB4KGJlZm9yZVN0eWxlLnBhZGRpbmdMZWZ0KSArXHJcbiAgICAgIHBhcnNlUHgoYmVmb3JlU3R5bGUucGFkZGluZ1JpZ2h0KSArXHJcbiAgICAgIHBhcnNlUHgoYmVmb3JlU3R5bGUubWFyZ2luTGVmdCkgK1xyXG4gICAgICBwYXJzZVB4KGJlZm9yZVN0eWxlLm1hcmdpblJpZ2h0KSArXHJcbiAgICAgIHBhcnNlUHgoYmVmb3JlU3R5bGUud2lkdGgpICtcclxuICAgICAgcGFyc2VQeChiZWZvcmVTdHlsZS5sZWZ0KTtcclxuXHJcbiAgICBjb25zdCB7cGF0aCwgY29sbGFwc2VkUGF0aHN9ID0gdGhpcy5wcm9wcztcclxuICAgIGludmFyaWFudChlLm5hdGl2ZUV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCk7XHJcbiAgICBpZiAoZS5uYXRpdmVFdmVudC5vZmZzZXRYIDw9IGNoZXZyb25XaWR0aCkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY29sbGFwc2VkUGF0aHMuc29tZShjb2xsYXBzZWRQYXRoID0+IGFycmF5RXF1YWwocGF0aCwgY29sbGFwc2VkUGF0aCkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRoaXMucHJvcHMub25FeHBhbmQocGF0aCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNvbGxhcHNlKHBhdGgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB7b25TZWxlY3QsIG9uQ29uZmlybSwgb25UcmlwbGVDbGlja30gPSB0aGlzLnByb3BzO1xyXG4gICAgY29uc3QgbnVtYmVyT2ZDbGlja3MgPSBlLmRldGFpbDtcclxuICAgIGlmIChudW1iZXJPZkNsaWNrcyA9PT0gMSAmJiBvblNlbGVjdCAhPSBudWxsKSB7XHJcbiAgICAgIG9uU2VsZWN0KHBhdGgpO1xyXG4gICAgfSBlbHNlIGlmIChudW1iZXJPZkNsaWNrcyA9PT0gMiAmJiBvbkNvbmZpcm0gIT0gbnVsbCkge1xyXG4gICAgICBvbkNvbmZpcm0ocGF0aCk7XHJcbiAgICB9IGVsc2UgaWYgKG51bWJlck9mQ2xpY2tzID09PSAzICYmIG9uVHJpcGxlQ2xpY2sgIT0gbnVsbCkge1xyXG4gICAgICBvblRyaXBsZUNsaWNrKHBhdGgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHJlbmRlcigpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgY2xhc3NOYW1lLFxyXG4gICAgICBoYXNGbGF0Q2hpbGRyZW4sXHJcbiAgICAgIGZvY3VzZWRQYXRoLFxyXG4gICAgICBzZWxlY3RlZFBhdGhzLFxyXG4gICAgICBjb2xsYXBzZWRQYXRocyxcclxuICAgICAgcGF0aCxcclxuICAgICAgbGFiZWwsXHJcbiAgICAgIGNoaWxkcmVuLFxyXG4gICAgfSA9IHRoaXMucHJvcHM7XHJcbiAgICBjb25zdCBpc0ZvY3VzZWQgPSBmb2N1c2VkUGF0aCAmJiBhcnJheUVxdWFsKHBhdGgsIGZvY3VzZWRQYXRoKTtcclxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzZWxlY3RlZFBhdGhzLnNvbWUoc2VsZWN0ZWRQYXRoID0+XHJcbiAgICAgIHNoYWxsb3dFcXVhbChwYXRoLCBzZWxlY3RlZFBhdGgpLFxyXG4gICAgKTtcclxuICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gY29sbGFwc2VkUGF0aHMuc29tZShjb2xsYXBzZWRQYXRoID0+XHJcbiAgICAgIHNoYWxsb3dFcXVhbChwYXRoLCBjb2xsYXBzZWRQYXRoKSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGxpXHJcbiAgICAgICAgYXJpYS1hY3RpdmVkZXNjZW5kYW50PXtpc0ZvY3VzZWR9XHJcbiAgICAgICAgYXJpYS1zZWxlY3RlZD17aXNTZWxlY3RlZH1cclxuICAgICAgICBhcmlhLWV4cGFuZGVkPXshaXNDb2xsYXBzZWR9XHJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKCdsaXN0LW5lc3RlZC1pdGVtJywgY2xhc3NOYW1lLCB7XHJcbiAgICAgICAgICBjb2xsYXBzZWQ6IGlzQ29sbGFwc2VkLFxyXG4gICAgICAgICAgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsXHJcbiAgICAgICAgfSl9XHJcbiAgICAgICAgb25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XHJcbiAgICAgICAgcm9sZT1cInRyZWVpdGVtXCI+XHJcbiAgICAgICAge2xhYmVsID09IG51bGwgPyBudWxsIDogKFxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsaXN0LWl0ZW1cIiByZWY9e25vZGUgPT4gKHRoaXMuX2l0ZW1Ob2RlID0gbm9kZSl9PlxyXG4gICAgICAgICAgICB7bGFiZWx9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApfVxyXG4gICAgICAgIDxUcmVlTGlzdCBoYXNGbGF0Q2hpbGRyZW49e2hhc0ZsYXRDaGlsZHJlbn0+e2NoaWxkcmVufTwvVHJlZUxpc3Q+XHJcbiAgICAgIDwvbGk+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0Tm9kZUF0UGF0aChyb290czogQXJyYXk8VHJlZU5vZGU+LCBwYXRoOiBOb2RlUGF0aCk6ID9UcmVlTm9kZSB7XHJcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBsZXQgbm9kZSA9IHJvb3RzW3BhdGhbMF1dO1xyXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xyXG4gICAgaW52YXJpYW50KG5vZGUudHlwZSA9PT0gJ05FU1RFRCcpO1xyXG4gICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcGF0aFtpXV07XHJcbiAgfVxyXG4gIHJldHVybiBub2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXROZXh0Tm9kZVBhdGgoXHJcbiAgcm9vdHM6IEFycmF5PFRyZWVOb2RlPixcclxuICBwYXRoOiBOb2RlUGF0aCxcclxuICBjb2xsYXBzZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG4pOiA/Tm9kZVBhdGgge1xyXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdE5vZGVBdFBhdGgocm9vdHMsIHBhdGgpO1xyXG4gIGlmIChjdXJyZW50Tm9kZSA9PSBudWxsKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAoXHJcbiAgICBjdXJyZW50Tm9kZS50eXBlID09PSAnTkVTVEVEJyAmJlxyXG4gICAgY3VycmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJlxyXG4gICAgLy8gZG9uJ3QgdHJhdmVyc2UgY2hpbGRyZW4gb2YgY29sbGFwc2VkIG5vZGVzXHJcbiAgICAhY29sbGFwc2VkUGF0aHMuZmluZChjb2xsYXBzZWRQYXRoID0+IGFycmF5RXF1YWwoY29sbGFwc2VkUGF0aCwgcGF0aCkpXHJcbiAgKSB7XHJcbiAgICAvLyAnZG93bicgd2FzIHByZXNzZWQgb24gYSBuZXN0ZWQgaXRlbS4gbW9zdCBvZiB0aGUgdGltZSB3ZSB3YW50IGdvIHRvIGl0c1xyXG4gICAgLy8gZmlyc3QgY2hpbGQsIGJ1dCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdCdzIG5vdCBoaWRkZW4gKGVnIGZpbHRlcmVkIGJ5XHJcbiAgICAvLyBhIHNlYXJjaCkgZmlyc3RcclxuICAgIGNvbnN0IGZpcnN0VmlzaWJsZUNoaWxkSW5kZXggPSBjdXJyZW50Tm9kZS5jaGlsZHJlbi5maW5kSW5kZXgoXHJcbiAgICAgIG4gPT4gIW4uaGlkZGVuLFxyXG4gICAgKTtcclxuICAgIGlmIChmaXJzdFZpc2libGVDaGlsZEluZGV4ID49IDApIHtcclxuICAgICAgcmV0dXJuIHBhdGguY29uY2F0KFtmaXJzdFZpc2libGVDaGlsZEluZGV4XSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmluZE5leHRTaWJsaW5nKHJvb3RzLCBwYXRoLCBjb2xsYXBzZWRQYXRocyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmROZXh0U2libGluZyhcclxuICByb290czogQXJyYXk8VHJlZU5vZGU+LFxyXG4gIHBhdGg6IE5vZGVQYXRoLFxyXG4gIGNvbGxhcHNlZFBhdGhzOiBBcnJheTxOb2RlUGF0aD4sXHJcbik6ID9Ob2RlUGF0aCB7XHJcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IGxlYWRpbmdJbmRleGVzID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xyXG4gIGNvbnN0IHRhaWxJbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcclxuICBjb25zdCBuZXh0U2libGluZ1BhdGggPSBbLi4ubGVhZGluZ0luZGV4ZXMsIHRhaWxJbmRleCArIDFdO1xyXG4gIGNvbnN0IG5leHRTaWJsaW5nID0gc2VsZWN0Tm9kZUF0UGF0aChyb290cywgbmV4dFNpYmxpbmdQYXRoKTtcclxuICBpZiAobmV4dFNpYmxpbmcgIT0gbnVsbCkge1xyXG4gICAgaWYgKG5leHRTaWJsaW5nLmhpZGRlbikge1xyXG4gICAgICAvLyBza2lwIG92ZXIgbmV4dCBoaWRkZW4gbm9kZXMgYnkgZmluZGluZyAqdGhlaXIqIG5leHQgc2libGluZ1xyXG4gICAgICByZXR1cm4gZmluZE5leHRTaWJsaW5nKHJvb3RzLCBuZXh0U2libGluZ1BhdGgsIGNvbGxhcHNlZFBhdGhzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXh0U2libGluZ1BhdGg7XHJcbiAgfVxyXG5cclxuICAvLyB0aGVyZSdzIG5vIG5leHQgc2libGluZy4gbGV0J3MgbmF2aWdhdGUgdG8gdGhpcyBub2RlJ3MgcGFyZW50J3Mgc2libGluZ3NcclxuICByZXR1cm4gZmluZE5leHRTaWJsaW5nKHJvb3RzLCBsZWFkaW5nSW5kZXhlcywgY29sbGFwc2VkUGF0aHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQcmV2Tm9kZVBhdGgoXHJcbiAgcm9vdHM6IEFycmF5PFRyZWVOb2RlPixcclxuICBwYXRoOiBOb2RlUGF0aCxcclxuICBjb2xsYXBzZWRQYXRoczogQXJyYXk8Tm9kZVBhdGg+LFxyXG4pOiA/Tm9kZVBhdGgge1xyXG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCBsZWFkaW5nSW5kZXhlcyA9IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKTtcclxuICBjb25zdCB0YWlsSW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XHJcbiAgY29uc3QgcHJldlNpYmxpbmdQYXRoID0gWy4uLmxlYWRpbmdJbmRleGVzLCB0YWlsSW5kZXggLSAxXTtcclxuICBjb25zdCBwcmV2U2libGluZyA9IHNlbGVjdE5vZGVBdFBhdGgocm9vdHMsIHByZXZTaWJsaW5nUGF0aCk7XHJcbiAgaWYgKHByZXZTaWJsaW5nICE9IG51bGwpIHtcclxuICAgIGlmIChwcmV2U2libGluZy5oaWRkZW4pIHtcclxuICAgICAgcmV0dXJuIGdldFByZXZOb2RlUGF0aChyb290cywgcHJldlNpYmxpbmdQYXRoLCBjb2xsYXBzZWRQYXRocyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBwcmV2U2libGluZy50eXBlID09PSAnTkVTVEVEJyAmJlxyXG4gICAgICBwcmV2U2libGluZy5jaGlsZHJlbi5sZW5ndGggPiAwICYmXHJcbiAgICAgIC8vIGRvbid0IHRyYXZlcnNlIGNoaWxkcmVuIG9mIGNvbGxhcHNlZCBub2Rlc1xyXG4gICAgICAhY29sbGFwc2VkUGF0aHMuZmluZChjb2xsYXBzZWRQYXRoID0+XHJcbiAgICAgICAgYXJyYXlFcXVhbChjb2xsYXBzZWRQYXRoLCBwcmV2U2libGluZ1BhdGgpLFxyXG4gICAgICApXHJcbiAgICApIHtcclxuICAgICAgLy8gcHJlc3NlZCAndXAnIG9uIGEgbm9kZSBqdXN0IGFmdGVyIGFuIGV4cGFuZGVkIG5lc3RlZCBpdGVtLiBOb3JtYWxseSB0aGlzXHJcbiAgICAgIC8vIHNob3VsZCB0YWtlIHVzIHRvIHRoZSBsYXN0IGl0ZW0gaW5zaWRlIHRoZSBleHBhbmRlZCBub2RlLCBidXQgc29tZSBtYXlcclxuICAgICAgLy8gYmUgaGlkZGVuLiBGaW5kIHRoZSBsYXN0IGluIHRoZSBsaXN0IHRoYXQncyB2aXNpYmxlLlxyXG4gICAgICBjb25zdCBsYXN0VmlzaWJsZUNoaWxkSW5kZXggPSBhcnJheUZpbmRMYXN0SW5kZXgoXHJcbiAgICAgICAgcHJldlNpYmxpbmcuY2hpbGRyZW4sXHJcbiAgICAgICAgbiA9PiAhbi5oaWRkZW4sXHJcbiAgICAgICk7XHJcbiAgICAgIGlmIChsYXN0VmlzaWJsZUNoaWxkSW5kZXggPj0gMCkge1xyXG4gICAgICAgIHJldHVybiBwcmV2U2libGluZ1BhdGguY29uY2F0KFtsYXN0VmlzaWJsZUNoaWxkSW5kZXhdKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwcmV2U2libGluZ1BhdGg7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm4gdGhlIHBhcmVudCBpZiBpdCdzIGEgdmFsaWQgcGF0aFxyXG4gIGlmIChsZWFkaW5nSW5kZXhlcy5sZW5ndGggPiAwKSB7XHJcbiAgICByZXR1cm4gbGVhZGluZ0luZGV4ZXM7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVB4KHB4OiBzdHJpbmcpOiBudW1iZXIge1xyXG4gIHJldHVybiBweC5sZW5ndGggPT09IDAgPyAwIDogTnVtYmVyKHB4LnJlcGxhY2UoJ3B4JywgJycpKTtcclxufVxyXG4iXX0=