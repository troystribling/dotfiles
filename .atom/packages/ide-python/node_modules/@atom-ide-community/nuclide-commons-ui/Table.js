"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._calculateColumnWidths = _calculateColumnWidths;
exports._calculatePreferredColumnWidths = _calculatePreferredColumnWidths;
exports.Table = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _classnames = _interopRequireDefault(require("classnames"));

var React = _interopRequireWildcard(require("react"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _Icon = require("./Icon");

var _collection = require("@atom-ide-community/nuclide-commons/collection");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _observableDom = require("./observable-dom");

var _scrollIntoView = require("./scrollIntoView");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const DEFAULT_MIN_COLUMN_WIDTH = 40;

const DefaultEmptyComponent = () => /*#__PURE__*/React.createElement("div", {
  className: "nuclide-ui-table-empty-message"
}, "Empty table");

/**
 * Design concerns:
 *
 * 1. Because of how it's used throughout the codebase, this Table needs to do all of the folowing:
 *        * Fill the available width of its parent
 *        * Automatically be tall enough to accommodate its contents
 *        * Have a vertically scrollable body if its parent is too small to accommodate the contents
 * 2. We need to support min widths for columns. Resizing the window or one of the component's
 *    containers should not cause a column to dip below its min width.
 *
 * This ends up being a surprisingly constraining set of concerns!
 *
 *     * We must guarantee that the contents of the table do not define the container's size.
 *       Otherwise, this we would be unable to determine the "available area" without hiding the
 *       contents, measuring, and then showing the contents again. Likewise, we could get stuck in
 *       a loop where we set the contents' size, which triggers the resize observer, which causes
 *       us to remeasure the container size and adjust the contents, which triggers the resize
 *       observer...
 *     * We can't use CSS for min width. Resizing one column affects the width of another; if we
 *       make column A smaller, column B needs to get wider to fill the extra space. But using CSS
 *       for min-width means we wouldn't know the true size, and therefore how to adjust B
 *       appropriately.
 *
 * To address these, we define our columns using percentage widths. Unfortunately, this means that
 * our table may behave a little strangely when the available area is less than the sum of the
 * minimum widths of the columns. (Ideally, the table would scroll horizontally in this case.)
 */
class Table extends React.Component {
  static getDerivedStateFromProps(nextProps, prevState) {
    const newState = {};

    if (nextProps.columns !== prevState.lastColumns) {
      newState.lastColumns = nextProps.columns;
    } // Did the columns change? If so, we need to recalculate the widths.


    const currentColumns = prevState.lastColumns;
    const nextColumns = nextProps.columns;

    if (currentColumns == null) {
      return newState;
    }

    if (nextColumns.length !== currentColumns.length || // If the columns just changed order, we want to keep their widths.
    !(0, _collection.areSetsEqual)(new Set(currentColumns.map(column => column.key)), new Set(nextColumns.map(column => column.key)))) {
      newState.preferredColumnWidths = getInitialPreferredColumnWidths(nextColumns);
    }

    return newState;
  }

  constructor(props) {
    super(props);
    this._mouseMoveDisposable = void 0;
    this._rootNode = void 0;
    this._disposables = void 0;
    this._tableBody = void 0;
    this._resizeStarts = void 0;

    this._selectRow = options => {
      const {
        index: selectedIndex,
        event,
        confirm
      } = options;
      const {
        onSelect,
        onWillSelect,
        rows
      } = this.props;

      if (onSelect == null) {
        return;
      }

      const selectedRow = rows[selectedIndex];
      const selectedItem = selectedRow.data;

      if (onWillSelect != null) {
        if (onWillSelect(selectedItem, selectedIndex, event) === false) {
          return;
        }
      }

      onSelect(selectedItem, selectedIndex, event);

      if (confirm && this.props.onConfirm != null) {
        this.props.onConfirm(selectedItem, selectedIndex);
      }
    };

    this._handleSortByColumn = sortedBy => {
      const {
        onSort,
        sortDescending,
        sortedColumn
      } = this.props;

      if (onSort == null) {
        return;
      }

      onSort(sortedBy, sortDescending == null || sortedBy !== sortedColumn ? false : !sortDescending);
    };

    this._resizeStarts = new _rxjsCompatUmdMin.Subject();
    this.state = {
      preferredColumnWidths: getInitialPreferredColumnWidths(props.columns),
      resizeOffset: null,
      tableWidth: 0,
      usingKeyboard: false,
      lastColumns: null
    };
  }

  shouldComponentUpdate(nextProps, nextState) {
    // If the state changed, we need to re-render.
    if (!(0, _shallowequal.default)(nextState, this.state, compareState)) {
      return true;
    }

    if (!(0, _shallowequal.default)(nextProps, this.props, compareCheapProps)) {
      return true;
    }

    if (!(0, _collection.arrayEqual)(nextProps.columns, this.props.columns, _shallowequal.default)) {
      return true;
    }

    if (!(0, _collection.arrayEqual)(nextProps.rows, this.props.rows)) {
      return true;
    }

    return false;
  }

  componentDidMount() {
    const el = (0, _nullthrows.default)(this._rootNode);
    this._disposables = new _UniversalDisposable.default( // Update the column widths when the table is resized.
    new _observableDom.ResizeObservable(el).startWith(null).map(() => el.offsetWidth).filter(tableWidth => tableWidth > 0).subscribe(tableWidth => {
      this.setState({
        tableWidth
      });
    }), this._resizeStarts.switchMap(({
      event: startEvent,
      resizerLocation
    }) => {
      const startX = startEvent.pageX;
      return _rxjsCompatUmdMin.Observable.fromEvent(document, 'mousemove').takeUntil(_rxjsCompatUmdMin.Observable.fromEvent(document, 'mouseup')).map(event => ({
        deltaPx: event.pageX - startX,
        resizerLocation
      })).concat(_rxjsCompatUmdMin.Observable.of(null));
    }).subscribe(resizeOffset => {
      if (resizeOffset == null) {
        // Finalize the resize by updating the user's preferred column widths to account for
        // their action. Note that these preferences are only updated when columns are resized
        // (NOT when the table is). This is important so that, if the user resizes the table
        // such that a column is at its minimum width and then resizes the table back to its
        // orignal size, their original column widths are restored.
        const preferredColumnWidths = _calculatePreferredColumnWidths({
          currentWidths: this._calculateColumnWidths(),
          // TODO: (wbinnssmith) T30771435 this setState depends on current state
          // and should use an updater function rather than an object
          // eslint-disable-next-line react/no-access-state-in-setstate
          tableWidth: this.state.tableWidth,
          minWidths: getMinWidths(this.props.columns)
        }); // Update the preferred distributions and end the resize.


        this.setState({
          preferredColumnWidths,
          resizeOffset: null
        });
      } else {
        this.setState({
          resizeOffset
        });
      }
    }), atom.commands.add(el, {
      'core:move-up': event => {
        this.setState({
          usingKeyboard: true
        });

        this._moveSelection(-1, event);
      },
      'core:move-down': event => {
        this.setState({
          usingKeyboard: true
        });

        this._moveSelection(1, event);
      },
      'core:confirm': event => {
        this.setState({
          usingKeyboard: true
        });
        const {
          rows,
          selectedIndex,
          onConfirm
        } = this.props;

        if (onConfirm == null || selectedIndex == null) {
          return;
        }

        const selectedRow = rows[selectedIndex];
        const selectedItem = selectedRow && selectedRow.data;

        if (selectedItem != null) {
          onConfirm(selectedItem, selectedIndex);
        }
      }
    }), () => {
      if (this._mouseMoveDisposable != null) {
        this._mouseMoveDisposable.dispose();
      }
    });
  }

  componentWillUnmount() {
    this._disposables.dispose();
  }

  componentDidUpdate(prevProps, prevState) {
    if (this._tableBody != null && this.props.selectedIndex != null && this.props.selectedIndex !== prevProps.selectedIndex) {
      const selectedRow = this._tableBody.children[this.props.selectedIndex];

      if (selectedRow != null) {
        (0, _scrollIntoView.scrollIntoViewIfNeeded)(selectedRow);
      }
    }

    if (this.state.usingKeyboard !== prevState.usingKeyboard) {
      if (this._mouseMoveDisposable != null) {
        this._mouseMoveDisposable.dispose();
      }

      if (this.state.usingKeyboard) {
        this._mouseMoveDisposable = new _UniversalDisposable.default(_rxjsCompatUmdMin.Observable.fromEvent(document, 'mousemove').take(1).subscribe(() => {
          this.setState({
            usingKeyboard: false
          });
        }));
      }
    }
  }

  focus() {
    if (this._tableBody == null) {
      return;
    }

    let el = document.activeElement;

    while (el != null) {
      if (el === this._tableBody) {
        // Already focused!
        return;
      }

      el = el.parentNode;
    }

    this._tableBody.focus();
  }

  _moveSelection(offset, event) {
    const {
      selectedIndex
    } = this.props;

    if (selectedIndex == null) {
      return;
    }

    const nextSelectedIndex = Math.max(0, Math.min(this.props.rows.length - 1, selectedIndex + offset));

    if (nextSelectedIndex === selectedIndex) {
      return;
    }

    this._selectRow({
      index: nextSelectedIndex,
      event
    });
  }

  // Just a bound version of the `_calculateColumnWidths` function for convenience.
  _calculateColumnWidths() {
    return _calculateColumnWidths({
      preferredWidths: this.state.preferredColumnWidths,
      minWidths: getMinWidths(this.props.columns),
      tableWidth: this.state.tableWidth,
      columnOrder: this.props.columns.map(column => column.key),
      resizeOffset: this.state.resizeOffset
    });
  }

  render() {
    return /*#__PURE__*/React.createElement("div", {
      className: this.props.className,
      ref: rootNode => this._rootNode = rootNode
    }, this._renderContents());
  }

  _renderContents() {
    if (this.state.tableWidth === 0) {
      // We don't have the table width yet so we can't render the columns.
      return null;
    }

    const {
      alternateBackground,
      collapsable,
      columns,
      enableKeyboardNavigation,
      emptyComponent,
      headerElement,
      headerTitle,
      maxBodyHeight,
      onBodyBlur,
      onBodyFocus,
      rows,
      selectable,
      selectedIndex,
      sortable,
      sortedColumn,
      sortDescending
    } = this.props;

    const columnWidths = this._calculateColumnWidths();

    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TableHeader, {
      columns: columns,
      columnWidths: columnWidths,
      headerElement: headerElement,
      headerTitle: headerTitle,
      onSortByColumn: this._handleSortByColumn,
      resizeStarts: this._resizeStarts,
      sortable: sortable,
      sortedColumn: sortedColumn,
      sortDescending: sortDescending
    }), /*#__PURE__*/React.createElement(TableBody, {
      emptyComponent: emptyComponent,
      enableKeyboardNavigation: enableKeyboardNavigation,
      rows: rows,
      columns: columns,
      columnWidths: columnWidths,
      selectable: selectable,
      usingKeyboard: this.state.usingKeyboard,
      selectRow: this._selectRow,
      onBodyBlur: onBodyBlur,
      onBodyFocus: onBodyFocus,
      alternateBackground: alternateBackground,
      collapsable: collapsable,
      selectedIndex: selectedIndex,
      maxBodyHeight: maxBodyHeight,
      tableRef: el => {
        this._tableBody = el;
      }
    }));
  }

}

exports.Table = Table;

function EmptyCellContent() {
  return /*#__PURE__*/React.createElement("div", null);
}

class TableHeader extends React.PureComponent {
  render() {
    const {
      columns,
      columnWidths,
      headerElement,
      headerTitle,
      onSortByColumn,
      resizeStarts,
      sortable,
      sortDescending,
      sortedColumn
    } = this.props;
    let inner;

    if (headerElement != null || headerTitle != null) {
      inner = /*#__PURE__*/React.createElement("div", {
        className: "nuclide-ui-table-header-cell nuclide-ui-table-full-header"
      }, headerElement != null ? headerElement : headerTitle);
    } else {
      inner = columns.map((column, i) => {
        const {
          title,
          key,
          shouldRightAlign,
          cellClassName
        } = column;
        let resizer;

        if (i < columns.length - 1) {
          resizer = /*#__PURE__*/React.createElement("div", {
            className: "nuclide-ui-table-header-resize-handle",
            onMouseDown: event => {
              resizeStarts.next({
                event,
                resizerLocation: i
              });
            },
            onClick: e => {
              // Prevent sortable column header click event from firing.
              e.stopPropagation();
            }
          });
        }

        const width = columnWidths[key];
        const optionalHeaderCellProps = {};

        if (width != null) {
          optionalHeaderCellProps.style = {
            width: `${width * 100}%`
          };
        }

        let sortIndicator;
        let titleOverlay = title;

        if (sortable) {
          optionalHeaderCellProps.onClick = () => {
            onSortByColumn(key);
          };

          titleOverlay += ' – click to sort';

          if (sortedColumn === key) {
            sortIndicator = /*#__PURE__*/React.createElement("span", {
              className: "nuclide-ui-table-sort-indicator"
            }, /*#__PURE__*/React.createElement(_Icon.Icon, {
              icon: sortDescending ? 'triangle-down' : 'triangle-up'
            }));
          }
        }

        return /*#__PURE__*/React.createElement("div", _extends({
          className: (0, _classnames.default)(cellClassName, {
            'nuclide-ui-table-cell-text-align-right': shouldRightAlign,
            'nuclide-ui-table-header-cell': true,
            'nuclide-ui-table-header-cell-sortable': sortable
          }),
          title: titleOverlay,
          key: key
        }, optionalHeaderCellProps), title, sortIndicator, resizer);
      });
    }

    return /*#__PURE__*/React.createElement("div", {
      key: "header",
      className: "nuclide-ui-table"
    }, /*#__PURE__*/React.createElement("div", {
      className: "nuclide-ui-table-header"
    }, inner));
  }

}

class TableBody extends React.PureComponent {
  render() {
    const {
      alternateBackground,
      collapsable,
      columns,
      columnWidths,
      emptyComponent,
      enableKeyboardNavigation,
      maxBodyHeight,
      rows,
      selectable,
      selectedIndex,
      selectRow,
      tableRef,
      usingKeyboard
    } = this.props;
    let body;

    if (rows.length === 0) {
      const EmptyComponent = emptyComponent !== null && emptyComponent !== void 0 ? emptyComponent : DefaultEmptyComponent;
      body = /*#__PURE__*/React.createElement(EmptyComponent, null);
    } else {
      body = rows.map((row, i) => {
        const {
          className: rowClassName,
          data,
          rowAttributes
        } = row;
        const renderedRow = columns.map((column, j) => {
          const {
            key,
            cellClassName,
            component: Component,
            shouldRightAlign
          } = column;
          let datum = data[key];

          if (Component != null) {
            datum = /*#__PURE__*/React.createElement(Component, {
              data: datum
            });
          } else if (datum == null) {
            datum = /*#__PURE__*/React.createElement(EmptyCellContent, null);
          }

          const cellStyle = {};
          const width = columnWidths[key];

          if (width != null) {
            cellStyle.width = `${width * 100}%`;
          }

          return /*#__PURE__*/React.createElement("div", _extends({
            className: (0, _classnames.default)(cellClassName, {
              'nuclide-ui-table-body-cell': true,
              'nuclide-ui-table-cell-text-align-right': shouldRightAlign
            }),
            key: j,
            style: cellStyle,
            title: typeof datum !== 'object' ? String(datum) : null
          }, rowAttributes), datum);
        });
        const selectableRow = typeof selectable === 'function' ? selectable(row.data) : selectable;
        const rowProps = selectableRow ? {
          onClick: event => {
            switch (event.detail) {
              // This (`event.detail === 0`) shouldn't happen normally but does when the click is
              // triggered by the integration test.
              case 0:
              case 1:
                selectRow({
                  index: i,
                  event
                });
                return;

              case 2:
                // We need to check `event.detail` (instead of using `onDoubleClick`) because
                // (for some reason) `onDoubleClick` is only firing sporadically.
                // TODO: Figure out why. Repros in the diagnostic table with React 16.0.0 and
                // Atom 1.22.0-beta1 (Chrome 56.0.2924.87). This may be because we're swapping out
                // the component on the click so a different one is receiving the second?
                selectRow({
                  index: i,
                  event,
                  confirm: true
                });
                return;
            }
          }
        } : {};
        const isSelectedRow = selectedIndex != null && i === selectedIndex;
        return /*#__PURE__*/React.createElement("div", _extends({
          className: (0, _classnames.default)(rowClassName, {
            'nuclide-ui-table-row': true,
            'nuclide-ui-table-row-selectable': selectableRow,
            'nuclide-ui-table-row-disabled': typeof selectable === 'function' && !selectableRow,
            'nuclide-ui-table-row-using-keyboard-nav': usingKeyboard,
            'nuclide-ui-table-row-selected': isSelectedRow,
            'nuclide-ui-table-row-alternate': alternateBackground !== false && i % 2 === 1,
            'nuclide-ui-table-collapsed-row': collapsable && !isSelectedRow
          }),
          "data-row-index": i,
          key: i
        }, rowProps), renderedRow);
      });
    }

    const bodyClassNames = (0, _classnames.default)('nuclide-ui-table', 'nuclide-ui-table-body', {
      // Before this class is applied only when `!this.props.selectable`
      // because (for some reason) `onDoubleClick` isn't being fired when
      // the element's "user-select" style is "none". Now re-enabling it to
      // support copy text selection
      'nuclide-ui-table-body-selectable-text': true,
      // Using native-key-bindings prevents the up and down arrows from being captured.
      'native-key-bindings': !enableKeyboardNavigation
    });
    const scrollableBodyStyle = {};

    if (maxBodyHeight != null) {
      scrollableBodyStyle.maxHeight = maxBodyHeight;
      scrollableBodyStyle.overflowY = 'auto';
    }

    return /*#__PURE__*/React.createElement("div", {
      style: scrollableBodyStyle,
      onFocus: event => {
        if (this.props.onBodyFocus != null) {
          this.props.onBodyFocus(event);
        }
      },
      onBlur: event => {
        if (this.props.onBodyBlur != null) {
          this.props.onBodyBlur(event);
        }
      }
    }, /*#__PURE__*/React.createElement("div", {
      ref: tableRef,
      className: bodyClassNames,
      tabIndex: "-1"
    }, body));
  }

}
/**
 * Get the initial size of each column as a percentage of the total.
 */


function getInitialPreferredColumnWidths(columns) {
  const columnWidthRatios = {};
  let assignedWidth = 0;
  const unresolvedColumns = [];
  columns.forEach(column => {
    const {
      key,
      width
    } = column;

    if (width != null) {
      columnWidthRatios[key] = width;
      assignedWidth += width;
    } else {
      unresolvedColumns.push(column);
    }
  });
  const residualColumnWidth = (1 - assignedWidth) / unresolvedColumns.length;
  unresolvedColumns.forEach(column => {
    columnWidthRatios[column.key] = residualColumnWidth;
  });
  return columnWidthRatios;
}

function getMinWidths(columns) {
  const minWidths = {};
  columns.forEach(column => {
    minWidths[column.key] = column.minWidth == null ? DEFAULT_MIN_COLUMN_WIDTH : column.minWidth;
  });
  return minWidths;
}
/**
 * Calculate widths, taking into account the preferred and minimum widths. Exported for testing
 * only.
 */


function _calculateColumnWidths(options) {
  const {
    preferredWidths,
    minWidths: minWidthsPx,
    tableWidth,
    columnOrder,
    resizeOffset: resizeOffset_
  } = options;
  const resizeOffset = resizeOffset_ || {
    deltaPx: 0,
    resizerLocation: 0
  };
  const widthsPx = {}; // Calculate the pixel widths of each column given its desired percentage width and minimum pixel
  // width.

  {
    // Figure out how many pixels each column wants, given the current available width.
    let widthToAllocate = tableWidth;
    let columnsToAllocate = columnOrder;

    while (columnsToAllocate.length > 0 && widthToAllocate > 0) {
      const remainingPct = columnsToAllocate.map(columnName => preferredWidths[columnName]).reduce((a, b) => a + b, 0);
      const desiredWidthsPx = (0, _collection.objectFromPairs)(columnsToAllocate.map(columnName => {
        const desiredPct = preferredWidths[columnName] / remainingPct;
        const desiredPx = Math.round(desiredPct * widthToAllocate);
        return [columnName, desiredPx];
      })); // Allocate widths for the columns who want less than their minimum width.

      let remainingPx = widthToAllocate;
      let remainingColumns = [];
      columnsToAllocate.forEach(columnName => {
        const desiredPx = desiredWidthsPx[columnName];
        const minPx = minWidthsPx[columnName];

        if (minPx >= desiredPx) {
          widthsPx[columnName] = Math.min(minPx, remainingPx);
          remainingPx -= widthsPx[columnName];
        } else {
          remainingColumns.push(columnName);
        }
      }); // If we didn't need to truncate any of the columns, give them all their desired width.

      if (columnsToAllocate.length === remainingColumns.length) {
        Object.assign(widthsPx, desiredWidthsPx);
        remainingColumns = [];
      } // If we had to truncate any of the columns, that changes the calculations for how big the
      // remaining columns want to be, so make another pass.


      widthToAllocate = remainingPx;
      columnsToAllocate = remainingColumns;
    }
  }
  {
    // Adjust the column widths according to the resized column.
    const {
      deltaPx,
      resizerLocation
    } = resizeOffset;
    const leftColumns = columnOrder.slice(0, resizerLocation + 1);
    const rightColumns = columnOrder.slice(resizerLocation + 1);
    const [shrinkingColumns, growingColumn] = deltaPx < 0 ? [leftColumns.reverse(), rightColumns[0]] : [rightColumns, leftColumns[leftColumns.length - 1]];
    const targetChange = Math.abs(deltaPx);
    let cumulativeChange = 0;

    for (const columnName of shrinkingColumns) {
      const startWidth = widthsPx[columnName];
      const minWidth = minWidthsPx[columnName];
      const remainingWidth = targetChange - cumulativeChange;
      const newWidth = Math.max(minWidth, startWidth - remainingWidth);
      const change = Math.abs(startWidth - newWidth);
      cumulativeChange += change;
      widthsPx[columnName] = newWidth;

      if (cumulativeChange >= targetChange) {
        break;
      }
    }

    widthsPx[growingColumn] += cumulativeChange;
  } // Convert all the widths from pixels to percentages.

  const widths = {};
  {
    let remainingWidth = 1;
    columnOrder.forEach((columnName, i) => {
      const isLastColumn = i === columnOrder.length - 1;

      if (isLastColumn) {
        // Give the last column all the remaining to account for rounding issues.
        widths[columnName] = remainingWidth;
      } else {
        widths[columnName] = widthsPx[columnName] / tableWidth;
        remainingWidth -= widths[columnName];
      }
    });
  }
  return widths;
}
/**
 * Given the current (percentage) widths of each column, determines what user-preferred distribution
 * this represents. Exported for testing only.
 */


function _calculatePreferredColumnWidths(options) {
  const {
    currentWidths,
    tableWidth,
    minWidths: minWidthsPx
  } = options;
  const currentWidthsPx = (0, _collection.objectMapValues)(currentWidths, w => w * tableWidth); // If any column is at its minimum width, we take that to mean that the user wants the column
  // remain at its minimum if the table is resized (as opposed to maintaining the same percentage).
  // Accordingly, we make that column's preferred width 0.

  const preferredColumnWidths = {}; // Figure out which columns are at their minimum widths.

  let remainingPx = 0; // The width that isn't accounted for after minWidth.

  const columnsNotAtMinimum = [];

  for (const [columnName, widthPx] of Object.entries(currentWidthsPx)) {
    (0, _assert.default)(typeof widthPx === 'number');
    const minWidthPx = minWidthsPx[columnName];

    if (Math.floor(widthPx) <= minWidthPx) {
      // Keep it at its min-width.
      preferredColumnWidths[columnName] = 0;
    } else {
      remainingPx += widthPx;
      columnsNotAtMinimum.push([columnName, widthPx]);
    }
  } // Now distribute the widths of the other columns.


  let remainingPct = 1;
  columnsNotAtMinimum.forEach(([columnName, width], index) => {
    const isLastColumn = index === columnsNotAtMinimum.length - 1;

    if (isLastColumn) {
      // We give the last column the remaining width just to be certain they all add up to 1.
      preferredColumnWidths[columnName] = remainingPct;
    } else {
      preferredColumnWidths[columnName] = width / remainingPx;
      remainingPct -= preferredColumnWidths[columnName];
    }
  });
  return preferredColumnWidths;
}
/**
 * An equality check for comparing Props using `shallowEqual()`. This only performs the cheap
 * checks and assumes that the rows and columns are equal. (They can be checked separatedly iff
 * necessary.)
 */


function compareCheapProps(a, b, key) {
  switch (key) {
    case undefined:
      // This is a magic way of telling `shallowEqual()` to use the default comparison for the
      // props objects (inspect its members).
      return undefined;

    case 'rows':
    case 'columns':
      // We'll check these later iff we need to since they're more expensive.
      return true;

    default:
      return a === b;
  }
}

function compareState(a, b, key) {
  switch (key) {
    case undefined:
      return undefined;

    case 'lastColumns':
      // `lastColumns` isn't used to render anything and only exists for
      // `getDerivedStateFromProps`. Don't count this toward rerendering.
      return true;

    default:
      return a === b;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL1RhYmxlLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfTUlOX0NPTFVNTl9XSURUSCIsIkRlZmF1bHRFbXB0eUNvbXBvbmVudCIsIlRhYmxlIiwiUmVhY3QiLCJDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJuZXh0UHJvcHMiLCJwcmV2U3RhdGUiLCJuZXdTdGF0ZSIsImNvbHVtbnMiLCJsYXN0Q29sdW1ucyIsImN1cnJlbnRDb2x1bW5zIiwibmV4dENvbHVtbnMiLCJsZW5ndGgiLCJTZXQiLCJtYXAiLCJjb2x1bW4iLCJrZXkiLCJwcmVmZXJyZWRDb2x1bW5XaWR0aHMiLCJnZXRJbml0aWFsUHJlZmVycmVkQ29sdW1uV2lkdGhzIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIl9tb3VzZU1vdmVEaXNwb3NhYmxlIiwiX3Jvb3ROb2RlIiwiX2Rpc3Bvc2FibGVzIiwiX3RhYmxlQm9keSIsIl9yZXNpemVTdGFydHMiLCJfc2VsZWN0Um93Iiwib3B0aW9ucyIsImluZGV4Iiwic2VsZWN0ZWRJbmRleCIsImV2ZW50IiwiY29uZmlybSIsIm9uU2VsZWN0Iiwib25XaWxsU2VsZWN0Iiwicm93cyIsInNlbGVjdGVkUm93Iiwic2VsZWN0ZWRJdGVtIiwiZGF0YSIsIm9uQ29uZmlybSIsIl9oYW5kbGVTb3J0QnlDb2x1bW4iLCJzb3J0ZWRCeSIsIm9uU29ydCIsInNvcnREZXNjZW5kaW5nIiwic29ydGVkQ29sdW1uIiwiU3ViamVjdCIsInN0YXRlIiwicmVzaXplT2Zmc2V0IiwidGFibGVXaWR0aCIsInVzaW5nS2V5Ym9hcmQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0U3RhdGUiLCJjb21wYXJlU3RhdGUiLCJjb21wYXJlQ2hlYXBQcm9wcyIsInNoYWxsb3dFcXVhbCIsImNvbXBvbmVudERpZE1vdW50IiwiZWwiLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwiUmVzaXplT2JzZXJ2YWJsZSIsInN0YXJ0V2l0aCIsIm9mZnNldFdpZHRoIiwiZmlsdGVyIiwic3Vic2NyaWJlIiwic2V0U3RhdGUiLCJzd2l0Y2hNYXAiLCJzdGFydEV2ZW50IiwicmVzaXplckxvY2F0aW9uIiwic3RhcnRYIiwicGFnZVgiLCJPYnNlcnZhYmxlIiwiZnJvbUV2ZW50IiwiZG9jdW1lbnQiLCJ0YWtlVW50aWwiLCJkZWx0YVB4IiwiY29uY2F0Iiwib2YiLCJfY2FsY3VsYXRlUHJlZmVycmVkQ29sdW1uV2lkdGhzIiwiY3VycmVudFdpZHRocyIsIl9jYWxjdWxhdGVDb2x1bW5XaWR0aHMiLCJtaW5XaWR0aHMiLCJnZXRNaW5XaWR0aHMiLCJhdG9tIiwiY29tbWFuZHMiLCJhZGQiLCJfbW92ZVNlbGVjdGlvbiIsImRpc3Bvc2UiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsImNoaWxkcmVuIiwidGFrZSIsImZvY3VzIiwiYWN0aXZlRWxlbWVudCIsInBhcmVudE5vZGUiLCJvZmZzZXQiLCJuZXh0U2VsZWN0ZWRJbmRleCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJwcmVmZXJyZWRXaWR0aHMiLCJjb2x1bW5PcmRlciIsInJlbmRlciIsImNsYXNzTmFtZSIsInJvb3ROb2RlIiwiX3JlbmRlckNvbnRlbnRzIiwiYWx0ZXJuYXRlQmFja2dyb3VuZCIsImNvbGxhcHNhYmxlIiwiZW5hYmxlS2V5Ym9hcmROYXZpZ2F0aW9uIiwiZW1wdHlDb21wb25lbnQiLCJoZWFkZXJFbGVtZW50IiwiaGVhZGVyVGl0bGUiLCJtYXhCb2R5SGVpZ2h0Iiwib25Cb2R5Qmx1ciIsIm9uQm9keUZvY3VzIiwic2VsZWN0YWJsZSIsInNvcnRhYmxlIiwiY29sdW1uV2lkdGhzIiwiRW1wdHlDZWxsQ29udGVudCIsIlRhYmxlSGVhZGVyIiwiUHVyZUNvbXBvbmVudCIsIm9uU29ydEJ5Q29sdW1uIiwicmVzaXplU3RhcnRzIiwiaW5uZXIiLCJpIiwidGl0bGUiLCJzaG91bGRSaWdodEFsaWduIiwiY2VsbENsYXNzTmFtZSIsInJlc2l6ZXIiLCJuZXh0IiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsIndpZHRoIiwib3B0aW9uYWxIZWFkZXJDZWxsUHJvcHMiLCJzdHlsZSIsInNvcnRJbmRpY2F0b3IiLCJ0aXRsZU92ZXJsYXkiLCJvbkNsaWNrIiwiVGFibGVCb2R5Iiwic2VsZWN0Um93IiwidGFibGVSZWYiLCJib2R5IiwiRW1wdHlDb21wb25lbnQiLCJyb3ciLCJyb3dDbGFzc05hbWUiLCJyb3dBdHRyaWJ1dGVzIiwicmVuZGVyZWRSb3ciLCJqIiwiY29tcG9uZW50IiwiZGF0dW0iLCJjZWxsU3R5bGUiLCJTdHJpbmciLCJzZWxlY3RhYmxlUm93Iiwicm93UHJvcHMiLCJkZXRhaWwiLCJpc1NlbGVjdGVkUm93IiwiYm9keUNsYXNzTmFtZXMiLCJzY3JvbGxhYmxlQm9keVN0eWxlIiwibWF4SGVpZ2h0Iiwib3ZlcmZsb3dZIiwiY29sdW1uV2lkdGhSYXRpb3MiLCJhc3NpZ25lZFdpZHRoIiwidW5yZXNvbHZlZENvbHVtbnMiLCJmb3JFYWNoIiwicHVzaCIsInJlc2lkdWFsQ29sdW1uV2lkdGgiLCJtaW5XaWR0aCIsIm1pbldpZHRoc1B4IiwicmVzaXplT2Zmc2V0XyIsIndpZHRoc1B4Iiwid2lkdGhUb0FsbG9jYXRlIiwiY29sdW1uc1RvQWxsb2NhdGUiLCJyZW1haW5pbmdQY3QiLCJjb2x1bW5OYW1lIiwicmVkdWNlIiwiYSIsImIiLCJkZXNpcmVkV2lkdGhzUHgiLCJkZXNpcmVkUGN0IiwiZGVzaXJlZFB4Iiwicm91bmQiLCJyZW1haW5pbmdQeCIsInJlbWFpbmluZ0NvbHVtbnMiLCJtaW5QeCIsIk9iamVjdCIsImFzc2lnbiIsImxlZnRDb2x1bW5zIiwic2xpY2UiLCJyaWdodENvbHVtbnMiLCJzaHJpbmtpbmdDb2x1bW5zIiwiZ3Jvd2luZ0NvbHVtbiIsInJldmVyc2UiLCJ0YXJnZXRDaGFuZ2UiLCJhYnMiLCJjdW11bGF0aXZlQ2hhbmdlIiwic3RhcnRXaWR0aCIsInJlbWFpbmluZ1dpZHRoIiwibmV3V2lkdGgiLCJjaGFuZ2UiLCJ3aWR0aHMiLCJpc0xhc3RDb2x1bW4iLCJjdXJyZW50V2lkdGhzUHgiLCJ3IiwiY29sdW1uc05vdEF0TWluaW11bSIsIndpZHRoUHgiLCJlbnRyaWVzIiwibWluV2lkdGhQeCIsImZsb29yIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFNQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7OztBQUlBLE1BQU1BLHdCQUF3QixHQUFHLEVBQWpDOztBQUVBLE1BQU1DLHFCQUFxQixHQUFHLG1CQUM1QjtBQUFLLEVBQUEsU0FBUyxFQUFDO0FBQWYsaUJBREY7O0FBeUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLEtBQU4sU0FBK0JDLEtBQUssQ0FBQ0MsU0FBckMsQ0FBbUU7QUFXekMsU0FBeEJDLHdCQUF3QixDQUM3QkMsU0FENkIsRUFFN0JDLFNBRjZCLEVBR1g7QUFDbEIsVUFBTUMsUUFBUSxHQUFHLEVBQWpCOztBQUNBLFFBQUlGLFNBQVMsQ0FBQ0csT0FBVixLQUFzQkYsU0FBUyxDQUFDRyxXQUFwQyxFQUFpRDtBQUMvQ0YsTUFBQUEsUUFBUSxDQUFDRSxXQUFULEdBQXVCSixTQUFTLENBQUNHLE9BQWpDO0FBQ0QsS0FKaUIsQ0FLbEI7OztBQUNBLFVBQU1FLGNBQWMsR0FBR0osU0FBUyxDQUFDRyxXQUFqQztBQUNBLFVBQU1FLFdBQVcsR0FBR04sU0FBUyxDQUFDRyxPQUE5Qjs7QUFFQSxRQUFJRSxjQUFjLElBQUksSUFBdEIsRUFBNEI7QUFDMUIsYUFBT0gsUUFBUDtBQUNEOztBQUVELFFBQ0VJLFdBQVcsQ0FBQ0MsTUFBWixLQUF1QkYsY0FBYyxDQUFDRSxN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QUFBLFlBQVksSUFBSXpKLHFCQUFxQixDQUFDMEosVUFBRCxDQUFyQztBQUNEO0FBQ0YsR0FURDtBQVdBLFNBQU8xSixxQkFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU21DLGlCQUFULENBQTJCeUgsQ0FBM0IsRUFBcUNDLENBQXJDLEVBQStDOUosR0FBL0MsRUFBNkU7QUFDM0UsVUFBUUEsR0FBUjtBQUNFLFNBQUs4TCxTQUFMO0FBQ0U7QUFDQTtBQUNBLGFBQU9BLFNBQVA7O0FBQ0YsU0FBSyxNQUFMO0FBQ0EsU0FBSyxTQUFMO0FBQ0U7QUFDQSxhQUFPLElBQVA7O0FBQ0Y7QUFDRSxhQUFPakMsQ0FBQyxLQUFLQyxDQUFiO0FBVko7QUFZRDs7QUFFRCxTQUFTM0gsWUFBVCxDQUFzQjBILENBQXRCLEVBQWdDQyxDQUFoQyxFQUEwQzlKLEdBQTFDLEVBQXdFO0FBQ3RFLFVBQVFBLEdBQVI7QUFDRSxTQUFLOEwsU0FBTDtBQUNFLGFBQU9BLFNBQVA7O0FBQ0YsU0FBSyxhQUFMO0FBQ0U7QUFDQTtBQUNBLGFBQU8sSUFBUDs7QUFDRjtBQUNFLGFBQU9qQyxDQUFDLEtBQUtDLENBQWI7QUFSSjtBQVVEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQgbnVsbHRocm93cyBmcm9tICdudWxsdGhyb3dzJztcclxuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ3NoYWxsb3dlcXVhbCc7XHJcbmltcG9ydCB7SWNvbn0gZnJvbSAnLi9JY29uJztcclxuaW1wb3J0IHtcclxuICBhcmVTZXRzRXF1YWwsXHJcbiAgb2JqZWN0TWFwVmFsdWVzLFxyXG4gIG9iamVjdEZyb21QYWlycyxcclxuICBhcnJheUVxdWFsLFxyXG59IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2NvbGxlY3Rpb24nO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IHtSZXNpemVPYnNlcnZhYmxlfSBmcm9tICcuL29ic2VydmFibGUtZG9tJztcclxuaW1wb3J0IHtzY3JvbGxJbnRvVmlld0lmTmVlZGVkfSBmcm9tICcuL3Njcm9sbEludG9WaWV3JztcclxuXHJcbnR5cGUgU2VsZWN0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudDwqPiB8IEV2ZW50O1xyXG5cclxuY29uc3QgREVGQVVMVF9NSU5fQ09MVU1OX1dJRFRIID0gNDA7XHJcblxyXG5jb25zdCBEZWZhdWx0RW1wdHlDb21wb25lbnQgPSAoKSA9PiAoXHJcbiAgPGRpdiBjbGFzc05hbWU9XCJudWNsaWRlLXVpLXRhYmxlLWVtcHR5LW1lc3NhZ2VcIj5FbXB0eSB0YWJsZTwvZGl2PlxyXG4pO1xyXG5cclxuZXhwb3J0IHR5cGUgQ29sdW1uPFQ6IE9iamVjdD4gPSB7XHJcbiAgdGl0bGU6IHN0cmluZyxcclxuICBrZXk6ICRLZXlzPFQ+LFxyXG4gIC8vIFBlcmNlbnRhZ2UuIFRoZSBgd2lkdGhgcyBvZiBhbGwgY29sdW1ucyBtdXN0IGFkZCB1cCB0byAxLlxyXG4gIHdpZHRoPzogbnVtYmVyLFxyXG4gIC8vIE9wdGlvbmFsIFJlYWN0IGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIGNlbGwgY29udGVudHMuXHJcbiAgLy8gVGhlIGNvbXBvbmVudCByZWNlaXZlcyB0aGUgY2VsbCB2YWx1ZSB2aWEgYHByb3BzLmRhdGFgLlxyXG4gIGNvbXBvbmVudD86IFJlYWN0LkNvbXBvbmVudFR5cGU8e2RhdGE6IGFueX0+LFxyXG4gIHNob3VsZFJpZ2h0QWxpZ24/OiBib29sZWFuLFxyXG4gIC8vIEEgY2xhc3MgdG8gYWRkIHRvIHRoZSBjZWxsLiBUaGlzIHdpbGwgYmUgYWRkZWQgdG8gYm90aCB0aGUgaGVhZGVyIGFuZCBib2R5OyB5b3UgY2FuXHJcbiAgLy8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZW0gd2l0aCBgLm51Y2xpZGUtdWktdGFibGUtaGVhZGVyLWNlbGxgIGFuZFxyXG4gIC8vIGAubnVjbGlkZS11aS10YWJsZS1ib2R5LWNlbGxgLlxyXG4gIGNlbGxDbGFzc05hbWU/OiBzdHJpbmcsXHJcbiAgLy8gQSBtaW5pbXVtIHdpZHRoIChpbiBwaXhlbHMpIGZvciB0aGUgY29sdW1uLlxyXG4gIG1pbldpZHRoPzogbnVtYmVyLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUm93PFQ6IE9iamVjdD4gPSB7XHJcbiAgY2xhc3NOYW1lPzogc3RyaW5nLFxyXG4gIGRhdGE6IFQsXHJcbiAgcm93QXR0cmlidXRlcz86IE9iamVjdCxcclxufTtcclxuXHJcbnR5cGUgUGVyY2VudGFnZVdpZHRoTWFwPFQ+ID0ge1trZXk6ICRLZXlzPFQ+XTogbnVtYmVyfTtcclxuLy8gU2FtZSBzaGFwZTsgdGhlIHNlcGFyYXRlIHR5cGUgaXMganVzdCB1c2VkIGZvciBkb2N1bWVudGF0aW9uLS1GbG93IGRvZXNuJ3QgcmVjb2duaXplIGFcclxuLy8gZGlmZmVyZW5jZS5cclxudHlwZSBQaXhlbFdpZHRoTWFwPFQ+ID0ge1trZXk6ICRLZXlzPFQ+XTogbnVtYmVyfTtcclxuXHJcbnR5cGUgUHJvcHM8VD4gPSB7XHJcbiAgLyoqXHJcbiAgICogT3B0aW9uYWwgY2xhc3NuYW1lIGZvciB0aGUgZW50aXJlIHRhYmxlLlxyXG4gICAqL1xyXG4gIGNsYXNzTmFtZT86IHN0cmluZyxcclxuICAvKipcclxuICAgKiBPcHRpb25hbCBtYXgtaGVpZ2h0IGZvciB0aGUgYm9keSBjb250YWluZXIuXHJcbiAgICogVXNlZnVsIGZvciBtYWtpbmcgdGhlIHRhYmxlIHNjcm9sbGFibGUgd2hpbGUga2VlcGluZyB0aGUgaGVhZGVyIGZpeGVkLlxyXG4gICAqL1xyXG4gIG1heEJvZHlIZWlnaHQ/OiBzdHJpbmcsXHJcbiAgY29sdW1uczogQXJyYXk8Q29sdW1uPFQ+PixcclxuICByb3dzOiBBcnJheTxSb3c8VD4+LFxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gc2hhZGUgZXZlbiBhbmQgb2RkIGl0ZW1zIGRpZmZlcmVudGx5LiBEZWZhdWx0IGJlaGF2aW9yIGlzIGB0cnVlYC5cclxuICAgKi9cclxuICBhbHRlcm5hdGVCYWNrZ3JvdW5kPzogbnVtYmVyLFxyXG4gIGNoaWxkcmVuPzogUmVhY3QuRWxlbWVudDxhbnk+LFxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgY29sdW1ucyBjYW4gYmUgc29ydGVkLlxyXG4gICAqIElmIHNwZWNpZmllZCwgYG9uU29ydGAsIGBzb3J0ZWRDb2x1bW5gLCBhbmQgYHNvcnREZXNjZW5kaW5nYCBtdXN0IGFsc28gYmUgc3BlY2lmaWVkLlxyXG4gICAqL1xyXG4gIHNvcnRhYmxlPzogYm9vbGVhbixcclxuICBvblNvcnQ/OiAoc29ydGVkQnk6ICRLZXlzPFQ+LCBzb3J0RGVzY2VuZGluZzogYm9vbGVhbikgPT4gdm9pZCxcclxuICBzb3J0ZWRDb2x1bW4/OiA/JEtleXM8VD4sXHJcbiAgc29ydERlc2NlbmRpbmc/OiBib29sZWFuLFxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgaXRlbXMgY2FuIGJlIHNlbGVjdGVkLlxyXG4gICAqIElmIHNwZWNpZmllZCwgYG9uU2VsZWN0YCBtdXN0IGFsc28gYmUgc3BlY2lmaWVkLlxyXG4gICAqL1xyXG4gIHNlbGVjdGFibGU/OiBib29sZWFuIHwgKChyb3c6IFQpID0+IGJvb2xlYW4pLFxyXG4gIHNlbGVjdGVkSW5kZXg/OiA/bnVtYmVyLFxyXG4gIC8qKlxyXG4gICAqIEhhbmRsZXIgdG8gYmUgY2FsbGVkIHVwb24gc2VsZWN0aW9uLiBDYWxsZWQgaWZmIGBzZWxlY3RhYmxlYCBpcyBgdHJ1ZWAuIFdlIHBhc3MgYWxvbmcgdGhlIGV2ZW50XHJcbiAgICogYmVjYXVzZSBzb21lIGNvbnN1bWVycyBtYXkgd2FudCB0byB0YWtlIGRpZmZlcmVudCBhY3Rpb24gZGVwZW5kaW5nIG9uIGl0LiBGb3IgZXhhbXBsZSwgaWYgeW91XHJcbiAgICogY2xpY2sgb24gYSByb3cgaW4gdGhlIGRpYWdub3N0aWNzIHRhYmxlLCB3ZSBrbm93IHlvdSB3YW50IHRvIGdvIHRvIHRoYXQgZGlhZ25vc3RpYzsgaWYgeW91XHJcbiAgICogc2VsZWN0IGl0IHdpdGggdGhlIGtleWJvYXJkLCB5b3UgbWF5IGp1c3QgYmUgZG9pbmcgc28gaW5jaWRlbnRhbGx5IHdoaWxlIG1vdmluZyB0aGUgc2VsZWN0aW9uXHJcbiAgICogdG8gYW5vdGhlciByb3cuXHJcbiAgICovXHJcbiAgb25TZWxlY3Q/OiAoXHJcbiAgICBzZWxlY3RlZEl0ZW06IGFueSxcclxuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlcixcclxuICAgIGV2ZW50OiBTZWxlY3Rpb25FdmVudCxcclxuICApID0+IG1peGVkLFxyXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIHRvIGJlIGludm9rZWQgYmVmb3JlIGNhbGxpbmcgb25TZWxlY3QuIENhbGxlZCBpZmYgYHNlbGVjdGFibGVgIGlzIGB0cnVlYC5cclxuICAgKiBJZiB0aGlzIGNhbGxiYWNrIHJldHVybnMgZmFsc2UsIHJvdyBzZWxlY3Rpb24gaXMgY2FuY2VsZWQuXHJcbiAgICovXHJcbiAgb25XaWxsU2VsZWN0PzogKFxyXG4gICAgc2VsZWN0ZWRJdGVtOiBhbnksXHJcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIsXHJcbiAgICBldmVudDogU2VsZWN0aW9uRXZlbnQsXHJcbiAgKSA9PiBib29sZWFuLFxyXG5cclxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBhIHJvdyBzZWxlY3Rpb24gaXMgY29uZmlybWVkLiBDdXJyZW50bHksIHRoaXMgaXMgZG9uZSBlaXRoZXIgYnkgdHJpZ2dlcmluZ1xyXG4gICAqIFwiY29yZTpjb25maXJtXCIgd2hpbGUgYW4gaXRlbSBpcyBzZWxlY3RlZCBvciBieSBzaW5nbGUgY2xpY2tpbmcgKHdoaWNoIHNlbGVjdHMgYW5kIGNvbmZpcm1zKS5cclxuICAgKiBJbiB0aGUgZnV0dXJlLCB3ZSBtYXkgY29uc2lkZXIgbW92aW5nIHNpbmdsZSBjbGljayB0byBzZWxlY3Qtb25seSBhbmQgcmVxdWlyaW5nIGRvdWJsZSBjbGlja1xyXG4gICAqIGZvciBjb25maXJtYXRpb24uXHJcbiAgICovXHJcbiAgb25Db25maXJtPzogKHNlbGVjdGVkSXRlbTogYW55LCBzZWxlY3RlZEluZGV4OiBudW1iZXIpID0+IG1peGVkLFxyXG5cclxuICBvbkJvZHlCbHVyPzogKGV2ZW50OiBTeW50aGV0aWNFdmVudDwqPikgPT4gbWl4ZWQsXHJcbiAgb25Cb2R5Rm9jdXM/OiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PCo+KSA9PiBtaXhlZCxcclxuXHJcbiAgLyoqXHJcbiAgICogT3B0aW9uYWwgUmVhY3QgQ29tcG9uZW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1lc3NhZ2Ugd2hlbiB6ZXJvIHJvd3MgYXJlIHByb3ZpZGVkLlxyXG4gICAqIFVzZWZ1bCBmb3Igc2hvd2luZyBsb2FkaW5nIHNwaW5uZXJzIGFuZCBjdXN0b20gbWVzc2FnZXMuXHJcbiAgICovXHJcbiAgZW1wdHlDb21wb25lbnQ/OiBSZWFjdC5Db21wb25lbnRUeXBlPGFueT4sXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciBhIHRhYmxlIHJvdyB3aWxsIGJlIGNvbGxhcHNlZCBpZiBpdHMgY29udGVudCBpcyB0b28gbGFyZ2VcclxuICAgKi9cclxuICBjb2xsYXBzYWJsZT86IGJvb2xlYW4sXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGVyZSdzIGEgaGVhZGVyIHRpdGxlIHNwYW5uaW5nIGFsbCBjZWxscyBpbnN0ZWFkIG9mIHRoZSBjb2x1bW4gdGl0bGVzLlxyXG4gICAqIEl0IGRpc2FibGVzIHRoZSAnc29ydGFibGUnIHByb3AuXHJcbiAgICovXHJcbiAgaGVhZGVyVGl0bGU/OiBzdHJpbmcsXHJcbiAgLyoqXHJcbiAgICogT3B0aW9uYWwgSFRNTEVsZW1lbnQgdG8gcmVuZGVyIGEgY3VzdG9tIHRhYmxlIGhlYWRlci4gVGFrZXMgcHJlY2VkZW5jZSBvdmVyXHJcbiAgICogaGVhZGVyVGl0bGUuXHJcbiAgICovXHJcbiAgaGVhZGVyRWxlbWVudD86IFJlYWN0Lk5vZGUsXHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3VsZCBrZXlib2FyZCBuYXZpZ2F0aW9uIGJlIGVuYWJsZWQ/IFRoaXMgb3B0aW9uIGV4aXN0cyBmb3IgaGlzdG9yaWNhbCBwdXJwb3Nlcy4gSWRlYWxseSBpdFxyXG4gICAqIHdvdWxkIGFsd2F5cyBiZSBlbmFibGVkLCBob3dldmVyLCBzb21lIGxvY2F0aW9ucyByZXF1aXJlIHRoZSBcIm5hdGl2ZS1rZXktYmluZGluZ3NcIiBjbGFzcy0tXHJcbiAgICogdXN1YWxseSB0byBlbmFibGUgY29weWluZyB0byB0aGUgY2xpcGJvYXJkLS13aGljaCBwcmV2ZW50cyBBdG9tIGNvbW1hbmRzIGZyb20gZmlyaW5nLlxyXG4gICAqIFRPRE86IEZpbmQgYW4gYWx0ZXJuYXRpdmUgbWVhbnMgb2YgZW5hYmxpbmcgY29weWluZyBpbiB0aG9zZSBsb2NhdGlvbnMsIGFsd2F5cyBlbmFibGUga2V5Ym9hcmRcclxuICAgKiBuYXZpZ2F0aW9uLCBhbmQgcmVtb3ZlIHRoaXMgcHJvcC5cclxuICAgKi9cclxuICBlbmFibGVLZXlib2FyZE5hdmlnYXRpb24/OiA/Ym9vbGVhbixcclxufTtcclxuXHJcbnR5cGUgUmVzaXplT2Zmc2V0ID0ge3xcclxuICBkZWx0YVB4OiBudW1iZXIsIC8vIEluIHBpeGVsc1xyXG4gIHJlc2l6ZXJMb2NhdGlvbjogbnVtYmVyLCAvLyBUaGUgY29sdW1uIGFmdGVyIHdoaWNoIHRoZSByZXNpemVyIGlzIGxvY2F0ZWQuXHJcbnx9O1xyXG5cclxudHlwZSBTdGF0ZTxUPiA9IHt8XHJcbiAgdGFibGVXaWR0aDogbnVtYmVyLFxyXG5cclxuICAvLyBUaGUgdXNlcidzIHByZWZlcnJlZCBjb2x1bW4gZGlzdHJpYnV0aW9ucy4gVGhlc2UgZG8gbm90IHRha2UgaW50byBhY2NvdW50IHRoZSBtaW5pbXVtIHdpZHRocy5cclxuICBwcmVmZXJyZWRDb2x1bW5XaWR0aHM6IFBlcmNlbnRhZ2VXaWR0aE1hcDxUPixcclxuXHJcbiAgLy8gRHVyaW5nIGEgZHJhZyBvcGVyYXRpb24sIHNwZWNpZmllcyB0aGUgY2hhbmdlIHRoZSB1c2VyIGRlc2lyZXMgaW4gdGhlIGNvbHVtbiBzaXplIChhbmQgdG8gd2hpY2hcclxuICAvLyBjb2x1bW4pLiBUaGlzIGlzIGtlcHQgYXMgYSBzZXBhcmF0ZSBwaWVjZSBvZiBzdGF0ZSBmcm9tIHRoZSBjYWxjdWxhdGVkIHdpZHRocyBhbmQgb25seSBjb21iaW5lZFxyXG4gIC8vIHdpdGggdGhlbSBpbiBgcmVuZGVyKClgIHNvIHRoYXQgd2UgY2FuIHJlY2FsY3VsYXRlIHdpZHRocyBpZiB0aGUgdGFibGUgY2hhbmdlcyBzaXplLiBXZSBjb3VsZFxyXG4gIC8vIGFsc28gc3VwcG9ydCBjYW5jZWxhdGlvbiBvZiB0aGUgcmVzaXplICh0aG91Z2ggd2UgZG9uJ3QgeWV0KS5cclxuICByZXNpemVPZmZzZXQ6ID9SZXNpemVPZmZzZXQsXHJcblxyXG4gIC8vIEl0J3MgYXdrd2FyZCB0byBoYXZlIGhvdmVyIHN0eWxpbmcgd2hlbiB5b3UncmUgdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgdGhlIG1vdXNlIGp1c3RcclxuICAvLyBoYXBwZW5zIHRvIGJlIG92ZXIgYSByb3cuIFRoZXJlZm9yZSwgd2UnbGwga2VlcCB0cmFjayBvZiB3aGVuIHlvdSB1c2Uga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmRcclxuICAvLyB3aWxsIGRpc2FibGUgdGhlIGhvdmVyIHN0YXRlIHVudGlsIHlvdSBtb3ZlIHRoZSBtb3VzZSBhZ2Fpbi5cclxuICB1c2luZ0tleWJvYXJkOiBib29sZWFuLFxyXG5cclxuICAvLyBSZWZsZWN0cyB0aGUgcHJldmlvdXMgdmFsdWUgc3RvcmVkIGluIGB0aGlzLnByb3BzLmNvbHVtbnNgLiBVc2VkIGV4Y2x1c2l2ZWx5XHJcbiAgLy8gYnkgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gY2hhbmdlIGNvbHVtbiB3aWR0aC5cclxuICBsYXN0Q29sdW1uczogP0FycmF5PENvbHVtbjxUPj4sXHJcbnx9O1xyXG5cclxuLyoqXHJcbiAqIERlc2lnbiBjb25jZXJuczpcclxuICpcclxuICogMS4gQmVjYXVzZSBvZiBob3cgaXQncyB1c2VkIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlLCB0aGlzIFRhYmxlIG5lZWRzIHRvIGRvIGFsbCBvZiB0aGUgZm9sb3dpbmc6XHJcbiAqICAgICAgICAqIEZpbGwgdGhlIGF2YWlsYWJsZSB3aWR0aCBvZiBpdHMgcGFyZW50XHJcbiAqICAgICAgICAqIEF1dG9tYXRpY2FsbHkgYmUgdGFsbCBlbm91Z2ggdG8gYWNjb21tb2RhdGUgaXRzIGNvbnRlbnRzXHJcbiAqICAgICAgICAqIEhhdmUgYSB2ZXJ0aWNhbGx5IHNjcm9sbGFibGUgYm9keSBpZiBpdHMgcGFyZW50IGlzIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB0aGUgY29udGVudHNcclxuICogMi4gV2UgbmVlZCB0byBzdXBwb3J0IG1pbiB3aWR0aHMgZm9yIGNvbHVtbnMuIFJlc2l6aW5nIHRoZSB3aW5kb3cgb3Igb25lIG9mIHRoZSBjb21wb25lbnQnc1xyXG4gKiAgICBjb250YWluZXJzIHNob3VsZCBub3QgY2F1c2UgYSBjb2x1bW4gdG8gZGlwIGJlbG93IGl0cyBtaW4gd2lkdGguXHJcbiAqXHJcbiAqIFRoaXMgZW5kcyB1cCBiZWluZyBhIHN1cnByaXNpbmdseSBjb25zdHJhaW5pbmcgc2V0IG9mIGNvbmNlcm5zIVxyXG4gKlxyXG4gKiAgICAgKiBXZSBtdXN0IGd1YXJhbnRlZSB0aGF0IHRoZSBjb250ZW50cyBvZiB0aGUgdGFibGUgZG8gbm90IGRlZmluZSB0aGUgY29udGFpbmVyJ3Mgc2l6ZS5cclxuICogICAgICAgT3RoZXJ3aXNlLCB0aGlzIHdlIHdvdWxkIGJlIHVuYWJsZSB0byBkZXRlcm1pbmUgdGhlIFwiYXZhaWxhYmxlIGFyZWFcIiB3aXRob3V0IGhpZGluZyB0aGVcclxuICogICAgICAgY29udGVudHMsIG1lYXN1cmluZywgYW5kIHRoZW4gc2hvd2luZyB0aGUgY29udGVudHMgYWdhaW4uIExpa2V3aXNlLCB3ZSBjb3VsZCBnZXQgc3R1Y2sgaW5cclxuICogICAgICAgYSBsb29wIHdoZXJlIHdlIHNldCB0aGUgY29udGVudHMnIHNpemUsIHdoaWNoIHRyaWdnZXJzIHRoZSByZXNpemUgb2JzZXJ2ZXIsIHdoaWNoIGNhdXNlc1xyXG4gKiAgICAgICB1cyB0byByZW1lYXN1cmUgdGhlIGNvbnRhaW5lciBzaXplIGFuZCBhZGp1c3QgdGhlIGNvbnRlbnRzLCB3aGljaCB0cmlnZ2VycyB0aGUgcmVzaXplXHJcbiAqICAgICAgIG9ic2VydmVyLi4uXHJcbiAqICAgICAqIFdlIGNhbid0IHVzZSBDU1MgZm9yIG1pbiB3aWR0aC4gUmVzaXppbmcgb25lIGNvbHVtbiBhZmZlY3RzIHRoZSB3aWR0aCBvZiBhbm90aGVyOyBpZiB3ZVxyXG4gKiAgICAgICBtYWtlIGNvbHVtbiBBIHNtYWxsZXIsIGNvbHVtbiBCIG5lZWRzIHRvIGdldCB3aWRlciB0byBmaWxsIHRoZSBleHRyYSBzcGFjZS4gQnV0IHVzaW5nIENTU1xyXG4gKiAgICAgICBmb3IgbWluLXdpZHRoIG1lYW5zIHdlIHdvdWxkbid0IGtub3cgdGhlIHRydWUgc2l6ZSwgYW5kIHRoZXJlZm9yZSBob3cgdG8gYWRqdXN0IEJcclxuICogICAgICAgYXBwcm9wcmlhdGVseS5cclxuICpcclxuICogVG8gYWRkcmVzcyB0aGVzZSwgd2UgZGVmaW5lIG91ciBjb2x1bW5zIHVzaW5nIHBlcmNlbnRhZ2Ugd2lkdGhzLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIG1lYW5zIHRoYXRcclxuICogb3VyIHRhYmxlIG1heSBiZWhhdmUgYSBsaXR0bGUgc3RyYW5nZWx5IHdoZW4gdGhlIGF2YWlsYWJsZSBhcmVhIGlzIGxlc3MgdGhhbiB0aGUgc3VtIG9mIHRoZVxyXG4gKiBtaW5pbXVtIHdpZHRocyBvZiB0aGUgY29sdW1ucy4gKElkZWFsbHksIHRoZSB0YWJsZSB3b3VsZCBzY3JvbGwgaG9yaXpvbnRhbGx5IGluIHRoaXMgY2FzZS4pXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGFibGU8VDogT2JqZWN0PiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wczxUPiwgU3RhdGU8VD4+IHtcclxuICBfbW91c2VNb3ZlRGlzcG9zYWJsZTogP0lEaXNwb3NhYmxlO1xyXG4gIF9yb290Tm9kZTogP0hUTUxEaXZFbGVtZW50O1xyXG4gIF9kaXNwb3NhYmxlczogVW5pdmVyc2FsRGlzcG9zYWJsZTtcclxuICBfdGFibGVCb2R5OiA/SFRNTEVsZW1lbnQ7XHJcblxyXG4gIF9yZXNpemVTdGFydHM6IFN1YmplY3Q8e1xyXG4gICAgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8Kj4sXHJcbiAgICByZXNpemVyTG9jYXRpb246IG51bWJlcixcclxuICB9PjtcclxuXHJcbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcclxuICAgIG5leHRQcm9wczogUHJvcHM8VD4sXHJcbiAgICBwcmV2U3RhdGU6IFN0YXRlPFQ+LFxyXG4gICk6ICRTaGFwZTxTdGF0ZTxUPj4ge1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB7fTtcclxuICAgIGlmIChuZXh0UHJvcHMuY29sdW1ucyAhPT0gcHJldlN0YXRlLmxhc3RDb2x1bW5zKSB7XHJcbiAgICAgIG5ld1N0YXRlLmxhc3RDb2x1bW5zID0gbmV4dFByb3BzLmNvbHVtbnM7XHJcbiAgICB9XHJcbiAgICAvLyBEaWQgdGhlIGNvbHVtbnMgY2hhbmdlPyBJZiBzbywgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSB0aGUgd2lkdGhzLlxyXG4gICAgY29uc3QgY3VycmVudENvbHVtbnMgPSBwcmV2U3RhdGUubGFzdENvbHVtbnM7XHJcbiAgICBjb25zdCBuZXh0Q29sdW1ucyA9IG5leHRQcm9wcy5jb2x1bW5zO1xyXG5cclxuICAgIGlmIChjdXJyZW50Q29sdW1ucyA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIG5leHRDb2x1bW5zLmxlbmd0aCAhPT0gY3VycmVudENvbHVtbnMubGVuZ3RoIHx8XHJcbiAgICAgIC8vIElmIHRoZSBjb2x1bW5zIGp1c3QgY2hhbmdlZCBvcmRlciwgd2Ugd2FudCB0byBrZWVwIHRoZWlyIHdpZHRocy5cclxuICAgICAgIWFyZVNldHNFcXVhbChcclxuICAgICAgICBuZXcgU2V0KGN1cnJlbnRDb2x1bW5zLm1hcChjb2x1bW4gPT4gY29sdW1uLmtleSkpLFxyXG4gICAgICAgIG5ldyBTZXQobmV4dENvbHVtbnMubWFwKGNvbHVtbiA9PiBjb2x1bW4ua2V5KSksXHJcbiAgICAgIClcclxuICAgICkge1xyXG4gICAgICBuZXdTdGF0ZS5wcmVmZXJyZWRDb2x1bW5XaWR0aHMgPSBnZXRJbml0aWFsUHJlZmVycmVkQ29sdW1uV2lkdGhzKFxyXG4gICAgICAgIG5leHRDb2x1bW5zLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBQcm9wczxUPikge1xyXG4gICAgc3VwZXIocHJvcHMpO1xyXG4gICAgdGhpcy5fcmVzaXplU3RhcnRzID0gbmV3IFN1YmplY3QoKTtcclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIHByZWZlcnJlZENvbHVtbldpZHRoczogZ2V0SW5pdGlhbFByZWZlcnJlZENvbHVtbldpZHRocyhwcm9wcy5jb2x1bW5zKSxcclxuICAgICAgcmVzaXplT2Zmc2V0OiBudWxsLFxyXG4gICAgICB0YWJsZVdpZHRoOiAwLFxyXG4gICAgICB1c2luZ0tleWJvYXJkOiBmYWxzZSxcclxuICAgICAgbGFzdENvbHVtbnM6IG51bGwsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wczogUHJvcHM8VD4sIG5leHRTdGF0ZTogU3RhdGU8VD4pOiBib29sZWFuIHtcclxuICAgIC8vIElmIHRoZSBzdGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHJlLXJlbmRlci5cclxuICAgIGlmICghc2hhbGxvd0VxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSwgY29tcGFyZVN0YXRlKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXNoYWxsb3dFcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMsIGNvbXBhcmVDaGVhcFByb3BzKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWFycmF5RXF1YWwobmV4dFByb3BzLmNvbHVtbnMsIHRoaXMucHJvcHMuY29sdW1ucywgc2hhbGxvd0VxdWFsKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWFycmF5RXF1YWwobmV4dFByb3BzLnJvd3MsIHRoaXMucHJvcHMucm93cykpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkTW91bnQoKTogdm9pZCB7XHJcbiAgICBjb25zdCBlbCA9IG51bGx0aHJvd3ModGhpcy5fcm9vdE5vZGUpO1xyXG5cclxuICAgIHRoaXMuX2Rpc3Bvc2FibGVzID0gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgY29sdW1uIHdpZHRocyB3aGVuIHRoZSB0YWJsZSBpcyByZXNpemVkLlxyXG4gICAgICBuZXcgUmVzaXplT2JzZXJ2YWJsZShlbClcclxuICAgICAgICAuc3RhcnRXaXRoKChudWxsOiBhbnkpKVxyXG4gICAgICAgIC5tYXAoKCkgPT4gZWwub2Zmc2V0V2lkdGgpXHJcbiAgICAgICAgLmZpbHRlcih0YWJsZVdpZHRoID0+IHRhYmxlV2lkdGggPiAwKVxyXG4gICAgICAgIC5zdWJzY3JpYmUodGFibGVXaWR0aCA9PiB7XHJcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKHt0YWJsZVdpZHRofSk7XHJcbiAgICAgICAgfSksXHJcbiAgICAgIHRoaXMuX3Jlc2l6ZVN0YXJ0c1xyXG4gICAgICAgIC5zd2l0Y2hNYXAoKHtldmVudDogc3RhcnRFdmVudCwgcmVzaXplckxvY2F0aW9ufSkgPT4ge1xyXG4gICAgICAgICAgY29uc3Qgc3RhcnRYID0gc3RhcnRFdmVudC5wYWdlWDtcclxuICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ21vdXNlbW92ZScpXHJcbiAgICAgICAgICAgIC50YWtlVW50aWwoT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJykpXHJcbiAgICAgICAgICAgIC5tYXAoZXZlbnQgPT4gKHtcclxuICAgICAgICAgICAgICBkZWx0YVB4OiBldmVudC5wYWdlWCAtIHN0YXJ0WCxcclxuICAgICAgICAgICAgICByZXNpemVyTG9jYXRpb24sXHJcbiAgICAgICAgICAgIH0pKVxyXG4gICAgICAgICAgICAuY29uY2F0KE9ic2VydmFibGUub2YobnVsbCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN1YnNjcmliZShyZXNpemVPZmZzZXQgPT4ge1xyXG4gICAgICAgICAgaWYgKHJlc2l6ZU9mZnNldCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSByZXNpemUgYnkgdXBkYXRpbmcgdGhlIHVzZXIncyBwcmVmZXJyZWQgY29sdW1uIHdpZHRocyB0byBhY2NvdW50IGZvclxyXG4gICAgICAgICAgICAvLyB0aGVpciBhY3Rpb24uIE5vdGUgdGhhdCB0aGVzZSBwcmVmZXJlbmNlcyBhcmUgb25seSB1cGRhdGVkIHdoZW4gY29sdW1ucyBhcmUgcmVzaXplZFxyXG4gICAgICAgICAgICAvLyAoTk9UIHdoZW4gdGhlIHRhYmxlIGlzKS4gVGhpcyBpcyBpbXBvcnRhbnQgc28gdGhhdCwgaWYgdGhlIHVzZXIgcmVzaXplcyB0aGUgdGFibGVcclxuICAgICAgICAgICAgLy8gc3VjaCB0aGF0IGEgY29sdW1uIGlzIGF0IGl0cyBtaW5pbXVtIHdpZHRoIGFuZCB0aGVuIHJlc2l6ZXMgdGhlIHRhYmxlIGJhY2sgdG8gaXRzXHJcbiAgICAgICAgICAgIC8vIG9yaWduYWwgc2l6ZSwgdGhlaXIgb3JpZ2luYWwgY29sdW1uIHdpZHRocyBhcmUgcmVzdG9yZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHByZWZlcnJlZENvbHVtbldpZHRocyA9IF9jYWxjdWxhdGVQcmVmZXJyZWRDb2x1bW5XaWR0aHMoe1xyXG4gICAgICAgICAgICAgIGN1cnJlbnRXaWR0aHM6IHRoaXMuX2NhbGN1bGF0ZUNvbHVtbldpZHRocygpLFxyXG4gICAgICAgICAgICAgIC8vIFRPRE86ICh3YmlubnNzbWl0aCkgVDMwNzcxNDM1IHRoaXMgc2V0U3RhdGUgZGVwZW5kcyBvbiBjdXJyZW50IHN0YXRlXHJcbiAgICAgICAgICAgICAgLy8gYW5kIHNob3VsZCB1c2UgYW4gdXBkYXRlciBmdW5jdGlvbiByYXRoZXIgdGhhbiBhbiBvYmplY3RcclxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tYWNjZXNzLXN0YXRlLWluLXNldHN0YXRlXHJcbiAgICAgICAgICAgICAgdGFibGVXaWR0aDogdGhpcy5zdGF0ZS50YWJsZVdpZHRoLFxyXG4gICAgICAgICAgICAgIG1pbldpZHRoczogZ2V0TWluV2lkdGhzKHRoaXMucHJvcHMuY29sdW1ucyksXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmVmZXJyZWQgZGlzdHJpYnV0aW9ucyBhbmQgZW5kIHRoZSByZXNpemUuXHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe3ByZWZlcnJlZENvbHVtbldpZHRocywgcmVzaXplT2Zmc2V0OiBudWxsfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtyZXNpemVPZmZzZXR9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgYXRvbS5jb21tYW5kcy5hZGQoZWwsIHtcclxuICAgICAgICAnY29yZTptb3ZlLXVwJzogZXZlbnQgPT4ge1xyXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXNpbmdLZXlib2FyZDogdHJ1ZX0pO1xyXG4gICAgICAgICAgdGhpcy5fbW92ZVNlbGVjdGlvbigtMSwgZXZlbnQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NvcmU6bW92ZS1kb3duJzogZXZlbnQgPT4ge1xyXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXNpbmdLZXlib2FyZDogdHJ1ZX0pO1xyXG4gICAgICAgICAgdGhpcy5fbW92ZVNlbGVjdGlvbigxLCBldmVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY29yZTpjb25maXJtJzogZXZlbnQgPT4ge1xyXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7dXNpbmdLZXlib2FyZDogdHJ1ZX0pO1xyXG4gICAgICAgICAgY29uc3Qge3Jvd3MsIHNlbGVjdGVkSW5kZXgsIG9uQ29uZmlybX0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgICAgaWYgKG9uQ29uZmlybSA9PSBudWxsIHx8IHNlbGVjdGVkSW5kZXggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFJvdyA9IHJvd3Nbc2VsZWN0ZWRJbmRleF07XHJcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZEl0ZW0gPSBzZWxlY3RlZFJvdyAmJiBzZWxlY3RlZFJvdy5kYXRhO1xyXG4gICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9uQ29uZmlybShzZWxlY3RlZEl0ZW0sIHNlbGVjdGVkSW5kZXgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlTW92ZURpc3Bvc2FibGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5fbW91c2VNb3ZlRGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvcHM8VD4sIHByZXZTdGF0ZTogU3RhdGU8VD4pOiB2b2lkIHtcclxuICAgIGlmIChcclxuICAgICAgdGhpcy5fdGFibGVCb2R5ICE9IG51bGwgJiZcclxuICAgICAgdGhpcy5wcm9wcy5zZWxlY3RlZEluZGV4ICE9IG51bGwgJiZcclxuICAgICAgdGhpcy5wcm9wcy5zZWxlY3RlZEluZGV4ICE9PSBwcmV2UHJvcHMuc2VsZWN0ZWRJbmRleFxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IHNlbGVjdGVkUm93ID0gdGhpcy5fdGFibGVCb2R5LmNoaWxkcmVuW3RoaXMucHJvcHMuc2VsZWN0ZWRJbmRleF07XHJcbiAgICAgIGlmIChzZWxlY3RlZFJvdyAhPSBudWxsKSB7XHJcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChzZWxlY3RlZFJvdyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0aGlzLnN0YXRlLnVzaW5nS2V5Ym9hcmQgIT09IHByZXZTdGF0ZS51c2luZ0tleWJvYXJkKSB7XHJcbiAgICAgIGlmICh0aGlzLl9tb3VzZU1vdmVEaXNwb3NhYmxlICE9IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9tb3VzZU1vdmVEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5zdGF0ZS51c2luZ0tleWJvYXJkKSB7XHJcbiAgICAgICAgdGhpcy5fbW91c2VNb3ZlRGlzcG9zYWJsZSA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKFxyXG4gICAgICAgICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZW1vdmUnKVxyXG4gICAgICAgICAgICAudGFrZSgxKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHt1c2luZ0tleWJvYXJkOiBmYWxzZX0pO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb2N1cygpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl90YWJsZUJvZHkgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgd2hpbGUgKGVsICE9IG51bGwpIHtcclxuICAgICAgaWYgKGVsID09PSB0aGlzLl90YWJsZUJvZHkpIHtcclxuICAgICAgICAvLyBBbHJlYWR5IGZvY3VzZWQhXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGVsID0gZWwucGFyZW50Tm9kZTtcclxuICAgIH1cclxuICAgIHRoaXMuX3RhYmxlQm9keS5mb2N1cygpO1xyXG4gIH1cclxuXHJcbiAgX21vdmVTZWxlY3Rpb24ob2Zmc2V0OiAtMSB8IDEsIGV2ZW50OiBTZWxlY3Rpb25FdmVudCk6IHZvaWQge1xyXG4gICAgY29uc3Qge3NlbGVjdGVkSW5kZXh9ID0gdGhpcy5wcm9wcztcclxuICAgIGlmIChzZWxlY3RlZEluZGV4ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV4dFNlbGVjdGVkSW5kZXggPSBNYXRoLm1heChcclxuICAgICAgMCxcclxuICAgICAgTWF0aC5taW4odGhpcy5wcm9wcy5yb3dzLmxlbmd0aCAtIDEsIHNlbGVjdGVkSW5kZXggKyBvZmZzZXQpLFxyXG4gICAgKTtcclxuICAgIGlmIChuZXh0U2VsZWN0ZWRJbmRleCA9PT0gc2VsZWN0ZWRJbmRleCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zZWxlY3RSb3coe2luZGV4OiBuZXh0U2VsZWN0ZWRJbmRleCwgZXZlbnR9KTtcclxuICB9XHJcblxyXG4gIF9zZWxlY3RSb3cgPSAob3B0aW9uczoge3xcclxuICAgIGluZGV4OiBudW1iZXIsXHJcbiAgICBldmVudDogU2VsZWN0aW9uRXZlbnQsXHJcbiAgICBjb25maXJtPzogYm9vbGVhbixcclxuICB8fSk6IHZvaWQgPT4ge1xyXG4gICAgY29uc3Qge2luZGV4OiBzZWxlY3RlZEluZGV4LCBldmVudCwgY29uZmlybX0gPSBvcHRpb25zO1xyXG4gICAgY29uc3Qge29uU2VsZWN0LCBvbldpbGxTZWxlY3QsIHJvd3N9ID0gdGhpcy5wcm9wcztcclxuICAgIGlmIChvblNlbGVjdCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlbGVjdGVkUm93ID0gcm93c1tzZWxlY3RlZEluZGV4XTtcclxuICAgIGNvbnN0IHNlbGVjdGVkSXRlbSA9IHNlbGVjdGVkUm93LmRhdGE7XHJcbiAgICBpZiAob25XaWxsU2VsZWN0ICE9IG51bGwpIHtcclxuICAgICAgaWYgKG9uV2lsbFNlbGVjdChzZWxlY3RlZEl0ZW0sIHNlbGVjdGVkSW5kZXgsIGV2ZW50KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2VsZWN0KHNlbGVjdGVkSXRlbSwgc2VsZWN0ZWRJbmRleCwgZXZlbnQpO1xyXG4gICAgaWYgKGNvbmZpcm0gJiYgdGhpcy5wcm9wcy5vbkNvbmZpcm0gIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLnByb3BzLm9uQ29uZmlybShzZWxlY3RlZEl0ZW0sIHNlbGVjdGVkSW5kZXgpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIF9oYW5kbGVTb3J0QnlDb2x1bW4gPSAoc29ydGVkQnk6ICRLZXlzPFQ+KTogdm9pZCA9PiB7XHJcbiAgICBjb25zdCB7b25Tb3J0LCBzb3J0RGVzY2VuZGluZywgc29ydGVkQ29sdW1ufSA9IHRoaXMucHJvcHM7XHJcbiAgICBpZiAob25Tb3J0ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgb25Tb3J0KFxyXG4gICAgICBzb3J0ZWRCeSxcclxuICAgICAgc29ydERlc2NlbmRpbmcgPT0gbnVsbCB8fCBzb3J0ZWRCeSAhPT0gc29ydGVkQ29sdW1uXHJcbiAgICAgICAgPyBmYWxzZVxyXG4gICAgICAgIDogIXNvcnREZXNjZW5kaW5nLFxyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICAvLyBKdXN0IGEgYm91bmQgdmVyc2lvbiBvZiB0aGUgYF9jYWxjdWxhdGVDb2x1bW5XaWR0aHNgIGZ1bmN0aW9uIGZvciBjb252ZW5pZW5jZS5cclxuICBfY2FsY3VsYXRlQ29sdW1uV2lkdGhzKCk6IFBlcmNlbnRhZ2VXaWR0aE1hcDxUPiB7XHJcbiAgICByZXR1cm4gX2NhbGN1bGF0ZUNvbHVtbldpZHRocyh7XHJcbiAgICAgIHByZWZlcnJlZFdpZHRoczogdGhpcy5zdGF0ZS5wcmVmZXJyZWRDb2x1bW5XaWR0aHMsXHJcbiAgICAgIG1pbldpZHRoczogZ2V0TWluV2lkdGhzKHRoaXMucHJvcHMuY29sdW1ucyksXHJcbiAgICAgIHRhYmxlV2lkdGg6IHRoaXMuc3RhdGUudGFibGVXaWR0aCxcclxuICAgICAgY29sdW1uT3JkZXI6IHRoaXMucHJvcHMuY29sdW1ucy5tYXAoY29sdW1uID0+IGNvbHVtbi5rZXkpLFxyXG4gICAgICByZXNpemVPZmZzZXQ6IHRoaXMuc3RhdGUucmVzaXplT2Zmc2V0LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZW5kZXIoKTogUmVhY3QuTm9kZSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNsYXNzTmFtZX1cclxuICAgICAgICByZWY9e3Jvb3ROb2RlID0+ICh0aGlzLl9yb290Tm9kZSA9IHJvb3ROb2RlKX0+XHJcbiAgICAgICAge3RoaXMuX3JlbmRlckNvbnRlbnRzKCl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIF9yZW5kZXJDb250ZW50cygpOiBSZWFjdC5Ob2RlIHtcclxuICAgIGlmICh0aGlzLnN0YXRlLnRhYmxlV2lkdGggPT09IDApIHtcclxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0aGUgdGFibGUgd2lkdGggeWV0IHNvIHdlIGNhbid0IHJlbmRlciB0aGUgY29sdW1ucy5cclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICBhbHRlcm5hdGVCYWNrZ3JvdW5kLFxyXG4gICAgICBjb2xsYXBzYWJsZSxcclxuICAgICAgY29sdW1ucyxcclxuICAgICAgZW5hYmxlS2V5Ym9hcmROYXZpZ2F0aW9uLFxyXG4gICAgICBlbXB0eUNvbXBvbmVudCxcclxuICAgICAgaGVhZGVyRWxlbWVudCxcclxuICAgICAgaGVhZGVyVGl0bGUsXHJcbiAgICAgIG1heEJvZHlIZWlnaHQsXHJcbiAgICAgIG9uQm9keUJsdXIsXHJcbiAgICAgIG9uQm9keUZvY3VzLFxyXG4gICAgICByb3dzLFxyXG4gICAgICBzZWxlY3RhYmxlLFxyXG4gICAgICBzZWxlY3RlZEluZGV4LFxyXG4gICAgICBzb3J0YWJsZSxcclxuICAgICAgc29ydGVkQ29sdW1uLFxyXG4gICAgICBzb3J0RGVzY2VuZGluZyxcclxuICAgIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIGNvbnN0IGNvbHVtbldpZHRocyA9IHRoaXMuX2NhbGN1bGF0ZUNvbHVtbldpZHRocygpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgPD5cclxuICAgICAgICA8VGFibGVIZWFkZXJcclxuICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XHJcbiAgICAgICAgICBjb2x1bW5XaWR0aHM9e2NvbHVtbldpZHRoc31cclxuICAgICAgICAgIGhlYWRlckVsZW1lbnQ9e2hlYWRlckVsZW1lbnR9XHJcbiAgICAgICAgICBoZWFkZXJUaXRsZT17aGVhZGVyVGl0bGV9XHJcbiAgICAgICAgICBvblNvcnRCeUNvbHVtbj17dGhpcy5faGFuZGxlU29ydEJ5Q29sdW1ufVxyXG4gICAgICAgICAgcmVzaXplU3RhcnRzPXt0aGlzLl9yZXNpemVTdGFydHN9XHJcbiAgICAgICAgICBzb3J0YWJsZT17c29ydGFibGV9XHJcbiAgICAgICAgICBzb3J0ZWRDb2x1bW49e3NvcnRlZENvbHVtbn1cclxuICAgICAgICAgIHNvcnREZXNjZW5kaW5nPXtzb3J0RGVzY2VuZGluZ31cclxuICAgICAgICAvPlxyXG4gICAgICAgIDxUYWJsZUJvZHlcclxuICAgICAgICAgIGVtcHR5Q29tcG9uZW50PXtlbXB0eUNvbXBvbmVudH1cclxuICAgICAgICAgIGVuYWJsZUtleWJvYXJkTmF2aWdhdGlvbj17ZW5hYmxlS2V5Ym9hcmROYXZpZ2F0aW9ufVxyXG4gICAgICAgICAgcm93cz17cm93c31cclxuICAgICAgICAgIGNvbHVtbnM9e2NvbHVtbnN9XHJcbiAgICAgICAgICBjb2x1bW5XaWR0aHM9e2NvbHVtbldpZHRoc31cclxuICAgICAgICAgIHNlbGVjdGFibGU9e3NlbGVjdGFibGV9XHJcbiAgICAgICAgICB1c2luZ0tleWJvYXJkPXt0aGlzLnN0YXRlLnVzaW5nS2V5Ym9hcmR9XHJcbiAgICAgICAgICBzZWxlY3RSb3c9e3RoaXMuX3NlbGVjdFJvd31cclxuICAgICAgICAgIG9uQm9keUJsdXI9e29uQm9keUJsdXJ9XHJcbiAgICAgICAgICBvbkJvZHlGb2N1cz17b25Cb2R5Rm9jdXN9XHJcbiAgICAgICAgICBhbHRlcm5hdGVCYWNrZ3JvdW5kPXthbHRlcm5hdGVCYWNrZ3JvdW5kfVxyXG4gICAgICAgICAgY29sbGFwc2FibGU9e2NvbGxhcHNhYmxlfVxyXG4gICAgICAgICAgc2VsZWN0ZWRJbmRleD17c2VsZWN0ZWRJbmRleH1cclxuICAgICAgICAgIG1heEJvZHlIZWlnaHQ9e21heEJvZHlIZWlnaHR9XHJcbiAgICAgICAgICB0YWJsZVJlZj17ZWwgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl90YWJsZUJvZHkgPSBlbDtcclxuICAgICAgICAgIH19XHJcbiAgICAgICAgLz5cclxuICAgICAgPC8+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gRW1wdHlDZWxsQ29udGVudCgpOiBSZWFjdC5Ob2RlIHtcclxuICByZXR1cm4gPGRpdiAvPjtcclxufVxyXG5cclxudHlwZSBUYWJsZUhlYWRlclByb3BzPFQ+ID0ge3xcclxuICBjb2x1bW5zOiBBcnJheTxDb2x1bW48VD4+LFxyXG4gIGNvbHVtbldpZHRoczogUGVyY2VudGFnZVdpZHRoTWFwPFQ+LFxyXG4gIGhlYWRlckVsZW1lbnQ6ID9SZWFjdC5Ob2RlLFxyXG4gIGhlYWRlclRpdGxlOiA/c3RyaW5nLFxyXG4gIG9uU29ydEJ5Q29sdW1uOiAoc29ydGVkQnk6ICRLZXlzPFQ+KSA9PiB2b2lkLFxyXG4gIHJlc2l6ZVN0YXJ0czogU3ViamVjdDx7XHJcbiAgICBldmVudDogU3ludGhldGljTW91c2VFdmVudDwqPixcclxuICAgIHJlc2l6ZXJMb2NhdGlvbjogbnVtYmVyLFxyXG4gIH0+LFxyXG4gIHNvcnRhYmxlOiA/Ym9vbGVhbixcclxuICBzb3J0RGVzY2VuZGluZzogP2Jvb2xlYW4sXHJcbiAgc29ydGVkQ29sdW1uOiA/JEtleXM8VD4sXHJcbnx9O1xyXG5jbGFzcyBUYWJsZUhlYWRlcjxUOiBPYmplY3Q+IGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxUYWJsZUhlYWRlclByb3BzPFQ+PiB7XHJcbiAgcmVuZGVyKCk6IFJlYWN0Lk5vZGUge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBjb2x1bW5zLFxyXG4gICAgICBjb2x1bW5XaWR0aHMsXHJcbiAgICAgIGhlYWRlckVsZW1lbnQsXHJcbiAgICAgIGhlYWRlclRpdGxlLFxyXG4gICAgICBvblNvcnRCeUNvbHVtbixcclxuICAgICAgcmVzaXplU3RhcnRzLFxyXG4gICAgICBzb3J0YWJsZSxcclxuICAgICAgc29ydERlc2NlbmRpbmcsXHJcbiAgICAgIHNvcnRlZENvbHVtbixcclxuICAgIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgIGxldCBpbm5lcjtcclxuICAgIGlmIChoZWFkZXJFbGVtZW50ICE9IG51bGwgfHwgaGVhZGVyVGl0bGUgIT0gbnVsbCkge1xyXG4gICAgICBpbm5lciA9IChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51Y2xpZGUtdWktdGFibGUtaGVhZGVyLWNlbGwgbnVjbGlkZS11aS10YWJsZS1mdWxsLWhlYWRlclwiPlxyXG4gICAgICAgICAge2hlYWRlckVsZW1lbnQgIT0gbnVsbCA/IGhlYWRlckVsZW1lbnQgOiBoZWFkZXJUaXRsZX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlubmVyID0gY29sdW1ucy5tYXAoKGNvbHVtbiwgaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHt0aXRsZSwga2V5LCBzaG91bGRSaWdodEFsaWduLCBjZWxsQ2xhc3NOYW1lfSA9IGNvbHVtbjtcclxuICAgICAgICBsZXQgcmVzaXplcjtcclxuICAgICAgICBpZiAoaSA8IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgcmVzaXplciA9IChcclxuICAgICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm51Y2xpZGUtdWktdGFibGUtaGVhZGVyLXJlc2l6ZS1oYW5kbGVcIlxyXG4gICAgICAgICAgICAgIG9uTW91c2VEb3duPXtldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVTdGFydHMubmV4dCh7ZXZlbnQsIHJlc2l6ZXJMb2NhdGlvbjogaX0pO1xyXG4gICAgICAgICAgICAgIH19XHJcbiAgICAgICAgICAgICAgb25DbGljaz17KGU6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBzb3J0YWJsZSBjb2x1bW4gaGVhZGVyIGNsaWNrIGV2ZW50IGZyb20gZmlyaW5nLlxyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICB9fVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjb2x1bW5XaWR0aHNba2V5XTtcclxuICAgICAgICBjb25zdCBvcHRpb25hbEhlYWRlckNlbGxQcm9wcyA9IHt9O1xyXG4gICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBvcHRpb25hbEhlYWRlckNlbGxQcm9wcy5zdHlsZSA9IHt3aWR0aDogYCR7d2lkdGggKiAxMDB9JWB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc29ydEluZGljYXRvcjtcclxuICAgICAgICBsZXQgdGl0bGVPdmVybGF5ID0gdGl0bGU7XHJcbiAgICAgICAgaWYgKHNvcnRhYmxlKSB7XHJcbiAgICAgICAgICBvcHRpb25hbEhlYWRlckNlbGxQcm9wcy5vbkNsaWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBvblNvcnRCeUNvbHVtbihrZXkpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHRpdGxlT3ZlcmxheSArPSAnIOKAkyBjbGljayB0byBzb3J0JztcclxuICAgICAgICAgIGlmIChzb3J0ZWRDb2x1bW4gPT09IGtleSkge1xyXG4gICAgICAgICAgICBzb3J0SW5kaWNhdG9yID0gKFxyXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm51Y2xpZGUtdWktdGFibGUtc29ydC1pbmRpY2F0b3JcIj5cclxuICAgICAgICAgICAgICAgIDxJY29uIGljb249e3NvcnREZXNjZW5kaW5nID8gJ3RyaWFuZ2xlLWRvd24nIDogJ3RyaWFuZ2xlLXVwJ30gLz5cclxuICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgPGRpdlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoY2VsbENsYXNzTmFtZSwge1xyXG4gICAgICAgICAgICAgICdudWNsaWRlLXVpLXRhYmxlLWNlbGwtdGV4dC1hbGlnbi1yaWdodCc6IHNob3VsZFJpZ2h0QWxpZ24sXHJcbiAgICAgICAgICAgICAgJ251Y2xpZGUtdWktdGFibGUtaGVhZGVyLWNlbGwnOiB0cnVlLFxyXG4gICAgICAgICAgICAgICdudWNsaWRlLXVpLXRhYmxlLWhlYWRlci1jZWxsLXNvcnRhYmxlJzogc29ydGFibGUsXHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICB0aXRsZT17dGl0bGVPdmVybGF5fVxyXG4gICAgICAgICAgICBrZXk9e2tleX1cclxuICAgICAgICAgICAgey4uLm9wdGlvbmFsSGVhZGVyQ2VsbFByb3BzfT5cclxuICAgICAgICAgICAge3RpdGxlfVxyXG4gICAgICAgICAgICB7c29ydEluZGljYXRvcn1cclxuICAgICAgICAgICAge3Jlc2l6ZXJ9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2IGtleT1cImhlYWRlclwiIGNsYXNzTmFtZT1cIm51Y2xpZGUtdWktdGFibGVcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm51Y2xpZGUtdWktdGFibGUtaGVhZGVyXCI+e2lubmVyfTwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG50eXBlIFRhYmxlQm9keVByb3BzPFQ+ID0ge3xcclxuICBhbHRlcm5hdGVCYWNrZ3JvdW5kOiA/bnVtYmVyLFxyXG4gIGNvbGxhcHNhYmxlOiA/Ym9vbGVhbixcclxuICBjb2x1bW5zOiBBcnJheTxDb2x1bW48VD4+LFxyXG4gIGNvbHVtbldpZHRoczogUGVyY2VudGFnZVdpZHRoTWFwPFQ+LFxyXG4gIGVtcHR5Q29tcG9uZW50OiA/UmVhY3QuQ29tcG9uZW50VHlwZTxhbnk+LFxyXG4gIGVuYWJsZUtleWJvYXJkTmF2aWdhdGlvbjogP2Jvb2xlYW4sXHJcbiAgbWF4Qm9keUhlaWdodDogP3N0cmluZyxcclxuICBvbkJvZHlCbHVyOiA/KGV2ZW50OiBTeW50aGV0aWNFdmVudDwqPikgPT4gbWl4ZWQsXHJcbiAgb25Cb2R5Rm9jdXM6ID8oZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PCo+KSA9PiBtaXhlZCxcclxuICByb3dzOiBBcnJheTxSb3c8VD4+LFxyXG4gIHNlbGVjdGFibGU6ID8oYm9vbGVhbiB8ICgocm93OiBUKSA9PiBib29sZWFuKSksXHJcbiAgc2VsZWN0ZWRJbmRleDogP251bWJlcixcclxuICBzZWxlY3RSb3c6IChvcHRpb25zOiB7fFxyXG4gICAgaW5kZXg6IG51bWJlcixcclxuICAgIGV2ZW50OiBTZWxlY3Rpb25FdmVudCxcclxuICAgIGNvbmZpcm0/OiBib29sZWFuLFxyXG4gIHx9KSA9PiB2b2lkLFxyXG4gIHRhYmxlUmVmOiBSZWFjdC5SZWY8J2Rpdic+LFxyXG4gIHVzaW5nS2V5Ym9hcmQ6IGJvb2xlYW4sXHJcbnx9O1xyXG5jbGFzcyBUYWJsZUJvZHk8VDogT2JqZWN0PiBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8VGFibGVCb2R5UHJvcHM8VD4+IHtcclxuICByZW5kZXIoKTogUmVhY3QuTm9kZSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIGFsdGVybmF0ZUJhY2tncm91bmQsXHJcbiAgICAgIGNvbGxhcHNhYmxlLFxyXG4gICAgICBjb2x1bW5zLFxyXG4gICAgICBjb2x1bW5XaWR0aHMsXHJcbiAgICAgIGVtcHR5Q29tcG9uZW50LFxyXG4gICAgICBlbmFibGVLZXlib2FyZE5hdmlnYXRpb24sXHJcbiAgICAgIG1heEJvZHlIZWlnaHQsXHJcbiAgICAgIHJvd3MsXHJcbiAgICAgIHNlbGVjdGFibGUsXHJcbiAgICAgIHNlbGVjdGVkSW5kZXgsXHJcbiAgICAgIHNlbGVjdFJvdyxcclxuICAgICAgdGFibGVSZWYsXHJcbiAgICAgIHVzaW5nS2V5Ym9hcmQsXHJcbiAgICB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICBsZXQgYm9keTtcclxuICAgIGlmIChyb3dzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zdCBFbXB0eUNvbXBvbmVudCA9IGVtcHR5Q29tcG9uZW50ID8/IERlZmF1bHRFbXB0eUNvbXBvbmVudDtcclxuICAgICAgYm9keSA9IDxFbXB0eUNvbXBvbmVudCAvPjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJvZHkgPSByb3dzLm1hcCgocm93LCBpKSA9PiB7XHJcbiAgICAgICAgY29uc3Qge2NsYXNzTmFtZTogcm93Q2xhc3NOYW1lLCBkYXRhLCByb3dBdHRyaWJ1dGVzfSA9IHJvdztcclxuICAgICAgICBjb25zdCByZW5kZXJlZFJvdyA9IGNvbHVtbnMubWFwKChjb2x1bW4sIGopID0+IHtcclxuICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICBjZWxsQ2xhc3NOYW1lLFxyXG4gICAgICAgICAgICBjb21wb25lbnQ6IENvbXBvbmVudCxcclxuICAgICAgICAgICAgc2hvdWxkUmlnaHRBbGlnbixcclxuICAgICAgICAgIH0gPSBjb2x1bW47XHJcbiAgICAgICAgICBsZXQgZGF0dW0gPSBkYXRhW2tleV07XHJcbiAgICAgICAgICBpZiAoQ29tcG9uZW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZGF0dW0gPSA8Q29tcG9uZW50IGRhdGE9e2RhdHVtfSAvPjtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0dW0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkYXR1bSA9IDxFbXB0eUNlbGxDb250ZW50IC8+O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY29uc3QgY2VsbFN0eWxlID0ge307XHJcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGNvbHVtbldpZHRoc1trZXldO1xyXG4gICAgICAgICAgaWYgKHdpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2VsbFN0eWxlLndpZHRoID0gYCR7d2lkdGggKiAxMDB9JWA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKGNlbGxDbGFzc05hbWUsIHtcclxuICAgICAgICAgICAgICAgICdudWNsaWRlLXVpLXRhYmxlLWJvZHktY2VsbCc6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAnbnVjbGlkZS11aS10YWJsZS1jZWxsLXRleHQtYWxpZ24tcmlnaHQnOiBzaG91bGRSaWdodEFsaWduLFxyXG4gICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgIGtleT17an1cclxuICAgICAgICAgICAgICBzdHlsZT17Y2VsbFN0eWxlfVxyXG4gICAgICAgICAgICAgIHRpdGxlPXt0eXBlb2YgZGF0dW0gIT09ICdvYmplY3QnID8gU3RyaW5nKGRhdHVtKSA6IG51bGx9XHJcbiAgICAgICAgICAgICAgey4uLnJvd0F0dHJpYnV0ZXN9PlxyXG4gICAgICAgICAgICAgIHtkYXR1bX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBzZWxlY3RhYmxlUm93ID1cclxuICAgICAgICAgIHR5cGVvZiBzZWxlY3RhYmxlID09PSAnZnVuY3Rpb24nID8gc2VsZWN0YWJsZShyb3cuZGF0YSkgOiBzZWxlY3RhYmxlO1xyXG4gICAgICAgIGNvbnN0IHJvd1Byb3BzID0gc2VsZWN0YWJsZVJvd1xyXG4gICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgb25DbGljazogZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5kZXRhaWwpIHtcclxuICAgICAgICAgICAgICAgICAgLy8gVGhpcyAoYGV2ZW50LmRldGFpbCA9PT0gMGApIHNob3VsZG4ndCBoYXBwZW4gbm9ybWFsbHkgYnV0IGRvZXMgd2hlbiB0aGUgY2xpY2sgaXNcclxuICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlcmVkIGJ5IHRoZSBpbnRlZ3JhdGlvbiB0ZXN0LlxyXG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RSb3coe2luZGV4OiBpLCBldmVudH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYGV2ZW50LmRldGFpbGAgKGluc3RlYWQgb2YgdXNpbmcgYG9uRG91YmxlQ2xpY2tgKSBiZWNhdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKGZvciBzb21lIHJlYXNvbikgYG9uRG91YmxlQ2xpY2tgIGlzIG9ubHkgZmlyaW5nIHNwb3JhZGljYWxseS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeS4gUmVwcm9zIGluIHRoZSBkaWFnbm9zdGljIHRhYmxlIHdpdGggUmVhY3QgMTYuMC4wIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0b20gMS4yMi4wLWJldGExIChDaHJvbWUgNTYuMC4yOTI0Ljg3KS4gVGhpcyBtYXkgYmUgYmVjYXVzZSB3ZSdyZSBzd2FwcGluZyBvdXRcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50IG9uIHRoZSBjbGljayBzbyBhIGRpZmZlcmVudCBvbmUgaXMgcmVjZWl2aW5nIHRoZSBzZWNvbmQ/XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0Um93KHtpbmRleDogaSwgZXZlbnQsIGNvbmZpcm06IHRydWV9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgOiB7fTtcclxuICAgICAgICBjb25zdCBpc1NlbGVjdGVkUm93ID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsICYmIGkgPT09IHNlbGVjdGVkSW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIDxkaXZcclxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHJvd0NsYXNzTmFtZSwge1xyXG4gICAgICAgICAgICAgICdudWNsaWRlLXVpLXRhYmxlLXJvdyc6IHRydWUsXHJcbiAgICAgICAgICAgICAgJ251Y2xpZGUtdWktdGFibGUtcm93LXNlbGVjdGFibGUnOiBzZWxlY3RhYmxlUm93LFxyXG4gICAgICAgICAgICAgICdudWNsaWRlLXVpLXRhYmxlLXJvdy1kaXNhYmxlZCc6XHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygc2VsZWN0YWJsZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2VsZWN0YWJsZVJvdyxcclxuICAgICAgICAgICAgICAnbnVjbGlkZS11aS10YWJsZS1yb3ctdXNpbmcta2V5Ym9hcmQtbmF2JzogdXNpbmdLZXlib2FyZCxcclxuICAgICAgICAgICAgICAnbnVjbGlkZS11aS10YWJsZS1yb3ctc2VsZWN0ZWQnOiBpc1NlbGVjdGVkUm93LFxyXG4gICAgICAgICAgICAgICdudWNsaWRlLXVpLXRhYmxlLXJvdy1hbHRlcm5hdGUnOlxyXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlQmFja2dyb3VuZCAhPT0gZmFsc2UgJiYgaSAlIDIgPT09IDEsXHJcbiAgICAgICAgICAgICAgJ251Y2xpZGUtdWktdGFibGUtY29sbGFwc2VkLXJvdyc6IGNvbGxhcHNhYmxlICYmICFpc1NlbGVjdGVkUm93LFxyXG4gICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgZGF0YS1yb3ctaW5kZXg9e2l9XHJcbiAgICAgICAgICAgIGtleT17aX1cclxuICAgICAgICAgICAgey4uLnJvd1Byb3BzfT5cclxuICAgICAgICAgICAge3JlbmRlcmVkUm93fVxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYm9keUNsYXNzTmFtZXMgPSBjbGFzc25hbWVzKFxyXG4gICAgICAnbnVjbGlkZS11aS10YWJsZScsXHJcbiAgICAgICdudWNsaWRlLXVpLXRhYmxlLWJvZHknLFxyXG4gICAgICB7XHJcbiAgICAgICAgLy8gQmVmb3JlIHRoaXMgY2xhc3MgaXMgYXBwbGllZCBvbmx5IHdoZW4gYCF0aGlzLnByb3BzLnNlbGVjdGFibGVgXHJcbiAgICAgICAgLy8gYmVjYXVzZSAoZm9yIHNvbWUgcmVhc29uKSBgb25Eb3VibGVDbGlja2AgaXNuJ3QgYmVpbmcgZmlyZWQgd2hlblxyXG4gICAgICAgIC8vIHRoZSBlbGVtZW50J3MgXCJ1c2VyLXNlbGVjdFwiIHN0eWxlIGlzIFwibm9uZVwiLiBOb3cgcmUtZW5hYmxpbmcgaXQgdG9cclxuICAgICAgICAvLyBzdXBwb3J0IGNvcHkgdGV4dCBzZWxlY3Rpb25cclxuICAgICAgICAnbnVjbGlkZS11aS10YWJsZS1ib2R5LXNlbGVjdGFibGUtdGV4dCc6IHRydWUsXHJcbiAgICAgICAgLy8gVXNpbmcgbmF0aXZlLWtleS1iaW5kaW5ncyBwcmV2ZW50cyB0aGUgdXAgYW5kIGRvd24gYXJyb3dzIGZyb20gYmVpbmcgY2FwdHVyZWQuXHJcbiAgICAgICAgJ25hdGl2ZS1rZXktYmluZGluZ3MnOiAhZW5hYmxlS2V5Ym9hcmROYXZpZ2F0aW9uLFxyXG4gICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBzY3JvbGxhYmxlQm9keVN0eWxlID0ge307XHJcbiAgICBpZiAobWF4Qm9keUhlaWdodCAhPSBudWxsKSB7XHJcbiAgICAgIHNjcm9sbGFibGVCb2R5U3R5bGUubWF4SGVpZ2h0ID0gbWF4Qm9keUhlaWdodDtcclxuICAgICAgc2Nyb2xsYWJsZUJvZHlTdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgc3R5bGU9e3Njcm9sbGFibGVCb2R5U3R5bGV9XHJcbiAgICAgICAgb25Gb2N1cz17ZXZlbnQgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Cb2R5Rm9jdXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQm9keUZvY3VzKGV2ZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9fVxyXG4gICAgICAgIG9uQmx1cj17ZXZlbnQgPT4ge1xyXG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Cb2R5Qmx1ciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Cb2R5Qmx1cihldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfX0+XHJcbiAgICAgICAgey8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBudWNsaWRlLWludGVybmFsL2pzeC1zaW1wbGUtY2FsbGJhY2stcmVmcyAqL31cclxuICAgICAgICA8ZGl2IHJlZj17dGFibGVSZWZ9IGNsYXNzTmFtZT17Ym9keUNsYXNzTmFtZXN9IHRhYkluZGV4PVwiLTFcIj5cclxuICAgICAgICAgIHtib2R5fVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBpbml0aWFsIHNpemUgb2YgZWFjaCBjb2x1bW4gYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEluaXRpYWxQcmVmZXJyZWRDb2x1bW5XaWR0aHM8VDogT2JqZWN0PihcclxuICBjb2x1bW5zOiBBcnJheTxDb2x1bW48VD4+LFxyXG4pOiBQZXJjZW50YWdlV2lkdGhNYXA8VD4ge1xyXG4gIGNvbnN0IGNvbHVtbldpZHRoUmF0aW9zID0ge307XHJcbiAgbGV0IGFzc2lnbmVkV2lkdGggPSAwO1xyXG4gIGNvbnN0IHVucmVzb2x2ZWRDb2x1bW5zID0gW107XHJcbiAgY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XHJcbiAgICBjb25zdCB7a2V5LCB3aWR0aH0gPSBjb2x1bW47XHJcbiAgICBpZiAod2lkdGggIT0gbnVsbCkge1xyXG4gICAgICBjb2x1bW5XaWR0aFJhdGlvc1trZXldID0gd2lkdGg7XHJcbiAgICAgIGFzc2lnbmVkV2lkdGggKz0gd2lkdGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB1bnJlc29sdmVkQ29sdW1ucy5wdXNoKGNvbHVtbik7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgY29uc3QgcmVzaWR1YWxDb2x1bW5XaWR0aCA9ICgxIC0gYXNzaWduZWRXaWR0aCkgLyB1bnJlc29sdmVkQ29sdW1ucy5sZW5ndGg7XHJcbiAgdW5yZXNvbHZlZENvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xyXG4gICAgY29sdW1uV2lkdGhSYXRpb3NbY29sdW1uLmtleV0gPSByZXNpZHVhbENvbHVtbldpZHRoO1xyXG4gIH0pO1xyXG4gIHJldHVybiBjb2x1bW5XaWR0aFJhdGlvcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TWluV2lkdGhzPFQ6IE9iamVjdD4oY29sdW1uczogQXJyYXk8Q29sdW1uPFQ+Pik6IFBpeGVsV2lkdGhNYXA8VD4ge1xyXG4gIGNvbnN0IG1pbldpZHRocyA9IHt9O1xyXG4gIGNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xyXG4gICAgbWluV2lkdGhzW2NvbHVtbi5rZXldID1cclxuICAgICAgY29sdW1uLm1pbldpZHRoID09IG51bGwgPyBERUZBVUxUX01JTl9DT0xVTU5fV0lEVEggOiBjb2x1bW4ubWluV2lkdGg7XHJcbiAgfSk7XHJcbiAgcmV0dXJuIG1pbldpZHRocztcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZSB3aWR0aHMsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIHByZWZlcnJlZCBhbmQgbWluaW11bSB3aWR0aHMuIEV4cG9ydGVkIGZvciB0ZXN0aW5nXHJcbiAqIG9ubHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX2NhbGN1bGF0ZUNvbHVtbldpZHRoczxUOiBPYmplY3Q+KG9wdGlvbnM6IHtcclxuICBwcmVmZXJyZWRXaWR0aHM6IFBlcmNlbnRhZ2VXaWR0aE1hcDxUPixcclxuICBtaW5XaWR0aHM6IFBpeGVsV2lkdGhNYXA8VD4sXHJcbiAgdGFibGVXaWR0aDogbnVtYmVyLFxyXG4gIGNvbHVtbk9yZGVyOiBBcnJheTwkS2V5czxUPj4sXHJcbiAgcmVzaXplT2Zmc2V0OiA/UmVzaXplT2Zmc2V0LFxyXG59KTogUGVyY2VudGFnZVdpZHRoTWFwPFQ+IHtcclxuICBjb25zdCB7XHJcbiAgICBwcmVmZXJyZWRXaWR0aHMsXHJcbiAgICBtaW5XaWR0aHM6IG1pbldpZHRoc1B4LFxyXG4gICAgdGFibGVXaWR0aCxcclxuICAgIGNvbHVtbk9yZGVyLFxyXG4gICAgcmVzaXplT2Zmc2V0OiByZXNpemVPZmZzZXRfLFxyXG4gIH0gPSBvcHRpb25zO1xyXG4gIGNvbnN0IHJlc2l6ZU9mZnNldCA9IHJlc2l6ZU9mZnNldF8gfHwge2RlbHRhUHg6IDAsIHJlc2l6ZXJMb2NhdGlvbjogMH07XHJcbiAgY29uc3Qgd2lkdGhzUHggPSB7fTtcclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSBwaXhlbCB3aWR0aHMgb2YgZWFjaCBjb2x1bW4gZ2l2ZW4gaXRzIGRlc2lyZWQgcGVyY2VudGFnZSB3aWR0aCBhbmQgbWluaW11bSBwaXhlbFxyXG4gIC8vIHdpZHRoLlxyXG4gIHtcclxuICAgIC8vIEZpZ3VyZSBvdXQgaG93IG1hbnkgcGl4ZWxzIGVhY2ggY29sdW1uIHdhbnRzLCBnaXZlbiB0aGUgY3VycmVudCBhdmFpbGFibGUgd2lkdGguXHJcbiAgICBsZXQgd2lkdGhUb0FsbG9jYXRlID0gdGFibGVXaWR0aDtcclxuICAgIGxldCBjb2x1bW5zVG9BbGxvY2F0ZSA9IGNvbHVtbk9yZGVyO1xyXG4gICAgd2hpbGUgKGNvbHVtbnNUb0FsbG9jYXRlLmxlbmd0aCA+IDAgJiYgd2lkdGhUb0FsbG9jYXRlID4gMCkge1xyXG4gICAgICBjb25zdCByZW1haW5pbmdQY3QgPSBjb2x1bW5zVG9BbGxvY2F0ZVxyXG4gICAgICAgIC5tYXAoY29sdW1uTmFtZSA9PiBwcmVmZXJyZWRXaWR0aHNbY29sdW1uTmFtZV0pXHJcbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xyXG4gICAgICBjb25zdCBkZXNpcmVkV2lkdGhzUHggPSBvYmplY3RGcm9tUGFpcnMoXHJcbiAgICAgICAgY29sdW1uc1RvQWxsb2NhdGUubWFwKGNvbHVtbk5hbWUgPT4ge1xyXG4gICAgICAgICAgY29uc3QgZGVzaXJlZFBjdCA9IHByZWZlcnJlZFdpZHRoc1tjb2x1bW5OYW1lXSAvIHJlbWFpbmluZ1BjdDtcclxuICAgICAgICAgIGNvbnN0IGRlc2lyZWRQeCA9IE1hdGgucm91bmQoZGVzaXJlZFBjdCAqIHdpZHRoVG9BbGxvY2F0ZSk7XHJcbiAgICAgICAgICByZXR1cm4gW2NvbHVtbk5hbWUsIGRlc2lyZWRQeF07XHJcbiAgICAgICAgfSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvLyBBbGxvY2F0ZSB3aWR0aHMgZm9yIHRoZSBjb2x1bW5zIHdobyB3YW50IGxlc3MgdGhhbiB0aGVpciBtaW5pbXVtIHdpZHRoLlxyXG4gICAgICBsZXQgcmVtYWluaW5nUHggPSB3aWR0aFRvQWxsb2NhdGU7XHJcbiAgICAgIGxldCByZW1haW5pbmdDb2x1bW5zID0gW107XHJcbiAgICAgIGNvbHVtbnNUb0FsbG9jYXRlLmZvckVhY2goY29sdW1uTmFtZSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGVzaXJlZFB4ID0gZGVzaXJlZFdpZHRoc1B4W2NvbHVtbk5hbWVdO1xyXG4gICAgICAgIGNvbnN0IG1pblB4ID0gbWluV2lkdGhzUHhbY29sdW1uTmFtZV07XHJcbiAgICAgICAgaWYgKG1pblB4ID49IGRlc2lyZWRQeCkge1xyXG4gICAgICAgICAgd2lkdGhzUHhbY29sdW1uTmFtZV0gPSBNYXRoLm1pbihtaW5QeCwgcmVtYWluaW5nUHgpO1xyXG4gICAgICAgICAgcmVtYWluaW5nUHggLT0gd2lkdGhzUHhbY29sdW1uTmFtZV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlbWFpbmluZ0NvbHVtbnMucHVzaChjb2x1bW5OYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gSWYgd2UgZGlkbid0IG5lZWQgdG8gdHJ1bmNhdGUgYW55IG9mIHRoZSBjb2x1bW5zLCBnaXZlIHRoZW0gYWxsIHRoZWlyIGRlc2lyZWQgd2lkdGguXHJcbiAgICAgIGlmIChjb2x1bW5zVG9BbGxvY2F0ZS5sZW5ndGggPT09IHJlbWFpbmluZ0NvbHVtbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih3aWR0aHNQeCwgZGVzaXJlZFdpZHRoc1B4KTtcclxuICAgICAgICByZW1haW5pbmdDb2x1bW5zID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIElmIHdlIGhhZCB0byB0cnVuY2F0ZSBhbnkgb2YgdGhlIGNvbHVtbnMsIHRoYXQgY2hhbmdlcyB0aGUgY2FsY3VsYXRpb25zIGZvciBob3cgYmlnIHRoZVxyXG4gICAgICAvLyByZW1haW5pbmcgY29sdW1ucyB3YW50IHRvIGJlLCBzbyBtYWtlIGFub3RoZXIgcGFzcy5cclxuICAgICAgd2lkdGhUb0FsbG9jYXRlID0gcmVtYWluaW5nUHg7XHJcbiAgICAgIGNvbHVtbnNUb0FsbG9jYXRlID0gcmVtYWluaW5nQ29sdW1ucztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHtcclxuICAgIC8vIEFkanVzdCB0aGUgY29sdW1uIHdpZHRocyBhY2NvcmRpbmcgdG8gdGhlIHJlc2l6ZWQgY29sdW1uLlxyXG4gICAgY29uc3Qge2RlbHRhUHgsIHJlc2l6ZXJMb2NhdGlvbn0gPSByZXNpemVPZmZzZXQ7XHJcbiAgICBjb25zdCBsZWZ0Q29sdW1ucyA9IGNvbHVtbk9yZGVyLnNsaWNlKDAsIHJlc2l6ZXJMb2NhdGlvbiArIDEpO1xyXG4gICAgY29uc3QgcmlnaHRDb2x1bW5zID0gY29sdW1uT3JkZXIuc2xpY2UocmVzaXplckxvY2F0aW9uICsgMSk7XHJcblxyXG4gICAgY29uc3QgW3Nocmlua2luZ0NvbHVtbnMsIGdyb3dpbmdDb2x1bW5dID1cclxuICAgICAgZGVsdGFQeCA8IDBcclxuICAgICAgICA/IFtsZWZ0Q29sdW1ucy5yZXZlcnNlKCksIHJpZ2h0Q29sdW1uc1swXV1cclxuICAgICAgICA6IFtyaWdodENvbHVtbnMsIGxlZnRDb2x1bW5zW2xlZnRDb2x1bW5zLmxlbmd0aCAtIDFdXTtcclxuICAgIGNvbnN0IHRhcmdldENoYW5nZSA9IE1hdGguYWJzKGRlbHRhUHgpO1xyXG4gICAgbGV0IGN1bXVsYXRpdmVDaGFuZ2UgPSAwO1xyXG5cclxuICAgIGZvciAoY29uc3QgY29sdW1uTmFtZSBvZiBzaHJpbmtpbmdDb2x1bW5zKSB7XHJcbiAgICAgIGNvbnN0IHN0YXJ0V2lkdGggPSB3aWR0aHNQeFtjb2x1bW5OYW1lXTtcclxuICAgICAgY29uc3QgbWluV2lkdGggPSBtaW5XaWR0aHNQeFtjb2x1bW5OYW1lXTtcclxuICAgICAgY29uc3QgcmVtYWluaW5nV2lkdGggPSB0YXJnZXRDaGFuZ2UgLSBjdW11bGF0aXZlQ2hhbmdlO1xyXG4gICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KG1pbldpZHRoLCBzdGFydFdpZHRoIC0gcmVtYWluaW5nV2lkdGgpO1xyXG4gICAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLmFicyhzdGFydFdpZHRoIC0gbmV3V2lkdGgpO1xyXG4gICAgICBjdW11bGF0aXZlQ2hhbmdlICs9IGNoYW5nZTtcclxuICAgICAgd2lkdGhzUHhbY29sdW1uTmFtZV0gPSBuZXdXaWR0aDtcclxuICAgICAgaWYgKGN1bXVsYXRpdmVDaGFuZ2UgPj0gdGFyZ2V0Q2hhbmdlKSB7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3aWR0aHNQeFtncm93aW5nQ29sdW1uXSArPSBjdW11bGF0aXZlQ2hhbmdlO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBhbGwgdGhlIHdpZHRocyBmcm9tIHBpeGVscyB0byBwZXJjZW50YWdlcy5cclxuICBjb25zdCB3aWR0aHMgPSB7fTtcclxuICB7XHJcbiAgICBsZXQgcmVtYWluaW5nV2lkdGggPSAxO1xyXG4gICAgY29sdW1uT3JkZXIuZm9yRWFjaCgoY29sdW1uTmFtZSwgaSkgPT4ge1xyXG4gICAgICBjb25zdCBpc0xhc3RDb2x1bW4gPSBpID09PSBjb2x1bW5PcmRlci5sZW5ndGggLSAxO1xyXG4gICAgICBpZiAoaXNMYXN0Q29sdW1uKSB7XHJcbiAgICAgICAgLy8gR2l2ZSB0aGUgbGFzdCBjb2x1bW4gYWxsIHRoZSByZW1haW5pbmcgdG8gYWNjb3VudCBmb3Igcm91bmRpbmcgaXNzdWVzLlxyXG4gICAgICAgIHdpZHRoc1tjb2x1bW5OYW1lXSA9IHJlbWFpbmluZ1dpZHRoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpZHRoc1tjb2x1bW5OYW1lXSA9IHdpZHRoc1B4W2NvbHVtbk5hbWVdIC8gdGFibGVXaWR0aDtcclxuICAgICAgICByZW1haW5pbmdXaWR0aCAtPSB3aWR0aHNbY29sdW1uTmFtZV07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHdpZHRocztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBjdXJyZW50IChwZXJjZW50YWdlKSB3aWR0aHMgb2YgZWFjaCBjb2x1bW4sIGRldGVybWluZXMgd2hhdCB1c2VyLXByZWZlcnJlZCBkaXN0cmlidXRpb25cclxuICogdGhpcyByZXByZXNlbnRzLiBFeHBvcnRlZCBmb3IgdGVzdGluZyBvbmx5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9jYWxjdWxhdGVQcmVmZXJyZWRDb2x1bW5XaWR0aHM8VDogT2JqZWN0PihvcHRpb25zOiB7XHJcbiAgY3VycmVudFdpZHRoczogUGVyY2VudGFnZVdpZHRoTWFwPFQ+LFxyXG4gIHRhYmxlV2lkdGg6IG51bWJlcixcclxuICBtaW5XaWR0aHM6IFBpeGVsV2lkdGhNYXA8VD4sXHJcbn0pOiBQZXJjZW50YWdlV2lkdGhNYXA8VD4ge1xyXG4gIGNvbnN0IHtjdXJyZW50V2lkdGhzLCB0YWJsZVdpZHRoLCBtaW5XaWR0aHM6IG1pbldpZHRoc1B4fSA9IG9wdGlvbnM7XHJcbiAgY29uc3QgY3VycmVudFdpZHRoc1B4ID0gb2JqZWN0TWFwVmFsdWVzKGN1cnJlbnRXaWR0aHMsIHcgPT4gdyAqIHRhYmxlV2lkdGgpO1xyXG5cclxuICAvLyBJZiBhbnkgY29sdW1uIGlzIGF0IGl0cyBtaW5pbXVtIHdpZHRoLCB3ZSB0YWtlIHRoYXQgdG8gbWVhbiB0aGF0IHRoZSB1c2VyIHdhbnRzIHRoZSBjb2x1bW5cclxuICAvLyByZW1haW4gYXQgaXRzIG1pbmltdW0gaWYgdGhlIHRhYmxlIGlzIHJlc2l6ZWQgKGFzIG9wcG9zZWQgdG8gbWFpbnRhaW5pbmcgdGhlIHNhbWUgcGVyY2VudGFnZSkuXHJcbiAgLy8gQWNjb3JkaW5nbHksIHdlIG1ha2UgdGhhdCBjb2x1bW4ncyBwcmVmZXJyZWQgd2lkdGggMC5cclxuXHJcbiAgY29uc3QgcHJlZmVycmVkQ29sdW1uV2lkdGhzID0ge307XHJcblxyXG4gIC8vIEZpZ3VyZSBvdXQgd2hpY2ggY29sdW1ucyBhcmUgYXQgdGhlaXIgbWluaW11bSB3aWR0aHMuXHJcbiAgbGV0IHJlbWFpbmluZ1B4ID0gMDsgLy8gVGhlIHdpZHRoIHRoYXQgaXNuJ3QgYWNjb3VudGVkIGZvciBhZnRlciBtaW5XaWR0aC5cclxuICBjb25zdCBjb2x1bW5zTm90QXRNaW5pbXVtID0gW107XHJcbiAgZm9yIChjb25zdCBbY29sdW1uTmFtZSwgd2lkdGhQeF0gb2YgT2JqZWN0LmVudHJpZXMoY3VycmVudFdpZHRoc1B4KSkge1xyXG4gICAgaW52YXJpYW50KHR5cGVvZiB3aWR0aFB4ID09PSAnbnVtYmVyJyk7XHJcbiAgICBjb25zdCBtaW5XaWR0aFB4ID0gbWluV2lkdGhzUHhbY29sdW1uTmFtZV07XHJcbiAgICBpZiAoTWF0aC5mbG9vcih3aWR0aFB4KSA8PSBtaW5XaWR0aFB4KSB7XHJcbiAgICAgIC8vIEtlZXAgaXQgYXQgaXRzIG1pbi13aWR0aC5cclxuICAgICAgcHJlZmVycmVkQ29sdW1uV2lkdGhzW2NvbHVtbk5hbWVdID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlbWFpbmluZ1B4ICs9IHdpZHRoUHg7XHJcbiAgICAgIGNvbHVtbnNOb3RBdE1pbmltdW0ucHVzaChbY29sdW1uTmFtZSwgd2lkdGhQeF0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gTm93IGRpc3RyaWJ1dGUgdGhlIHdpZHRocyBvZiB0aGUgb3RoZXIgY29sdW1ucy5cclxuICBsZXQgcmVtYWluaW5nUGN0ID0gMTtcclxuICBjb2x1bW5zTm90QXRNaW5pbXVtLmZvckVhY2goKFtjb2x1bW5OYW1lLCB3aWR0aF0sIGluZGV4KSA9PiB7XHJcbiAgICBjb25zdCBpc0xhc3RDb2x1bW4gPSBpbmRleCA9PT0gY29sdW1uc05vdEF0TWluaW11bS5sZW5ndGggLSAxO1xyXG4gICAgaWYgKGlzTGFzdENvbHVtbikge1xyXG4gICAgICAvLyBXZSBnaXZlIHRoZSBsYXN0IGNvbHVtbiB0aGUgcmVtYWluaW5nIHdpZHRoIGp1c3QgdG8gYmUgY2VydGFpbiB0aGV5IGFsbCBhZGQgdXAgdG8gMS5cclxuICAgICAgcHJlZmVycmVkQ29sdW1uV2lkdGhzW2NvbHVtbk5hbWVdID0gcmVtYWluaW5nUGN0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJlZmVycmVkQ29sdW1uV2lkdGhzW2NvbHVtbk5hbWVdID0gd2lkdGggLyByZW1haW5pbmdQeDtcclxuICAgICAgcmVtYWluaW5nUGN0IC09IHByZWZlcnJlZENvbHVtbldpZHRoc1tjb2x1bW5OYW1lXTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIHByZWZlcnJlZENvbHVtbldpZHRocztcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGVxdWFsaXR5IGNoZWNrIGZvciBjb21wYXJpbmcgUHJvcHMgdXNpbmcgYHNoYWxsb3dFcXVhbCgpYC4gVGhpcyBvbmx5IHBlcmZvcm1zIHRoZSBjaGVhcFxyXG4gKiBjaGVja3MgYW5kIGFzc3VtZXMgdGhhdCB0aGUgcm93cyBhbmQgY29sdW1ucyBhcmUgZXF1YWwuIChUaGV5IGNhbiBiZSBjaGVja2VkIHNlcGFyYXRlZGx5IGlmZlxyXG4gKiBuZWNlc3NhcnkuKVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGFyZUNoZWFwUHJvcHMoYTogbWl4ZWQsIGI6IG1peGVkLCBrZXk6ID9zdHJpbmcpOiBib29sZWFuIHwgdm9pZCB7XHJcbiAgc3dpdGNoIChrZXkpIHtcclxuICAgIGNhc2UgdW5kZWZpbmVkOlxyXG4gICAgICAvLyBUaGlzIGlzIGEgbWFnaWMgd2F5IG9mIHRlbGxpbmcgYHNoYWxsb3dFcXVhbCgpYCB0byB1c2UgdGhlIGRlZmF1bHQgY29tcGFyaXNvbiBmb3IgdGhlXHJcbiAgICAgIC8vIHByb3BzIG9iamVjdHMgKGluc3BlY3QgaXRzIG1lbWJlcnMpLlxyXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgY2FzZSAncm93cyc6XHJcbiAgICBjYXNlICdjb2x1bW5zJzpcclxuICAgICAgLy8gV2UnbGwgY2hlY2sgdGhlc2UgbGF0ZXIgaWZmIHdlIG5lZWQgdG8gc2luY2UgdGhleSdyZSBtb3JlIGV4cGVuc2l2ZS5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gYSA9PT0gYjtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBhcmVTdGF0ZShhOiBtaXhlZCwgYjogbWl4ZWQsIGtleTogP3N0cmluZyk6IGJvb2xlYW4gfCB2b2lkIHtcclxuICBzd2l0Y2ggKGtleSkge1xyXG4gICAgY2FzZSB1bmRlZmluZWQ6XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBjYXNlICdsYXN0Q29sdW1ucyc6XHJcbiAgICAgIC8vIGBsYXN0Q29sdW1uc2AgaXNuJ3QgdXNlZCB0byByZW5kZXIgYW55dGhpbmcgYW5kIG9ubHkgZXhpc3RzIGZvclxyXG4gICAgICAvLyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYC4gRG9uJ3QgY291bnQgdGhpcyB0b3dhcmQgcmVyZW5kZXJpbmcuXHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGEgPT09IGI7XHJcbiAgfVxyXG59XHJcbiJdfQ==