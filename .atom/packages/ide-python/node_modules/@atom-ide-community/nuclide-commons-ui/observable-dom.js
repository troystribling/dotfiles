"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResizeObservable = exports.PerformanceObservable = exports.MutationObservable = exports.IntersectionObservable = exports._DOMObserverObservable = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _os = _interopRequireDefault(require("os"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _shallowequal = _interopRequireDefault(require("shallowequal"));

var _collection = require("@atom-ide-community/nuclide-commons/collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */

/* global IntersectionObserver, PerformanceObserver, ResizeObserver, DOMRect */

/**
 * Creates an observable sequence from a DOM-style Observer.
 *
 * **Use this sparingly: prefer to use the extended, specialized classes below
 *   or add a new one below when a new DOM-style Observer comes along*
 *
 * Emits the same array or EntryList (as with PerformanceObservers) as the
 * original DOM Observable.
 *
 * Known to work with DOM `MutationObserver`, `IntersectionObserver`,
 * `ResizeObserver`, and `PerformanceObserver`
 *
 * A DOM-style Observer is defined as implementing the `DOMObserver` interface
 * below. Here's an example with `MutationObserver`:
 *
 *   const mutations = DOMObserverObservable.create(
 *    MutationObserver,
 *    document.getElementById('bar'),
 *    { attributes: true, childList: true, characterData: true }
 *   );
 *
 *   mutations.subscribe(record => console.log(record));
 *
 * This emits and logs each batch of MutationRecords unmodified as an array. To
 * emit and log each record individually on the observable, call
 * `.flattenEntries()` before subscribing:
 *
 *   const mutations = DOMObserverObservable.create(
 *    MutationObserver,
 *    document.getElementById('bar'),
 *    { attributes: true, childList: true, characterData: true }
 *   ).flattenEntries();
 *
 *   mutations.subscribe(record => console.log(record));
 *
 * This results in MutationRecord objects emitted *individually* and
 * synchonrously every time a mutation occurs.
 *
 * To add additional observations to the observable, use `observe`:
 *
 *   const mutations = DOMObserverObservable.create(MutationObserver)
 *      .observe(
 *        document.getElementById('bar'),
 *        {attributes: true, childList: true, characterData: true}
 *      )
 *      .observe(
 *        document.getElementById('bar'),
 *        {attributes: true}
 *      )
 *      .flattenEntries();
 *
 *   mutations.subscribe(record => console.log(record));
 */
// A bug in Chrome < 62 frees PerformanceObservers and their listeners
// once the PerformanceObserver is eligible for GC:
// https://bugs.chromium.org/p/chromium/issues/detail?id=742530
//
// This means that callbacks for a PerformanceObserver will stop getting called
// (and themselves GCed) at an abitrary time.
//
// Intentionally hold references to all DOM Observers in this set, and delete
// them when the last subscriber unsubscribes.
const observers = new Set(); // $FlowFixMe(>=0.55.0) Flow suppress

class DOMObserverObservable extends _rxjsCompatUmdMin.Observable {
  constructor(DOMObserverCtor, ...observeArgs) {
    super();
    this._DOMObserverCtor = void 0;
    this._observations = [];
    this._domObserver = void 0;
    this._refs = 0;
    this._DOMObserverCtor = DOMObserverCtor;

    if (observeArgs.length > 0) {
      this.observe(...observeArgs);
    }
  }

  lift(operator) {
    const Constructor = this.constructor;
    const [firstObservation, ...restObservations] = this._observations;
    const obs = new Constructor(this._DOMObserverCtor, ...firstObservation);

    for (const observation of restObservations) {
      obs.observe(...observation);
    }

    obs.source = this;
    obs.operator = operator;
    return obs;
  }

  observe(...observeArgs) {
    this._observations.push(observeArgs);

    if (this._domObserver != null) {
      this._domObserver.observe(...observeArgs);
    }
  }

  unobserve(...unobserveArgs) {
    if (this._domObserver != null && this._domObserver.unobserve == null) {
      throw new Error(`Cannot unobserve: This observable has an active ${this._DOMObserverCtor.name} and it does not support unobserve`);
    }

    for (let i = 0; i < this._observations.length; i++) {
      if ((0, _shallowequal.default)(this._observations[i], unobserveArgs)) {
        this._observations.splice(i, 1);

        break;
      }
    }

    if (this._domObserver != null && this._domObserver.unobserve != null) {
      this._domObserver.unobserve(...unobserveArgs);
    }
  }

  flattenEntries() {
    return this.mergeMap(records => {
      if ((0, _collection.isIterable)(records)) {
        // $FlowFixMe
        return _rxjsCompatUmdMin.Observable.from(records); // $FlowFixMe
      } else if (typeof records.getEntries === 'function') {
        return _rxjsCompatUmdMin.Observable.from(records.getEntries());
      }

      return _rxjsCompatUmdMin.Observable.throw(new Error('Tried to merge DOM Observer entries, but they were not iterable nor were they an EntryList.'));
    });
  }

  _subscribe(subscriber) {
    if (this._refs === 0) {
      (0, _assert.default)(this._domObserver == null);
      this._domObserver = new this._DOMObserverCtor(records => {
        subscriber.next(records);
      });

      for (const observation of this._observations) {
        this._domObserver.observe(...observation);
      }

      observers.add(this._domObserver);
    }

    const subscription = new _rxjsCompatUmdMin.Subscription();
    this._refs++;
    subscription.add(() => {
      this._refs--; // the underlying observer should only disconnect when all subscribers have
      // unsubscribed

      if (this._refs === 0) {
        (0, _assert.default)(this._domObserver != null);

        this._domObserver.disconnect();

        this._domObserver = null;
        observers.delete(this._domObserver);
      }
    });
    return subscription;
  }

}

const _DOMObserverObservable = DOMObserverObservable;
/**
 * Returns an RxJS Observable that wraps an IntersectionObserver
 */

exports._DOMObserverObservable = _DOMObserverObservable;

class IntersectionObservable extends DOMObserverObservable {
  constructor(target) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.IntersectionObserver !== null, 'environment must contain IntersectionObserver'); // $FlowFixMe(>=0.55.0) Flow suppress

    super(IntersectionObserver, target);
  }

}
/**
 * Returns an RxJS Observable that wraps a MutationObserver
 */


exports.IntersectionObservable = IntersectionObservable;

class MutationObservable extends DOMObserverObservable {
  constructor(target, options) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.MutationObserver !== null, 'environment must contain MutationObserver'); // $FlowFixMe(>=0.55.0) Flow suppress

    super(MutationObserver, target, options);
  }

}
/**
 * Returns an RxJS Observable that wraps a PerformanceObserver
 */


exports.MutationObservable = MutationObservable;

class PerformanceObservable extends DOMObserverObservable {
  constructor(options) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.PerformanceObserver !== null, 'environment must contain PerformanceObserver'); // $FlowFixMe(>=0.55.0) Flow suppress

    super(PerformanceObserver, options);
  }

}
/**
 * Returns an RxJS Observable that wraps a ResizeObserver
 */


exports.PerformanceObservable = PerformanceObservable;

class ResizeObservable extends DOMObserverObservable {
  constructor(target) {
    (0, _assert.default)( // eslint-disable-next-line eqeqeq
    global.ResizeObserver !== null, 'environment must contain ResizeObserver');

    if (_os.default.platform() === 'win32' || _os.default.platform() === 'linux') {
      super(WindowsResizeMeasurementPatchingObserver, target);
    } else {
      // $FlowFixMe(>=0.55.0) Flow suppress
      super(ResizeObserver, target);
    }
  }

}

exports.ResizeObservable = ResizeObservable;

function lastRectPerTarget(entries) {
  const rectMap = new Map();
  entries.forEach(entry => rectMap.set(entry.target, entry.contentRect));
  return rectMap;
}

function remeasureContentRect(element, contentRect) {
  const {
    clientHeight,
    clientWidth
  } = element; // Client height/width include padding
  // https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth
  // We have to strip it to obtain result similar to what the original computed style provided

  const computedStyle = window.getComputedStyle(element);
  const {
    paddingLeft,
    paddingRight,
    paddingTop,
    paddingBottom
  } = computedStyle;
  const height = clientHeight - parseFloat(paddingTop) - parseFloat(paddingBottom);
  const width = clientWidth - parseFloat(paddingLeft) - parseFloat(paddingRight);
  return new DOMRectReadOnly(contentRect.x, contentRect.y, width, height);
}
/*
 * The values provided by the ResizeOverver on Windows do not seem to reflect the actual size
 * of the element (!!!), so we need to "fix" them before passing on to the downstream subscriber
 * We're wrapping the ResizeObserver instance and are patching the last result of the array with
 * a set of custom measured values
 */


class WindowsResizeMeasurementPatchingObserver {
  constructor(callback, ...rest) {
    this._resizeObserver = void 0;

    const remeasuringCallback = entries => {
      const rebuiltEntries = [];
      const mappedRects = lastRectPerTarget(entries);
      mappedRects.forEach((originalRect, target) => {
        const contentRect = remeasureContentRect(target, originalRect);
        rebuiltEntries.push({
          target,
          contentRect
        });
      });
      callback(rebuiltEntries);
    };

    this._resizeObserver = new ResizeObserver(remeasuringCallback, ...rest); // To make flow happy

    return this;
  }

  observe(...observeArgs) {
    this._resizeObserver.observe(...observeArgs);
  }

  disconnect() {
    this._resizeObserver.disconnect();
  }

  unobserve(...unobserveArgs) {
    if (typeof this._resizeObserver.unobserve === 'function') {
      this._resizeObserver.unobserve(...unobserveArgs);
    }
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL29ic2VydmFibGUtZG9tLmpzIl0sIm5hbWVzIjpbIm9ic2VydmVycyIsIlNldCIsIkRPTU9ic2VydmVyT2JzZXJ2YWJsZSIsIk9ic2VydmFibGUiLCJjb25zdHJ1Y3RvciIsIkRPTU9ic2VydmVyQ3RvciIsIm9ic2VydmVBcmdzIiwiX0RPTU9ic2VydmVyQ3RvciIsIl9vYnNlcnZhdGlvbnMiLCJfZG9tT2JzZXJ2ZXIiLCJfcmVmcyIsImxlbmd0aCIsIm9ic2VydmUiLCJsaWZ0Iiwib3BlcmF0b3IiLCJDb25zdHJ1Y3RvciIsImZpcnN0T2JzZXJ2YXRpb24iLCJyZXN0T2JzZXJ2YXRpb25zIiwib2JzIiwib2JzZXJ2YXRpb24iLCJzb3VyY2UiLCJwdXNoIiwidW5vYnNlcnZlIiwidW5vYnNlcnZlQXJncyIsIkVycm9yIiwibmFtZSIsImkiLCJzcGxpY2UiLCJmbGF0dGVuRW50cmllcyIsIm1lcmdlTWFwIiwicmVjb3JkcyIsImZyb20iLCJnZXRFbnRyaWVzIiwidGhyb3ciLCJfc3Vic2NyaWJlIiwic3Vic2NyaWJlciIsIm5leHQiLCJhZGQiLCJzdWJzY3JpcHRpb24iLCJTdWJzY3JpcHRpb24iLCJkaXNjb25uZWN0IiwiZGVsZXRlIiwiX0RPTU9ic2VydmVyT2JzZXJ2YWJsZSIsIkludGVyc2VjdGlvbk9ic2VydmFibGUiLCJ0YXJnZXQiLCJnbG9iYWwiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2YWJsZSIsIm9wdGlvbnMiLCJNdXRhdGlvbk9ic2VydmVyIiwiUGVyZm9ybWFuY2VPYnNlcnZhYmxlIiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmFibGUiLCJSZXNpemVPYnNlcnZlciIsIm9zIiwicGxhdGZvcm0iLCJXaW5kb3dzUmVzaXplTWVhc3VyZW1lbnRQYXRjaGluZ09ic2VydmVyIiwibGFzdFJlY3RQZXJUYXJnZXQiLCJlbnRyaWVzIiwicmVjdE1hcCIsIk1hcCIsImZvckVhY2giLCJlbnRyeSIsInNldCIsImNvbnRlbnRSZWN0IiwicmVtZWFzdXJlQ29udGVudFJlY3QiLCJlbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjb21wdXRlZFN0eWxlIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJoZWlnaHQiLCJwYXJzZUZsb2F0Iiwid2lkdGgiLCJET01SZWN0UmVhZE9ubHkiLCJ4IiwieSIsImNhbGxiYWNrIiwicmVzdCIsIl9yZXNpemVPYnNlcnZlciIsInJlbWVhc3VyaW5nQ2FsbGJhY2siLCJyZWJ1aWx0RW50cmllcyIsIm1hcHBlZFJlY3RzIiwib3JpZ2luYWxSZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBZUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsU0FBUyxHQUFHLElBQUlDLEdBQUosRUFBbEIsQyxDQUVBOztBQVNBLE1BQU1DLHFCQUFOLFNBSVVDLDRCQUpWLENBSTRCO0FBTTFCQyxFQUFBQSxX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R0FBRzlCLGlCQUFpQixDQUFDQyxPQUFELENBQXJDO0FBQ0E2QixNQUFBQSxXQUFXLENBQUMxQixPQUFaLENBQW9CLENBQUMyQixZQUFELEVBQWU1QyxNQUFmLEtBQTBCO0FBQzVDLGNBQU1vQixXQUFXLEdBQUdDLG9CQUFvQixDQUFDckIsTUFBRCxFQUFTNEMsWUFBVCxDQUF4QztBQUNBRixRQUFBQSxjQUFjLENBQUNqRSxJQUFmLENBQW9CO0FBQUN1QixVQUFBQSxNQUFEO0FBQVNvQixVQUFBQTtBQUFULFNBQXBCO0FBQ0QsT0FIRDtBQUtBa0IsTUFBQUEsUUFBUSxDQUFDSSxjQUFELENBQVI7QUFDRCxLQVREOztBQVVBLFNBQUtGLGVBQUwsR0FBdUIsSUFBSS9CLGNBQUosQ0FBbUJnQyxtQkFBbkIsRUFBd0MsR0FBR0YsSUFBM0MsQ0FBdkIsQ0FYc0UsQ0FhdEU7O0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBRUR2RSxFQUFBQSxPQUFPLENBQUMsR0FBR04sV0FBSixFQUFtQztBQUN4QyxTQUFLOEUsZUFBTCxDQUFxQnhFLE9BQXJCLENBQTZCLEdBQUdOLFdBQWhDO0FBQ0Q7O0FBRURrQyxFQUFBQSxVQUFVLEdBQVM7QUFDakIsU0FBSzRDLGVBQUwsQ0FBcUI1QyxVQUFyQjtBQUNEOztBQUVEbEIsRUFBQUEsU0FBUyxDQUFDLEdBQUdDLGFBQUosRUFBcUM7QUFDNUMsUUFBSSxPQUFPLEtBQUs2RCxlQUFMLENBQXFCOUQsU0FBNUIsS0FBMEMsVUFBOUMsRUFBMEQ7QUFDeEQsV0FBSzhELGVBQUwsQ0FBcUI5RCxTQUFyQixDQUErQixHQUFHQyxhQUFsQztBQUNEO0FBQ0Y7O0FBaENtRSIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xyXG4vKiBnbG9iYWwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIsIFBlcmZvcm1hbmNlT2JzZXJ2ZXIsIFJlc2l6ZU9ic2VydmVyLCBET01SZWN0ICovXHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCBvcyBmcm9tICdvcyc7XHJcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJ3NoYWxsb3dlcXVhbCc7XHJcbmltcG9ydCB7aXNJdGVyYWJsZX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvY29sbGVjdGlvbic7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGZyb20gYSBET00tc3R5bGUgT2JzZXJ2ZXIuXHJcbiAqXHJcbiAqICoqVXNlIHRoaXMgc3BhcmluZ2x5OiBwcmVmZXIgdG8gdXNlIHRoZSBleHRlbmRlZCwgc3BlY2lhbGl6ZWQgY2xhc3NlcyBiZWxvd1xyXG4gKiAgIG9yIGFkZCBhIG5ldyBvbmUgYmVsb3cgd2hlbiBhIG5ldyBET00tc3R5bGUgT2JzZXJ2ZXIgY29tZXMgYWxvbmcqXHJcbiAqXHJcbiAqIEVtaXRzIHRoZSBzYW1lIGFycmF5IG9yIEVudHJ5TGlzdCAoYXMgd2l0aCBQZXJmb3JtYW5jZU9ic2VydmVycykgYXMgdGhlXHJcbiAqIG9yaWdpbmFsIERPTSBPYnNlcnZhYmxlLlxyXG4gKlxyXG4gKiBLbm93biB0byB3b3JrIHdpdGggRE9NIGBNdXRhdGlvbk9ic2VydmVyYCwgYEludGVyc2VjdGlvbk9ic2VydmVyYCxcclxuICogYFJlc2l6ZU9ic2VydmVyYCwgYW5kIGBQZXJmb3JtYW5jZU9ic2VydmVyYFxyXG4gKlxyXG4gKiBBIERPTS1zdHlsZSBPYnNlcnZlciBpcyBkZWZpbmVkIGFzIGltcGxlbWVudGluZyB0aGUgYERPTU9ic2VydmVyYCBpbnRlcmZhY2VcclxuICogYmVsb3cuIEhlcmUncyBhbiBleGFtcGxlIHdpdGggYE11dGF0aW9uT2JzZXJ2ZXJgOlxyXG4gKlxyXG4gKiAgIGNvbnN0IG11dGF0aW9ucyA9IERPTU9ic2VydmVyT2JzZXJ2YWJsZS5jcmVhdGUoXHJcbiAqICAgIE11dGF0aW9uT2JzZXJ2ZXIsXHJcbiAqICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYXInKSxcclxuICogICAgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWUgfVxyXG4gKiAgICk7XHJcbiAqXHJcbiAqICAgbXV0YXRpb25zLnN1YnNjcmliZShyZWNvcmQgPT4gY29uc29sZS5sb2cocmVjb3JkKSk7XHJcbiAqXHJcbiAqIFRoaXMgZW1pdHMgYW5kIGxvZ3MgZWFjaCBiYXRjaCBvZiBNdXRhdGlvblJlY29yZHMgdW5tb2RpZmllZCBhcyBhbiBhcnJheS4gVG9cclxuICogZW1pdCBhbmQgbG9nIGVhY2ggcmVjb3JkIGluZGl2aWR1YWxseSBvbiB0aGUgb2JzZXJ2YWJsZSwgY2FsbFxyXG4gKiBgLmZsYXR0ZW5FbnRyaWVzKClgIGJlZm9yZSBzdWJzY3JpYmluZzpcclxuICpcclxuICogICBjb25zdCBtdXRhdGlvbnMgPSBET01PYnNlcnZlck9ic2VydmFibGUuY3JlYXRlKFxyXG4gKiAgICBNdXRhdGlvbk9ic2VydmVyLFxyXG4gKiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFyJyksXHJcbiAqICAgIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlIH1cclxuICogICApLmZsYXR0ZW5FbnRyaWVzKCk7XHJcbiAqXHJcbiAqICAgbXV0YXRpb25zLnN1YnNjcmliZShyZWNvcmQgPT4gY29uc29sZS5sb2cocmVjb3JkKSk7XHJcbiAqXHJcbiAqIFRoaXMgcmVzdWx0cyBpbiBNdXRhdGlvblJlY29yZCBvYmplY3RzIGVtaXR0ZWQgKmluZGl2aWR1YWxseSogYW5kXHJcbiAqIHN5bmNob25yb3VzbHkgZXZlcnkgdGltZSBhIG11dGF0aW9uIG9jY3Vycy5cclxuICpcclxuICogVG8gYWRkIGFkZGl0aW9uYWwgb2JzZXJ2YXRpb25zIHRvIHRoZSBvYnNlcnZhYmxlLCB1c2UgYG9ic2VydmVgOlxyXG4gKlxyXG4gKiAgIGNvbnN0IG11dGF0aW9ucyA9IERPTU9ic2VydmVyT2JzZXJ2YWJsZS5jcmVhdGUoTXV0YXRpb25PYnNlcnZlcilcclxuICogICAgICAub2JzZXJ2ZShcclxuICogICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYXInKSxcclxuICogICAgICAgIHthdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWV9XHJcbiAqICAgICAgKVxyXG4gKiAgICAgIC5vYnNlcnZlKFxyXG4gKiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhcicpLFxyXG4gKiAgICAgICAge2F0dHJpYnV0ZXM6IHRydWV9XHJcbiAqICAgICAgKVxyXG4gKiAgICAgIC5mbGF0dGVuRW50cmllcygpO1xyXG4gKlxyXG4gKiAgIG11dGF0aW9ucy5zdWJzY3JpYmUocmVjb3JkID0+IGNvbnNvbGUubG9nKHJlY29yZCkpO1xyXG4gKi9cclxuXHJcbi8vIEEgYnVnIGluIENocm9tZSA8IDYyIGZyZWVzIFBlcmZvcm1hbmNlT2JzZXJ2ZXJzIGFuZCB0aGVpciBsaXN0ZW5lcnNcclxuLy8gb25jZSB0aGUgUGVyZm9ybWFuY2VPYnNlcnZlciBpcyBlbGlnaWJsZSBmb3IgR0M6XHJcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc0MjUzMFxyXG4vL1xyXG4vLyBUaGlzIG1lYW5zIHRoYXQgY2FsbGJhY2tzIGZvciBhIFBlcmZvcm1hbmNlT2JzZXJ2ZXIgd2lsbCBzdG9wIGdldHRpbmcgY2FsbGVkXHJcbi8vIChhbmQgdGhlbXNlbHZlcyBHQ2VkKSBhdCBhbiBhYml0cmFyeSB0aW1lLlxyXG4vL1xyXG4vLyBJbnRlbnRpb25hbGx5IGhvbGQgcmVmZXJlbmNlcyB0byBhbGwgRE9NIE9ic2VydmVycyBpbiB0aGlzIHNldCwgYW5kIGRlbGV0ZVxyXG4vLyB0aGVtIHdoZW4gdGhlIGxhc3Qgc3Vic2NyaWJlciB1bnN1YnNjcmliZXMuXHJcbmNvbnN0IG9ic2VydmVycyA9IG5ldyBTZXQoKTtcclxuXHJcbi8vICRGbG93Rml4TWUoPj0wLjU1LjApIEZsb3cgc3VwcHJlc3NcclxudHlwZSBSZWNvcmRDYWxsYmFjayA9IChyZWNvcmRzOiBhbnksIC4uLnJlc3Q6IEFycmF5PGFueT4pID0+IG1peGVkO1xyXG5pbnRlcmZhY2UgRE9NT2JzZXJ2ZXIge1xyXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrOiBSZWNvcmRDYWxsYmFjaywgLi4ucmVzdDogQXJyYXk8YW55Pik6IERPTU9ic2VydmVyO1xyXG4gIG9ic2VydmUoLi4ub2JzZXJ2ZUFyZ3M6IEFycmF5PGFueT4pOiB2b2lkO1xyXG4gIGRpc2Nvbm5lY3QoKTogdm9pZDtcclxuICArdW5vYnNlcnZlPzogKC4uLnVub2JzZXJ2ZUFyZ3M6IEFycmF5PGFueT4pID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNsYXNzIERPTU9ic2VydmVyT2JzZXJ2YWJsZTxcclxuICBUTmV4dCwgLy8gd2hhdCBkb2VzIHRoaXMgb2JzZXJ2YWJsZSBgbmV4dCgpYD9cclxuICBURW50cnksIC8vIHdoYXQgaXMgYW4gaW5kaXZpZHVhbCBlbnRyeT9cclxuICBUT2JzZXJ2ZUFyZ3M6ICRSZWFkT25seUFycmF5PGFueT4sIC8vIHdoYXQgYXJlIHRoZSBhcmd1bWVudHMgdG8gYG9ic2VydmUoKWAgYW5kIGB1bm9ic2VydmVgKCk/XHJcbj4gZXh0ZW5kcyBPYnNlcnZhYmxlPFROZXh0PiB7XHJcbiAgX0RPTU9ic2VydmVyQ3RvcjogQ2xhc3M8RE9NT2JzZXJ2ZXI+O1xyXG4gIF9vYnNlcnZhdGlvbnM6IEFycmF5PFRPYnNlcnZlQXJncz4gPSBbXTtcclxuICBfZG9tT2JzZXJ2ZXI6ID9ET01PYnNlcnZlcjtcclxuICBfcmVmczogbnVtYmVyID0gMDtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBET01PYnNlcnZlckN0b3I6IENsYXNzPERPTU9ic2VydmVyPixcclxuICAgIC4uLm9ic2VydmVBcmdzOiBUT2JzZXJ2ZUFyZ3NcclxuICApOiB2b2lkIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9ET01PYnNlcnZlckN0b3IgPSBET01PYnNlcnZlckN0b3I7XHJcbiAgICBpZiAob2JzZXJ2ZUFyZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLm9ic2VydmUoLi4ub2JzZXJ2ZUFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbGlmdDxSPihvcGVyYXRvcjogcnhqcyRPcGVyYXRvcjxUTmV4dCwgUj4pOiB0aGlzIHtcclxuICAgIGNvbnN0IENvbnN0cnVjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuICAgIGNvbnN0IFtmaXJzdE9ic2VydmF0aW9uLCAuLi5yZXN0T2JzZXJ2YXRpb25zXSA9IHRoaXMuX29ic2VydmF0aW9ucztcclxuICAgIGNvbnN0IG9icyA9IG5ldyBDb25zdHJ1Y3Rvcih0aGlzLl9ET01PYnNlcnZlckN0b3IsIC4uLmZpcnN0T2JzZXJ2YXRpb24pO1xyXG4gICAgZm9yIChjb25zdCBvYnNlcnZhdGlvbiBvZiByZXN0T2JzZXJ2YXRpb25zKSB7XHJcbiAgICAgIG9icy5vYnNlcnZlKC4uLm9ic2VydmF0aW9uKTtcclxuICAgIH1cclxuICAgIG9icy5zb3VyY2UgPSB0aGlzO1xyXG4gICAgb2JzLm9wZXJhdG9yID0gb3BlcmF0b3I7XHJcbiAgICByZXR1cm4gb2JzO1xyXG4gIH1cclxuXHJcbiAgb2JzZXJ2ZSguLi5vYnNlcnZlQXJnczogVE9ic2VydmVBcmdzKTogdm9pZCB7XHJcbiAgICB0aGlzLl9vYnNlcnZhdGlvbnMucHVzaChvYnNlcnZlQXJncyk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIub2JzZXJ2ZSguLi5vYnNlcnZlQXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB1bm9ic2VydmUoLi4udW5vYnNlcnZlQXJnczogVE9ic2VydmVBcmdzKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fZG9tT2JzZXJ2ZXIgIT0gbnVsbCAmJiB0aGlzLl9kb21PYnNlcnZlci51bm9ic2VydmUgPT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCB1bm9ic2VydmU6IFRoaXMgb2JzZXJ2YWJsZSBoYXMgYW4gYWN0aXZlICR7XHJcbiAgICAgICAgICB0aGlzLl9ET01PYnNlcnZlckN0b3IubmFtZVxyXG4gICAgICAgIH0gYW5kIGl0IGRvZXMgbm90IHN1cHBvcnQgdW5vYnNlcnZlYCxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX29ic2VydmF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoc2hhbGxvd0VxdWFsKHRoaXMuX29ic2VydmF0aW9uc1tpXSwgdW5vYnNlcnZlQXJncykpIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZhdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyICE9IG51bGwgJiYgdGhpcy5fZG9tT2JzZXJ2ZXIudW5vYnNlcnZlICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIudW5vYnNlcnZlKC4uLnVub2JzZXJ2ZUFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZmxhdHRlbkVudHJpZXMoKTogT2JzZXJ2YWJsZTxURW50cnk+IHtcclxuICAgIHJldHVybiB0aGlzLm1lcmdlTWFwKHJlY29yZHMgPT4ge1xyXG4gICAgICBpZiAoaXNJdGVyYWJsZShyZWNvcmRzKSkge1xyXG4gICAgICAgIC8vICRGbG93Rml4TWVcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5mcm9tKHJlY29yZHMpO1xyXG4gICAgICAgIC8vICRGbG93Rml4TWVcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVjb3Jkcy5nZXRFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbShyZWNvcmRzLmdldEVudHJpZXMoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLnRocm93KFxyXG4gICAgICAgIG5ldyBFcnJvcihcclxuICAgICAgICAgICdUcmllZCB0byBtZXJnZSBET00gT2JzZXJ2ZXIgZW50cmllcywgYnV0IHRoZXkgd2VyZSBub3QgaXRlcmFibGUgbm9yIHdlcmUgdGhleSBhbiBFbnRyeUxpc3QuJyxcclxuICAgICAgICApLFxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IHJ4anMkU3Vic2NyaWJlcjxUTmV4dD4pOiByeGpzJFN1YnNjcmlwdGlvbiB7XHJcbiAgICBpZiAodGhpcy5fcmVmcyA9PT0gMCkge1xyXG4gICAgICBpbnZhcmlhbnQodGhpcy5fZG9tT2JzZXJ2ZXIgPT0gbnVsbCk7XHJcbiAgICAgIHRoaXMuX2RvbU9ic2VydmVyID0gbmV3IHRoaXMuX0RPTU9ic2VydmVyQ3RvcihyZWNvcmRzID0+IHtcclxuICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVjb3Jkcyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZm9yIChjb25zdCBvYnNlcnZhdGlvbiBvZiB0aGlzLl9vYnNlcnZhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5vYnNlcnZlKC4uLm9ic2VydmF0aW9uKTtcclxuICAgICAgfVxyXG4gICAgICBvYnNlcnZlcnMuYWRkKHRoaXMuX2RvbU9ic2VydmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XHJcbiAgICB0aGlzLl9yZWZzKys7XHJcbiAgICBzdWJzY3JpcHRpb24uYWRkKCgpID0+IHtcclxuICAgICAgdGhpcy5fcmVmcy0tO1xyXG5cclxuICAgICAgLy8gdGhlIHVuZGVybHlpbmcgb2JzZXJ2ZXIgc2hvdWxkIG9ubHkgZGlzY29ubmVjdCB3aGVuIGFsbCBzdWJzY3JpYmVycyBoYXZlXHJcbiAgICAgIC8vIHVuc3Vic2NyaWJlZFxyXG4gICAgICBpZiAodGhpcy5fcmVmcyA9PT0gMCkge1xyXG4gICAgICAgIGludmFyaWFudCh0aGlzLl9kb21PYnNlcnZlciAhPSBudWxsKTtcclxuICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIG9ic2VydmVycy5kZWxldGUodGhpcy5fZG9tT2JzZXJ2ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IF9ET01PYnNlcnZlck9ic2VydmFibGUgPSBET01PYnNlcnZlck9ic2VydmFibGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbiBSeEpTIE9ic2VydmFibGUgdGhhdCB3cmFwcyBhbiBJbnRlcnNlY3Rpb25PYnNlcnZlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEludGVyc2VjdGlvbk9ic2VydmFibGUgZXh0ZW5kcyBET01PYnNlcnZlck9ic2VydmFibGU8XHJcbiAgQXJyYXk8SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeT4sXHJcbiAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSxcclxuICBbSFRNTEVsZW1lbnRdLFxyXG4+IHtcclxuICBjb25zdHJ1Y3Rvcih0YXJnZXQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICBpbnZhcmlhbnQoXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuICAgICAgZ2xvYmFsLkludGVyc2VjdGlvbk9ic2VydmVyICE9PSBudWxsLFxyXG4gICAgICAnZW52aXJvbm1lbnQgbXVzdCBjb250YWluIEludGVyc2VjdGlvbk9ic2VydmVyJyxcclxuICAgICk7XHJcbiAgICAvLyAkRmxvd0ZpeE1lKD49MC41NS4wKSBGbG93IHN1cHByZXNzXHJcbiAgICBzdXBlcihJbnRlcnNlY3Rpb25PYnNlcnZlciwgdGFyZ2V0KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIFJ4SlMgT2JzZXJ2YWJsZSB0aGF0IHdyYXBzIGEgTXV0YXRpb25PYnNlcnZlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIE11dGF0aW9uT2JzZXJ2YWJsZSBleHRlbmRzIERPTU9ic2VydmVyT2JzZXJ2YWJsZTxcclxuICBBcnJheTxNdXRhdGlvblJlY29yZD4sXHJcbiAgTXV0YXRpb25SZWNvcmQsXHJcbiAgW05vZGUsIE11dGF0aW9uT2JzZXJ2ZXJJbml0XSxcclxuPiB7XHJcbiAgY29uc3RydWN0b3IodGFyZ2V0OiBOb2RlLCBvcHRpb25zPzogTXV0YXRpb25PYnNlcnZlckluaXQpIHtcclxuICAgIGludmFyaWFudChcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgICBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciAhPT0gbnVsbCxcclxuICAgICAgJ2Vudmlyb25tZW50IG11c3QgY29udGFpbiBNdXRhdGlvbk9ic2VydmVyJyxcclxuICAgICk7XHJcbiAgICAvLyAkRmxvd0ZpeE1lKD49MC41NS4wKSBGbG93IHN1cHByZXNzXHJcbiAgICBzdXBlcihNdXRhdGlvbk9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gUnhKUyBPYnNlcnZhYmxlIHRoYXQgd3JhcHMgYSBQZXJmb3JtYW5jZU9ic2VydmVyXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VPYnNlcnZhYmxlIGV4dGVuZHMgRE9NT2JzZXJ2ZXJPYnNlcnZhYmxlPFxyXG4gIFBlcmZvcm1hbmNlT2JzZXJ2ZXJFbnRyeUxpc3QsXHJcbiAgUGVyZm9ybWFuY2VFbnRyeSxcclxuICBbUGVyZm9ybWFuY2VPYnNlcnZlckluaXRdLFxyXG4+IHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBQZXJmb3JtYW5jZU9ic2VydmVySW5pdCkge1xyXG4gICAgaW52YXJpYW50KFxyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXHJcbiAgICAgIGdsb2JhbC5QZXJmb3JtYW5jZU9ic2VydmVyICE9PSBudWxsLFxyXG4gICAgICAnZW52aXJvbm1lbnQgbXVzdCBjb250YWluIFBlcmZvcm1hbmNlT2JzZXJ2ZXInLFxyXG4gICAgKTtcclxuICAgIC8vICRGbG93Rml4TWUoPj0wLjU1LjApIEZsb3cgc3VwcHJlc3NcclxuICAgIHN1cGVyKFBlcmZvcm1hbmNlT2JzZXJ2ZXIsIG9wdGlvbnMpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gUnhKUyBPYnNlcnZhYmxlIHRoYXQgd3JhcHMgYSBSZXNpemVPYnNlcnZlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFJlc2l6ZU9ic2VydmFibGUgZXh0ZW5kcyBET01PYnNlcnZlck9ic2VydmFibGU8XHJcbiAgQXJyYXk8UmVzaXplT2JzZXJ2ZXJFbnRyeT4sXHJcbiAgUmVzaXplT2JzZXJ2ZXJFbnRyeSxcclxuICBbSFRNTEVsZW1lbnRdLFxyXG4+IHtcclxuICBjb25zdHJ1Y3Rvcih0YXJnZXQ6IEhUTUxFbGVtZW50KSB7XHJcbiAgICBpbnZhcmlhbnQoXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcclxuICAgICAgZ2xvYmFsLlJlc2l6ZU9ic2VydmVyICE9PSBudWxsLFxyXG4gICAgICAnZW52aXJvbm1lbnQgbXVzdCBjb250YWluIFJlc2l6ZU9ic2VydmVyJyxcclxuICAgICk7XHJcblxyXG4gICAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicgfHwgb3MucGxhdGZvcm0oKSA9PT0gJ2xpbnV4Jykge1xyXG4gICAgICBzdXBlcihXaW5kb3dzUmVzaXplTWVhc3VyZW1lbnRQYXRjaGluZ09ic2VydmVyLCB0YXJnZXQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gJEZsb3dGaXhNZSg+PTAuNTUuMCkgRmxvdyBzdXBwcmVzc1xyXG4gICAgICBzdXBlcihSZXNpemVPYnNlcnZlciwgdGFyZ2V0KTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxhc3RSZWN0UGVyVGFyZ2V0KFxyXG4gIGVudHJpZXM6IEFycmF5PFJlc2l6ZU9ic2VydmVyRW50cnk+LFxyXG4pOiBNYXA8SFRNTEVsZW1lbnQsIERPTVJlY3RSZWFkT25seT4ge1xyXG4gIGNvbnN0IHJlY3RNYXAgPSBuZXcgTWFwKCk7XHJcbiAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHJlY3RNYXAuc2V0KGVudHJ5LnRhcmdldCwgZW50cnkuY29udGVudFJlY3QpKTtcclxuICByZXR1cm4gcmVjdE1hcDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVtZWFzdXJlQ29udGVudFJlY3QoXHJcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXHJcbiAgY29udGVudFJlY3Q6IERPTVJlY3RSZWFkT25seSxcclxuKTogRE9NUmVjdFJlYWRPbmx5IHtcclxuICBjb25zdCB7Y2xpZW50SGVpZ2h0LCBjbGllbnRXaWR0aH0gPSBlbGVtZW50O1xyXG5cclxuICAvLyBDbGllbnQgaGVpZ2h0L3dpZHRoIGluY2x1ZGUgcGFkZGluZ1xyXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2NsaWVudFdpZHRoXHJcbiAgLy8gV2UgaGF2ZSB0byBzdHJpcCBpdCB0byBvYnRhaW4gcmVzdWx0IHNpbWlsYXIgdG8gd2hhdCB0aGUgb3JpZ2luYWwgY29tcHV0ZWQgc3R5bGUgcHJvdmlkZWRcclxuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XHJcbiAgY29uc3Qge3BhZGRpbmdMZWZ0LCBwYWRkaW5nUmlnaHQsIHBhZGRpbmdUb3AsIHBhZGRpbmdCb3R0b219ID0gY29tcHV0ZWRTdHlsZTtcclxuXHJcbiAgY29uc3QgaGVpZ2h0ID1cclxuICAgIGNsaWVudEhlaWdodCAtIHBhcnNlRmxvYXQocGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdCb3R0b20pO1xyXG4gIGNvbnN0IHdpZHRoID1cclxuICAgIGNsaWVudFdpZHRoIC0gcGFyc2VGbG9hdChwYWRkaW5nTGVmdCkgLSBwYXJzZUZsb2F0KHBhZGRpbmdSaWdodCk7XHJcblxyXG4gIHJldHVybiBuZXcgRE9NUmVjdFJlYWRPbmx5KGNvbnRlbnRSZWN0LngsIGNvbnRlbnRSZWN0LnksIHdpZHRoLCBoZWlnaHQpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBUaGUgdmFsdWVzIHByb3ZpZGVkIGJ5IHRoZSBSZXNpemVPdmVydmVyIG9uIFdpbmRvd3MgZG8gbm90IHNlZW0gdG8gcmVmbGVjdCB0aGUgYWN0dWFsIHNpemVcclxuICogb2YgdGhlIGVsZW1lbnQgKCEhISksIHNvIHdlIG5lZWQgdG8gXCJmaXhcIiB0aGVtIGJlZm9yZSBwYXNzaW5nIG9uIHRvIHRoZSBkb3duc3RyZWFtIHN1YnNjcmliZXJcclxuICogV2UncmUgd3JhcHBpbmcgdGhlIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIGFuZCBhcmUgcGF0Y2hpbmcgdGhlIGxhc3QgcmVzdWx0IG9mIHRoZSBhcnJheSB3aXRoXHJcbiAqIGEgc2V0IG9mIGN1c3RvbSBtZWFzdXJlZCB2YWx1ZXNcclxuICovXHJcbmNsYXNzIFdpbmRvd3NSZXNpemVNZWFzdXJlbWVudFBhdGNoaW5nT2JzZXJ2ZXIgaW1wbGVtZW50cyBET01PYnNlcnZlciB7XHJcbiAgX3Jlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoY2FsbGJhY2s6IFJlY29yZENhbGxiYWNrLCAuLi5yZXN0OiBBcnJheTxhbnk+KTogRE9NT2JzZXJ2ZXIge1xyXG4gICAgY29uc3QgcmVtZWFzdXJpbmdDYWxsYmFjayA9IChlbnRyaWVzOiBBcnJheTxSZXNpemVPYnNlcnZlckVudHJ5Pik6IHZvaWQgPT4ge1xyXG4gICAgICBjb25zdCByZWJ1aWx0RW50cmllcyA9IFtdO1xyXG4gICAgICBjb25zdCBtYXBwZWRSZWN0cyA9IGxhc3RSZWN0UGVyVGFyZ2V0KGVudHJpZXMpO1xyXG4gICAgICBtYXBwZWRSZWN0cy5mb3JFYWNoKChvcmlnaW5hbFJlY3QsIHRhcmdldCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSZWN0ID0gcmVtZWFzdXJlQ29udGVudFJlY3QodGFyZ2V0LCBvcmlnaW5hbFJlY3QpO1xyXG4gICAgICAgIHJlYnVpbHRFbnRyaWVzLnB1c2goe3RhcmdldCwgY29udGVudFJlY3R9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjYWxsYmFjayhyZWJ1aWx0RW50cmllcyk7XHJcbiAgICB9O1xyXG4gICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIocmVtZWFzdXJpbmdDYWxsYmFjaywgLi4ucmVzdCk7XHJcblxyXG4gICAgLy8gVG8gbWFrZSBmbG93IGhhcHB5XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIG9ic2VydmUoLi4ub2JzZXJ2ZUFyZ3M6IEFycmF5PGFueT4pOiB2b2lkIHtcclxuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoLi4ub2JzZXJ2ZUFyZ3MpO1xyXG4gIH1cclxuXHJcbiAgZGlzY29ubmVjdCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICB9XHJcblxyXG4gIHVub2JzZXJ2ZSguLi51bm9ic2VydmVBcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci51bm9ic2VydmUoLi4udW5vYnNlcnZlQXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==