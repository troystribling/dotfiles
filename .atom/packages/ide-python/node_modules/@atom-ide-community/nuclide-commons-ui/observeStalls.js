"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intentionallyBlocksInResponseToUserAction = intentionallyBlocksInResponseToUserAction;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _getDisplayName = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/getDisplayName"));

var _electron = require("electron");

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _observableDom = require("./observable-dom");

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _once = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/once"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* eslint-env browser */
(0, _assert.default)(_electron.remote != null); // The startup period naturally causes many event loop blockages.
// Don't start checking blockages until some time has passed.

const BLOCKED_GRACE_PERIOD = 30; // Report all blockages over this threshold.

const BLOCKED_MIN = 100; // Discard overly long blockages as spurious (e.g. computer was asleep)

const BLOCKED_MAX = 60 * 1000; // 1 minute in ms
// Range padding on either side of long task interval.
// If an intentional block timestamp lies in this range,
// we consider it intentional.

const BLOCKED_RANGE_PADDING = 15;
let intentionalBlockTime = 0; // Share + cache the observable.
// $FlowFixMe (>=0.85.0) (T35986896) Flow upgrade suppress

const observeStalls = (0, _once.default)(() => {
  const browserWindow = _electron.remote.getCurrentWindow();

  const onIntentionalBlock = () => {
    intentionalBlockTime = performance.now();
  };

  const blockedEvents = new _observableDom.PerformanceObservable({
    entryTypes: ['longtask']
  }).flattenEntries() // only count if the window is focused when the task ran long
  .filter(() => document.hasFocus()) // discard early longtasks as the app is booting
  .filter(() => process.uptime() > BLOCKED_GRACE_PERIOD) // discard durations that are unrealistically long, or those that aren't
  // meaningful enough
  .filter(entry => entry.duration > BLOCKED_MIN && entry.duration < BLOCKED_MAX) // discard events that result from user interaction actually blocking the
  // thread when there is no other option (e.g. context menus)
  .filter(entry => // did the intentionalblocktime occur between the start and end,
  // accounting for some extra padding?
  !(intentionalBlockTime > entry.startTime - BLOCKED_RANGE_PADDING && intentionalBlockTime < entry.startTime + entry.duration + BLOCKED_RANGE_PADDING));
  return _rxjsCompatUmdMin.Observable.using(() => new _UniversalDisposable.default( // Confirmation dialogs also block the event loop.
  // This typically happens when you're about to close an unsaved file.
  atom.workspace.onWillDestroyPaneItem(onIntentionalBlock), // Electron context menus block the event loop.
  _rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'context-menu') // There appears to be an race with browser window shutdown where
  // the 'context-menu' event fires after window destruction.
  // Try to prevent this by removing the event on close.
  // https://github.com/facebook/nuclide/issues/1246
  .takeUntil(_rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'close')).subscribe(onIntentionalBlock)), () => {
    return _rxjsCompatUmdMin.Observable.merge( // kick off subscription with a one-time query on start
    _rxjsCompatUmdMin.Observable.of(document.hasFocus()), _rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'focus').mapTo(true), _rxjsCompatUmdMin.Observable.fromEvent(browserWindow, 'blur').mapTo(false)).distinctUntilChanged().switchMap(isFocused => isFocused ? blockedEvents : _rxjsCompatUmdMin.Observable.empty()).map(entry => entry.duration);
  }).share();
});
var _default = observeStalls;
/*
 * Often times users take an action and can resonably expect a long, blocking task
 * to run to completion before they can take action again:
 * https://developers.google.com/web/fundamentals/performance/rail#ux
 * This is analagous to a web page or app's initial loading, transitioning to
 * another significant view, etc.
 *
 * This is a decorator that wraps a function that pauses in response to user action,
 * opting it out of stall observation and forwarding any arguments passed and returning
 * the original function's return value.
 *
 * **Use this cautiously and deliberately, only in situations where it is
 * reasonable for a user to expect a pause!**
 *
 * If the action takes longer than 1s, we still record this as a stall, as it
 * fails the RAIL model's definition of responsive loading.
 */

exports.default = _default;

function intentionallyBlocksInResponseToUserAction(fn) {
  const intentionallyBlocks = function (...args) {
    const before = performance.now();
    const ret = fn.apply(this, args);

    if (performance.now() - before < 1000) {
      intentionalBlockTime = before;
    }

    return ret;
  };

  intentionallyBlocks.displayName = `intentionallyBlocks(${(0, _getDisplayName.default)(fn)})`;
  return intentionallyBlocks;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL29ic2VydmVTdGFsbHMuanMiXSwibmFtZXMiOlsicmVtb3RlIiwiQkxPQ0tFRF9HUkFDRV9QRVJJT0QiLCJCTE9DS0VEX01JTiIsIkJMT0NLRURfTUFYIiwiQkxPQ0tFRF9SQU5HRV9QQURESU5HIiwiaW50ZW50aW9uYWxCbG9ja1RpbWUiLCJvYnNlcnZlU3RhbGxzIiwiYnJvd3NlcldpbmRvdyIsImdldEN1cnJlbnRXaW5kb3ciLCJvbkludGVudGlvbmFsQmxvY2siLCJwZXJmb3JtYW5jZSIsIm5vdyIsImJsb2NrZWRFdmVudHMiLCJQZXJmb3JtYW5jZU9ic2VydmFibGUiLCJlbnRyeVR5cGVzIiwiZmxhdHRlbkVudHJpZXMiLCJmaWx0ZXIiLCJkb2N1bWVudCIsImhhc0ZvY3VzIiwicHJvY2VzcyIsInVwdGltZSIsImVudHJ5IiwiZHVyYXRpb24iLCJzdGFydFRpbWUiLCJPYnNlcnZhYmxlIiwidXNpbmciLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwiYXRvbSIsIndvcmtzcGFjZSIsIm9uV2lsbERlc3Ryb3lQYW5lSXRlbSIsImZyb21FdmVudCIsInRha2VVbnRpbCIsInN1YnNjcmliZSIsIm1lcmdlIiwib2YiLCJtYXBUbyIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwic3dpdGNoTWFwIiwiaXNGb2N1c2VkIiwiZW1wdHkiLCJtYXAiLCJzaGFyZSIsImludGVudGlvbmFsbHlCbG9ja3NJblJlc3BvbnNlVG9Vc2VyQWN0aW9uIiwiZm4iLCJpbnRlbnRpb25hbGx5QmxvY2tzIiwiYXJncyIsImJlZm9yZSIsInJldCIsImFwcGx5IiwiZGlzcGxheU5hbWUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBY0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQVdBLHFCQUFV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QVosRUFBNEI7QUFDdEQsVUFBTUMsTUFBTSxHQUFHcEMsV0FBVyxDQUFDQyxHQUFaLEVBQWY7QUFDQSxVQUFNb0MsR0FBRyxHQUFHSixFQUFFLENBQUNLLEtBQUgsQ0FBUyxJQUFULEVBQWVILElBQWYsQ0FBWjs7QUFDQSxRQUFJbkMsV0FBVyxDQUFDQyxHQUFaLEtBQW9CbUMsTUFBcEIsR0FBNkIsSUFBakMsRUFBdUM7QUFDckN6QyxNQUFBQSxvQkFBb0IsR0FBR3lDLE1BQXZCO0FBQ0Q7O0FBRUQsV0FBT0MsR0FBUDtBQUNELEdBUkQ7O0FBVUFILEVBQUFBLG1CQUFtQixDQUFDSyxXQUFwQixHQUFtQyx1QkFBc0IsNkJBQ3ZETixFQUR1RCxDQUV2RCxHQUZGO0FBR0EsU0FBT0MsbUJBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3cgc3RyaWN0LWxvY2FsXHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuaW1wb3J0IGdldERpc3BsYXlOYW1lIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL2dldERpc3BsYXlOYW1lJztcclxuaW1wb3J0IHtyZW1vdGV9IGZyb20gJ2VsZWN0cm9uJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5pbXBvcnQge1BlcmZvcm1hbmNlT2JzZXJ2YWJsZX0gZnJvbSAnLi9vYnNlcnZhYmxlLWRvbSc7XHJcblxyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IG9uY2UgZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvb25jZSc7XHJcblxyXG5pbnZhcmlhbnQocmVtb3RlICE9IG51bGwpO1xyXG5cclxuLy8gVGhlIHN0YXJ0dXAgcGVyaW9kIG5hdHVyYWxseSBjYXVzZXMgbWFueSBldmVudCBsb29wIGJsb2NrYWdlcy5cclxuLy8gRG9uJ3Qgc3RhcnQgY2hlY2tpbmcgYmxvY2thZ2VzIHVudGlsIHNvbWUgdGltZSBoYXMgcGFzc2VkLlxyXG5jb25zdCBCTE9DS0VEX0dSQUNFX1BFUklPRCA9IDMwO1xyXG4vLyBSZXBvcnQgYWxsIGJsb2NrYWdlcyBvdmVyIHRoaXMgdGhyZXNob2xkLlxyXG5jb25zdCBCTE9DS0VEX01JTiA9IDEwMDtcclxuLy8gRGlzY2FyZCBvdmVybHkgbG9uZyBibG9ja2FnZXMgYXMgc3B1cmlvdXMgKGUuZy4gY29tcHV0ZXIgd2FzIGFzbGVlcClcclxuY29uc3QgQkxPQ0tFRF9NQVggPSA2MCAqIDEwMDA7IC8vIDEgbWludXRlIGluIG1zXHJcbi8vIFJhbmdlIHBhZGRpbmcgb24gZWl0aGVyIHNpZGUgb2YgbG9uZyB0YXNrIGludGVydmFsLlxyXG4vLyBJZiBhbiBpbnRlbnRpb25hbCBibG9jayB0aW1lc3RhbXAgbGllcyBpbiB0aGlzIHJhbmdlLFxyXG4vLyB3ZSBjb25zaWRlciBpdCBpbnRlbnRpb25hbC5cclxuY29uc3QgQkxPQ0tFRF9SQU5HRV9QQURESU5HID0gMTU7XHJcblxyXG5sZXQgaW50ZW50aW9uYWxCbG9ja1RpbWUgPSAwO1xyXG5cclxuLy8gU2hhcmUgKyBjYWNoZSB0aGUgb2JzZXJ2YWJsZS5cclxuLy8gJEZsb3dGaXhNZSAoPj0wLjg1LjApIChUMzU5ODY4OTYpIEZsb3cgdXBncmFkZSBzdXBwcmVzc1xyXG5jb25zdCBvYnNlcnZlU3RhbGxzID0gb25jZShcclxuICAoKTogT2JzZXJ2YWJsZTxudW1iZXI+ID0+IHtcclxuICAgIGNvbnN0IGJyb3dzZXJXaW5kb3cgPSByZW1vdGUuZ2V0Q3VycmVudFdpbmRvdygpO1xyXG5cclxuICAgIGNvbnN0IG9uSW50ZW50aW9uYWxCbG9jayA9ICgpID0+IHtcclxuICAgICAgaW50ZW50aW9uYWxCbG9ja1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYmxvY2tlZEV2ZW50cyA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmFibGUoe2VudHJ5VHlwZXM6IFsnbG9uZ3Rhc2snXX0pXHJcbiAgICAgIC5mbGF0dGVuRW50cmllcygpXHJcbiAgICAgIC8vIG9ubHkgY291bnQgaWYgdGhlIHdpbmRvdyBpcyBmb2N1c2VkIHdoZW4gdGhlIHRhc2sgcmFuIGxvbmdcclxuICAgICAgLmZpbHRlcigoKSA9PiBkb2N1bWVudC5oYXNGb2N1cygpKVxyXG4gICAgICAvLyBkaXNjYXJkIGVhcmx5IGxvbmd0YXNrcyBhcyB0aGUgYXBwIGlzIGJvb3RpbmdcclxuICAgICAgLmZpbHRlcigoKSA9PiBwcm9jZXNzLnVwdGltZSgpID4gQkxPQ0tFRF9HUkFDRV9QRVJJT0QpXHJcbiAgICAgIC8vIGRpc2NhcmQgZHVyYXRpb25zIHRoYXQgYXJlIHVucmVhbGlzdGljYWxseSBsb25nLCBvciB0aG9zZSB0aGF0IGFyZW4ndFxyXG4gICAgICAvLyBtZWFuaW5nZnVsIGVub3VnaFxyXG4gICAgICAuZmlsdGVyKFxyXG4gICAgICAgIGVudHJ5ID0+IGVudHJ5LmR1cmF0aW9uID4gQkxPQ0tFRF9NSU4gJiYgZW50cnkuZHVyYXRpb24gPCBCTE9DS0VEX01BWCxcclxuICAgICAgKVxyXG4gICAgICAvLyBkaXNjYXJkIGV2ZW50cyB0aGF0IHJlc3VsdCBmcm9tIHVzZXIgaW50ZXJhY3Rpb24gYWN0dWFsbHkgYmxvY2tpbmcgdGhlXHJcbiAgICAgIC8vIHRocmVhZCB3aGVuIHRoZXJlIGlzIG5vIG90aGVyIG9wdGlvbiAoZS5nLiBjb250ZXh0IG1lbnVzKVxyXG4gICAgICAuZmlsdGVyKFxyXG4gICAgICAgIGVudHJ5ID0+XHJcbiAgICAgICAgICAvLyBkaWQgdGhlIGludGVudGlvbmFsYmxvY2t0aW1lIG9jY3VyIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQsXHJcbiAgICAgICAgICAvLyBhY2NvdW50aW5nIGZvciBzb21lIGV4dHJhIHBhZGRpbmc/XHJcbiAgICAgICAgICAhKFxyXG4gICAgICAgICAgICBpbnRlbnRpb25hbEJsb2NrVGltZSA+IGVudHJ5LnN0YXJ0VGltZSAtIEJMT0NLRURfUkFOR0VfUEFERElORyAmJlxyXG4gICAgICAgICAgICBpbnRlbnRpb25hbEJsb2NrVGltZSA8XHJcbiAgICAgICAgICAgICAgZW50cnkuc3RhcnRUaW1lICsgZW50cnkuZHVyYXRpb24gKyBCTE9DS0VEX1JBTkdFX1BBRERJTkdcclxuICAgICAgICAgICksXHJcbiAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuIE9ic2VydmFibGUudXNpbmcoXHJcbiAgICAgICgpID0+XHJcbiAgICAgICAgbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoXHJcbiAgICAgICAgICAvLyBDb25maXJtYXRpb24gZGlhbG9ncyBhbHNvIGJsb2NrIHRoZSBldmVudCBsb29wLlxyXG4gICAgICAgICAgLy8gVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIHlvdSdyZSBhYm91dCB0byBjbG9zZSBhbiB1bnNhdmVkIGZpbGUuXHJcbiAgICAgICAgICBhdG9tLndvcmtzcGFjZS5vbldpbGxEZXN0cm95UGFuZUl0ZW0ob25JbnRlbnRpb25hbEJsb2NrKSxcclxuICAgICAgICAgIC8vIEVsZWN0cm9uIGNvbnRleHQgbWVudXMgYmxvY2sgdGhlIGV2ZW50IGxvb3AuXHJcbiAgICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudChicm93c2VyV2luZG93LCAnY29udGV4dC1tZW51JylcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXBwZWFycyB0byBiZSBhbiByYWNlIHdpdGggYnJvd3NlciB3aW5kb3cgc2h1dGRvd24gd2hlcmVcclxuICAgICAgICAgICAgLy8gdGhlICdjb250ZXh0LW1lbnUnIGV2ZW50IGZpcmVzIGFmdGVyIHdpbmRvdyBkZXN0cnVjdGlvbi5cclxuICAgICAgICAgICAgLy8gVHJ5IHRvIHByZXZlbnQgdGhpcyBieSByZW1vdmluZyB0aGUgZXZlbnQgb24gY2xvc2UuXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9udWNsaWRlL2lzc3Vlcy8xMjQ2XHJcbiAgICAgICAgICAgIC50YWtlVW50aWwoT2JzZXJ2YWJsZS5mcm9tRXZlbnQoYnJvd3NlcldpbmRvdywgJ2Nsb3NlJykpXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUob25JbnRlbnRpb25hbEJsb2NrKSxcclxuICAgICAgICApLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUubWVyZ2UoXHJcbiAgICAgICAgICAvLyBraWNrIG9mZiBzdWJzY3JpcHRpb24gd2l0aCBhIG9uZS10aW1lIHF1ZXJ5IG9uIHN0YXJ0XHJcbiAgICAgICAgICBPYnNlcnZhYmxlLm9mKGRvY3VtZW50Lmhhc0ZvY3VzKCkpLFxyXG4gICAgICAgICAgT2JzZXJ2YWJsZS5mcm9tRXZlbnQoYnJvd3NlcldpbmRvdywgJ2ZvY3VzJykubWFwVG8odHJ1ZSksXHJcbiAgICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudChicm93c2VyV2luZG93LCAnYmx1cicpLm1hcFRvKGZhbHNlKSxcclxuICAgICAgICApXHJcbiAgICAgICAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxyXG4gICAgICAgICAgLnN3aXRjaE1hcChcclxuICAgICAgICAgICAgaXNGb2N1c2VkID0+IChpc0ZvY3VzZWQgPyBibG9ja2VkRXZlbnRzIDogT2JzZXJ2YWJsZS5lbXB0eSgpKSxcclxuICAgICAgICAgIClcclxuICAgICAgICAgIC5tYXAoZW50cnkgPT4gZW50cnkuZHVyYXRpb24pO1xyXG4gICAgICB9LFxyXG4gICAgKS5zaGFyZSgpO1xyXG4gIH0sXHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBvYnNlcnZlU3RhbGxzO1xyXG5cclxuLypcclxuICogT2Z0ZW4gdGltZXMgdXNlcnMgdGFrZSBhbiBhY3Rpb24gYW5kIGNhbiByZXNvbmFibHkgZXhwZWN0IGEgbG9uZywgYmxvY2tpbmcgdGFza1xyXG4gKiB0byBydW4gdG8gY29tcGxldGlvbiBiZWZvcmUgdGhleSBjYW4gdGFrZSBhY3Rpb24gYWdhaW46XHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3dlYi9mdW5kYW1lbnRhbHMvcGVyZm9ybWFuY2UvcmFpbCN1eFxyXG4gKiBUaGlzIGlzIGFuYWxhZ291cyB0byBhIHdlYiBwYWdlIG9yIGFwcCdzIGluaXRpYWwgbG9hZGluZywgdHJhbnNpdGlvbmluZyB0b1xyXG4gKiBhbm90aGVyIHNpZ25pZmljYW50IHZpZXcsIGV0Yy5cclxuICpcclxuICogVGhpcyBpcyBhIGRlY29yYXRvciB0aGF0IHdyYXBzIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb24sXHJcbiAqIG9wdGluZyBpdCBvdXQgb2Ygc3RhbGwgb2JzZXJ2YXRpb24gYW5kIGZvcndhcmRpbmcgYW55IGFyZ3VtZW50cyBwYXNzZWQgYW5kIHJldHVybmluZ1xyXG4gKiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUuXHJcbiAqXHJcbiAqICoqVXNlIHRoaXMgY2F1dGlvdXNseSBhbmQgZGVsaWJlcmF0ZWx5LCBvbmx5IGluIHNpdHVhdGlvbnMgd2hlcmUgaXQgaXNcclxuICogcmVhc29uYWJsZSBmb3IgYSB1c2VyIHRvIGV4cGVjdCBhIHBhdXNlISoqXHJcbiAqXHJcbiAqIElmIHRoZSBhY3Rpb24gdGFrZXMgbG9uZ2VyIHRoYW4gMXMsIHdlIHN0aWxsIHJlY29yZCB0aGlzIGFzIGEgc3RhbGwsIGFzIGl0XHJcbiAqIGZhaWxzIHRoZSBSQUlMIG1vZGVsJ3MgZGVmaW5pdGlvbiBvZiByZXNwb25zaXZlIGxvYWRpbmcuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW50ZW50aW9uYWxseUJsb2Nrc0luUmVzcG9uc2VUb1VzZXJBY3Rpb248VCwgVT4oXHJcbiAgZm46ICguLi5hcmdzOiBBcnJheTxUPikgPT4gVSxcclxuKTogKC4uLmFyZ3M6IEFycmF5PFQ+KSA9PiBVIHtcclxuICBjb25zdCBpbnRlbnRpb25hbGx5QmxvY2tzID0gZnVuY3Rpb24oLi4uYXJnczogQXJyYXk8VD4pIHtcclxuICAgIGNvbnN0IGJlZm9yZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgY29uc3QgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBiZWZvcmUgPCAxMDAwKSB7XHJcbiAgICAgIGludGVudGlvbmFsQmxvY2tUaW1lID0gYmVmb3JlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbiAgfTtcclxuXHJcbiAgaW50ZW50aW9uYWxseUJsb2Nrcy5kaXNwbGF5TmFtZSA9IGBpbnRlbnRpb25hbGx5QmxvY2tzKCR7Z2V0RGlzcGxheU5hbWUoXHJcbiAgICBmbixcclxuICApfSlgO1xyXG4gIHJldHVybiBpbnRlbnRpb25hbGx5QmxvY2tzO1xyXG59XHJcbiJdfQ==