"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = openPreview;

var _goToLocation = require("@atom-ide-community/nuclide-commons-atom/go-to-location");

var _paneItem = require("@atom-ide-community/nuclide-commons-atom/pane-item");

var _promise = require("@atom-ide-community/nuclide-commons/promise");

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
let preview;
let marker;
let originalPoint;
let lastOpenablePreview;
let activeOpenableId = 0; // Previews a particular destination using goToLocation. This may involve opening
// a new pane if the destination uri is not the active item. However, if the
// user has disabled preview panes, we won't show them a preview.
// openPreview supports being called many times, and it deallocates prior
// previews on its own when this happens. It also returns the user's focus when
// to the original destination when cancelled. This *could* be implemented using
// a stack, but this simpler implementation just holds global references and restores
// focus using the active item and position that was present when the first preview occurred.

function openPreview(uri, // $FlowIgnore
options = {}, openDelay = 0) {
  const {
    line,
    column
  } = options;
  const thisOpenableId = ++activeOpenableId;

  if (lastOpenablePreview != null) {
    lastOpenablePreview.cancel();
  }

  let canceled;
  let confirmed;
  const activeItem = atom.workspace.getActivePaneItem();
  const activeEditor = atom.workspace.getActiveTextEditor();

  if (preview == null && activeItem != null) {
    // this is the first preview in a potential "stack" of previews.
    // persist the current position so we can return to it later.
    originalPoint = {
      item: activeItem,
      point: activeItem === activeEditor && activeEditor != null ? activeEditor.getCursorBufferPosition() : null
    };
  }

  const isWithinSameFile = uri === (activeEditor && activeEditor.getURI());
  const arePendingPanesEnabled = Boolean(atom.config.get('core.allowPendingPaneItems'));
  let promise;

  if (isWithinSameFile || arePendingPanesEnabled) {
    // a common case is scrolling through many results, cancelling one after
    // the other. give things a chance to cancel before going throught the work
    // of rendering a preview
    promise = (0, _promise.delayTime)(openDelay).then(() => {
      if (preview != null && (0, _paneItem.isPending)(preview) && preview.isModified()) {
        // To avoid leaving behind a "Save changes before close?" dialog, forcefully
        // destroy any pane that is both pending *and* modified
        preview.destroy();
      }

      if (canceled) {
        return Promise.resolve();
      } else {
        return (0, _goToLocation.goToLocation)(uri, {
          line,
          column,
          center: true,
          activateItem: true,
          activatePane: false,
          pending: true,
          moveCursor: false
        }).then(newPreview => {
          if (canceled && (0, _paneItem.isPending)(newPreview) && // don't destroy the pane if it's not new (e.g. within the same file --
          // like a symbol within the originating file)
          originalPoint != null && newPreview !== originalPoint.item) {
            newPreview.destroy();
            return;
          } // the pane may have been reused: e.g. previewing a line in the same file
          // so make sure it wasn't. Then destroy the old preview if it's not the
          // original pane.


          if (preview != null && (0, _paneItem.isPending)(preview) && preview !== newPreview) {
            preview.destroy();
          }

          if (marker != null) {
            marker.destroy();
            marker = null;
          }

          preview = newPreview; // highlight the relevant line (and possibly point if there's a column)
          // if a line is provided in the options

          if (line != null) {
            marker = preview.markBufferPosition({
              row: line,
              column: column == null ? 0 : column
            });
            preview.decorateMarker(marker, {
              type: 'line',
              class: 'nuclide-line-preview'
            });
          }

          return newPreview;
        });
      }
    });
  } else {
    promise = Promise.resolve();
  }

  const openablePreview = {
    cancel() {
      canceled = true;

      if (activeOpenableId !== thisOpenableId) {
        // the next preview has cleaned up our markers for us
        return;
      }

      if (confirmed) {
        throw new Error('A preview cannot be cancelled after it has been confirmed.');
      }

      if (preview != null && (originalPoint == null || preview !== originalPoint.item)) {
        preview.destroy();
      }

      preview = null;

      if (marker != null) {
        marker.destroy();
        marker = null;
      }
    },

    confirm() {
      if (activeOpenableId !== thisOpenableId) {
        // another preview is currently being shown
        throw new Error('Another preview has become active after this one was shown. Cannot confirm.');
      }

      if (canceled) {
        throw new Error('A preview cannot be confirmed after it has been cancelled');
      }

      confirmed = true;
      const goToLocationPromise = (0, _goToLocation.goToLocation)(uri, options).then(newEditor => {
        newEditor.terminatePendingState();

        if (preview != null && preview !== newEditor && (originalPoint == null || preview !== originalPoint.item)) {
          // This case seems very unlikely: if the editor opened on confirmation
          // is not the same editor that was used for the preview pane, destroy
          // the preview pane
          preview.destroy();
        }
      });

      if (marker != null) {
        marker.destroy();
        marker = null;
      }

      preview = null;
      return goToLocationPromise;
    },

    // exported for test
    _promise: promise
  };
  lastOpenablePreview = openablePreview;
  return openablePreview;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zLXVpL29wZW5QcmV2aWV3LmpzIl0sIm5hbWVzIjpbInByZXZpZXciLCJtYXJrZXIiLCJvcmlnaW5hbFBvaW50IiwibGFzdE9wZW5hYmxlUHJldmlldyIsImFjdGl2ZU9wZW5hYmxlSWQiLCJvcGVuUHJldmlldyIsInVyaSIsIm9wdGlvbnMiLCJvcGVuRGVsYXkiLCJsaW5lIiwiY29sdW1uIiwidGhpc09wZW5hYmxlSWQiLCJjYW5jZWwiLCJjYW5jZWxlZCIsImNvbmZpcm1lZCIsImFjdGl2ZUl0ZW0iLCJhdG9tIiwid29ya3NwYWNlIiwiZ2V0QWN0aXZlUGFuZUl0ZW0iLCJhY3RpdmVFZGl0b3IiLCJnZXRBY3RpdmVUZXh0RWRpdG9yIiwiaXRlbSIsInBvaW50IiwiZ2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24iLCJpc1dpdGhpblNhbWVGaWxlIiwiZ2V0VVJJIiwiYXJlUGVuZGluZ1BhbmVzRW5hYmxlZCIsIkJvb2xlYW4iLCJjb25maWciLCJnZXQiLCJwcm9taXNlIiwidGhlbiIsImlzTW9kaWZpZWQiLCJkZXN0cm95IiwiUHJvbWlzZSIsInJlc29sdmUiLCJjZW50ZXIiLCJhY3RpdmF0ZUl0ZW0iLCJhY3RpdmF0ZVBhbmUiLCJwZW5kaW5nIiwibW92ZUN1cnNvciIsIm5ld1ByZXZpZXciLCJtYXJrQnVmZmVyUG9zaXRpb24iLCJyb3ciLCJkZWNvcmF0ZU1hcmtlciIsInR5cGUiLCJjbGFzcyIsIm9wZW5hYmxlUHJldmlldyIsIkVycm9yIiwiY29uZmlybSIsImdvVG9Mb2NhdGlvblByb21pc2UiLCJuZXdFZGl0b3IiLCJ0ZXJtaW5hdGVQZW5kaW5nU3RhdGUiLCJfcHJvbWlzZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWVBOztBQUNBOztBQUNBOztBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZUEsSUFBSUEsT0FBSjtBQUNBLElBQUlDLE1BQUo7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Z2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7TnVjbGlkZVVyaX0gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvbnVjbGlkZVVyaSc7XHJcblxyXG5pbXBvcnQgdHlwZSB7R29Ub0xvY2F0aW9uT3B0aW9uc30gZnJvbSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMtYXRvbS9nby10by1sb2NhdGlvbic7XHJcbmltcG9ydCB7Z29Ub0xvY2F0aW9ufSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy1hdG9tL2dvLXRvLWxvY2F0aW9uJztcclxuaW1wb3J0IHtpc1BlbmRpbmd9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zLWF0b20vcGFuZS1pdGVtJztcclxuaW1wb3J0IHtkZWxheVRpbWV9IGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL3Byb21pc2UnO1xyXG5cclxudHlwZSBPcGVuYWJsZVByZXZpZXcgPSB7fFxyXG4gIGNhbmNlbDogKCkgPT4gdm9pZCxcclxuICBjb25maXJtOiAoKSA9PiBQcm9taXNlPD9hdG9tJFRleHRFZGl0b3I+LFxyXG4gIF9wcm9taXNlOiBQcm9taXNlPD9hdG9tJFRleHRFZGl0b3I+LFxyXG58fTtcclxuXHJcbmxldCBwcmV2aWV3OiA/YXRvbSRUZXh0RWRpdG9yO1xyXG5sZXQgbWFya2VyOiA/YXRvbSRNYXJrZXI7XHJcbmxldCBvcmlnaW5hbFBvaW50OiA/e1xyXG4gIGl0ZW06IGF0b20kUGFuZUl0ZW0sXHJcbiAgcG9pbnQ6ID9hdG9tJFBvaW50LFxyXG59O1xyXG5sZXQgbGFzdE9wZW5hYmxlUHJldmlldzogP09wZW5hYmxlUHJldmlldztcclxuXHJcbmxldCBhY3RpdmVPcGVuYWJsZUlkID0gMDtcclxuXHJcbi8vIFByZXZpZXdzIGEgcGFydGljdWxhciBkZXN0aW5hdGlvbiB1c2luZyBnb1RvTG9jYXRpb24uIFRoaXMgbWF5IGludm9sdmUgb3BlbmluZ1xyXG4vLyBhIG5ldyBwYW5lIGlmIHRoZSBkZXN0aW5hdGlvbiB1cmkgaXMgbm90IHRoZSBhY3RpdmUgaXRlbS4gSG93ZXZlciwgaWYgdGhlXHJcbi8vIHVzZXIgaGFzIGRpc2FibGVkIHByZXZpZXcgcGFuZXMsIHdlIHdvbid0IHNob3cgdGhlbSBhIHByZXZpZXcuXHJcblxyXG4vLyBvcGVuUHJldmlldyBzdXBwb3J0cyBiZWluZyBjYWxsZWQgbWFueSB0aW1lcywgYW5kIGl0IGRlYWxsb2NhdGVzIHByaW9yXHJcbi8vIHByZXZpZXdzIG9uIGl0cyBvd24gd2hlbiB0aGlzIGhhcHBlbnMuIEl0IGFsc28gcmV0dXJucyB0aGUgdXNlcidzIGZvY3VzIHdoZW5cclxuLy8gdG8gdGhlIG9yaWdpbmFsIGRlc3RpbmF0aW9uIHdoZW4gY2FuY2VsbGVkLiBUaGlzICpjb3VsZCogYmUgaW1wbGVtZW50ZWQgdXNpbmdcclxuLy8gYSBzdGFjaywgYnV0IHRoaXMgc2ltcGxlciBpbXBsZW1lbnRhdGlvbiBqdXN0IGhvbGRzIGdsb2JhbCByZWZlcmVuY2VzIGFuZCByZXN0b3Jlc1xyXG4vLyBmb2N1cyB1c2luZyB0aGUgYWN0aXZlIGl0ZW0gYW5kIHBvc2l0aW9uIHRoYXQgd2FzIHByZXNlbnQgd2hlbiB0aGUgZmlyc3QgcHJldmlldyBvY2N1cnJlZC5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3BlblByZXZpZXcoXHJcbiAgdXJpOiBOdWNsaWRlVXJpLFxyXG4gIC8vICRGbG93SWdub3JlXHJcbiAgb3B0aW9ucz86IEdvVG9Mb2NhdGlvbk9wdGlvbnMgPSB7fSxcclxuICBvcGVuRGVsYXk/OiBudW1iZXIgPSAwLFxyXG4pOiBPcGVuYWJsZVByZXZpZXcge1xyXG4gIGNvbnN0IHtsaW5lLCBjb2x1bW59ID0gb3B0aW9ucztcclxuICBjb25zdCB0aGlzT3BlbmFibGVJZCA9ICsrYWN0aXZlT3BlbmFibGVJZDtcclxuXHJcbiAgaWYgKGxhc3RPcGVuYWJsZVByZXZpZXcgIT0gbnVsbCkge1xyXG4gICAgbGFzdE9wZW5hYmxlUHJldmlldy5jYW5jZWwoKTtcclxuICB9XHJcblxyXG4gIGxldCBjYW5jZWxlZDtcclxuICBsZXQgY29uZmlybWVkO1xyXG5cclxuICBjb25zdCBhY3RpdmVJdGVtID0gYXRvbS53b3Jrc3BhY2UuZ2V0QWN0aXZlUGFuZUl0ZW0oKTtcclxuICBjb25zdCBhY3RpdmVFZGl0b3IgPSBhdG9tLndvcmtzcGFjZS5nZXRBY3RpdmVUZXh0RWRpdG9yKCk7XHJcblxyXG4gIGlmIChwcmV2aWV3ID09IG51bGwgJiYgYWN0aXZlSXRlbSAhPSBudWxsKSB7XHJcbiAgICAvLyB0aGlzIGlzIHRoZSBmaXJzdCBwcmV2aWV3IGluIGEgcG90ZW50aWFsIFwic3RhY2tcIiBvZiBwcmV2aWV3cy5cclxuICAgIC8vIHBlcnNpc3QgdGhlIGN1cnJlbnQgcG9zaXRpb24gc28gd2UgY2FuIHJldHVybiB0byBpdCBsYXRlci5cclxuICAgIG9yaWdpbmFsUG9pbnQgPSB7XHJcbiAgICAgIGl0ZW06IGFjdGl2ZUl0ZW0sXHJcbiAgICAgIHBvaW50OlxyXG4gICAgICAgIGFjdGl2ZUl0ZW0gPT09IGFjdGl2ZUVkaXRvciAmJiBhY3RpdmVFZGl0b3IgIT0gbnVsbFxyXG4gICAgICAgICAgPyBhY3RpdmVFZGl0b3IuZ2V0Q3Vyc29yQnVmZmVyUG9zaXRpb24oKVxyXG4gICAgICAgICAgOiBudWxsLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGlzV2l0aGluU2FtZUZpbGUgPSB1cmkgPT09IChhY3RpdmVFZGl0b3IgJiYgYWN0aXZlRWRpdG9yLmdldFVSSSgpKTtcclxuICBjb25zdCBhcmVQZW5kaW5nUGFuZXNFbmFibGVkID0gQm9vbGVhbihcclxuICAgIGF0b20uY29uZmlnLmdldCgnY29yZS5hbGxvd1BlbmRpbmdQYW5lSXRlbXMnKSxcclxuICApO1xyXG5cclxuICBsZXQgcHJvbWlzZTtcclxuICBpZiAoaXNXaXRoaW5TYW1lRmlsZSB8fCBhcmVQZW5kaW5nUGFuZXNFbmFibGVkKSB7XHJcbiAgICAvLyBhIGNvbW1vbiBjYXNlIGlzIHNjcm9sbGluZyB0aHJvdWdoIG1hbnkgcmVzdWx0cywgY2FuY2VsbGluZyBvbmUgYWZ0ZXJcclxuICAgIC8vIHRoZSBvdGhlci4gZ2l2ZSB0aGluZ3MgYSBjaGFuY2UgdG8gY2FuY2VsIGJlZm9yZSBnb2luZyB0aHJvdWdodCB0aGUgd29ya1xyXG4gICAgLy8gb2YgcmVuZGVyaW5nIGEgcHJldmlld1xyXG4gICAgcHJvbWlzZSA9IGRlbGF5VGltZShvcGVuRGVsYXkpLnRoZW4oKCkgPT4ge1xyXG4gICAgICBpZiAocHJldmlldyAhPSBudWxsICYmIGlzUGVuZGluZyhwcmV2aWV3KSAmJiBwcmV2aWV3LmlzTW9kaWZpZWQoKSkge1xyXG4gICAgICAgIC8vIFRvIGF2b2lkIGxlYXZpbmcgYmVoaW5kIGEgXCJTYXZlIGNoYW5nZXMgYmVmb3JlIGNsb3NlP1wiIGRpYWxvZywgZm9yY2VmdWxseVxyXG4gICAgICAgIC8vIGRlc3Ryb3kgYW55IHBhbmUgdGhhdCBpcyBib3RoIHBlbmRpbmcgKmFuZCogbW9kaWZpZWRcclxuICAgICAgICBwcmV2aWV3LmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhbmNlbGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBnb1RvTG9jYXRpb24odXJpLCB7XHJcbiAgICAgICAgICBsaW5lLFxyXG4gICAgICAgICAgY29sdW1uLFxyXG4gICAgICAgICAgY2VudGVyOiB0cnVlLFxyXG4gICAgICAgICAgYWN0aXZhdGVJdGVtOiB0cnVlLFxyXG4gICAgICAgICAgYWN0aXZhdGVQYW5lOiBmYWxzZSxcclxuICAgICAgICAgIHBlbmRpbmc6IHRydWUsXHJcbiAgICAgICAgICBtb3ZlQ3Vyc29yOiBmYWxzZSxcclxuICAgICAgICB9KS50aGVuKG5ld1ByZXZpZXcgPT4ge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBjYW5jZWxlZCAmJlxyXG4gICAgICAgICAgICBpc1BlbmRpbmcobmV3UHJldmlldykgJiZcclxuICAgICAgICAgICAgLy8gZG9uJ3QgZGVzdHJveSB0aGUgcGFuZSBpZiBpdCdzIG5vdCBuZXcgKGUuZy4gd2l0aGluIHRoZSBzYW1lIGZpbGUgLS1cclxuICAgICAgICAgICAgLy8gbGlrZSBhIHN5bWJvbCB3aXRoaW4gdGhlIG9yaWdpbmF0aW5nIGZpbGUpXHJcbiAgICAgICAgICAgIG9yaWdpbmFsUG9pbnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBuZXdQcmV2aWV3ICE9PSBvcmlnaW5hbFBvaW50Lml0ZW1cclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBuZXdQcmV2aWV3LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHRoZSBwYW5lIG1heSBoYXZlIGJlZW4gcmV1c2VkOiBlLmcuIHByZXZpZXdpbmcgYSBsaW5lIGluIHRoZSBzYW1lIGZpbGVcclxuICAgICAgICAgIC8vIHNvIG1ha2Ugc3VyZSBpdCB3YXNuJ3QuIFRoZW4gZGVzdHJveSB0aGUgb2xkIHByZXZpZXcgaWYgaXQncyBub3QgdGhlXHJcbiAgICAgICAgICAvLyBvcmlnaW5hbCBwYW5lLlxyXG4gICAgICAgICAgaWYgKHByZXZpZXcgIT0gbnVsbCAmJiBpc1BlbmRpbmcocHJldmlldykgJiYgcHJldmlldyAhPT0gbmV3UHJldmlldykge1xyXG4gICAgICAgICAgICBwcmV2aWV3LmRlc3Ryb3koKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAobWFya2VyICE9IG51bGwpIHtcclxuICAgICAgICAgICAgbWFya2VyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgbWFya2VyID0gbnVsbDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwcmV2aWV3ID0gbmV3UHJldmlldztcclxuXHJcbiAgICAgICAgICAvLyBoaWdobGlnaHQgdGhlIHJlbGV2YW50IGxpbmUgKGFuZCBwb3NzaWJseSBwb2ludCBpZiB0aGVyZSdzIGEgY29sdW1uKVxyXG4gICAgICAgICAgLy8gaWYgYSBsaW5lIGlzIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zXHJcbiAgICAgICAgICBpZiAobGluZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1hcmtlciA9IHByZXZpZXcubWFya0J1ZmZlclBvc2l0aW9uKHtcclxuICAgICAgICAgICAgICByb3c6IGxpbmUsXHJcbiAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4gPT0gbnVsbCA/IDAgOiBjb2x1bW4sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwcmV2aWV3LmRlY29yYXRlTWFya2VyKG1hcmtlciwge1xyXG4gICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICBjbGFzczogJ251Y2xpZGUtbGluZS1wcmV2aWV3JyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ld1ByZXZpZXc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBvcGVuYWJsZVByZXZpZXcgPSB7XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIGlmIChhY3RpdmVPcGVuYWJsZUlkICE9PSB0aGlzT3BlbmFibGVJZCkge1xyXG4gICAgICAgIC8vIHRoZSBuZXh0IHByZXZpZXcgaGFzIGNsZWFuZWQgdXAgb3VyIG1hcmtlcnMgZm9yIHVzXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29uZmlybWVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ0EgcHJldmlldyBjYW5ub3QgYmUgY2FuY2VsbGVkIGFmdGVyIGl0IGhhcyBiZWVuIGNvbmZpcm1lZC4nLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBwcmV2aWV3ICE9IG51bGwgJiZcclxuICAgICAgICAob3JpZ2luYWxQb2ludCA9PSBudWxsIHx8IHByZXZpZXcgIT09IG9yaWdpbmFsUG9pbnQuaXRlbSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgcHJldmlldy5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgICAgcHJldmlldyA9IG51bGw7XHJcblxyXG4gICAgICBpZiAobWFya2VyICE9IG51bGwpIHtcclxuICAgICAgICBtYXJrZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIG1hcmtlciA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb25maXJtKCkge1xyXG4gICAgICBpZiAoYWN0aXZlT3BlbmFibGVJZCAhPT0gdGhpc09wZW5hYmxlSWQpIHtcclxuICAgICAgICAvLyBhbm90aGVyIHByZXZpZXcgaXMgY3VycmVudGx5IGJlaW5nIHNob3duXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ0Fub3RoZXIgcHJldmlldyBoYXMgYmVjb21lIGFjdGl2ZSBhZnRlciB0aGlzIG9uZSB3YXMgc2hvd24uIENhbm5vdCBjb25maXJtLicsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhbmNlbGVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ0EgcHJldmlldyBjYW5ub3QgYmUgY29uZmlybWVkIGFmdGVyIGl0IGhhcyBiZWVuIGNhbmNlbGxlZCcsXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uZmlybWVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIGNvbnN0IGdvVG9Mb2NhdGlvblByb21pc2UgPSBnb1RvTG9jYXRpb24odXJpLCBvcHRpb25zKS50aGVuKG5ld0VkaXRvciA9PiB7XHJcbiAgICAgICAgbmV3RWRpdG9yLnRlcm1pbmF0ZVBlbmRpbmdTdGF0ZSgpO1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHByZXZpZXcgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgcHJldmlldyAhPT0gbmV3RWRpdG9yICYmXHJcbiAgICAgICAgICAob3JpZ2luYWxQb2ludCA9PSBudWxsIHx8IHByZXZpZXcgIT09IG9yaWdpbmFsUG9pbnQuaXRlbSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIC8vIFRoaXMgY2FzZSBzZWVtcyB2ZXJ5IHVubGlrZWx5OiBpZiB0aGUgZWRpdG9yIG9wZW5lZCBvbiBjb25maXJtYXRpb25cclxuICAgICAgICAgIC8vIGlzIG5vdCB0aGUgc2FtZSBlZGl0b3IgdGhhdCB3YXMgdXNlZCBmb3IgdGhlIHByZXZpZXcgcGFuZSwgZGVzdHJveVxyXG4gICAgICAgICAgLy8gdGhlIHByZXZpZXcgcGFuZVxyXG4gICAgICAgICAgcHJldmlldy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChtYXJrZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIG1hcmtlci5kZXN0cm95KCk7XHJcbiAgICAgICAgbWFya2VyID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBwcmV2aWV3ID0gbnVsbDtcclxuXHJcbiAgICAgIHJldHVybiBnb1RvTG9jYXRpb25Qcm9taXNlO1xyXG4gICAgfSxcclxuICAgIC8vIGV4cG9ydGVkIGZvciB0ZXN0XHJcbiAgICBfcHJvbWlzZTogcHJvbWlzZSxcclxuICB9O1xyXG5cclxuICBsYXN0T3BlbmFibGVQcmV2aWV3ID0gb3BlbmFibGVQcmV2aWV3O1xyXG4gIHJldHVybiBvcGVuYWJsZVByZXZpZXc7XHJcbn1cclxuIl19