"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FileResults = void 0;

var _atom = require("atom");

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
class FileResults {
  constructor(path, groups, pathMatch) {
    this.path = void 0;
    this.groups = void 0;
    this.pathMatch = void 0;
    this.path = path;
    this.groups = groups;
    this.pathMatch = pathMatch;
  } // Apply a grep filter to all line groups, splitting into new groups as necessary.
  // Pass `invert = true` to invert the grep filter.
  // When invert is false, regex match ranges will be added to each group's list of matches.


  filterGroups(regex, invert) {
    const filtered = [];
    this.groups.forEach(group => {
      let lines = [];
      let matches = [];
      let startLine = -1;
      let curMatch = 0;

      for (let i = 0; i < group.lines.length; i++) {
        const line = group.lines[i];
        const lineNum = group.startLine + i - 1; // $FlowFixMe (>= v0.75.0)

        const regexMatch = regex.exec(line);
        const matched = regexMatch == null === invert; // Keep all the existing match ranges only if the regex matched.

        while (curMatch < group.matches.length && group.matches[curMatch].start.row === lineNum) {
          if (matched) {
            matches.push(group.matches[curMatch]);
          }

          curMatch++;
        }

        if (!matched) {
          // A non-match means that we should split into a new group, if necessary.
          if (lines.length !== 0) {
            filtered.push({
              startLine,
              lines,
              matches
            });
            lines = [];
            matches = [];
          }
        } else {
          if (lines.length === 0) {
            startLine = lineNum + 1;
          }

          lines.push(line); // For non-invert matches, additionally highlight the first regex match.

          if (!invert) {
            const filterMatch = new _atom.Range([lineNum, regexMatch.index], [lineNum, regexMatch.index + regexMatch[0].length]); // Keep `matches` sorted via insertion sort.
            // This does not cause quadratic runtime, since this will only scan the previous line.

            for (let j = matches.length; j >= 0; j--) {
              if (j === 0 || matches[j - 1].compare(filterMatch) <= 0) {
                matches.splice(j, j, filterMatch);
                break;
              }
            }
          }
        }
      } // Finish off the current group.


      if (lines.length !== 0) {
        filtered.push({
          startLine,
          lines,
          matches
        });
      }
    });
    return filtered;
  } // Applies the grep filter to both filename and line groups.
  // Returns null if neither filename or line contents match.


  applyGrep(regex, invert) {
    const {
      path
    } = this;

    if (invert && regex.exec(path) != null) {
      return null;
    }

    const groups = this.filterGroups(regex, invert);

    if (groups.length === 0) {
      const fileMatch = regex.exec(path);

      if (fileMatch == null !== invert) {
        return null;
      }

      if (fileMatch != null) {
        return new FileResults(path, groups, [fileMatch.index, fileMatch.index + fileMatch[0].length]);
      }
    }

    return new FileResults(path, groups);
  }

}

exports.FileResults = FileResults;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL0ZpbGVSZXN1bHRzLmpzIl0sIm5hbWVzIjpbIkZpbGVSZXN1bHRzIiwiY29uc3RydWN0b3IiLCJwYXRoIiwiZ3JvdXBzIiwicGF0aE1hdGNoIiwiZmlsdGVyR3JvdXBzIiwicmVnZXgiLCJpbnZlcnQiLCJmaWx0ZXJlZCIsImZvckVhY2giLCJncm91cCIsImxpbmVzIiwibWF0Y2hlcyIsInN0YXJ0TGluZSIsImN1ck1hdGNoIiwiaSIsImxlbmd0aCIsImxpbmUiLCJsaW5lTnVtIiwicmVnZXhNYXRjaCIsImV4ZWMiLCJtYXRjaGVkIiwic3RhcnQiLCJyb3ciLCJwdXNoIiwiZmlsdGVyTWF0Y2giLCJSYW5nZSIsImluZGV4IiwiaiIsImNvbXBhcmUiLCJzcGxpY2UiLCJhcHBseUdyZXAiLCJmaWxlTWF0Y2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFZQTs7QUFaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVU8sTUFBTUEsV0FBTixDQUFrQjtBQUt2QkMsRUFBQUEsV0FBVyxDQUNUQyxJQURTLEVBRVRDLE1BRlMsRUFHVEMsU0FIUyxFQUlUO0FBQUEsU0FSRkYsSUFRRTtBQUFBLFNBUEZDLE1BT0U7QUFBQSxTQU5GQyxTQU1FO0FBQ0EsU0FBS0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQkEsU0FBakI7QUFDRCxHQWJzQixDQWV2QjtBQUNBO0FBQ0E7OztBQUNBQyxFQUFBQSxZQUFZLENBQUNDLEtBQUQsRUFBZ0JDLE1BQWhCLEVBQW1EO0FBQzdELFVBQU1DLFFBQVEsR0FBRyxFQUFqQjtBQUNBLFNBQUtMLE1BQUwsQ0FBWU0sT0FBWixDQUFvQkMsS0FBSyxJQUFJO0FBQzNCLFVBQUlDLEtBQUssR0FBRyxFQUFaO0FBQ0EsVUFBSUMsT0FBTyxHQUFHLEVBQWQ7QUFDQSxVQUFJQyxT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QUN0RCxVQUFNO0FBQUNMLE1BQUFBO0FBQUQsUUFBUyxJQUFmOztBQUNBLFFBQUlLLE1BQU0sSUFBSUQsS0FBSyxDQUFDYyxJQUFOLENBQVdsQixJQUFYLEtBQW9CLElBQWxDLEVBQXdDO0FBQ3RDLGFBQU8sSUFBUDtBQUNEOztBQUNELFVBQU1DLE1BQU0sR0FBRyxLQUFLRSxZQUFMLENBQWtCQyxLQUFsQixFQUF5QkMsTUFBekIsQ0FBZjs7QUFDQSxRQUFJSixNQUFNLENBQUNhLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkIsWUFBTWdCLFNBQVMsR0FBRzFCLEtBQUssQ0FBQ2MsSUFBTixDQUFXbEIsSUFBWCxDQUFsQjs7QUFDQSxVQUFLOEIsU0FBUyxJQUFJLElBQWQsS0FBd0J6QixNQUE1QixFQUFvQztBQUNsQyxlQUFPLElBQVA7QUFDRDs7QUFDRCxVQUFJeUIsU0FBUyxJQUFJLElBQWpCLEVBQXVCO0FBQ3JCLGVBQU8sSUFBSWhDLFdBQUosQ0FBZ0JFLElBQWhCLEVBQXNCQyxNQUF0QixFQUE4QixDQUNuQzZCLFNBQVMsQ0FBQ0wsS0FEeUIsRUFFbkNLLFNBQVMsQ0FBQ0wsS0FBVixHQUFrQkssU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhaEIsTUFGSSxDQUE5QixDQUFQO0FBSUQ7QUFDRjs7QUFDRCxXQUFPLElBQUloQixXQUFKLENBQWdCRSxJQUFoQixFQUFzQkMsTUFBdEIsQ0FBUDtBQUNEOztBQW5Hc0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQge1JhbmdlfSBmcm9tICdhdG9tJztcclxuXHJcbmV4cG9ydCB0eXBlIExpbmVHcm91cCA9IHtcclxuICBzdGFydExpbmU6IG51bWJlcixcclxuICBsaW5lczogQXJyYXk8c3RyaW5nPixcclxuICBtYXRjaGVzOiBBcnJheTxhdG9tJFJhbmdlPixcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBGaWxlUmVzdWx0cyB7XHJcbiAgcGF0aDogc3RyaW5nO1xyXG4gIGdyb3VwczogQXJyYXk8TGluZUdyb3VwPjtcclxuICBwYXRoTWF0Y2g6ID9bbnVtYmVyLCBudW1iZXJdO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHBhdGg6IHN0cmluZyxcclxuICAgIGdyb3VwczogQXJyYXk8TGluZUdyb3VwPixcclxuICAgIHBhdGhNYXRjaD86IFtudW1iZXIsIG51bWJlcl0sXHJcbiAgKSB7XHJcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgdGhpcy5ncm91cHMgPSBncm91cHM7XHJcbiAgICB0aGlzLnBhdGhNYXRjaCA9IHBhdGhNYXRjaDtcclxuICB9XHJcblxyXG4gIC8vIEFwcGx5IGEgZ3JlcCBmaWx0ZXIgdG8gYWxsIGxpbmUgZ3JvdXBzLCBzcGxpdHRpbmcgaW50byBuZXcgZ3JvdXBzIGFzIG5lY2Vzc2FyeS5cclxuICAvLyBQYXNzIGBpbnZlcnQgPSB0cnVlYCB0byBpbnZlcnQgdGhlIGdyZXAgZmlsdGVyLlxyXG4gIC8vIFdoZW4gaW52ZXJ0IGlzIGZhbHNlLCByZWdleCBtYXRjaCByYW5nZXMgd2lsbCBiZSBhZGRlZCB0byBlYWNoIGdyb3VwJ3MgbGlzdCBvZiBtYXRjaGVzLlxyXG4gIGZpbHRlckdyb3VwcyhyZWdleDogUmVnRXhwLCBpbnZlcnQ6IGJvb2xlYW4pOiBBcnJheTxMaW5lR3JvdXA+IHtcclxuICAgIGNvbnN0IGZpbHRlcmVkID0gW107XHJcbiAgICB0aGlzLmdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcclxuICAgICAgbGV0IGxpbmVzID0gW107XHJcbiAgICAgIGxldCBtYXRjaGVzID0gW107XHJcbiAgICAgIGxldCBzdGFydExpbmUgPSAtMTtcclxuICAgICAgbGV0IGN1ck1hdGNoID0gMDtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5saW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBncm91cC5saW5lc1tpXTtcclxuICAgICAgICBjb25zdCBsaW5lTnVtID0gZ3JvdXAuc3RhcnRMaW5lICsgaSAtIDE7XHJcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAoPj0gdjAuNzUuMClcclxuICAgICAgICBjb25zdCByZWdleE1hdGNoOiBSZWdFeHAkbWF0Y2hSZXN1bHQgPSByZWdleC5leGVjKGxpbmUpO1xyXG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSAocmVnZXhNYXRjaCA9PSBudWxsKSA9PT0gaW52ZXJ0O1xyXG4gICAgICAgIC8vIEtlZXAgYWxsIHRoZSBleGlzdGluZyBtYXRjaCByYW5nZXMgb25seSBpZiB0aGUgcmVnZXggbWF0Y2hlZC5cclxuICAgICAgICB3aGlsZSAoXHJcbiAgICAgICAgICBjdXJNYXRjaCA8IGdyb3VwLm1hdGNoZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICBncm91cC5tYXRjaGVzW2N1ck1hdGNoXS5zdGFydC5yb3cgPT09IGxpbmVOdW1cclxuICAgICAgICApIHtcclxuICAgICAgICAgIGlmIChtYXRjaGVkKSB7XHJcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChncm91cC5tYXRjaGVzW2N1ck1hdGNoXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjdXJNYXRjaCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW1hdGNoZWQpIHtcclxuICAgICAgICAgIC8vIEEgbm9uLW1hdGNoIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIHNwbGl0IGludG8gYSBuZXcgZ3JvdXAsIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh7c3RhcnRMaW5lLCBsaW5lcywgbWF0Y2hlc30pO1xyXG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xyXG4gICAgICAgICAgICBtYXRjaGVzID0gW107XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgc3RhcnRMaW5lID0gbGluZU51bSArIDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xyXG4gICAgICAgICAgLy8gRm9yIG5vbi1pbnZlcnQgbWF0Y2hlcywgYWRkaXRpb25hbGx5IGhpZ2hsaWdodCB0aGUgZmlyc3QgcmVnZXggbWF0Y2guXHJcbiAgICAgICAgICBpZiAoIWludmVydCkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJNYXRjaCA9IG5ldyBSYW5nZShcclxuICAgICAgICAgICAgICBbbGluZU51bSwgcmVnZXhNYXRjaC5pbmRleF0sXHJcbiAgICAgICAgICAgICAgW2xpbmVOdW0sIHJlZ2V4TWF0Y2guaW5kZXggKyByZWdleE1hdGNoWzBdLmxlbmd0aF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIC8vIEtlZXAgYG1hdGNoZXNgIHNvcnRlZCB2aWEgaW5zZXJ0aW9uIHNvcnQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgY2F1c2UgcXVhZHJhdGljIHJ1bnRpbWUsIHNpbmNlIHRoaXMgd2lsbCBvbmx5IHNjYW4gdGhlIHByZXZpb3VzIGxpbmUuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBtYXRjaGVzLmxlbmd0aDsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICBpZiAoaiA9PT0gMCB8fCBtYXRjaGVzW2ogLSAxXS5jb21wYXJlKGZpbHRlck1hdGNoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnNwbGljZShqLCBqLCBmaWx0ZXJNYXRjaCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gRmluaXNoIG9mZiB0aGUgY3VycmVudCBncm91cC5cclxuICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIGZpbHRlcmVkLnB1c2goe3N0YXJ0TGluZSwgbGluZXMsIG1hdGNoZXN9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZmlsdGVyZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBBcHBsaWVzIHRoZSBncmVwIGZpbHRlciB0byBib3RoIGZpbGVuYW1lIGFuZCBsaW5lIGdyb3Vwcy5cclxuICAvLyBSZXR1cm5zIG51bGwgaWYgbmVpdGhlciBmaWxlbmFtZSBvciBsaW5lIGNvbnRlbnRzIG1hdGNoLlxyXG4gIGFwcGx5R3JlcChyZWdleDogUmVnRXhwLCBpbnZlcnQ6IGJvb2xlYW4pOiA/RmlsZVJlc3VsdHMge1xyXG4gICAgY29uc3Qge3BhdGh9ID0gdGhpcztcclxuICAgIGlmIChpbnZlcnQgJiYgcmVnZXguZXhlYyhwYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZ3JvdXBzID0gdGhpcy5maWx0ZXJHcm91cHMocmVnZXgsIGludmVydCk7XHJcbiAgICBpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBjb25zdCBmaWxlTWF0Y2ggPSByZWdleC5leGVjKHBhdGgpO1xyXG4gICAgICBpZiAoKGZpbGVNYXRjaCA9PSBudWxsKSAhPT0gaW52ZXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGZpbGVNYXRjaCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlUmVzdWx0cyhwYXRoLCBncm91cHMsIFtcclxuICAgICAgICAgIGZpbGVNYXRjaC5pbmRleCxcclxuICAgICAgICAgIGZpbGVNYXRjaC5pbmRleCArIGZpbGVNYXRjaFswXS5sZW5ndGgsXHJcbiAgICAgICAgXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRmlsZVJlc3VsdHMocGF0aCwgZ3JvdXBzKTtcclxuICB9XHJcbn1cclxuIl19