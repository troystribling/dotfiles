"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Get a hash for the provider object. Hashes are unique per-hasher, so if you have two different
 * hashers, there is no guarantee that they will give the same hash for the same object.
 *
 * One use case for this is with lists of React elements. Just create a hasher and use the hash as
 * a key:
 *
 *    class MyComponent extends React.Component {
 *      constructor(props) {
 *        super(props);
 *        this._hasher = new Hasher();
 *      }
 *      render() {
 *        return this.props.items.map(item => (
 *          <ItemView key={this._hasher.getHash(item)} model={item} />
 *        ));
 *      }
 *    }
 */

/* $FlowFixMe(>=0.86.0) This
 * comment suppresses an error found when Flow v0.86 was
 * deployed. To see the error, delete this comment and
 * run Flow. */
class Hasher {
  constructor() {
    this._hashes = void 0;
    this._objectCount = void 0;

    /* $FlowFixMe(>=0.86.0) This
     * comment suppresses an error found when Flow v0.86 was
     * deployed. To see the error, delete this comment and
     * run Flow. */
    this._hashes = new WeakMap();
    this._objectCount = 0;
  }

  getHash(item) {
    // eslint-disable-next-line eqeqeq
    if (item === null) {
      return 'null';
    }

    const type = typeof item;

    switch (typeof item) {
      case 'object':
        {
          let hash = this._hashes.get(item);

          if (hash == null) {
            hash = `${type}:${this._objectCount}`;

            this._hashes.set(item, hash);

            this._objectCount = this._objectCount + 1 === Number.MAX_SAFE_INTEGER ? Number.MIN_SAFE_INTEGER : this._objectCount + 1;
          }

          return hash;
        }

      case 'undefined':
        return 'undefined';

      case 'string':
      case 'boolean':
        return `${type}:${item.toString()}`;

      case 'number':
        return item;

      default:
        throw new Error('Unhashable object');
    }
  }

}

exports.default = Hasher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL0hhc2hlci5qcyJdLCJuYW1lcyI6WyJIYXNoZXIiLCJjb25zdHJ1Y3RvciIsIl9oYXNoZXMiLCJfb2JqZWN0Q291bnQiLCJXZWFrTWFwIiwiZ2V0SGFzaCIsIml0ZW0iLCJ0eXBlIiwiaGFzaCIsImdldCIsInNldCIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwidG9TdHJpbmciLCJFcnJvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZSxNQUFNQSxNQUFOLENBQWdCO0FBSTdCQyxFQUFBQSxXQUFXLEdBQUc7QUFBQSxTQUhkQyxPQUdjO0FBQUEsU0FGZEMsWUFFYzs7QUFDWjtBQUNKO0FBQ0E7QUFDQTtBQUNJLFNBQUtELE9BQUwsR0FBZSxJQUFJRSxPQUFKLEVBQWY7QUFDQSxTQUFLRCxZQUFMLEdBQW9CLENBQXBCO0FBQ0Q7O0FBRURFLEVBQUFBLE9BQU8sQ0FBQ0MsSUFBRCxFQUEyQjtBQUNoQztBQUNBLFFBQUlBLElBQUksS0FBSyxJQUFiLEVBQW1CO0FBQ2pCLGFBQU8sTUFBUDtBQUNEOztBQUNELFVBQU1DLElBQUksR0FBRyxPQUFPRCxJQUFwQjs7QUFDQSxZQUFRLE9BQU9BLElBQWY7QUFDRSxXQUFLLFFBQUw7QUFBZTtBQUNiLGNBQUlFLElBQUksR0FBRyxLQUFLTixPQUFMLENBQWFPLEdBQWIsQ0FBaUJILElBQWpCLENBQVg7O0FBQ0EsY0FBSUUsSUFBSSxJQUFJLElBQVosRUFBa0I7QUFDaEJBLFlBQUFBLElBQUksR0FBSSxHQUFFRCxJQUFLLElBQUcsS0FBS0osWUFBYSxFQUFwQzs7QUFDQSxpQkFBS0QsT0FBTCxDQUFhUSxHQUFiLENBQWlCSixJQUFqQixFQUF1QkUsSUFBdkI7O0FBQ0EsaUJBQUtMLFlBQUwsR0FDRSxLQUFLQSxZQUFMLEdBQW9CLENBQXBCLEtBQTBCUSxNQUFNLENBQUNDLGdCQUFqQyxHQUNJRCxNQUFNLENBQUNFLGdCQURYLEdBRUksS0FBS1YsWUFBTCxHQUFvQixDQUgxQjtBQUlEOztBQUNELGlCQUFPSyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBSyxXQUFMO0FBQ0UsZUFBTyxXQUFQOztBQUNGLFdBQUssUUFBTDtBQUNBLFdBQUssU0FBTDtBQUNFLGVBQVEsR0FBRUQsSUFBSyxJQUFHRCxJQUFJLENBQUNRLFFBQUwsRUFBZ0IsRUFBbEM7O0FBQ0YsV0FBSyxRQUFMO0FBQ0UsZUFBT1IsSUFBUDs7QUFDRjtBQUNFLGNBQU0sSUFBSVMsS0FBSixDQUFVLG1CQUFWLENBQU47QUFyQko7QUF1QkQ7O0FBMUM0QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3cgc3RyaWN0XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG4vKipcclxuICogR2V0IGEgaGFzaCBmb3IgdGhlIHByb3ZpZGVyIG9iamVjdC4gSGFzaGVzIGFyZSB1bmlxdWUgcGVyLWhhc2hlciwgc28gaWYgeW91IGhhdmUgdHdvIGRpZmZlcmVudFxyXG4gKiBoYXNoZXJzLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGV5IHdpbGwgZ2l2ZSB0aGUgc2FtZSBoYXNoIGZvciB0aGUgc2FtZSBvYmplY3QuXHJcbiAqXHJcbiAqIE9uZSB1c2UgY2FzZSBmb3IgdGhpcyBpcyB3aXRoIGxpc3RzIG9mIFJlYWN0IGVsZW1lbnRzLiBKdXN0IGNyZWF0ZSBhIGhhc2hlciBhbmQgdXNlIHRoZSBoYXNoIGFzXHJcbiAqIGEga2V5OlxyXG4gKlxyXG4gKiAgICBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcbiAqICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICogICAgICAgIHN1cGVyKHByb3BzKTtcclxuICogICAgICAgIHRoaXMuX2hhc2hlciA9IG5ldyBIYXNoZXIoKTtcclxuICogICAgICB9XHJcbiAqICAgICAgcmVuZGVyKCkge1xyXG4gKiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaXRlbXMubWFwKGl0ZW0gPT4gKFxyXG4gKiAgICAgICAgICA8SXRlbVZpZXcga2V5PXt0aGlzLl9oYXNoZXIuZ2V0SGFzaChpdGVtKX0gbW9kZWw9e2l0ZW19IC8+XHJcbiAqICAgICAgICApKTtcclxuICogICAgICB9XHJcbiAqICAgIH1cclxuICovXHJcbi8qICRGbG93Rml4TWUoPj0wLjg2LjApIFRoaXNcclxuICogY29tbWVudCBzdXBwcmVzc2VzIGFuIGVycm9yIGZvdW5kIHdoZW4gRmxvdyB2MC44NiB3YXNcclxuICogZGVwbG95ZWQuIFRvIHNlZSB0aGUgZXJyb3IsIGRlbGV0ZSB0aGlzIGNvbW1lbnQgYW5kXHJcbiAqIHJ1biBGbG93LiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIYXNoZXI8Sz4ge1xyXG4gIF9oYXNoZXM6IFdlYWtNYXA8Sywgc3RyaW5nPjtcclxuICBfb2JqZWN0Q291bnQ6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvKiAkRmxvd0ZpeE1lKD49MC44Ni4wKSBUaGlzXHJcbiAgICAgKiBjb21tZW50IHN1cHByZXNzZXMgYW4gZXJyb3IgZm91bmQgd2hlbiBGbG93IHYwLjg2IHdhc1xyXG4gICAgICogZGVwbG95ZWQuIFRvIHNlZSB0aGUgZXJyb3IsIGRlbGV0ZSB0aGlzIGNvbW1lbnQgYW5kXHJcbiAgICAgKiBydW4gRmxvdy4gKi9cclxuICAgIHRoaXMuX2hhc2hlcyA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICB0aGlzLl9vYmplY3RDb3VudCA9IDA7XHJcbiAgfVxyXG5cclxuICBnZXRIYXNoKGl0ZW06IEspOiBzdHJpbmcgfCBudW1iZXIge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxyXG4gICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuICdudWxsJztcclxuICAgIH1cclxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaXRlbTtcclxuICAgIHN3aXRjaCAodHlwZW9mIGl0ZW0pIHtcclxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xyXG4gICAgICAgIGxldCBoYXNoID0gdGhpcy5faGFzaGVzLmdldChpdGVtKTtcclxuICAgICAgICBpZiAoaGFzaCA9PSBudWxsKSB7XHJcbiAgICAgICAgICBoYXNoID0gYCR7dHlwZX06JHt0aGlzLl9vYmplY3RDb3VudH1gO1xyXG4gICAgICAgICAgdGhpcy5faGFzaGVzLnNldChpdGVtLCBoYXNoKTtcclxuICAgICAgICAgIHRoaXMuX29iamVjdENvdW50ID1cclxuICAgICAgICAgICAgdGhpcy5fb2JqZWN0Q291bnQgKyAxID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxyXG4gICAgICAgICAgICAgID8gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcclxuICAgICAgICAgICAgICA6IHRoaXMuX29iamVjdENvdW50ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgIH1cclxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcclxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XHJcbiAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgIHJldHVybiBgJHt0eXBlfToke2l0ZW0udG9TdHJpbmcoKX1gO1xyXG4gICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5oYXNoYWJsZSBvYmplY3QnKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19