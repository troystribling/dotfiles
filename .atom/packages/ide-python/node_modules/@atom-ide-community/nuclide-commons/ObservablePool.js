"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * ObservablePool allows you to execute Observables or functions that return
 * Observable inputs (i.e. Observables, Promises, or Iterables)
 * with a concurrency limit.
 *
 * Execution requests are queued and unsubscriptions are forwarded through
 * (if a request is still on the queue, its execution will be cancelled.)
 *
 * For requests that return a Promise, the ObservablePool is pessimistic
 * and assumes that the operation is uncancellable - it will not remove
 * the execution from the pool until it resolves or rejects. However
 * `schedule()` will still return an Observable to enable the use case
 * of cancelling requests while they're in the queue.
 *
 * Example:
 *
 *   const pool = new ObservablePool(2);
 *   pool
 *     .schedule(Observable.timer(1000).mapTo(1))
 *     .subscribe(console.log);
 *   Observable.timer(1000)
 *     .mapTo(2)
 *     .let(pool.schedule.bind(pool))
 *     .subscribe(console.log);
 *   pool
 *     .schedule(Observable.timer(100).mapTo(3))
 *     .subscribe(console.log);
 *
 * The output here is 1, 2, then 3. Despite the fact that the third observable
 * finishes more quickly, its execution is postponed until the first two finish.
 */
class ObservablePool {
  constructor(concurrency) {
    this._requests = void 0;
    this._responseListeners = void 0;
    this._subscription = void 0;
    this._requests = new _rxjsCompatUmdMin.Subject();
    this._responseListeners = new Map();
    this._subscription = this._handleEvents(concurrency);
  }

  schedule(executor) {
    return _rxjsCompatUmdMin.Observable.create(observer => {
      const unsubscribed = new _rxjsCompatUmdMin.Subject();
      const tag = {}; // Just a unique object.

      this._responseListeners.set(tag, {
        observer,
        unsubscribed
      });

      this._requests.next({
        tag,
        executor
      });

      return () => {
        this._responseListeners.delete(tag);

        unsubscribed.next();
      };
    });
  }
  /**
   * Warning: calling dispose() will error all executing requests.
   */


  dispose() {
    this._responseListeners.forEach(({
      observer
    }) => {
      observer.error(Error('ObservablePool was disposed'));
    });

    this._subscription.unsubscribe();
  }

  _handleEvents(concurrency) {
    return this._requests.mergeMap(event => {
      const {
        executor,
        tag
      } = event;

      const listener = this._responseListeners.get(tag); // unsubscribed before we could even get to it!


      if (listener == null) {
        return _rxjsCompatUmdMin.Observable.empty();
      }

      const {
        observer,
        unsubscribed
      } = listener;
      let result;

      if (executor instanceof _rxjsCompatUmdMin.Observable) {
        result = executor;
      } else {
        try {
          result = executor();
        } catch (err) {
          // Catch errors from executor().
          observer.error(err);
          return _rxjsCompatUmdMin.Observable.empty();
        }
      }

      if (result instanceof _rxjsCompatUmdMin.Observable) {
        // We can safely forward unsubscriptions!
        return result.takeUntil(unsubscribed) // $FlowFixMe: Flow doesn't like this.
        .do(observer).catch(() => _rxjsCompatUmdMin.Observable.empty());
      } else {
        // In the absence of cancellation, assume the worst.
        return _rxjsCompatUmdMin.Observable.from(result) // $FlowFixMe: Flow doesn't like this.
        .do(observer).catch(() => _rxjsCompatUmdMin.Observable.empty());
      }
    }, concurrency).subscribe();
  }

}

exports.default = ObservablePool;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL09ic2VydmFibGVQb29sLmpzIl0sIm5hbWVzIjpbIk9ic2VydmFibGVQb29sIiwiY29uc3RydWN0b3IiLCJjb25jdXJyZW5jeSIsIl9yZXF1ZXN0cyIsIl9yZXNwb25zZUxpc3RlbmVycyIsIl9zdWJzY3JpcHRpb24iLCJTdWJqZWN0IiwiTWFwIiwiX2hhbmRsZUV2ZW50cyIsInNjaGVkdWxlIiwiZXhlY3V0b3IiLCJPYnNlcnZhYmxlIiwiY3JlYXRlIiwib2JzZXJ2ZXIiLCJ1bnN1YnNjcmliZWQiLCJ0YWciLCJzZXQiLCJuZXh0IiwiZGVsZXRlIiwiZGlzcG9zZSIsImZvckVhY2giLCJlcnJvciIsIkVycm9yIiwidW5zdWJzY3JpYmUiLCJtZXJnZU1hcCIsImV2ZW50IiwibGlzdGVuZXIiLCJnZXQiLCJlbXB0eSIsInJlc3VsdCIsImVyciIsInRha2VVbnRpbCIsImRvIiwiY2F0Y2giLCJmcm9tIiwic3Vic2NyaWJlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLE1BQU1BLGNBQU4sQ0FBd0I7QUFLckNDLEVBQUFBLFdBQVcsQ0FBQ0MsV0FBRCxFQUFzQjtBQUFBLFNBSmpDQyxTQUlpQztBQUFBLFNBSGpDQyxrQkFHaUM7QUFBQSxTQUZqQ0MsYUFFaUM7QUFDL0IsU0FBS0YsU0FBTCxHQUFpQixJQUFJRyx5QkFBSixFQUFqQjtBQUNBLFNBQUtGLGtCQUFMLEdBQTBCLElBQUlHLEdBQUosRUFBMUI7QUFDQSxTQUFLRixhQUFMLEdBQXFCLEtBQUtHLGFBQUwsQ0FBbUJOLFdBQW5CLENBQXJCO0FBQ0Q7O0FBRURPLEVBQUFBLFFBQVEsQ0FBQ0MsUUFBRCxFQUF1QztBQUM3QyxXQUFPQyw2QkFBV0MsTUFBWCxDQUFrQkMsUUFBUSxJQUFJO0FBQ25DLFlBQU1DLFlBQVksR0FBRyxJQUFJUix5QkFBSixFQUFyQjtBQUNBLFlBQU1TLEdBQUcsR0FBRyxFQUFaLENBRm1DLENBRW5COztBQUNoQixXQUFLWCxrQkFBTCxDQUF3QlksR0FBeEIsQ0FBNEJELEdBQTVCLEVBQWlDO0FBQUNGLFFBQUFBLFFBQUQ7QUFBV0MsUUFBQUE7QUFBWCxPQUFqQzs7QUFDQSxXQUFLWCxTQUFMLENBQWVjLElBQWYsQ0FBb0I7QUFBQ0YsUUFBQUEsR0FBRDtBQUFNTCxRQUFBQTtBQUFOLE9BQXBCOztBQUNBLGFBQU8sTUFBTTtBQUNYLGFBQUtOLGtCQUFMLENBQXdCYyxNQUF4QixDQUErQkgsR0FBL0I7O0FBQ0FELFFBQUFBLFlBQVksQ0FBQ0csSUFBYjtBQUNELE9BSEQ7QUFJRCxLQVRNLENBQVA7QUFVRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBQ0VFLEVBQUFBLE9BQU8sR0FBRztBQUNSLFNBQUtmLGtCQUFMLENBQXdCZ0IsT0FBeEIsQ0FBZ0MsQ0FBQztBQUFDUCxNQUFBQTtBQUFELEtBQUQsS0FBZ0I7QUFDOUNBLE1BQUFBLFFBQVEsQ0FBQ1EsS0FBVCxDQUFlQyxLQUFLLENBQUMsNkJBQUQsQ0FBcEI7QUFDRCxLQUZEOztBQUdBLFNBQUtqQixhQUFMLENBQW1Ca0IsV0FBbkI7QUFDRDs7QUFFRGYsRUFBQUEsYUFBYSxDQUFDTixXQUFELEVBQTBDO0FBQ3JELFdBQU8sS0FBS0MsU0FBTCxDQUNKcUIsUUFESSxDQUNLQyxLQUFLLElBQUk7QUFDakIsWUFBTTtBQUFDZixRQUFBQSxRQUFEO0FBQVdLLFFBQUFBO0FBQVgsVUFBa0JVLEtBQXhCOztBQUNBLFlBQU1DLFFBQVEsR0FBRyxLQUFLdEIsa0JBQUwsQ0FBd0J1QixHQUF4QixDQUE0QlosR0FBNUIsQ0FBakIsQ0FGaUIsQ0FHakI7OztBQUNBLFVBQUlXLFFBQVEsSUFBSSxJQUFoQixFQUFzQjtBQUNwQixlQUFPZiw2QkFBV2lCLEtBQVgsRUFBUDtBQUNEOztBQUNELFlBQU07QUFBQ2YsUUFBQUEsUUFBRDtBQUFXQyxRQUFBQTtBQUFYLFVBQTJCWSxRQUFqQztBQUNBLFVBQUlHLE1BQUo7O0FBQ0EsVUFBSW5CLFFBQVEsWUFBWUMsNEJBQXhCLEVBQW9DO0FBQ2xDa0IsUUFBQUEsTUFBTSxHQUFHbkIsUUFBVDtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUk7QUFDRm1CLFVBQUFBLE1BQU0sR0FBR25CLFFBQVEsRUFBakI7QUFDRCxTQUZELENBRUUsT0FBT29CLEdBQVAsRUFBWTtBQUNaO0FBQ0FqQixVQUFBQSxRQUFRLENBQUNRLEtBQVQsQ0FBZVMsR0FBZjtBQUNBLGlCQUFPbkIsNkJBQVdpQixLQUFYLEVBQVA7QUFDRDtBQUNGOztBQUNELFVBQUlDLE1BQU0sWUFBWWxCLDRCQUF0QixFQUFrQztBQUNoQztBQUNBLGVBQ0VrQixNQUFNLENBQ0hFLFNBREgsQ0FDYWpCLFlBRGIsRUFFRTtBQUZGLFNBR0drQixFQUhILENBR01uQixRQUhOLEVBSUdvQixLQUpILENBSVMsTUFBTXRCLDZCQUFXaUIsS0FBWCxFQUpmLENBREY7QUFPRCxPQVRELE1BU087QUFDTDtBQUNBLGVBQ0VqQiw2QkFBV3VCLElBQVgsQ0FBZ0JMLE1BQWhCLEVBQ0U7QUFERixTQUVHRyxFQUZILENBRU1uQixRQUZOLEVBR0dvQixLQUhILENBR1MsTUFBTXRCLDZCQUFXaUIsS0FBWCxFQUhmLENBREY7QUFNRDtBQUNGLEtBdkNJLEVBdUNGMUIsV0F2Q0UsRUF3Q0ppQyxTQXhDSSxFQUFQO0FBeUNEOztBQTVFb0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBTdWJqZWN0fSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5cclxudHlwZSBFeGVjdXRvcjxUPiA9IE9ic2VydmFibGU8VD4gfCAoKCkgPT4gcnhqcyRPYnNlcnZhYmxlSW5wdXQ8VD4pO1xyXG5cclxudHlwZSBSZXF1ZXN0PFQ+ID0ge3RhZzogbWl4ZWQsIGV4ZWN1dG9yOiBFeGVjdXRvcjxUPn07XHJcblxyXG50eXBlIFJlc3BvbnNlPFQ+ID0ge1xyXG4gIG9ic2VydmVyOiByeGpzJE9ic2VydmVyPFQ+LFxyXG4gIHVuc3Vic2NyaWJlZDogU3ViamVjdDx2b2lkPixcclxufTtcclxuXHJcbi8qKlxyXG4gKiBPYnNlcnZhYmxlUG9vbCBhbGxvd3MgeW91IHRvIGV4ZWN1dGUgT2JzZXJ2YWJsZXMgb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuXHJcbiAqIE9ic2VydmFibGUgaW5wdXRzIChpLmUuIE9ic2VydmFibGVzLCBQcm9taXNlcywgb3IgSXRlcmFibGVzKVxyXG4gKiB3aXRoIGEgY29uY3VycmVuY3kgbGltaXQuXHJcbiAqXHJcbiAqIEV4ZWN1dGlvbiByZXF1ZXN0cyBhcmUgcXVldWVkIGFuZCB1bnN1YnNjcmlwdGlvbnMgYXJlIGZvcndhcmRlZCB0aHJvdWdoXHJcbiAqIChpZiBhIHJlcXVlc3QgaXMgc3RpbGwgb24gdGhlIHF1ZXVlLCBpdHMgZXhlY3V0aW9uIHdpbGwgYmUgY2FuY2VsbGVkLilcclxuICpcclxuICogRm9yIHJlcXVlc3RzIHRoYXQgcmV0dXJuIGEgUHJvbWlzZSwgdGhlIE9ic2VydmFibGVQb29sIGlzIHBlc3NpbWlzdGljXHJcbiAqIGFuZCBhc3N1bWVzIHRoYXQgdGhlIG9wZXJhdGlvbiBpcyB1bmNhbmNlbGxhYmxlIC0gaXQgd2lsbCBub3QgcmVtb3ZlXHJcbiAqIHRoZSBleGVjdXRpb24gZnJvbSB0aGUgcG9vbCB1bnRpbCBpdCByZXNvbHZlcyBvciByZWplY3RzLiBIb3dldmVyXHJcbiAqIGBzY2hlZHVsZSgpYCB3aWxsIHN0aWxsIHJldHVybiBhbiBPYnNlcnZhYmxlIHRvIGVuYWJsZSB0aGUgdXNlIGNhc2VcclxuICogb2YgY2FuY2VsbGluZyByZXF1ZXN0cyB3aGlsZSB0aGV5J3JlIGluIHRoZSBxdWV1ZS5cclxuICpcclxuICogRXhhbXBsZTpcclxuICpcclxuICogICBjb25zdCBwb29sID0gbmV3IE9ic2VydmFibGVQb29sKDIpO1xyXG4gKiAgIHBvb2xcclxuICogICAgIC5zY2hlZHVsZShPYnNlcnZhYmxlLnRpbWVyKDEwMDApLm1hcFRvKDEpKVxyXG4gKiAgICAgLnN1YnNjcmliZShjb25zb2xlLmxvZyk7XHJcbiAqICAgT2JzZXJ2YWJsZS50aW1lcigxMDAwKVxyXG4gKiAgICAgLm1hcFRvKDIpXHJcbiAqICAgICAubGV0KHBvb2wuc2NoZWR1bGUuYmluZChwb29sKSlcclxuICogICAgIC5zdWJzY3JpYmUoY29uc29sZS5sb2cpO1xyXG4gKiAgIHBvb2xcclxuICogICAgIC5zY2hlZHVsZShPYnNlcnZhYmxlLnRpbWVyKDEwMCkubWFwVG8oMykpXHJcbiAqICAgICAuc3Vic2NyaWJlKGNvbnNvbGUubG9nKTtcclxuICpcclxuICogVGhlIG91dHB1dCBoZXJlIGlzIDEsIDIsIHRoZW4gMy4gRGVzcGl0ZSB0aGUgZmFjdCB0aGF0IHRoZSB0aGlyZCBvYnNlcnZhYmxlXHJcbiAqIGZpbmlzaGVzIG1vcmUgcXVpY2tseSwgaXRzIGV4ZWN1dGlvbiBpcyBwb3N0cG9uZWQgdW50aWwgdGhlIGZpcnN0IHR3byBmaW5pc2guXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPYnNlcnZhYmxlUG9vbDxUPiB7XHJcbiAgX3JlcXVlc3RzOiBTdWJqZWN0PFJlcXVlc3Q8VD4+O1xyXG4gIF9yZXNwb25zZUxpc3RlbmVyczogTWFwPG1peGVkLCBSZXNwb25zZTxUPj47XHJcbiAgX3N1YnNjcmlwdGlvbjogcnhqcyRJU3Vic2NyaXB0aW9uO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeTogbnVtYmVyKSB7XHJcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICB0aGlzLl9yZXNwb25zZUxpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX2hhbmRsZUV2ZW50cyhjb25jdXJyZW5jeSk7XHJcbiAgfVxyXG5cclxuICBzY2hlZHVsZShleGVjdXRvcjogRXhlY3V0b3I8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlZCA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgIGNvbnN0IHRhZyA9IHt9OyAvLyBKdXN0IGEgdW5pcXVlIG9iamVjdC5cclxuICAgICAgdGhpcy5fcmVzcG9uc2VMaXN0ZW5lcnMuc2V0KHRhZywge29ic2VydmVyLCB1bnN1YnNjcmliZWR9KTtcclxuICAgICAgdGhpcy5fcmVxdWVzdHMubmV4dCh7dGFnLCBleGVjdXRvcn0pO1xyXG4gICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlTGlzdGVuZXJzLmRlbGV0ZSh0YWcpO1xyXG4gICAgICAgIHVuc3Vic2NyaWJlZC5uZXh0KCk7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdhcm5pbmc6IGNhbGxpbmcgZGlzcG9zZSgpIHdpbGwgZXJyb3IgYWxsIGV4ZWN1dGluZyByZXF1ZXN0cy5cclxuICAgKi9cclxuICBkaXNwb3NlKCkge1xyXG4gICAgdGhpcy5fcmVzcG9uc2VMaXN0ZW5lcnMuZm9yRWFjaCgoe29ic2VydmVyfSkgPT4ge1xyXG4gICAgICBvYnNlcnZlci5lcnJvcihFcnJvcignT2JzZXJ2YWJsZVBvb2wgd2FzIGRpc3Bvc2VkJykpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIF9oYW5kbGVFdmVudHMoY29uY3VycmVuY3k6IG51bWJlcik6IHJ4anMkSVN1YnNjcmlwdGlvbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdHNcclxuICAgICAgLm1lcmdlTWFwKGV2ZW50ID0+IHtcclxuICAgICAgICBjb25zdCB7ZXhlY3V0b3IsIHRhZ30gPSBldmVudDtcclxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX3Jlc3BvbnNlTGlzdGVuZXJzLmdldCh0YWcpO1xyXG4gICAgICAgIC8vIHVuc3Vic2NyaWJlZCBiZWZvcmUgd2UgY291bGQgZXZlbiBnZXQgdG8gaXQhXHJcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmVtcHR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHtvYnNlcnZlciwgdW5zdWJzY3JpYmVkfSA9IGxpc3RlbmVyO1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGV4ZWN1dG9yIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gZXhlY3V0b3I7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGV4ZWN1dG9yKCk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgLy8gQ2F0Y2ggZXJyb3JzIGZyb20gZXhlY3V0b3IoKS5cclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZW1wdHkoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcclxuICAgICAgICAgIC8vIFdlIGNhbiBzYWZlbHkgZm9yd2FyZCB1bnN1YnNjcmlwdGlvbnMhXHJcbiAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICByZXN1bHRcclxuICAgICAgICAgICAgICAudGFrZVVudGlsKHVuc3Vic2NyaWJlZClcclxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSB0aGlzLlxyXG4gICAgICAgICAgICAgIC5kbyhvYnNlcnZlcilcclxuICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gT2JzZXJ2YWJsZS5lbXB0eSgpKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSW4gdGhlIGFic2VuY2Ugb2YgY2FuY2VsbGF0aW9uLCBhc3N1bWUgdGhlIHdvcnN0LlxyXG4gICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgT2JzZXJ2YWJsZS5mcm9tKHJlc3VsdClcclxuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSB0aGlzLlxyXG4gICAgICAgICAgICAgIC5kbyhvYnNlcnZlcilcclxuICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gT2JzZXJ2YWJsZS5lbXB0eSgpKVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sIGNvbmN1cnJlbmN5KVxyXG4gICAgICAuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==