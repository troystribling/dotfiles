"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__test__ = exports.default = void 0;

var _log4js = require("log4js");

var _performanceNow = _interopRequireDefault(require("./performanceNow"));

var _os = _interopRequireDefault(require("os"));

var _process = require("./process");

var _which = _interopRequireDefault(require("./which"));

var _once = _interopRequireDefault(require("./once"));

var _passesGK = _interopRequireDefault(require("./passesGK"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
const DEFAULT_JOIN_TIMEOUT = 5000;
let SCRIBE_CAT_COMMAND = 'scribe_cat'; // On Mac OS, `scribe_cat` isn't quite the same as the server-side one:
// it only dumps its logs on exit. To make sure that logs are delivered
// in a timely manner, we'll periodically force-kill the process.

const DEFAULT_JOIN_INTERVAL = process.platform === 'darwin' ? 60000 : null; // If spawning the Scribe process takes this long, disable it.
// Node sometimes runs into strange issues where spawning() starts to block.
// https://github.com/nodejs/node/issues/14917

const SPAWN_TOO_LONG_MS = 2000;
/**
 * A wrapper of `scribe_cat` (https://github.com/facebookarchive/scribe/blob/master/examples/scribe_cat)
 * command. User could call `new ScribeProcess($scribeCategoryName)` to create a process and then
 * call `scribeProcess.write($object)` to save an JSON schemaed Object into scribe category.
 * It will also recover from `scribe_cat` failure automatically.
 */

class ScribeProcess {
  constructor(scribeCategory, joinInterval = DEFAULT_JOIN_INTERVAL) {
    this._scribeCategory = void 0;
    this._childPromise = void 0;
    this._subscription = void 0;
    this._joinTimer = void 0;
    this._joinInterval = void 0;
    this._scribeCategory = scribeCategory;
    this._joinInterval = joinInterval;

    this._getChildProcess();
  }
  /**
   * Check if `scribe_cat` exists in PATH.
   */


  static isEnabled() {
    return ScribeProcess._enabled;
  }
  /**
   * Write a string to a Scribe category.
   * Ensure newlines are properly escaped.
   * Returns false if something is wrong with the Scribe process (use a fallback instead.)
   */


  async write(message) {
    if (!ScribeProcess._enabled) {
      return false;
    }

    let child;

    try {
      child = await this._getChildProcess();
      await writeToStream(child.stdin, `${message}${_os.default.EOL}`);
    } catch (err) {
      ScribeProcess._enabled = false; // Note: Logging errors is potentially recursive, since they go through Scribe!
      // It's important that we set _enabled before logging errors in this file.

      (0, _log4js.getLogger)('ScribeProcess').error('Disabling ScribeProcess due to error:', err);
      return false;
    }

    return true;
  }
  /**
   * Waits for the remaining messages to be written, then closes the write stream. Resolves once the
   * process has exited. This method is called when the server shuts down in order to guarantee we
   * capture logging during shutdown.
   */


  async join(timeout = DEFAULT_JOIN_TIMEOUT) {
    const {
      _childPromise,
      _subscription
    } = this;

    if (_childPromise == null || _subscription == null) {
      return;
    } // join() renders the existing process unusable.
    // The next call to write() should create a new process, so clear out the references.
    // Note that we stored them in local variables already above.


    this._clear();

    const child = await _childPromise;
    const {
      stdin
    } = child;
    const waitForExit = new Promise(resolve => {
      child.on('exit', () => {
        resolve();
      });
      setTimeout(() => {
        _subscription.unsubscribe();

        resolve();
      }, timeout);
    }); // Make sure stdin has drained before ending it.

    if (!stdin.write(_os.default.EOL)) {
      stdin.once('drain', () => stdin.end());
    } else {
      stdin.end();
    }

    return waitForExit;
  }

  _getChildProcess() {
    if (this._childPromise) {
      return this._childPromise;
    } // Obtain a promise to get the child process, but don't start it yet.
    // this._subscription will have control over starting / stopping the process.


    const startTime = (0, _performanceNow.default)();
    const processStream = (0, _process.spawn)(SCRIBE_CAT_COMMAND, [this._scribeCategory], {
      dontLogInNuclide: true
    }).do(child => {
      const duration = (0, _performanceNow.default)() - startTime;

      if (duration > SPAWN_TOO_LONG_MS) {
        ScribeProcess._enabled = false;
        (0, _log4js.getLogger)('ScribeProcess').error(`Disabling ScribeProcess because spawn took too long (${duration}ms)`); // Don't raise any errors and allow the current write to complete.
        // However, the next write will fail due to the _enabled check.

        this.join();
      }

      child.stdin.setDefaultEncoding('utf8');
    }).finally(() => {
      // We may have already started a new process in the meantime.
      if (this._childPromise === childPromise) {
        this._clear();
      }
    }).publish();
    const childPromise = this._childPromise = processStream.first().toPromise();
    this._subscription = processStream.connect();

    if (this._joinInterval != null) {
      this._joinTimer = setTimeout(() => {
        this._joinTimer = null;
        this.join();
      }, this._joinInterval);
    }

    return childPromise;
  }

  _clear() {
    this._childPromise = null;
    this._subscription = null;

    if (this._joinTimer != null) {
      clearTimeout(this._joinTimer);
      this._joinTimer = null;
    }
  }

}

exports.default = ScribeProcess;
ScribeProcess._enabled = true;
ScribeProcess.isScribeCatOnPath = (0, _once.default)(async () => {
  const [whichCmd, gkEnabled] = await Promise.all([(0, _which.default)(SCRIBE_CAT_COMMAND), process.platform === 'darwin' ? (0, _passesGK.default)('nuclide_scribe_macos') : Promise.resolve(true)]);
  return whichCmd != null && gkEnabled;
});
const __test__ = {
  setScribeCatCommand(newCommand) {
    const originalCommand = SCRIBE_CAT_COMMAND;
    SCRIBE_CAT_COMMAND = newCommand;
    return originalCommand;
  }

};
exports.__test__ = __test__;

function writeToStream(stream, message) {
  return new Promise((resolve, reject) => {
    // According to `stream.write()` [docs][1], "If an error occurs, the
    // callback may or may not be called with the error as its first argument.
    // To reliably detect write errors, add a listener for the 'error' event."
    //
    // [1]: https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback
    const handleError = err => {
      reject(err);
      stream.removeListener('error', handleError);
    };

    stream.once('error', handleError);
    stream.write(message, err => {
      if (err != null) {
        handleError(err);
        return;
      }

      stream.removeListener('error', handleError);
      resolve();
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL1NjcmliZVByb2Nlc3MuanMiXSwibmFtZXMiOlsiREVGQVVMVF9KT0lOX1RJTUVPVVQiLCJTQ1JJQkVfQ0FUX0NPTU1BTkQiLCJERUZBVUxUX0pPSU5fSU5URVJWQUwiLCJwcm9jZXNzIiwicGxhdGZvcm0iLCJTUEFXTl9UT09fTE9OR19NUyIsIlNjcmliZVByb2Nlc3MiLCJjb25zdHJ1Y3RvciIsInNjcmliZUNhdGVnb3J5Iiwiam9pbkludGVydmFsIiwiX3NjcmliZUNhdGVnb3J5IiwiX2NoaWxkUHJvbWlzZSIsIl9zdWJzY3JpcHRpb24iLCJfam9pblRpbWVyIiwiX2pvaW5JbnRlcnZhbCIsIl9nZXRDaGlsZFByb2Nlc3MiLCJpc0VuYWJsZWQiLCJfZW5hYmxlZCIsIndyaXRlIiwibWVzc2FnZSIsImNoaWxkIiwid3JpdGVUb1N0cmVhbSIsInN0ZGluIiwib3MiLCJFT0wiLCJlcnIiLCJlcnJvciIsImpvaW4iLCJ0aW1lb3V0IiwiX2NsZWFyIiwid2FpdEZvckV4aXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9uIiwic2V0VGltZW91dCIsInVuc3Vic2NyaWJlIiwib25jZSIsImVuZCIsInN0YXJ0VGltZSIsInByb2Nlc3NTdHJlYW0iLCJkb250TG9nSW5OdWNsaWRlIiwiZG8iLCJkdXJhdGlvbiIsInNldERlZmF1bHRFbmNvZGluZyIsImZpbmFsbHkiLCJjaGlsZFByb21pc2UiLCJwdWJsaXNoIiwiZmlyc3QiLCJ0b1Byb21pc2UiLCJjb25uZWN0IiwiY2xlYXJUaW1lb3V0IiwiaXNTY3JpYmVDYXRPblBhdGgiLCJ3aGljaENtZCIsImdrRW5hYmxlZCIsImFsbCIsIl9fdGVzdF9fIiwic2V0U2NyaWJlQ2F0Q29tbWFuZCIsIm5ld0NvbW1hbmQiLCJvcmlnaW5hbENvbW1hbmQiLCJzdHJlYW0iLCJyZWplY3QiLCJoYW5kbGVFcnJvciIsInJlbW92ZUxpc3RlbmVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBWUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBLE1BQU1BLG9CQUFvQixHQUFHLElBQTdCO0FBQ0EsSUFBSUMsa0JBQWtCLEdBQUcsWUFBekIsQyxDQUVBO0FBQ0E7QUFDQTs7QUFDQSxNQUFNQyxxQkFBcUIsR0FBR0MsT0FBTyxDQUFDQyxRQUFSLEtBQXFCLFFBQXJCLEdBQWdDLEtBQWhDLEdBQXdDLElBQXRFLEMsQ0FFQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsSUFBMUI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ2UsTUFBTUMsYUFBTixDQUFvQjtBQVNqQ0MsRUFBQUEsV0FBVyxDQUNUQyxjQURTLEVBRVRDLFlBQXFCLEdBQUdQLHFCQUZmLEVBR1Q7QUFBQSxTQVRGUSxlQVNFO0FBQUEsU0FSRkMsYUFRRTtBQUFBLFNBUEZDLGFBT0U7QUFBQSxTQU5GQyxVQU1FO0FBQUEsU0FMRkMsYUFLRTtBQUNBLFNBQUtKLGVBQUwsR0FBdUJGLGNBQXZCO0FBQ0EsU0FBS00sYUFBTCxHQUFxQkwsWUFBckI7O0FBQ0EsU0FBS00sZ0JBQUw7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7O0FBV2tCLFNBQVRDLFNBQVMsR0FBWTtBQUMxQixXQUFPVixhQUFhLENBQUNXLFFBQXJCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDYSxRQUFMQyxLQUFLLENBQUNDLE9BQUQsRUFBb0M7QUFDN0MsUUFBSSxDQUFDYixhQUFhLENBQUNXLFFBQW5CLEVBQTZCO0FBQzNCLGFBQU8sS0FBUDtBQUNEOztBQUNELFFBQUlHLEtBQUo7O0FBQ0EsUUFBSTtBQUNGQSxNQUFBQSxLQUFLLEdBQUcsTUFBTSxLQUFLTCxnQkFBTCxFQUFkO0FBQ0EsWUFBTU0sYUFBYSxDQUFDRCxLQUFLLENBQUNFLEtBQVAsRUFBZSxHQUFFSCxPQUFRLEdBQUVJLFlBQUdDLEdBQUksRUFBbEMsQ0FBbkI7QUFDRCxLQUhELENBR0UsT0FBT0MsR0FBUCxFQUFZO0FBQ1puQixNQUFBQSxhQUFhLENBQUNXLFFBQWQsR0FBeUIsS0FBekIsQ0FEWSxDQUVaO0FBQ0E7O0FBQ0EsNkJBQVUsZUFBVixFQUEyQlMsS0FBM0IsQ0FDRSx1Q0FERixFQUVFRCxHQUZGO0FBSUEsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBTyxJQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDWSxRQUFKRSxJQUFJLENBQUNDLE9BQWUsR0FBRzVCLG9CQUFuQixFQUF3RDtBQUNoRSxVQUFNO0FBQUNXLE1BQUFBLGFBQUQ7QUFBZ0JDLE1BQUFBO0FBQWhCLFFBQWlDLElBQXZDOztBQUNBLFFBQUlELGFBQWEsSUFBSSxJQUFqQixJQUF5QkMsYUFBYSxJQUFJLElBQTlDLEVBQW9EO0FBQ2xEO0FBQ0QsS0FKK0QsQ0FNaEU7QUFDQTtBQUNBOzs7QUFDQSxTQUFLaUIsTUFBTDs7QUFFQSxVQUFNVCxLQUFLLEdBQUcsTUFBTVQsYUFBcEI7QUFDQSxVQUFNO0FBQUNXLE1BQUFBO0FBQUQsUUFBVUYsS0FBaEI7QUFDQSxVQUFNVSxXQUFXLEdBQUcsSUFBSUMsT0FBSixDQUFZQyxPQUFPLElBQUk7QUFDekNaLE1BQUFBLEtBQUssQ0FBQ2EsRUFBTixDQUFTLE1BQVQsRUFBaUIsTUFBTTtBQUNyQkQsUUFBQUEsT0FBTztBQUNSLE9BRkQ7QUFHQUUsTUFBQUEsVUFBVSxDQUFDLE1BQU07QUFDZnRCLFFBQUFBLGFBQWEsQ0FBQ3VCLFdBQWQ7O0FBQ0FILFFBQUFBLE9BQU87QUFDUixPQUhTLEVBR1BKLE9BSE8sQ0FBVjtBQUlELEtBUm1CLENBQXBCLENBYmdFLENBc0JoRTs7QUFDQSxRQUFJLENBQUNOLEtBQUssQ0FBQ0osS0FBTixDQUFZSyxZQUFHQyxHQUFmLENBQUwsRUFBMEI7QUFDeEJGLE1BQUFBLEtBQUssQ0FBQ2MsSUFBTixDQUFXLE9BQVgsRUFBb0IsTUFBTWQsS0FBSyxDQUFDZSxHQUFOLEVBQTFCO0FBQ0QsS0FGRCxNQUVPO0FBQ0xmLE1BQUFBLEtBQUssQ0FBQ2UsR0FBTjtBQUNEOztBQUNELFdBQU9QLFdBQVA7QUFDRDs7QUFFRGYsRUFBQUEsZ0JBQWdCLEdBQXdDO0FBQ3RELFFBQUksS0FBS0osYUFBVCxFQUF3QjtBQUN0QixhQUFPLEtBQUtBLGFBQVo7QUFDRCxLQUhxRCxDQUt0RDtBQUNBOzs7QUFDQSxVQUFNMkIsU0FBUyxHQUFHLDhCQUFsQjtBQUNBLFVBQU1DLGFBQWEsR0FBRyxvQkFBTXRDLGtCQUFOLEVBQTBCLENBQUMsS0FBS1MsZUFBTixDQUExQixFQUFrRDtBQUN0RThCLE1BQUFBLGdCQUFnQixFQUFFO0FBRG9ELEtBQWxELEVBR25CQyxFQUhtQixDQUdoQnJCLEtBQUssSUFBSTtBQUNYLFlBQU1zQixRQUFRLEdBQUcsaUNBQW1CSixTQUFwQzs7QUFDQSxVQUFJSSxRQUFRLEdBQUdyQyxpQkFBZixFQUFrQztBQUNoQ0MsUUFBQUEsYUFBYSxDQUFDVyxRQUFkLEdBQXlCLEtBQXpCO0FBQ0EsK0JBQVUsZUFBVixFQUEyQlMsS0FBM0IsQ0FDRyx3REFBdURnQixRQUFTLEtBRG5FLEVBRmdDLENBS2hDO0FBQ0E7O0FBQ0EsYUFBS2YsSUFBTDtBQUNEOztBQUNEUCxNQUFBQSxLQUFLLENBQUNFLEtBQU4sQ0FBWXFCLGtCQUFaLENBQStCLE1BQS9CO0FBQ0QsS0FmbUIsRUFnQm5CQyxPQWhCbUIsQ0FnQlgsTUFBTTtBQUNiO0FBQ0EsVUFBSSxLQUFLakMsYUFBTCxLQUF1QmtDLFlBQTNCLEVBQXlDO0FBQ3ZDLGFBQUtoQixNQUFMO0FBQ0Q7QUFDRixLQXJCbUIsRUFzQm5CaUIsT0F0Qm1CLEVBQXRCO0FBd0JBLFVBQU1ELFlBQVksR0FBSSxLQUFLbEMsYUFBTCxHQUFxQjRCLGFBQWEsQ0FDckRRLEtBRHdDLEdBRXhDQyxTQUZ3QyxFQUEzQztBQUdBLFNBQUtwQyxhQUFMLEdBQXFCMkIsYUFBYSxDQUFDVSxPQUFkLEVBQXJCOztBQUVBLFFBQUksS0FBS25DLGFBQUwsSUFBc0IsSUFBMUIsRUFBZ0M7QUFDOUIsV0FBS0QsVUFBTCxHQUFrQnFCLFVBQVUsQ0FBQyxNQUFNO0FBQ2pDLGFBQUtyQixVQUFMLEdBQWtCLElBQWxCO0FBQ0EsYUFBS2MsSUFBTDtBQUNELE9BSDJCLEVBR3pCLEtBQUtiLGFBSG9CLENBQTVCO0FBSUQ7O0FBRUQsV0FBTytCLFlBQVA7QUFDRDs7QUFFRGhCLEVBQUFBLE1BQU0sR0FBRztBQUNQLFNBQUtsQixhQUFMLEdBQXFCLElBQXJCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixJQUFyQjs7QUFDQSxRQUFJLEtBQUtDLFVBQUwsSUFBbUIsSUFBdkIsRUFBNkI7QUFDM0JxQyxNQUFBQSxZQUFZLENBQUMsS0FBS3JDLFVBQU4sQ0FBWjtBQUNBLFdBQUtBLFVBQUwsR0FBa0IsSUFBbEI7QUFDRDtBQUNGOztBQXhKZ0M7OztBQUFkUCxhLENBQ1pXLFEsR0FBb0IsSTtBQURSWCxhLENBcUJaNkMsaUIsR0FBNEMsbUJBQUssWUFBWTtBQUNsRSxRQUFNLENBQUNDLFFBQUQsRUFBV0MsU0FBWCxJQUF3QixNQUFNdEIsT0FBTyxDQUFDdUIsR0FBUixDQUFZLENBQzlDLG9CQUFNckQsa0JBQU4sQ0FEOEMsRUFFOUNFLE9BQU8sQ0FBQ0MsUUFBUixLQUFxQixRQUFyQixHQUNJLHVCQUFTLHNCQUFULENBREosR0FFSTJCLE9BQU8sQ0FBQ0MsT0FBUixDQUFnQixJQUFoQixDQUowQyxDQUFaLENBQXBDO0FBTUEsU0FBT29CLFFBQVEsSUFBSSxJQUFaLElBQW9CQyxTQUEzQjtBQUNELENBUmtELEM7QUFzSTlDLE1BQU1FLFFBQVEsR0FBRztBQUN0QkMsRUFBQUEsbUJBQW1CLENBQUNDLFVBQUQsRUFBNkI7QUFDOUMsVUFBTUMsZUFBZSxHQUFHekQsa0JBQXhCO0FBQ0FBLElBQUFBLGtCQUFrQixHQUFHd0QsVUFBckI7QUFDQSxXQUFPQyxlQUFQO0FBQ0Q7O0FBTHFCLENBQWpCOzs7QUFRUCxTQUFTckMsYUFBVCxDQUF1QnNDLE1BQXZCLEVBQStCeEMsT0FBL0IsRUFBdUQ7QUFDckQsU0FBTyxJQUFJWSxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVNEIsTUFBVixLQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBTUMsV0FBVyxHQUFHcEMsR0FBRyxJQUFJO0FBQ3pCbUMsTUFBQUEsTUFBTSxDQUFDbkMsR0FBRCxDQUFOO0FBQ0FrQyxNQUFBQSxNQUFNLENBQUNHLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0JELFdBQS9CO0FBQ0QsS0FIRDs7QUFJQUYsSUFBQUEsTUFBTSxDQUFDdkIsSUFBUCxDQUFZLE9BQVosRUFBcUJ5QixXQUFyQjtBQUNBRixJQUFBQSxNQUFNLENBQUN6QyxLQUFQLENBQWFDLE9BQWIsRUFBc0JNLEdBQUcsSUFBSTtBQUMzQixVQUFJQSxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmb0MsUUFBQUEsV0FBVyxDQUFDcEMsR0FBRCxDQUFYO0FBQ0E7QUFDRDs7QUFDRGtDLE1BQUFBLE1BQU0sQ0FBQ0csY0FBUCxDQUFzQixPQUF0QixFQUErQkQsV0FBL0I7QUFDQTdCLE1BQUFBLE9BQU87QUFDUixLQVBEO0FBUUQsR0FuQk0sQ0FBUDtBQW9CRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3cgc3RyaWN0LWxvY2FsXHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQge2dldExvZ2dlcn0gZnJvbSAnbG9nNGpzJztcclxuaW1wb3J0IHBlcmZvcm1hbmNlTm93IGZyb20gJy4vcGVyZm9ybWFuY2VOb3cnO1xyXG5pbXBvcnQgb3MgZnJvbSAnb3MnO1xyXG5pbXBvcnQge3NwYXdufSBmcm9tICcuL3Byb2Nlc3MnO1xyXG5pbXBvcnQgd2hpY2ggZnJvbSAnLi93aGljaCc7XHJcbmltcG9ydCBvbmNlIGZyb20gJy4vb25jZSc7XHJcbmltcG9ydCBwYXNzZXNHSyBmcm9tICcuL3Bhc3Nlc0dLJztcclxuXHJcbmNvbnN0IERFRkFVTFRfSk9JTl9USU1FT1VUID0gNTAwMDtcclxubGV0IFNDUklCRV9DQVRfQ09NTUFORCA9ICdzY3JpYmVfY2F0JztcclxuXHJcbi8vIE9uIE1hYyBPUywgYHNjcmliZV9jYXRgIGlzbid0IHF1aXRlIHRoZSBzYW1lIGFzIHRoZSBzZXJ2ZXItc2lkZSBvbmU6XHJcbi8vIGl0IG9ubHkgZHVtcHMgaXRzIGxvZ3Mgb24gZXhpdC4gVG8gbWFrZSBzdXJlIHRoYXQgbG9ncyBhcmUgZGVsaXZlcmVkXHJcbi8vIGluIGEgdGltZWx5IG1hbm5lciwgd2UnbGwgcGVyaW9kaWNhbGx5IGZvcmNlLWtpbGwgdGhlIHByb2Nlc3MuXHJcbmNvbnN0IERFRkFVTFRfSk9JTl9JTlRFUlZBTCA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICdkYXJ3aW4nID8gNjAwMDAgOiBudWxsO1xyXG5cclxuLy8gSWYgc3Bhd25pbmcgdGhlIFNjcmliZSBwcm9jZXNzIHRha2VzIHRoaXMgbG9uZywgZGlzYWJsZSBpdC5cclxuLy8gTm9kZSBzb21ldGltZXMgcnVucyBpbnRvIHN0cmFuZ2UgaXNzdWVzIHdoZXJlIHNwYXduaW5nKCkgc3RhcnRzIHRvIGJsb2NrLlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzE0OTE3XHJcbmNvbnN0IFNQQVdOX1RPT19MT05HX01TID0gMjAwMDtcclxuXHJcbi8qKlxyXG4gKiBBIHdyYXBwZXIgb2YgYHNjcmliZV9jYXRgIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2thcmNoaXZlL3NjcmliZS9ibG9iL21hc3Rlci9leGFtcGxlcy9zY3JpYmVfY2F0KVxyXG4gKiBjb21tYW5kLiBVc2VyIGNvdWxkIGNhbGwgYG5ldyBTY3JpYmVQcm9jZXNzKCRzY3JpYmVDYXRlZ29yeU5hbWUpYCB0byBjcmVhdGUgYSBwcm9jZXNzIGFuZCB0aGVuXHJcbiAqIGNhbGwgYHNjcmliZVByb2Nlc3Mud3JpdGUoJG9iamVjdClgIHRvIHNhdmUgYW4gSlNPTiBzY2hlbWFlZCBPYmplY3QgaW50byBzY3JpYmUgY2F0ZWdvcnkuXHJcbiAqIEl0IHdpbGwgYWxzbyByZWNvdmVyIGZyb20gYHNjcmliZV9jYXRgIGZhaWx1cmUgYXV0b21hdGljYWxseS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcmliZVByb2Nlc3Mge1xyXG4gIHN0YXRpYyBfZW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gIF9zY3JpYmVDYXRlZ29yeTogc3RyaW5nO1xyXG4gIF9jaGlsZFByb21pc2U6ID9Qcm9taXNlPGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzPjtcclxuICBfc3Vic2NyaXB0aW9uOiA/cnhqcyRJU3Vic2NyaXB0aW9uO1xyXG4gIF9qb2luVGltZXI6ID9UaW1lb3V0SUQ7XHJcbiAgX2pvaW5JbnRlcnZhbDogP251bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBzY3JpYmVDYXRlZ29yeTogc3RyaW5nLFxyXG4gICAgam9pbkludGVydmFsOiA/bnVtYmVyID0gREVGQVVMVF9KT0lOX0lOVEVSVkFMLFxyXG4gICkge1xyXG4gICAgdGhpcy5fc2NyaWJlQ2F0ZWdvcnkgPSBzY3JpYmVDYXRlZ29yeTtcclxuICAgIHRoaXMuX2pvaW5JbnRlcnZhbCA9IGpvaW5JbnRlcnZhbDtcclxuICAgIHRoaXMuX2dldENoaWxkUHJvY2VzcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYHNjcmliZV9jYXRgIGV4aXN0cyBpbiBQQVRILlxyXG4gICAqL1xyXG4gIHN0YXRpYyBpc1NjcmliZUNhdE9uUGF0aDogKCkgPT4gUHJvbWlzZTxib29sZWFuPiA9IG9uY2UoYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgW3doaWNoQ21kLCBna0VuYWJsZWRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICB3aGljaChTQ1JJQkVfQ0FUX0NPTU1BTkQpLFxyXG4gICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xyXG4gICAgICAgID8gcGFzc2VzR0soJ251Y2xpZGVfc2NyaWJlX21hY29zJylcclxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh0cnVlKSxcclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIHdoaWNoQ21kICE9IG51bGwgJiYgZ2tFbmFibGVkO1xyXG4gIH0pO1xyXG5cclxuICBzdGF0aWMgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIFNjcmliZVByb2Nlc3MuX2VuYWJsZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBXcml0ZSBhIHN0cmluZyB0byBhIFNjcmliZSBjYXRlZ29yeS5cclxuICAgKiBFbnN1cmUgbmV3bGluZXMgYXJlIHByb3Blcmx5IGVzY2FwZWQuXHJcbiAgICogUmV0dXJucyBmYWxzZSBpZiBzb21ldGhpbmcgaXMgd3Jvbmcgd2l0aCB0aGUgU2NyaWJlIHByb2Nlc3MgKHVzZSBhIGZhbGxiYWNrIGluc3RlYWQuKVxyXG4gICAqL1xyXG4gIGFzeW5jIHdyaXRlKG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgaWYgKCFTY3JpYmVQcm9jZXNzLl9lbmFibGVkKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGxldCBjaGlsZDtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNoaWxkID0gYXdhaXQgdGhpcy5fZ2V0Q2hpbGRQcm9jZXNzKCk7XHJcbiAgICAgIGF3YWl0IHdyaXRlVG9TdHJlYW0oY2hpbGQuc3RkaW4sIGAke21lc3NhZ2V9JHtvcy5FT0x9YCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgU2NyaWJlUHJvY2Vzcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAvLyBOb3RlOiBMb2dnaW5nIGVycm9ycyBpcyBwb3RlbnRpYWxseSByZWN1cnNpdmUsIHNpbmNlIHRoZXkgZ28gdGhyb3VnaCBTY3JpYmUhXHJcbiAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2Ugc2V0IF9lbmFibGVkIGJlZm9yZSBsb2dnaW5nIGVycm9ycyBpbiB0aGlzIGZpbGUuXHJcbiAgICAgIGdldExvZ2dlcignU2NyaWJlUHJvY2VzcycpLmVycm9yKFxyXG4gICAgICAgICdEaXNhYmxpbmcgU2NyaWJlUHJvY2VzcyBkdWUgdG8gZXJyb3I6JyxcclxuICAgICAgICBlcnIsXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFdhaXRzIGZvciB0aGUgcmVtYWluaW5nIG1lc3NhZ2VzIHRvIGJlIHdyaXR0ZW4sIHRoZW4gY2xvc2VzIHRoZSB3cml0ZSBzdHJlYW0uIFJlc29sdmVzIG9uY2UgdGhlXHJcbiAgICogcHJvY2VzcyBoYXMgZXhpdGVkLiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIHNodXRzIGRvd24gaW4gb3JkZXIgdG8gZ3VhcmFudGVlIHdlXHJcbiAgICogY2FwdHVyZSBsb2dnaW5nIGR1cmluZyBzaHV0ZG93bi5cclxuICAgKi9cclxuICBhc3luYyBqb2luKHRpbWVvdXQ6IG51bWJlciA9IERFRkFVTFRfSk9JTl9USU1FT1VUKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB7X2NoaWxkUHJvbWlzZSwgX3N1YnNjcmlwdGlvbn0gPSB0aGlzO1xyXG4gICAgaWYgKF9jaGlsZFByb21pc2UgPT0gbnVsbCB8fCBfc3Vic2NyaXB0aW9uID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGpvaW4oKSByZW5kZXJzIHRoZSBleGlzdGluZyBwcm9jZXNzIHVudXNhYmxlLlxyXG4gICAgLy8gVGhlIG5leHQgY2FsbCB0byB3cml0ZSgpIHNob3VsZCBjcmVhdGUgYSBuZXcgcHJvY2Vzcywgc28gY2xlYXIgb3V0IHRoZSByZWZlcmVuY2VzLlxyXG4gICAgLy8gTm90ZSB0aGF0IHdlIHN0b3JlZCB0aGVtIGluIGxvY2FsIHZhcmlhYmxlcyBhbHJlYWR5IGFib3ZlLlxyXG4gICAgdGhpcy5fY2xlYXIoKTtcclxuXHJcbiAgICBjb25zdCBjaGlsZCA9IGF3YWl0IF9jaGlsZFByb21pc2U7XHJcbiAgICBjb25zdCB7c3RkaW59ID0gY2hpbGQ7XHJcbiAgICBjb25zdCB3YWl0Rm9yRXhpdCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICBjaGlsZC5vbignZXhpdCcsICgpID0+IHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBfc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9LCB0aW1lb3V0KTtcclxuICAgIH0pO1xyXG4gICAgLy8gTWFrZSBzdXJlIHN0ZGluIGhhcyBkcmFpbmVkIGJlZm9yZSBlbmRpbmcgaXQuXHJcbiAgICBpZiAoIXN0ZGluLndyaXRlKG9zLkVPTCkpIHtcclxuICAgICAgc3RkaW4ub25jZSgnZHJhaW4nLCAoKSA9PiBzdGRpbi5lbmQoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGRpbi5lbmQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB3YWl0Rm9yRXhpdDtcclxuICB9XHJcblxyXG4gIF9nZXRDaGlsZFByb2Nlc3MoKTogUHJvbWlzZTxjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcz4ge1xyXG4gICAgaWYgKHRoaXMuX2NoaWxkUHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fY2hpbGRQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9idGFpbiBhIHByb21pc2UgdG8gZ2V0IHRoZSBjaGlsZCBwcm9jZXNzLCBidXQgZG9uJ3Qgc3RhcnQgaXQgeWV0LlxyXG4gICAgLy8gdGhpcy5fc3Vic2NyaXB0aW9uIHdpbGwgaGF2ZSBjb250cm9sIG92ZXIgc3RhcnRpbmcgLyBzdG9wcGluZyB0aGUgcHJvY2Vzcy5cclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XHJcbiAgICBjb25zdCBwcm9jZXNzU3RyZWFtID0gc3Bhd24oU0NSSUJFX0NBVF9DT01NQU5ELCBbdGhpcy5fc2NyaWJlQ2F0ZWdvcnldLCB7XHJcbiAgICAgIGRvbnRMb2dJbk51Y2xpZGU6IHRydWUsXHJcbiAgICB9KVxyXG4gICAgICAuZG8oY2hpbGQgPT4ge1xyXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0VGltZTtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPiBTUEFXTl9UT09fTE9OR19NUykge1xyXG4gICAgICAgICAgU2NyaWJlUHJvY2Vzcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgZ2V0TG9nZ2VyKCdTY3JpYmVQcm9jZXNzJykuZXJyb3IoXHJcbiAgICAgICAgICAgIGBEaXNhYmxpbmcgU2NyaWJlUHJvY2VzcyBiZWNhdXNlIHNwYXduIHRvb2sgdG9vIGxvbmcgKCR7ZHVyYXRpb259bXMpYCxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICAvLyBEb24ndCByYWlzZSBhbnkgZXJyb3JzIGFuZCBhbGxvdyB0aGUgY3VycmVudCB3cml0ZSB0byBjb21wbGV0ZS5cclxuICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZSBuZXh0IHdyaXRlIHdpbGwgZmFpbCBkdWUgdG8gdGhlIF9lbmFibGVkIGNoZWNrLlxyXG4gICAgICAgICAgdGhpcy5qb2luKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkLnN0ZGluLnNldERlZmF1bHRFbmNvZGluZygndXRmOCcpO1xyXG4gICAgICB9KVxyXG4gICAgICAuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgLy8gV2UgbWF5IGhhdmUgYWxyZWFkeSBzdGFydGVkIGEgbmV3IHByb2Nlc3MgaW4gdGhlIG1lYW50aW1lLlxyXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZFByb21pc2UgPT09IGNoaWxkUHJvbWlzZSkge1xyXG4gICAgICAgICAgdGhpcy5fY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5wdWJsaXNoKCk7XHJcblxyXG4gICAgY29uc3QgY2hpbGRQcm9taXNlID0gKHRoaXMuX2NoaWxkUHJvbWlzZSA9IHByb2Nlc3NTdHJlYW1cclxuICAgICAgLmZpcnN0KClcclxuICAgICAgLnRvUHJvbWlzZSgpKTtcclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHByb2Nlc3NTdHJlYW0uY29ubmVjdCgpO1xyXG5cclxuICAgIGlmICh0aGlzLl9qb2luSW50ZXJ2YWwgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9qb2luVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICB0aGlzLl9qb2luVGltZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuam9pbigpO1xyXG4gICAgICB9LCB0aGlzLl9qb2luSW50ZXJ2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaGlsZFByb21pc2U7XHJcbiAgfVxyXG5cclxuICBfY2xlYXIoKSB7XHJcbiAgICB0aGlzLl9jaGlsZFByb21pc2UgPSBudWxsO1xyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gbnVsbDtcclxuICAgIGlmICh0aGlzLl9qb2luVGltZXIgIT0gbnVsbCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fam9pblRpbWVyKTtcclxuICAgICAgdGhpcy5fam9pblRpbWVyID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBfX3Rlc3RfXyA9IHtcclxuICBzZXRTY3JpYmVDYXRDb21tYW5kKG5ld0NvbW1hbmQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBvcmlnaW5hbENvbW1hbmQgPSBTQ1JJQkVfQ0FUX0NPTU1BTkQ7XHJcbiAgICBTQ1JJQkVfQ0FUX0NPTU1BTkQgPSBuZXdDb21tYW5kO1xyXG4gICAgcmV0dXJuIG9yaWdpbmFsQ29tbWFuZDtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JpdGVUb1N0cmVhbShzdHJlYW0sIG1lc3NhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgLy8gQWNjb3JkaW5nIHRvIGBzdHJlYW0ud3JpdGUoKWAgW2RvY3NdWzFdLCBcIklmIGFuIGVycm9yIG9jY3VycywgdGhlXHJcbiAgICAvLyBjYWxsYmFjayBtYXkgb3IgbWF5IG5vdCBiZSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50LlxyXG4gICAgLy8gVG8gcmVsaWFibHkgZGV0ZWN0IHdyaXRlIGVycm9ycywgYWRkIGEgbGlzdGVuZXIgZm9yIHRoZSAnZXJyb3InIGV2ZW50LlwiXHJcbiAgICAvL1xyXG4gICAgLy8gWzFdOiBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI3N0cmVhbV93cml0YWJsZV93cml0ZV9jaHVua19lbmNvZGluZ19jYWxsYmFja1xyXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSBlcnIgPT4ge1xyXG4gICAgICByZWplY3QoZXJyKTtcclxuICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcclxuICAgIH07XHJcbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBoYW5kbGVFcnJvcik7XHJcbiAgICBzdHJlYW0ud3JpdGUobWVzc2FnZSwgZXJyID0+IHtcclxuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcclxuICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuIl19