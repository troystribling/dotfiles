"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.track = track;
exports.isTrackSupported = isTrackSupported;
exports.trackImmediate = trackImmediate;
exports.trackEvent = trackEvent;
exports.trackEvents = trackEvents;
exports.trackSampled = trackSampled;
exports.startTracking = startTracking;
exports.trackTiming = trackTiming;
exports.decorateTrackTiming = decorateTrackTiming;
exports.trackTimingSampled = trackTimingSampled;
exports.decorateTrackTimingSampled = decorateTrackTimingSampled;
exports.setRawAnalyticsService = setRawAnalyticsService;
exports.default = exports.TimingTracker = void 0;

var _getDisplayName = _interopRequireDefault(require("./getDisplayName"));

var _UniversalDisposable = _interopRequireDefault(require("./UniversalDisposable"));

var _promise = require("./promise");

var _performanceNow = _interopRequireDefault(require("./performanceNow"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
let rawAnalyticsService = {
  track() {},

  isTrackSupported: () => false,
  setApplicationSessionObservable: ob => {}
};

/**
 * Track a set of values against a named event.
 * Analytics will be batched and processed asynchronously in the background.
 *
 * @param eventName Name of the event to be tracked.
 * @param values The object containing the data to track.
 */
function track(eventName, values) {
  rawAnalyticsService.track(eventName, values || {});
}

function isTrackSupported() {
  return rawAnalyticsService.isTrackSupported();
}
/**
 * Same as `track`, except this is guaranteed to send immediately.
 * The returned promise will resolve when the request completes (or reject on failure).
 */


function trackImmediate(eventName, values) {
  return rawAnalyticsService.track(eventName, values || {}, true) || Promise.resolve();
}
/**
 * An alternative interface for `track` that accepts a single event object. This is particularly
 * useful when dealing with streams (Observables).
 */


function trackEvent(event) {
  track(event.type, event.data);
}
/**
 * Track each event in a stream of TrackingEvents.
 */


function trackEvents(events) {
  return new _UniversalDisposable.default(events.subscribe(trackEvent));
}
/**
 * A sampled version of track that only tracks every 1/sampleRate calls.
 */


function trackSampled(eventName, sampleRate, values) {
  if (Math.random() * sampleRate <= 1) {
    rawAnalyticsService.track(eventName, { ...values,
      sample_rate: sampleRate
    });
  }
}

const PERFORMANCE_EVENT = 'performance';
const canMeasure = typeof performance !== 'undefined';

class TimingTracker {
  constructor(eventName, values) {
    this._eventName = void 0;
    this._startTime = void 0;
    this._startMark = void 0;
    this._values = void 0;
    this._eventName = eventName;
    this._startMark = `${this._eventName}_${TimingTracker.eventCount++}_start`;
    this._startTime = (0, _performanceNow.default)();
    this._values = values;

    if (canMeasure) {
      // eslint-disable-next-line no-undef
      performance.mark(this._startMark);
    }
  }

  onError(error) {
    this._trackTimingEvent(error);
  }

  onCancel() {
    this._trackTimingEvent(
    /* error */
    null, true);
  }

  onSuccess() {
    this._trackTimingEvent(
    /* error */
    null);
  }

  _trackTimingEvent(exception, canceled = false) {
    if (canMeasure) {
      /* eslint-disable no-undef */
      // call measure to add this information to the devtools timeline in the
      // case the profiler is running.
      performance.measure(this._eventName, this._startMark); // then clear all the marks and measurements to avoid growing the
      // performance entry buffer

      performance.clearMarks(this._startMark);
      performance.clearMeasures(this._eventName);
      /* eslint-enable no-undef */
    }

    track(PERFORMANCE_EVENT, { ...this._values,
      duration: Math.round((0, _performanceNow.default)() - this._startTime).toString(),
      eventName: this._eventName,
      error: exception ? '1' : '0',
      exception: exception ? exception.toString() : '',
      canceled
    });
  }

}

exports.TimingTracker = TimingTracker;
TimingTracker.eventCount = 0;

function startTracking(eventName, values = {}) {
  return new TimingTracker(eventName, values);
}
/**
 * Reports analytics including timing for a single operation.
 *
 * Usage:
 *
 * analytics.trackTiming('my-package-some-long-operation' () => doit());
 *
 * Returns (or throws) the result of the operation.
 */


function trackTiming(eventName, operation, values = {}) {
  const tracker = startTracking(eventName, values);

  try {
    const result = operation();

    if ((0, _promise.isPromise)(result)) {
      // Atom uses a different Promise implementation than Nuclide, so the following is not true:
      // invariant(result instanceof Promise);
      // For the method returning a Promise, track the time after the promise is resolved/rejected.
      return result.then(value => {
        tracker.onSuccess();
        return value;
      }, reason => {
        tracker.onError(reason instanceof Error ? reason : new Error(reason));
        return Promise.reject(reason);
      });
    } else {
      tracker.onSuccess();
      return result;
    }
  } catch (error) {
    tracker.onError(error);
    throw error;
  }
}

function decorateTrackTiming(fn, values = {}) {
  const name = (0, _getDisplayName.default)(fn);

  function decoratedTrackTiming(...args) {
    return trackTiming(name, fn.bind(this, ...args), values);
  }

  decoratedTrackTiming.displayName = `trackTiming(${name})`;
  return decoratedTrackTiming;
}
/**
 * A sampled version of trackTiming that only tracks every 1/sampleRate calls.
 */


function trackTimingSampled(eventName, operation, sampleRate, values = {}) {
  if (Math.random() * sampleRate <= 1) {
    return trackTiming(eventName, operation, { ...values,
      sample_rate: sampleRate
    });
  }

  return operation();
}

function decorateTrackTimingSampled(fn, sampleRate, values = {}) {
  const name = (0, _getDisplayName.default)(fn);

  function decoratedTrackTimingSampled(...args) {
    return trackTimingSampled(name, fn.bind(this, ...args), sampleRate, values);
  }

  decoratedTrackTimingSampled.displayName = `trackTimingSampled(${name})`;
  return decoratedTrackTimingSampled;
}

function setRawAnalyticsService(analyticsService, ob) {
  analyticsService.setApplicationSessionObservable(ob);
  rawAnalyticsService = analyticsService;
}

var _default = {
  track,
  trackSampled,
  trackEvent,
  trackTiming,
  trackTimingSampled,
  startTracking,
  TimingTracker,
  decorateTrackTiming,
  decorateTrackTimingSampled
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL2FuYWx5dGljcy5qcyJdLCJuYW1lcyI6WyJyYXdBbmFseXRpY3NTZXJ2aWNlIiwidHJhY2siLCJpc1RyYWNrU3VwcG9ydGVkIiwic2V0QXBwbGljYXRpb25TZXNzaW9uT2JzZXJ2YWJsZSIsIm9iIiwiZXZlbnROYW1lIiwidmFsdWVzIiwidHJhY2tJbW1lZGlhdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRyYWNrRXZlbnQiLCJldmVudCIsInR5cGUiLCJkYXRhIiwidHJhY2tFdmVudHMiLCJldmVudHMiLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwic3Vic2NyaWJlIiwidHJhY2tTYW1wbGVkIiwic2FtcGxlUmF0ZSIsIk1hdGgiLCJyYW5kb20iLCJzYW1wbGVfcmF0ZSIsIlBFUkZPUk1BTkNFX0VWRU5UIiwiY2FuTWVhc3VyZSIsInBlcmZvcm1hbmNlIiwiVGltaW5nVHJhY2tlciIsImNvbnN0cnVjdG9yIiwiX2V2ZW50TmFtZSIsIl9zdGFydFRpbWUiLCJfc3RhcnRNYXJrIiwiX3ZhbHVlcyIsImV2ZW50Q291bnQiLCJtYXJrIiwib25FcnJvciIsImVycm9yIiwiX3RyYWNrVGltaW5nRXZlbnQiLCJvbkNhbmNlbCIsIm9uU3VjY2VzcyIsImV4Y2VwdGlvbiIsImNhbmNlbGVkIiwibWVhc3VyZSIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwiZHVyYXRpb24iLCJyb3VuZCIsInRvU3RyaW5nIiwic3RhcnRUcmFja2luZyIsInRyYWNrVGltaW5nIiwib3BlcmF0aW9uIiwidHJhY2tlciIsInJlc3VsdCIsInRoZW4iLCJ2YWx1ZSIsInJlYXNvbiIsIkVycm9yIiwicmVqZWN0IiwiZGVjb3JhdGVUcmFja1RpbWluZyIsImZuIiwibmFtZSIsImRlY29yYXRlZFRyYWNrVGltaW5nIiwiYXJncyIsImJpbmQiLCJkaXNwbGF5TmFtZSIsInRyYWNrVGltaW5nU2FtcGxlZCIsImRlY29yYXRlVHJhY2tUaW1pbmdTYW1wbGVkIiwiZGVjb3JhdGVkVHJhY2tUaW1pbmdTYW1wbGVkIiwic2V0UmF3QW5hbHl0aWNzU2VydmljZSIsImFuYWx5dGljc1NlcnZpY2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBd0JBLElBQUlBLG1CQUF3QyxHQUFHO0FBQzdDQyxFQUFBQSxLQUFLLEdBQW9CLENBQUUsQ0FEa0I7O0FBRTdDQyxFQUFBQSxnQkFBZ0IsRUFBRSxNQUFNLEtBRnFCO0FBRzdDQyxFQUFBQSwrQkFBK0IsRUFBR0MsRUFBRCxJQUFpQyxDQUFFO0FBSHZCLENBQS9DOztBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNILEtBQVQsQ0FDTEksU0FESyxFQUVMQyxNQUZLLEVBR0M7QUFDTk4sRUFBQUEsbUJBQW1CLENBQUNDLEtBQXBCLENBQTBCSSxTQUExQixFQUFxQ0MsTUFBTSxJQUFJLEVBQS9DO0FBQ0Q7O0FBRU0sU0FBU0osZ0JBQVQsR0FBcUM7QUFDMUMsU0FBT0YsbUJBQW1CLENBQUNFLGdCQUFwQixFQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0ssY0FBVCxDQUNMRixTQURLLEVBRUxDLE1BRkssRUFHVztBQUNoQixTQUNFTixtQkFBbUIsQ0FBQ0MsS0FBcEIsQ0FBMEJJLFNBQTFCLEVBQXFDQyxNQUFNLElBQUksRUFBL0MsRUFBbUQsSUFBbkQsS0FDQUUsT0FBTyxDQUFDQyxPQUFSLEVBRkY7QUFJRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTQyxVQUFULENBQW9CQyxLQUFwQixFQUFnRDtBQUNyRFYsRUFBQUEsS0FBSyxDQUFDVSxLQUFLLENBQUNDLElBQVAsRUFBYUQsS0FBSyxDQUFDRSxJQUFuQixDQUFMO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7OztBQUNPLFNBQVNDLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQXFFO0FBQzFFLFNBQU8sSUFBSUMsNEJBQUosQ0FBd0JELE1BQU0sQ0FBQ0UsU0FBUCxDQUFpQlAsVUFBakIsQ0FBeEIsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBOzs7QUFDTyxTQUFTUSxZQUFULENBQ0xiLFNBREssRUFFTGMsVUFGSyxFQUdMYixNQUhLLEVBSUM7QUFDTixNQUFJYyxJQUFJLENBQUNDLE1BQUwsS0FBZ0JGLFVBQWhCLElBQThCLENBQWxDLEVBQXFDO0FBQ25DbkIsSUFBQUEsbUJBQW1CLENBQUNDLEtBQXBCLENBQTBCSSxTQUExQixFQUFxQyxFQUNuQyxHQUFHQyxNQURnQztBQUVuQ2dCLE1BQUFBLFdBQVcsRUFBRUg7QUFGc0IsS0FBckM7QUFJRDtBQUNGOztBQUVELE1BQU1JLGlCQUFpQixHQUFHLGFBQTFCO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLE9BQU9DLFdBQVAsS0FBdUIsV0FBMUM7O0FBQ08sTUFBTUMsYUFBTixDQUFvQjtBQVF6QkMsRUFBQUEsV0FBVyxDQUFDdEIsU0FBRCxFQUFvQkMsTUFBcEIsRUFBb0Q7QUFBQSxTQUwvRHNCLFVBSytEO0FBQUEsU0FKL0RDLFVBSStEO0FBQUEsU0FIL0RDLFVBRytEO0FBQUEsU0FGL0RDLE9BRStEO0FBQzdELFNBQUtILFVBQUwsR0FBa0J2QixTQUFsQjtBQUNBLFNBQUt5QixVQUFMLEdBQW1CLEdBQUUsS0FBS0YsVUFBVyxJQUFHRixhQUFhLENBQUNNLFVBQWQsRUFBMkIsUUFBbkU7QUFDQSxTQUFLSCxVQUFMLEdBQWtCLDhCQUFsQjtBQUNBLFNBQUtFLE9BQUwsR0FBZXpCLE1BQWY7O0FBQ0EsUUFBSWtCLFVBQUosRUFBZ0I7QUFDZDtBQUNBQyxNQUFBQSxXQUFXLENBQUNRLElBQVosQ0FBaUIsS0FBS0gsVUFBdEI7QUFDRDtBQUNGOztBQUVESSxFQUFBQSxPQUFPLENBQUNDLEtBQUQsRUFBcUI7QUFDMUIsU0FBS0MsaUJBQUwsQ0FBdUJELEtBQXZCO0FBQ0Q7O0FBRURFLEVBQUFBLFFBQVEsR0FBUztBQUNmLFNBQUtELGlCQUFMO0FBQXVCO0FBQVksUUFBbkMsRUFBeUMsSUFBekM7QUFDRDs7QUFFREUsRUFBQUEsU0FBUyxHQUFTO0FBQ2hCLFNBQUtGLGlCQUFMO0FBQXVCO0FBQVksUUFBbkM7QUFDRDs7QUFFREEsRUFBQUEsaUJBQWlCLENBQUNHLFNBQUQsRUFBb0JDLFFBQWlCLEdBQUcsS0FBeEMsRUFBcUQ7QUFDcEUsUUFBSWhCLFVBQUosRUFBZ0I7QUFDZDtBQUNBO0FBQ0E7QUFDQUMsTUFBQUEsV0FBVyxDQUFDZ0IsT0FBWixDQUFvQixLQUFLYixVQUF6QixFQUFxQyxLQUFLRSxVQUExQyxFQUpjLENBS2Q7QUFDQTs7QUFDQUwsTUFBQUEsV0FBVyxDQUFDaUIsVUFBWixDQUF1QixLQUFLWixVQUE1QjtBQUNBTCxNQUFBQSxXQUFXLENBQUNrQixhQUFaLENBQTBCLEtBQUtmLFVBQS9CO0FBQ0E7QUFDRDs7QUFFRDNCLElBQUFBLEtBQUssQ0FBQ3NCLGlCQUFELEVBQW9CLEVBQ3ZCLEdBQUcsS0FBS1EsT0FEZTtBQUV2QmEsTUFBQUEsUUFBUSxFQUFFeEIsSUFBSSxDQUFDeUIsS0FBTCxDQUFXLGlDQUFtQixLQUFLaEIsVUFBbkMsRUFBK0NpQixRQUEvQyxFQUZhO0FBR3ZCekMsTUFBQUEsU0FBUyxFQUFFLEtBQUt1QixVQUhPO0FBSXZCTyxNQUFBQSxLQUFLLEVBQUVJLFNBQVMsR0FBRyxHQUFILEdBQVMsR0FKRjtBQUt2QkEsTUFBQUEsU0FBUyxFQUFFQSxTQUFTLEdBQUdBLFNBQVMsQ0FBQ08sUUFBVixFQUFILEdBQTBCLEVBTHZCO0FBTXZCTixNQUFBQTtBQU51QixLQUFwQixDQUFMO0FBUUQ7O0FBcER3Qjs7O0FBQWRkLGEsQ0FDSk0sVSxHQUFhLEM7O0FBc0RmLFNBQVNlLGFBQVQsQ0FDTDFDLFNBREssRUFFTEMsTUFBNkIsR0FBRyxFQUYzQixFQUdVO0FBQ2YsU0FBTyxJQUFJb0IsYUFBSixDQUFrQnJCLFNBQWxCLEVBQTZCQyxNQUE3QixDQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVMwQyxXQUFULENBQ0wzQyxTQURLLEVBRUw0QyxTQUZLLEVBR0wzQyxNQUE2QixHQUFHLEVBSDNCLEVBSUY7QUFDSCxRQUFNNEMsT0FBTyxHQUFHSCxhQUFhLENBQUMxQyxTQUFELEVBQVlDLE1BQVosQ0FBN0I7O0FBRUEsTUFBSTtBQUNGLFVBQU02QyxNQUFNLEdBQUdGLFNBQVMsRUFBeEI7O0FBRUEsUUFBSSx3QkFBVUUsTUFBVixDQUFKLEVBQXVCO0FBQ3JCO0FBQ0E7QUFFQTtBQUNBLGFBQVFBLE1BQUQsQ0FBY0MsSUFBZCxDQUNMQyxLQUFLLElBQUk7QUFDUEgsUUFBQUEsT0FBTyxDQUFDWixTQUFSO0FBQ0EsZUFBT2UsS0FBUDtBQUNELE9BSkksRUFLTEMsTUFBTSxJQUFJO0FBQ1JKLFFBQUFBLE9BQU8sQ0FBQ2hCLE9BQVIsQ0FBZ0JvQixNQUFNLFlBQVlDLEtBQWxCLEdBQTBCRCxNQUExQixHQUFtQyxJQUFJQyxLQUFKLENBQVVELE1BQVYsQ0FBbkQ7QUFDQSxlQUFPOUMsT0FBTyxDQUFDZ0QsTUFBUixDQUFlRixNQUFmLENBQVA7QUFDRCxPQVJJLENBQVA7QUFVRCxLQWZELE1BZU87QUFDTEosTUFBQUEsT0FBTyxDQUFDWixTQUFSO0FBQ0EsYUFBT2EsTUFBUDtBQUNEO0FBQ0YsR0F0QkQsQ0FzQkUsT0FBT2hCLEtBQVAsRUFBYztBQUNkZSxJQUFBQSxPQUFPLENBQUNoQixPQUFSLENBQWdCQyxLQUFoQjtBQUNBLFVBQU1BLEtBQU47QUFDRDtBQUNGOztBQUVNLFNBQVNzQixtQkFBVCxDQUNMQyxFQURLLEVBRUxwRCxNQUE2QixHQUFHLEVBRjNCLEVBR2M7QUFDbkIsUUFBTXFELElBQUksR0FBRyw2QkFBZUQsRUFBZixDQUFiOztBQUNBLFdBQVNFLG9CQUFULENBQThCLEdBQUdDLElBQWpDLEVBQTBDO0FBQ3hDLFdBQU9iLFdBQVcsQ0FBQ1csSUFBRCxFQUFPRCxFQUFFLENBQUNJLElBQUgsQ0FBUSxJQUFSLEVBQWMsR0FBR0QsSUFBakIsQ0FBUCxFQUErQnZELE1BQS9CLENBQWxCO0FBQ0Q7O0FBQ0RzRCxFQUFBQSxvQkFBb0IsQ0FBQ0csV0FBckIsR0FBb0MsZUFBY0osSUFBSyxHQUF2RDtBQUNBLFNBQU9DLG9CQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7OztBQUNPLFNBQVNJLGtCQUFULENBQ0wzRCxTQURLLEVBRUw0QyxTQUZLLEVBR0w5QixVQUhLLEVBSUxiLE1BQTZCLEdBQUcsRUFKM0IsRUFLRjtBQUNILE1BQUljLElBQUksQ0FBQ0MsTUFBTCxLQUFnQkYsVUFBaEIsSUFBOEIsQ0FBbEMsRUFBcUM7QUFDbkMsV0FBTzZCLFdBQVcsQ0FBQzNDLFNBQUQsRUFBWTRDLFNBQVosRUFBdUIsRUFDdkMsR0FBRzNDLE1BRG9DO0FBRXZDZ0IsTUFBQUEsV0FBVyxFQUFFSDtBQUYwQixLQUF2QixDQUFsQjtBQUlEOztBQUNELFNBQU84QixTQUFTLEVBQWhCO0FBQ0Q7O0FBRU0sU0FBU2dCLDBCQUFULENBQ0xQLEVBREssRUFFTHZDLFVBRkssRUFHTGIsTUFBNkIsR0FBRyxFQUgzQixFQUljO0FBQ25CLFFBQU1xRCxJQUFJLEdBQUcsNkJBQWVELEVBQWYsQ0FBYjs7QUFDQSxXQUFTUSwyQkFBVCxDQUFxQyxHQUFHTCxJQUF4QyxFQUFpRDtBQUMvQyxXQUFPRyxrQkFBa0IsQ0FBQ0wsSUFBRCxFQUFPRCxFQUFFLENBQUNJLElBQUgsQ0FBUSxJQUFSLEVBQWMsR0FBR0QsSUFBakIsQ0FBUCxFQUErQjFDLFVBQS9CLEVBQTJDYixNQUEzQyxDQUF6QjtBQUNEOztBQUNENEQsRUFBQUEsMkJBQTJCLENBQUNILFdBQTVCLEdBQTJDLHNCQUFxQkosSUFBSyxHQUFyRTtBQUNBLFNBQU9PLDJCQUFQO0FBQ0Q7O0FBRU0sU0FBU0Msc0JBQVQsQ0FDTEMsZ0JBREssRUFFTGhFLEVBRkssRUFHQztBQUNOZ0UsRUFBQUEsZ0JBQWdCLENBQUNqRSwrQkFBakIsQ0FBaURDLEVBQWpEO0FBQ0FKLEVBQUFBLG1CQUFtQixHQUFHb0UsZ0JBQXRCO0FBQ0Q7O2VBRWM7QUFDYm5FLEVBQUFBLEtBRGE7QUFFYmlCLEVBQUFBLFlBRmE7QUFHYlIsRUFBQUEsVUFIYTtBQUlic0MsRUFBQUEsV0FKYTtBQUtiZ0IsRUFBQUEsa0JBTGE7QUFNYmpCLEVBQUFBLGFBTmE7QUFPYnJCLEVBQUFBLGFBUGE7QUFRYitCLEVBQUFBLG1CQVJhO0FBU2JRLEVBQUFBO0FBVGEsQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5cclxuaW1wb3J0IGdldERpc3BsYXlOYW1lIGZyb20gJy4vZ2V0RGlzcGxheU5hbWUnO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICcuL1VuaXZlcnNhbERpc3Bvc2FibGUnO1xyXG5pbXBvcnQge2lzUHJvbWlzZX0gZnJvbSAnLi9wcm9taXNlJztcclxuaW1wb3J0IHBlcmZvcm1hbmNlTm93IGZyb20gJy4vcGVyZm9ybWFuY2VOb3cnO1xyXG5cclxuZXhwb3J0IHR5cGUgU2Vzc2lvbkluZm8gPSB7XHJcbiAgaWQ6IHN0cmluZyxcclxuICBzdGFydDogbnVtYmVyLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgUmF3QW5hbHl0aWNzU2VydmljZSA9IHtcclxuICB0cmFjayhcclxuICAgIGV2ZW50TmFtZTogc3RyaW5nLFxyXG4gICAgdmFsdWVzPzoge1trZXk6IHN0cmluZ106IG1peGVkfSxcclxuICAgIGltbWVkaWF0ZT86IGJvb2xlYW4sXHJcbiAgKTogP1Byb21pc2U8bWl4ZWQ+LFxyXG4gIGlzVHJhY2tTdXBwb3J0ZWQ6ICgpID0+IGJvb2xlYW4sXHJcbiAgc2V0QXBwbGljYXRpb25TZXNzaW9uT2JzZXJ2YWJsZTogKE9ic2VydmFibGU8U2Vzc2lvbkluZm8+KSA9PiB2b2lkLFxyXG59O1xyXG5cclxubGV0IHJhd0FuYWx5dGljc1NlcnZpY2U6IFJhd0FuYWx5dGljc1NlcnZpY2UgPSB7XHJcbiAgdHJhY2soKTogP1Byb21pc2U8bWl4ZWQ+IHt9LFxyXG4gIGlzVHJhY2tTdXBwb3J0ZWQ6ICgpID0+IGZhbHNlLFxyXG4gIHNldEFwcGxpY2F0aW9uU2Vzc2lvbk9ic2VydmFibGU6IChvYjogT2JzZXJ2YWJsZTxTZXNzaW9uSW5mbz4pID0+IHt9LFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgVHJhY2tpbmdFdmVudCA9IHtcclxuICB0eXBlOiBzdHJpbmcsXHJcbiAgZGF0YT86IE9iamVjdCxcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFRyYWNrRXZlbnQgPSB7XHJcbiAga2V5OiBzdHJpbmcsXHJcbiAgdmFsdWVzOiB7W2tleTogc3RyaW5nXTogbWl4ZWR9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGEgc2V0IG9mIHZhbHVlcyBhZ2FpbnN0IGEgbmFtZWQgZXZlbnQuXHJcbiAqIEFuYWx5dGljcyB3aWxsIGJlIGJhdGNoZWQgYW5kIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseSBpbiB0aGUgYmFja2dyb3VuZC5cclxuICpcclxuICogQHBhcmFtIGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBldmVudCB0byBiZSB0cmFja2VkLlxyXG4gKiBAcGFyYW0gdmFsdWVzIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgZGF0YSB0byB0cmFjay5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFjayhcclxuICBldmVudE5hbWU6IHN0cmluZyxcclxuICB2YWx1ZXM/OiB7W2tleTogc3RyaW5nXTogbWl4ZWR9LFxyXG4pOiB2b2lkIHtcclxuICByYXdBbmFseXRpY3NTZXJ2aWNlLnRyYWNrKGV2ZW50TmFtZSwgdmFsdWVzIHx8IHt9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVHJhY2tTdXBwb3J0ZWQoKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIHJhd0FuYWx5dGljc1NlcnZpY2UuaXNUcmFja1N1cHBvcnRlZCgpO1xyXG59XHJcblxyXG4vKipcclxuICogU2FtZSBhcyBgdHJhY2tgLCBleGNlcHQgdGhpcyBpcyBndWFyYW50ZWVkIHRvIHNlbmQgaW1tZWRpYXRlbHkuXHJcbiAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSByZXF1ZXN0IGNvbXBsZXRlcyAob3IgcmVqZWN0IG9uIGZhaWx1cmUpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrSW1tZWRpYXRlKFxyXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxyXG4gIHZhbHVlcz86IHtba2V5OiBzdHJpbmddOiBtaXhlZH0sXHJcbik6IFByb21pc2U8bWl4ZWQ+IHtcclxuICByZXR1cm4gKFxyXG4gICAgcmF3QW5hbHl0aWNzU2VydmljZS50cmFjayhldmVudE5hbWUsIHZhbHVlcyB8fCB7fSwgdHJ1ZSkgfHxcclxuICAgIFByb21pc2UucmVzb2x2ZSgpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIGludGVyZmFjZSBmb3IgYHRyYWNrYCB0aGF0IGFjY2VwdHMgYSBzaW5nbGUgZXZlbnQgb2JqZWN0LiBUaGlzIGlzIHBhcnRpY3VsYXJseVxyXG4gKiB1c2VmdWwgd2hlbiBkZWFsaW5nIHdpdGggc3RyZWFtcyAoT2JzZXJ2YWJsZXMpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRXZlbnQoZXZlbnQ6IFRyYWNraW5nRXZlbnQpOiB2b2lkIHtcclxuICB0cmFjayhldmVudC50eXBlLCBldmVudC5kYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYWNrIGVhY2ggZXZlbnQgaW4gYSBzdHJlYW0gb2YgVHJhY2tpbmdFdmVudHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tFdmVudHMoZXZlbnRzOiBPYnNlcnZhYmxlPFRyYWNraW5nRXZlbnQ+KTogSURpc3Bvc2FibGUge1xyXG4gIHJldHVybiBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShldmVudHMuc3Vic2NyaWJlKHRyYWNrRXZlbnQpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgc2FtcGxlZCB2ZXJzaW9uIG9mIHRyYWNrIHRoYXQgb25seSB0cmFja3MgZXZlcnkgMS9zYW1wbGVSYXRlIGNhbGxzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrU2FtcGxlZChcclxuICBldmVudE5hbWU6IHN0cmluZyxcclxuICBzYW1wbGVSYXRlOiBudW1iZXIsXHJcbiAgdmFsdWVzPzoge1trZXk6IHN0cmluZ106IG1peGVkfSxcclxuKTogdm9pZCB7XHJcbiAgaWYgKE1hdGgucmFuZG9tKCkgKiBzYW1wbGVSYXRlIDw9IDEpIHtcclxuICAgIHJhd0FuYWx5dGljc1NlcnZpY2UudHJhY2soZXZlbnROYW1lLCB7XHJcbiAgICAgIC4uLnZhbHVlcyxcclxuICAgICAgc2FtcGxlX3JhdGU6IHNhbXBsZVJhdGUsXHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IFBFUkZPUk1BTkNFX0VWRU5UID0gJ3BlcmZvcm1hbmNlJztcclxuY29uc3QgY2FuTWVhc3VyZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCc7XHJcbmV4cG9ydCBjbGFzcyBUaW1pbmdUcmFja2VyIHtcclxuICBzdGF0aWMgZXZlbnRDb3VudCA9IDA7XHJcblxyXG4gIF9ldmVudE5hbWU6IHN0cmluZztcclxuICBfc3RhcnRUaW1lOiBudW1iZXI7XHJcbiAgX3N0YXJ0TWFyazogc3RyaW5nO1xyXG4gIF92YWx1ZXM6IHtba2V5OiBzdHJpbmddOiBtaXhlZH07XHJcblxyXG4gIGNvbnN0cnVjdG9yKGV2ZW50TmFtZTogc3RyaW5nLCB2YWx1ZXM6IHtba2V5OiBzdHJpbmddOiBtaXhlZH0pIHtcclxuICAgIHRoaXMuX2V2ZW50TmFtZSA9IGV2ZW50TmFtZTtcclxuICAgIHRoaXMuX3N0YXJ0TWFyayA9IGAke3RoaXMuX2V2ZW50TmFtZX1fJHtUaW1pbmdUcmFja2VyLmV2ZW50Q291bnQrK31fc3RhcnRgO1xyXG4gICAgdGhpcy5fc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcclxuICAgIHRoaXMuX3ZhbHVlcyA9IHZhbHVlcztcclxuICAgIGlmIChjYW5NZWFzdXJlKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxyXG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKHRoaXMuX3N0YXJ0TWFyayk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBvbkVycm9yKGVycm9yOiBFcnJvcik6IHZvaWQge1xyXG4gICAgdGhpcy5fdHJhY2tUaW1pbmdFdmVudChlcnJvcik7XHJcbiAgfVxyXG5cclxuICBvbkNhbmNlbCgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3RyYWNrVGltaW5nRXZlbnQoLyogZXJyb3IgKi8gbnVsbCwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBvblN1Y2Nlc3MoKTogdm9pZCB7XHJcbiAgICB0aGlzLl90cmFja1RpbWluZ0V2ZW50KC8qIGVycm9yICovIG51bGwpO1xyXG4gIH1cclxuXHJcbiAgX3RyYWNrVGltaW5nRXZlbnQoZXhjZXB0aW9uOiA/RXJyb3IsIGNhbmNlbGVkOiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcclxuICAgIGlmIChjYW5NZWFzdXJlKSB7XHJcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXHJcbiAgICAgIC8vIGNhbGwgbWVhc3VyZSB0byBhZGQgdGhpcyBpbmZvcm1hdGlvbiB0byB0aGUgZGV2dG9vbHMgdGltZWxpbmUgaW4gdGhlXHJcbiAgICAgIC8vIGNhc2UgdGhlIHByb2ZpbGVyIGlzIHJ1bm5pbmcuXHJcbiAgICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUodGhpcy5fZXZlbnROYW1lLCB0aGlzLl9zdGFydE1hcmspO1xyXG4gICAgICAvLyB0aGVuIGNsZWFyIGFsbCB0aGUgbWFya3MgYW5kIG1lYXN1cmVtZW50cyB0byBhdm9pZCBncm93aW5nIHRoZVxyXG4gICAgICAvLyBwZXJmb3JtYW5jZSBlbnRyeSBidWZmZXJcclxuICAgICAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyh0aGlzLl9zdGFydE1hcmspO1xyXG4gICAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKHRoaXMuX2V2ZW50TmFtZSk7XHJcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5kZWYgKi9cclxuICAgIH1cclxuXHJcbiAgICB0cmFjayhQRVJGT1JNQU5DRV9FVkVOVCwge1xyXG4gICAgICAuLi50aGlzLl92YWx1ZXMsXHJcbiAgICAgIGR1cmF0aW9uOiBNYXRoLnJvdW5kKHBlcmZvcm1hbmNlTm93KCkgLSB0aGlzLl9zdGFydFRpbWUpLnRvU3RyaW5nKCksXHJcbiAgICAgIGV2ZW50TmFtZTogdGhpcy5fZXZlbnROYW1lLFxyXG4gICAgICBlcnJvcjogZXhjZXB0aW9uID8gJzEnIDogJzAnLFxyXG4gICAgICBleGNlcHRpb246IGV4Y2VwdGlvbiA/IGV4Y2VwdGlvbi50b1N0cmluZygpIDogJycsXHJcbiAgICAgIGNhbmNlbGVkLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRUcmFja2luZyhcclxuICBldmVudE5hbWU6IHN0cmluZyxcclxuICB2YWx1ZXM/OiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9LFxyXG4pOiBUaW1pbmdUcmFja2VyIHtcclxuICByZXR1cm4gbmV3IFRpbWluZ1RyYWNrZXIoZXZlbnROYW1lLCB2YWx1ZXMpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwb3J0cyBhbmFseXRpY3MgaW5jbHVkaW5nIHRpbWluZyBmb3IgYSBzaW5nbGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICpcclxuICogYW5hbHl0aWNzLnRyYWNrVGltaW5nKCdteS1wYWNrYWdlLXNvbWUtbG9uZy1vcGVyYXRpb24nICgpID0+IGRvaXQoKSk7XHJcbiAqXHJcbiAqIFJldHVybnMgKG9yIHRocm93cykgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrVGltaW5nPFQ+KFxyXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxyXG4gIG9wZXJhdGlvbjogKCkgPT4gVCxcclxuICB2YWx1ZXM/OiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9LFxyXG4pOiBUIHtcclxuICBjb25zdCB0cmFja2VyID0gc3RhcnRUcmFja2luZyhldmVudE5hbWUsIHZhbHVlcyk7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBvcGVyYXRpb24oKTtcclxuXHJcbiAgICBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcclxuICAgICAgLy8gQXRvbSB1c2VzIGEgZGlmZmVyZW50IFByb21pc2UgaW1wbGVtZW50YXRpb24gdGhhbiBOdWNsaWRlLCBzbyB0aGUgZm9sbG93aW5nIGlzIG5vdCB0cnVlOlxyXG4gICAgICAvLyBpbnZhcmlhbnQocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSk7XHJcblxyXG4gICAgICAvLyBGb3IgdGhlIG1ldGhvZCByZXR1cm5pbmcgYSBQcm9taXNlLCB0cmFjayB0aGUgdGltZSBhZnRlciB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZC9yZWplY3RlZC5cclxuICAgICAgcmV0dXJuIChyZXN1bHQ6IGFueSkudGhlbihcclxuICAgICAgICB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICB0cmFja2VyLm9uU3VjY2VzcygpO1xyXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVhc29uID0+IHtcclxuICAgICAgICAgIHRyYWNrZXIub25FcnJvcihyZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbiA6IG5ldyBFcnJvcihyZWFzb24pKTtcclxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0cmFja2VyLm9uU3VjY2VzcygpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICB0cmFja2VyLm9uRXJyb3IoZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVjb3JhdGVUcmFja1RpbWluZzxVOiBBcnJheTwqPiwgVD4oXHJcbiAgZm46ICguLi5hcmdzOiBVKSA9PiBULFxyXG4gIHZhbHVlcz86IHtba2V5OiBzdHJpbmddOiBhbnl9ID0ge30sXHJcbik6ICguLi5hcmdzOiBVKSA9PiBUIHtcclxuICBjb25zdCBuYW1lID0gZ2V0RGlzcGxheU5hbWUoZm4pO1xyXG4gIGZ1bmN0aW9uIGRlY29yYXRlZFRyYWNrVGltaW5nKC4uLmFyZ3M6IFUpIHtcclxuICAgIHJldHVybiB0cmFja1RpbWluZyhuYW1lLCBmbi5iaW5kKHRoaXMsIC4uLmFyZ3MpLCB2YWx1ZXMpO1xyXG4gIH1cclxuICBkZWNvcmF0ZWRUcmFja1RpbWluZy5kaXNwbGF5TmFtZSA9IGB0cmFja1RpbWluZygke25hbWV9KWA7XHJcbiAgcmV0dXJuIGRlY29yYXRlZFRyYWNrVGltaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQSBzYW1wbGVkIHZlcnNpb24gb2YgdHJhY2tUaW1pbmcgdGhhdCBvbmx5IHRyYWNrcyBldmVyeSAxL3NhbXBsZVJhdGUgY2FsbHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tUaW1pbmdTYW1wbGVkPFQ+KFxyXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxyXG4gIG9wZXJhdGlvbjogKCkgPT4gVCxcclxuICBzYW1wbGVSYXRlOiBudW1iZXIsXHJcbiAgdmFsdWVzPzoge1trZXk6IHN0cmluZ106IGFueX0gPSB7fSxcclxuKTogVCB7XHJcbiAgaWYgKE1hdGgucmFuZG9tKCkgKiBzYW1wbGVSYXRlIDw9IDEpIHtcclxuICAgIHJldHVybiB0cmFja1RpbWluZyhldmVudE5hbWUsIG9wZXJhdGlvbiwge1xyXG4gICAgICAuLi52YWx1ZXMsXHJcbiAgICAgIHNhbXBsZV9yYXRlOiBzYW1wbGVSYXRlLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBvcGVyYXRpb24oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlVHJhY2tUaW1pbmdTYW1wbGVkPFU6IEFycmF5PCo+LCBUPihcclxuICBmbjogKC4uLmFyZ3M6IFUpID0+IFQsXHJcbiAgc2FtcGxlUmF0ZTogbnVtYmVyLFxyXG4gIHZhbHVlcz86IHtba2V5OiBzdHJpbmddOiBhbnl9ID0ge30sXHJcbik6ICguLi5hcmdzOiBVKSA9PiBUIHtcclxuICBjb25zdCBuYW1lID0gZ2V0RGlzcGxheU5hbWUoZm4pO1xyXG4gIGZ1bmN0aW9uIGRlY29yYXRlZFRyYWNrVGltaW5nU2FtcGxlZCguLi5hcmdzOiBVKSB7XHJcbiAgICByZXR1cm4gdHJhY2tUaW1pbmdTYW1wbGVkKG5hbWUsIGZuLmJpbmQodGhpcywgLi4uYXJncyksIHNhbXBsZVJhdGUsIHZhbHVlcyk7XHJcbiAgfVxyXG4gIGRlY29yYXRlZFRyYWNrVGltaW5nU2FtcGxlZC5kaXNwbGF5TmFtZSA9IGB0cmFja1RpbWluZ1NhbXBsZWQoJHtuYW1lfSlgO1xyXG4gIHJldHVybiBkZWNvcmF0ZWRUcmFja1RpbWluZ1NhbXBsZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRSYXdBbmFseXRpY3NTZXJ2aWNlKFxyXG4gIGFuYWx5dGljc1NlcnZpY2U6IFJhd0FuYWx5dGljc1NlcnZpY2UsXHJcbiAgb2I6IE9ic2VydmFibGU8U2Vzc2lvbkluZm8+LFxyXG4pOiB2b2lkIHtcclxuICBhbmFseXRpY3NTZXJ2aWNlLnNldEFwcGxpY2F0aW9uU2Vzc2lvbk9ic2VydmFibGUob2IpO1xyXG4gIHJhd0FuYWx5dGljc1NlcnZpY2UgPSBhbmFseXRpY3NTZXJ2aWNlO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdHJhY2ssXHJcbiAgdHJhY2tTYW1wbGVkLFxyXG4gIHRyYWNrRXZlbnQsXHJcbiAgdHJhY2tUaW1pbmcsXHJcbiAgdHJhY2tUaW1pbmdTYW1wbGVkLFxyXG4gIHN0YXJ0VHJhY2tpbmcsXHJcbiAgVGltaW5nVHJhY2tlcixcclxuICBkZWNvcmF0ZVRyYWNrVGltaW5nLFxyXG4gIGRlY29yYXRlVHJhY2tUaW1pbmdTYW1wbGVkLFxyXG59O1xyXG4iXX0=