"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensureArray = ensureArray;
exports.arrayRemove = arrayRemove;
exports.arrayEqual = arrayEqual;
exports.arrayCompact = arrayCompact;
exports.arrayFlatten = arrayFlatten;
exports.arrayUnique = arrayUnique;
exports.arrayFindLastIndex = arrayFindLastIndex;
exports.findSubArrayIndex = findSubArrayIndex;
exports.arrayPartition = arrayPartition;
exports.mapUnion = mapUnion;
exports.mapCompact = mapCompact;
exports.mapFilter = mapFilter;
exports.mapTransform = mapTransform;
exports.mapEqual = mapEqual;
exports.mapGetWithDefault = mapGetWithDefault;
exports.areSetsEqual = areSetsEqual;
exports.every = every;
exports.setIntersect = setIntersect;
exports.setUnion = setUnion;
exports.setDifference = setDifference;
exports.setFilter = setFilter;
exports.isEmpty = isEmpty;
exports.keyMirror = keyMirror;
exports.collect = collect;
exports.objectFromPairs = objectFromPairs;
exports.objectMapValues = objectMapValues;
exports.objectValues = objectValues;
exports.objectEntries = objectEntries;
exports.objectFromMap = objectFromMap;
exports.concatIterators = concatIterators;
exports.someOfIterable = someOfIterable;
exports.findInIterable = findInIterable;
exports.filterIterable = filterIterable;
exports.mapIterable = mapIterable;
exports.takeIterable = takeIterable;
exports.range = range;
exports.firstOfIterable = firstOfIterable;
exports.iterableIsEmpty = iterableIsEmpty;
exports.iterableContains = iterableContains;
exports.count = count;
exports.isIterable = isIterable;
exports.insideOut = insideOut;
exports.mapFromObject = mapFromObject;
exports.lastFromArray = lastFromArray;
exports.distinct = distinct;
exports.findTopRanked = findTopRanked;
exports.DefaultWeakMap = exports.DefaultMap = exports.MultiMap = void 0;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
function ensureArray(x) {
  return Array.isArray(x) ? x : [x];
}

function arrayRemove(array, element) {
  const index = array.indexOf(element);

  if (index >= 0) {
    array.splice(index, 1);
  }
}

function arrayEqual(array1, array2, equalComparator) {
  if (array1 === array2) {
    return true;
  }

  if (array1.length !== array2.length) {
    return false;
  }

  const equalFunction = equalComparator || ((a, b) => a === b);

  return array1.every((item1, i) => equalFunction(item1, array2[i]));
}
/**
 * Returns a copy of the input Array with all `null` and `undefined` values filtered out.
 * Allows Flow to typecheck the common `filter(x => x != null)` pattern.
 */


function arrayCompact(array) {
  const result = [];

  for (const elem of array) {
    if (elem != null) {
      result.push(elem);
    }
  }

  return result;
}
/**
 * Flattens an Array<Array<T>> into just an Array<T>
 */


function arrayFlatten(array) {
  const result = [];

  for (const subArray of array) {
    for (const element of subArray) {
      result.push(element);
    }
  }

  return result;
}
/**
 * Removes duplicates from Array<T>.
 * Uses SameValueZero for equality purposes, which is like '===' except it deems
 * two NaNs equal. http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero
 */


function arrayUnique(array) {
  return Array.from(new Set(array));
}
/**
 * Returns the last index in the input array that matches the predicate.
 * Returns -1 if no match is found.
 */


function arrayFindLastIndex(array, predicate, thisArg) {
  for (let i = array.length - 1; i >= 0; i--) {
    if (predicate.call(thisArg, array[i], i, array)) {
      return i;
    }
  }

  return -1;
}
/**
 * Return the first index in array where subarray is equal to the next
 * subarray-sized slice of array. Return -1 if no match is found.
 */


function findSubArrayIndex(array, subarr) {
  return array.findIndex((_, offset) => arrayEqual(array.slice(offset, offset + subarr.length), subarr));
}
/**
 * Separates an array into two subarrays -- the first contains all elements that
 * match the predicate and the latter contains all the rest that fail.
 */


function arrayPartition(array, predicate) {
  const pass = [];
  const fail = [];
  array.forEach(elem => predicate(elem) ? pass.push(elem) : fail.push(elem));
  return [pass, fail];
}
/**
 * Merges a given arguments of maps into one Map, with the latest maps
 * overriding the values of the prior maps.
 */


function mapUnion(...maps) {
  const unionMap = new Map();

  for (const map of maps) {
    for (const [key, value] of map) {
      unionMap.set(key, value);
    }
  }

  return unionMap;
}

function mapCompact(map) {
  const selected = new Map();

  for (const [key, value] of map) {
    if (value != null) {
      selected.set(key, value);
    }
  }

  return selected;
}

function mapFilter(map, selector) {
  const selected = new Map();

  for (const [key, value] of map) {
    if (selector(key, value)) {
      selected.set(key, value);
    }
  }

  return selected;
}

function mapTransform(src, transform) {
  const result = new Map();

  for (const [key, value] of src) {
    result.set(key, transform(value, key));
  }

  return result;
}

function mapEqual(map1, map2, equalComparator) {
  if (map1.size !== map2.size) {
    return false;
  }

  const equalFunction = equalComparator || ((a, b) => a === b);

  for (const [key, value1] of map1) {
    if (!map2.has(key) || !equalFunction(value1, map2.get(key))) {
      return false;
    }
  }

  return true;
}

function mapGetWithDefault(map, key, default_) {
  if (map.has(key)) {
    // Cast through `any` since map.get's return is a maybe type. We can't just get the value and
    // check it against `null`, since null/undefined may inhabit V. We know this is safe since we
    // just checked that the map has the key.
    return map.get(key);
  } else {
    return default_;
  }
}

function areSetsEqual(a, b) {
  return a.size === b.size && every(a, element => b.has(element));
} // Array.every but for any iterable.


function every(values, predicate) {
  for (const element of values) {
    if (!predicate(element)) {
      return false;
    }
  }

  return true;
}

function setIntersect(a, b) {
  return setFilter(a, e => b.has(e));
}

function setUnionTwo(a, b) {
  // Avoids the extra Array allocations that `new Set([...a, ...b])` would incur. Some quick tests
  // indicate it would be about 60% slower.
  const result = new Set(a);
  b.forEach(x => {
    result.add(x);
  });
  return result;
}

function setUnion(...sets) {
  if (sets.length < 1) {
    return new Set();
  }

  const setReducer = (accumulator, current) => {
    return setUnionTwo(accumulator, current);
  };

  return sets.reduce(setReducer);
}

function setDifference(a, b, hash_) {
  if (a.size === 0) {
    return new Set();
  } else if (b.size === 0) {
    return new Set(a);
  }

  const result = new Set();

  const hash = hash_ || (x => x);

  const bHashes = hash_ == null ? b : new Set(Array.from(b.values()).map(hash));
  a.forEach(value => {
    if (!bHashes.has(hash(value))) {
      result.add(value);
    }
  });
  return result;
}

function setFilter(set, predicate) {
  const out = new Set();

  for (const item of set) {
    if (predicate(item)) {
      out.add(item);
    }
  }

  return out;
}
/**
 * O(1)-check if a given object is empty (has no properties, inherited or not)
 */


function isEmpty(obj) {
  for (const key in obj) {
    return false;
  }

  return true;
}
/**
 * Constructs an enumeration with keys equal to their value.
 * e.g. keyMirror({a: null, b: null}) => {a: 'a', b: 'b'}
 *
 * Based off the equivalent function in www.
 */


function keyMirror(obj) {
  const ret = {};
  Object.keys(obj).forEach(key => {
    ret[key] = key;
  });
  return ret;
}
/**
 * Given an array of [key, value] pairs, construct a map where the values for
 * each key are collected into an array of values, in order.
 */


function collect(pairs) {
  const result = new Map();

  for (const pair of pairs) {
    const [k, v] = pair;
    let list = result.get(k);

    if (list == null) {
      list = [];
      result.set(k, list);
    }

    list.push(v);
  }

  return result;
}

function objectFromPairs(iterable) {
  const result = {};

  for (const [key, value] of iterable) {
    result[key] = value;
  }

  return result;
}

function objectMapValues(object, project) {
  const result = {};
  Object.keys(object).forEach(key => {
    result[key] = project(object[key], key);
  });
  return result;
}

class MultiMap {
  // Invariant: no empty sets. They should be removed instead.
  // TODO may be worth defining a getter but no setter, to mimic Map. But please just behave and
  // don't mutate this from outside this class.
  //
  // Invariant: equal to the sum of the sizes of all the sets contained in this._map

  /* The total number of key-value bindings contained */
  constructor() {
    this._map = void 0;
    this.size = void 0;
    this._map = new Map();
    this.size = 0;
  }
  /*
   * Returns the set of values associated with the given key. Do not mutate the given set. Copy it
   * if you need to store it past the next operation on this MultiMap.
   */


  get(key) {
    const set = this._map.get(key);

    if (set == null) {
      return new Set();
    }

    return set;
  }
  /*
   * Mimics the Map.prototype.set interface. Deliberately did not choose "set" as the name since the
   * implication is that it removes the previous binding.
   */


  add(key, value) {
    let set = this._map.get(key);

    if (set == null) {
      set = new Set();

      this._map.set(key, set);
    }

    if (!set.has(value)) {
      set.add(value);
      this.size++;
    }

    return this;
  }
  /*
   * Mimics the Map.prototype.set interface. Replaces the previous binding with new values.
   */


  set(key, values) {
    this.deleteAll(key);
    const newSet = new Set(values);

    if (newSet.size !== 0) {
      this._map.set(key, newSet);

      this.size += newSet.size;
    }
  }
  /*
   * Deletes a single binding. Returns true iff the binding existed.
   */


  delete(key, value) {
    const set = this.get(key);
    const didRemove = set.delete(value);

    if (set.size === 0) {
      this._map.delete(key);
    }

    if (didRemove) {
      this.size--;
    }

    return didRemove;
  }
  /*
   * Deletes all bindings associated with the given key. Returns true iff any bindings were deleted.
   */


  deleteAll(key) {
    const set = this.get(key);
    this.size -= set.size;
    return this._map.delete(key);
  }

  clear() {
    this._map.clear();

    this.size = 0;
  }

  has(key, value) {
    return this.get(key).has(value);
  }

  hasAny(key) {
    return this._map.has(key);
  }

  *values() {
    for (const set of this._map.values()) {
      yield* set;
    }
  }

  forEach(callback) {
    this._map.forEach((values, key) => values.forEach(value => callback(value, key, this)));
  }

}

exports.MultiMap = MultiMap;

function objectValues(obj) {
  return Object.keys(obj).map(key => obj[key]);
}

function objectEntries(obj) {
  if (obj == null) {
    throw new TypeError();
  }

  const entries = [];

  for (const key in obj) {
    if (obj.hasOwnProperty(key) && Object.prototype.propertyIsEnumerable.call(obj, key)) {
      entries.push([key, obj[key]]);
    }
  }

  return entries;
}

function objectFromMap(map) {
  const obj = {};
  map.forEach((v, k) => {
    obj[k] = v;
  });
  return obj;
}

function* concatIterators(...iterators) {
  for (const iterator of iterators) {
    for (const element of iterator) {
      yield element;
    }
  }
}

function someOfIterable(iterable, predicate) {
  for (const element of iterable) {
    if (predicate(element)) {
      return true;
    }
  }

  return false;
}

function findInIterable(iterable, predicate) {
  for (const element of iterable) {
    if (predicate(element)) {
      return element;
    }
  }

  return null;
}

function* filterIterable(iterable, predicate) {
  for (const element of iterable) {
    if (predicate(element)) {
      yield element;
    }
  }
}

function* mapIterable(iterable, projectorFn) {
  for (const element of iterable) {
    yield projectorFn(element);
  }
}

function* takeIterable(iterable, limit) {
  let i = 0;

  for (const element of iterable) {
    if (++i > limit) {
      break;
    }

    yield element;
  }
} // Return an iterable of the numbers start (inclusive) through stop (exclusive)


function* range(start, stop, step = 1) {
  // We don't currently support negative step values.
  (0, _assert.default)(step > 0);

  for (let i = start; i < stop; i += step) {
    yield i;
  }
}

function firstOfIterable(iterable) {
  return findInIterable(iterable, () => true);
}

function iterableIsEmpty(iterable) {
  // eslint-disable-next-line no-unused-vars
  for (const element of iterable) {
    return false;
  }

  return true;
}

function iterableContains(iterable, value) {
  return !iterableIsEmpty(filterIterable(iterable, element => element === value));
}

function count(iterable) {
  let size = 0; // eslint-disable-next-line no-unused-vars

  for (const element of iterable) {
    size++;
  }

  return size;
}

function isIterable(obj) {
  return typeof obj[Symbol.iterator] === 'function';
} // Traverse an array from the inside out, starting at the specified index.


function* insideOut(arr, startingIndex) {
  if (arr.length === 0) {
    return;
  }

  let i = startingIndex == null ? Math.floor(arr.length / 2) : Math.min(arr.length, Math.max(0, startingIndex));
  let j = i - 1;

  while (i < arr.length || j >= 0) {
    if (i < arr.length) {
      yield [arr[i], i];
      i++;
    }

    if (j >= 0) {
      yield [arr[j], j];
      j--;
    }
  }
}

function mapFromObject(obj) {
  return new Map(objectEntries(obj));
}

function lastFromArray(arr) {
  return arr[arr.length - 1];
}

function distinct(array, keyFn) {
  if (keyFn == null) {
    return Array.from(new Set(array));
  }

  const seenKeys = new Set();
  return array.filter(elem => {
    const key = keyFn(elem);

    if (seenKeys.has(key)) {
      return false;
    }

    seenKeys.add(key);
    return true;
  });
}

class DefaultMap extends Map {
  constructor(factory, iterable) {
    super(iterable);
    this._factory = void 0;
    this._factory = factory;
  }

  get(key) {
    if (!this.has(key)) {
      const value = this._factory(key);

      this.set(key, value);
      return value;
    } // If the key is present we must have a value of type V.


    return super.get(key);
  }

}

exports.DefaultMap = DefaultMap;

class DefaultWeakMap extends WeakMap {
  constructor(factory, iterable) {
    super(iterable);
    this._factory = void 0;
    this._factory = factory;
  }

  get(key) {
    if (!this.has(key)) {
      const value = this._factory(key);

      this.set(key, value);
      return value;
    } // If the key is present we must have a value of type V.


    return super.get(key);
  }

}
/**
 * Return the highest ranked item in a list, according to the provided ranking function. A max rank
 * may optionally be provided so the whole list doesn't have to be iterated. Items with ranks of
 * zero or less are never returned.
 */


exports.DefaultWeakMap = DefaultWeakMap;

function findTopRanked(items, ranker, maxRank) {
  let maxSeenRank = 0;
  let maxRankedItem;

  for (const item of items) {
    const rank = ranker(item);

    if (rank === maxRank) {
      return item;
    }

    if (rank > 0 && rank > maxSeenRank) {
      maxSeenRank = rank;
      maxRankedItem = item;
    }
  }

  return maxRankedItem;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL2NvbGxlY3Rpb24uanMiXSwibmFtZXMiOlsiZW5zdXJlQXJyYXkiLCJ4IiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyYXlSZW1vdmUiLCJhcnJheSIsImVsZW1lbnQiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJhcnJheUVxdWFsIiwiYXJyYXkxIiwiYXJyYXkyIiwiZXF1YWxDb21wYXJhdG9yIiwibGVuZ3RoIiwiZXF1YWxGdW5jdGlvbiIsImEiLCJiIiwiZXZlcnkiLCJpdGVtMSIsImkiLCJhcnJheUNvbXBhY3QiLCJyZXN1bHQiLCJlbGVtIiwicHVzaCIsImFycmF5RmxhdHRlbiIsInN1YkFycmF5IiwiYXJyYXlVbmlxdWUiLCJmcm9tIiwiU2V0IiwiYXJyYXlGaW5kTGFzdEluZGV4IiwicHJlZGljYXRlIiwidGhpc0FyZyIsImNhbGwiLCJmaW5kU3ViQXJyYXlJbmRleCIsInN1YmFyciIsImZpbmRJbmRleCIsIl8iLCJvZmZzZXQiLCJzbGljZSIsImFycmF5UGFydGl0aW9uIiwicGFzcyIsImZhaWwiLCJmb3JFYWNoIiwibWFwVW5pb24iLCJtYXBzIiwidW5pb25NYXAiLCJNYXAiLCJtYXAiLCJrZXkiLCJ2YWx1ZSIsInNldCIsIm1hcENvbXBhY3QiLCJzZWxlY3RlZCIsIm1hcEZpbHRlciIsInNlbGVjdG9yIiwibWFwVHJhbnNmb3JtIiwic3JjIiwidHJhbnNmb3JtIiwibWFwRXF1YWwiLCJtYXAxIiwibWFwMiIsInNpemUiLCJ2YWx1ZTEiLCJoYXMiLCJnZXQiLCJtYXBHZXRXaXRoRGVmYXVsdCIsImRlZmF1bHRfIiwiYXJlU2V0c0VxdWFsIiwidmFsdWVzIiwic2V0SW50ZXJzZWN0Iiwic2V0RmlsdGVyIiwiZSIsInNldFVuaW9uVHdvIiwiYWRkIiwic2V0VW5pb24iLCJzZXRzIiwic2V0UmVkdWNlciIsImFjY3VtdWxhdG9yIiwiY3VycmVudCIsInJlZHVjZSIsInNldERpZmZlcmVuY2UiLCJoYXNoXyIsImhhc2giLCJiSGFzaGVzIiwib3V0IiwiaXRlbSIsImlzRW1wdHkiLCJvYmoiLCJrZXlNaXJyb3IiLCJyZXQiLCJPYmplY3QiLCJrZXlzIiwiY29sbGVjdCIsInBhaXJzIiwicGFpciIsImsiLCJ2IiwibGlzdCIsIm9iamVjdEZyb21QYWlycyIsIml0ZXJhYmxlIiwib2JqZWN0TWFwVmFsdWVzIiwib2JqZWN0IiwicHJvamVjdCIsIk11bHRpTWFwIiwiY29uc3RydWN0b3IiLCJfbWFwIiwiZGVsZXRlQWxsIiwibmV3U2V0IiwiZGVsZXRlIiwiZGlkUmVtb3ZlIiwiY2xlYXIiLCJoYXNBbnkiLCJjYWxsYmFjayIsIm9iamVjdFZhbHVlcyIsIm9iamVjdEVudHJpZXMiLCJUeXBlRXJyb3IiLCJlbnRyaWVzIiwiaGFzT3duUHJvcGVydHkiLCJwcm90b3R5cGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm9iamVjdEZyb21NYXAiLCJjb25jYXRJdGVyYXRvcnMiLCJpdGVyYXRvcnMiLCJpdGVyYXRvciIsInNvbWVPZkl0ZXJhYmxlIiwiZmluZEluSXRlcmFibGUiLCJmaWx0ZXJJdGVyYWJsZSIsIm1hcEl0ZXJhYmxlIiwicHJvamVjdG9yRm4iLCJ0YWtlSXRlcmFibGUiLCJsaW1pdCIsInJhbmdlIiwic3RhcnQiLCJzdG9wIiwic3RlcCIsImZpcnN0T2ZJdGVyYWJsZSIsIml0ZXJhYmxlSXNFbXB0eSIsIml0ZXJhYmxlQ29udGFpbnMiLCJjb3VudCIsImlzSXRlcmFibGUiLCJTeW1ib2wiLCJpbnNpZGVPdXQiLCJhcnIiLCJzdGFydGluZ0luZGV4IiwiTWF0aCIsImZsb29yIiwibWluIiwibWF4IiwiaiIsIm1hcEZyb21PYmplY3QiLCJsYXN0RnJvbUFycmF5IiwiZGlzdGluY3QiLCJrZXlGbiIsInNlZW5LZXlzIiwiZmlsdGVyIiwiRGVmYXVsdE1hcCIsImZhY3RvcnkiLCJfZmFjdG9yeSIsIkRlZmF1bHRXZWFrTWFwIiwiV2Vha01hcCIsImZpbmRUb3BSYW5rZWQiLCJpdGVtcyIsInJh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OztBQWhCeUQ7QUFtQjVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ08sU0FBU2dILGFBQVQsQ0FDTEMsS0FESyxFQUVMQyxNQUZLLEVBR0xDLE9BSEssRUFJRDtBQUNKLE1BQUlDLFdBQVcsR0FBRyxDQUFsQjtBQUNBLE1BQUlDLGFBQUo7O0FBQ0EsT0FBSyxNQUFNaEYsSUFBWCxJQUFtQjRFLEtBQW5CLEVBQTBCO0FBQ3hCLFVBQU1LLElBQUksR0FBR0osTUFBTSxDQUFDN0UsSUFBRCxDQUFuQjs7QUFDQSxRQUFJaUYsSUFBSSxLQUFLSCxPQUFiLEVBQXNCO0FBQ3BCLGFBQU85RSxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSWlGLElBQUksR0FBRyxDQUFQLElBQVlBLElBQUksR0FBR0YsV0FBdkIsRUFBb0M7QUFDbENBLE1BQUFBLFdBQVcsR0FBR0UsSUFBZDtBQUNBRCxNQUFBQSxhQUFhLEdBQUdoRixJQUFoQjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBT2dGLGFBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVBcnJheTxUPih4OiBBcnJheTxUPiB8IFQpOiBBcnJheTxUPiB7XHJcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlSZW1vdmU8VD4oYXJyYXk6IEFycmF5PFQ+LCBlbGVtZW50OiBUKTogdm9pZCB7XHJcbiAgY29uc3QgaW5kZXggPSBhcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5RXF1YWw8VD4oXHJcbiAgYXJyYXkxOiAkUmVhZE9ubHlBcnJheTxUPixcclxuICBhcnJheTI6ICRSZWFkT25seUFycmF5PFQ+LFxyXG4gIGVxdWFsQ29tcGFyYXRvcj86IChhOiBULCBiOiBUKSA9PiBib29sZWFuLFxyXG4pOiBib29sZWFuIHtcclxuICBpZiAoYXJyYXkxID09PSBhcnJheTIpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBjb25zdCBlcXVhbEZ1bmN0aW9uID0gZXF1YWxDb21wYXJhdG9yIHx8ICgoYTogVCwgYjogVCkgPT4gYSA9PT0gYik7XHJcbiAgcmV0dXJuIGFycmF5MS5ldmVyeSgoaXRlbTEsIGkpID0+IGVxdWFsRnVuY3Rpb24oaXRlbTEsIGFycmF5MltpXSkpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGlucHV0IEFycmF5IHdpdGggYWxsIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzIGZpbHRlcmVkIG91dC5cclxuICogQWxsb3dzIEZsb3cgdG8gdHlwZWNoZWNrIHRoZSBjb21tb24gYGZpbHRlcih4ID0+IHggIT0gbnVsbClgIHBhdHRlcm4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlDb21wYWN0PFQ+KGFycmF5OiAkUmVhZE9ubHlBcnJheTw/VD4pOiBBcnJheTxUPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgZm9yIChjb25zdCBlbGVtIG9mIGFycmF5KSB7XHJcbiAgICBpZiAoZWxlbSAhPSBudWxsKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGVsZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogRmxhdHRlbnMgYW4gQXJyYXk8QXJyYXk8VD4+IGludG8ganVzdCBhbiBBcnJheTxUPlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5RmxhdHRlbjxUPihcclxuICBhcnJheTogJFJlYWRPbmx5QXJyYXk8JFJlYWRPbmx5QXJyYXk8VD4+LFxyXG4pOiBBcnJheTxUPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgZm9yIChjb25zdCBzdWJBcnJheSBvZiBhcnJheSkge1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHN1YkFycmF5KSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gQXJyYXk8VD4uXHJcbiAqIFVzZXMgU2FtZVZhbHVlWmVybyBmb3IgZXF1YWxpdHkgcHVycG9zZXMsIHdoaWNoIGlzIGxpa2UgJz09PScgZXhjZXB0IGl0IGRlZW1zXHJcbiAqIHR3byBOYU5zIGVxdWFsLiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtc2FtZXZhbHVlemVyb1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5VW5pcXVlPFQ+KGFycmF5OiAkUmVhZE9ubHlBcnJheTxUPik6IEFycmF5PFQ+IHtcclxuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGluZGV4IGluIHRoZSBpbnB1dCBhcnJheSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS5cclxuICogUmV0dXJucyAtMSBpZiBubyBtYXRjaCBpcyBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJheUZpbmRMYXN0SW5kZXg8VD4oXHJcbiAgYXJyYXk6ICRSZWFkT25seUFycmF5PFQ+LFxyXG4gIHByZWRpY2F0ZTogKGVsZW06IFQsIGluZGV4OiBudW1iZXIsIGFycmF5OiAkUmVhZE9ubHlBcnJheTxUPikgPT4gYm9vbGVhbixcclxuICB0aGlzQXJnPzogYW55LFxyXG4pOiBudW1iZXIge1xyXG4gIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGFycmF5W2ldLCBpLCBhcnJheSkpIHtcclxuICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAtMTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggaW4gYXJyYXkgd2hlcmUgc3ViYXJyYXkgaXMgZXF1YWwgdG8gdGhlIG5leHRcclxuICogc3ViYXJyYXktc2l6ZWQgc2xpY2Ugb2YgYXJyYXkuIFJldHVybiAtMSBpZiBubyBtYXRjaCBpcyBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kU3ViQXJyYXlJbmRleDxUPihcclxuICBhcnJheTogJFJlYWRPbmx5QXJyYXk8VD4sXHJcbiAgc3ViYXJyOiAkUmVhZE9ubHlBcnJheTxUPixcclxuKTogbnVtYmVyIHtcclxuICByZXR1cm4gYXJyYXkuZmluZEluZGV4KChfLCBvZmZzZXQpID0+XHJcbiAgICBhcnJheUVxdWFsKGFycmF5LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3ViYXJyLmxlbmd0aCksIHN1YmFyciksXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlcGFyYXRlcyBhbiBhcnJheSBpbnRvIHR3byBzdWJhcnJheXMgLS0gdGhlIGZpcnN0IGNvbnRhaW5zIGFsbCBlbGVtZW50cyB0aGF0XHJcbiAqIG1hdGNoIHRoZSBwcmVkaWNhdGUgYW5kIHRoZSBsYXR0ZXIgY29udGFpbnMgYWxsIHRoZSByZXN0IHRoYXQgZmFpbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJheVBhcnRpdGlvbjxUPihcclxuICBhcnJheTogJFJlYWRPbmx5QXJyYXk8VD4sXHJcbiAgcHJlZGljYXRlOiAoZWxlbTogVCkgPT4gYm9vbGVhbixcclxuKTogW0FycmF5PFQ+LCBBcnJheTxUPl0ge1xyXG4gIGNvbnN0IHBhc3MgPSBbXTtcclxuICBjb25zdCBmYWlsID0gW107XHJcbiAgYXJyYXkuZm9yRWFjaChlbGVtID0+IChwcmVkaWNhdGUoZWxlbSkgPyBwYXNzLnB1c2goZWxlbSkgOiBmYWlsLnB1c2goZWxlbSkpKTtcclxuICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIGEgZ2l2ZW4gYXJndW1lbnRzIG9mIG1hcHMgaW50byBvbmUgTWFwLCB3aXRoIHRoZSBsYXRlc3QgbWFwc1xyXG4gKiBvdmVycmlkaW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHByaW9yIG1hcHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFwVW5pb248VCwgWD4oLi4ubWFwczogJFJlYWRPbmx5QXJyYXk8TWFwPFQsIFg+Pik6IE1hcDxULCBYPiB7XHJcbiAgY29uc3QgdW5pb25NYXAgPSBuZXcgTWFwKCk7XHJcbiAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwKSB7XHJcbiAgICAgIHVuaW9uTWFwLnNldChrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHVuaW9uTWFwO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwQ29tcGFjdDxULCBYPihtYXA6IE1hcDxULCA/WD4pOiBNYXA8VCwgWD4ge1xyXG4gIGNvbnN0IHNlbGVjdGVkID0gbmV3IE1hcCgpO1xyXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xyXG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgc2VsZWN0ZWQuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc2VsZWN0ZWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBGaWx0ZXI8VCwgWD4oXHJcbiAgbWFwOiBNYXA8VCwgWD4sXHJcbiAgc2VsZWN0b3I6IChrZXk6IFQsIHZhbHVlOiBYKSA9PiBib29sZWFuLFxyXG4pOiBNYXA8VCwgWD4ge1xyXG4gIGNvbnN0IHNlbGVjdGVkID0gbmV3IE1hcCgpO1xyXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xyXG4gICAgaWYgKHNlbGVjdG9yKGtleSwgdmFsdWUpKSB7XHJcbiAgICAgIHNlbGVjdGVkLnNldChrZXksIHZhbHVlKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHNlbGVjdGVkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gbWFwVHJhbnNmb3JtPFQsIFYxLCBWMj4oXHJcbiAgc3JjOiBNYXA8VCwgVjE+LFxyXG4gIHRyYW5zZm9ybTogKHZhbHVlOiBWMSwga2V5OiBUKSA9PiBWMixcclxuKTogTWFwPFQsIFYyPiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNyYykge1xyXG4gICAgcmVzdWx0LnNldChrZXksIHRyYW5zZm9ybSh2YWx1ZSwga2V5KSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBFcXVhbDxULCBYPihcclxuICBtYXAxOiBNYXA8VCwgWD4sXHJcbiAgbWFwMjogTWFwPFQsIFg+LFxyXG4gIGVxdWFsQ29tcGFyYXRvcj86ICh2YWwxOiBYLCB2YWwyOiBYLCBrZXk/OiBUKSA9PiBib29sZWFuLFxyXG4pIHtcclxuICBpZiAobWFwMS5zaXplICE9PSBtYXAyLnNpemUpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgY29uc3QgZXF1YWxGdW5jdGlvbiA9IGVxdWFsQ29tcGFyYXRvciB8fCAoKGE6IFgsIGI6IFgpID0+IGEgPT09IGIpO1xyXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWUxXSBvZiBtYXAxKSB7XHJcbiAgICBpZiAoIW1hcDIuaGFzKGtleSkgfHwgIWVxdWFsRnVuY3Rpb24odmFsdWUxLCAobWFwMi5nZXQoa2V5KTogYW55KSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcEdldFdpdGhEZWZhdWx0PEssIFY+KFxyXG4gIG1hcDogTWFwPEssIFY+LFxyXG4gIGtleTogSyxcclxuICBkZWZhdWx0XzogVixcclxuKTogViB7XHJcbiAgaWYgKG1hcC5oYXMoa2V5KSkge1xyXG4gICAgLy8gQ2FzdCB0aHJvdWdoIGBhbnlgIHNpbmNlIG1hcC5nZXQncyByZXR1cm4gaXMgYSBtYXliZSB0eXBlLiBXZSBjYW4ndCBqdXN0IGdldCB0aGUgdmFsdWUgYW5kXHJcbiAgICAvLyBjaGVjayBpdCBhZ2FpbnN0IGBudWxsYCwgc2luY2UgbnVsbC91bmRlZmluZWQgbWF5IGluaGFiaXQgVi4gV2Uga25vdyB0aGlzIGlzIHNhZmUgc2luY2Ugd2VcclxuICAgIC8vIGp1c3QgY2hlY2tlZCB0aGF0IHRoZSBtYXAgaGFzIHRoZSBrZXkuXHJcbiAgICByZXR1cm4gKG1hcC5nZXQoa2V5KTogYW55KTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRfO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZVNldHNFcXVhbDxUPihhOiBTZXQ8VD4sIGI6IFNldDxUPik6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBhLnNpemUgPT09IGIuc2l6ZSAmJiBldmVyeShhLCBlbGVtZW50ID0+IGIuaGFzKGVsZW1lbnQpKTtcclxufVxyXG5cclxuLy8gQXJyYXkuZXZlcnkgYnV0IGZvciBhbnkgaXRlcmFibGUuXHJcbmV4cG9ydCBmdW5jdGlvbiBldmVyeTxUPihcclxuICB2YWx1ZXM6IEl0ZXJhYmxlPFQ+LFxyXG4gIHByZWRpY2F0ZTogKGVsZW1lbnQ6IFQpID0+IGJvb2xlYW4sXHJcbik6IGJvb2xlYW4ge1xyXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiB2YWx1ZXMpIHtcclxuICAgIGlmICghcHJlZGljYXRlKGVsZW1lbnQpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcnNlY3Q8VD4oYTogU2V0PFQ+LCBiOiBTZXQ8VD4pOiBTZXQ8VD4ge1xyXG4gIHJldHVybiBzZXRGaWx0ZXIoYSwgZSA9PiBiLmhhcyhlKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFVuaW9uVHdvPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KTogU2V0PFQ+IHtcclxuICAvLyBBdm9pZHMgdGhlIGV4dHJhIEFycmF5IGFsbG9jYXRpb25zIHRoYXQgYG5ldyBTZXQoWy4uLmEsIC4uLmJdKWAgd291bGQgaW5jdXIuIFNvbWUgcXVpY2sgdGVzdHNcclxuICAvLyBpbmRpY2F0ZSBpdCB3b3VsZCBiZSBhYm91dCA2MCUgc2xvd2VyLlxyXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoYSk7XHJcbiAgYi5mb3JFYWNoKHggPT4ge1xyXG4gICAgcmVzdWx0LmFkZCh4KTtcclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VW5pb248VD4oLi4uc2V0czogJFJlYWRPbmx5QXJyYXk8U2V0PFQ+Pik6IFNldDxUPiB7XHJcbiAgaWYgKHNldHMubGVuZ3RoIDwgMSkge1xyXG4gICAgcmV0dXJuIG5ldyBTZXQoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNldFJlZHVjZXIgPSAoYWNjdW11bGF0b3I6IFNldDxUPiwgY3VycmVudDogU2V0PFQ+KTogU2V0PFQ+ID0+IHtcclxuICAgIHJldHVybiBzZXRVbmlvblR3byhhY2N1bXVsYXRvciwgY3VycmVudCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIHNldHMucmVkdWNlKHNldFJlZHVjZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0RGlmZmVyZW5jZTxUPihcclxuICBhOiBTZXQ8VD4sXHJcbiAgYjogU2V0PFQ+LFxyXG4gIGhhc2hfPzogKHY6IFQpID0+IGFueSxcclxuKTogU2V0PFQ+IHtcclxuICBpZiAoYS5zaXplID09PSAwKSB7XHJcbiAgICByZXR1cm4gbmV3IFNldCgpO1xyXG4gIH0gZWxzZSBpZiAoYi5zaXplID09PSAwKSB7XHJcbiAgICByZXR1cm4gbmV3IFNldChhKTtcclxuICB9XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xyXG4gIGNvbnN0IGhhc2ggPSBoYXNoXyB8fCAoeCA9PiB4KTtcclxuICBjb25zdCBiSGFzaGVzID0gaGFzaF8gPT0gbnVsbCA/IGIgOiBuZXcgU2V0KEFycmF5LmZyb20oYi52YWx1ZXMoKSkubWFwKGhhc2gpKTtcclxuICBhLmZvckVhY2godmFsdWUgPT4ge1xyXG4gICAgaWYgKCFiSGFzaGVzLmhhcyhoYXNoKHZhbHVlKSkpIHtcclxuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldEZpbHRlcjxUPihcclxuICBzZXQ6IFNldDxUPixcclxuICBwcmVkaWNhdGU6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbixcclxuKTogU2V0PFQ+IHtcclxuICBjb25zdCBvdXQgPSBuZXcgU2V0KCk7XHJcbiAgZm9yIChjb25zdCBpdGVtIG9mIHNldCkge1xyXG4gICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICBvdXQuYWRkKGl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE8oMSktY2hlY2sgaWYgYSBnaXZlbiBvYmplY3QgaXMgZW1wdHkgKGhhcyBubyBwcm9wZXJ0aWVzLCBpbmhlcml0ZWQgb3Igbm90KVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkob2JqOiBPYmplY3QpOiBib29sZWFuIHtcclxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGFuIGVudW1lcmF0aW9uIHdpdGgga2V5cyBlcXVhbCB0byB0aGVpciB2YWx1ZS5cclxuICogZS5nLiBrZXlNaXJyb3Ioe2E6IG51bGwsIGI6IG51bGx9KSA9PiB7YTogJ2EnLCBiOiAnYid9XHJcbiAqXHJcbiAqIEJhc2VkIG9mZiB0aGUgZXF1aXZhbGVudCBmdW5jdGlvbiBpbiB3d3cuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24ga2V5TWlycm9yPFQ6IE9iamVjdD4ob2JqOiBUKTogJE9iak1hcGk8VCwgPEs+KGs6IEspID0+IEs+IHtcclxuICBjb25zdCByZXQgPSB7fTtcclxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgIHJldFtrZXldID0ga2V5O1xyXG4gIH0pO1xyXG4gIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBba2V5LCB2YWx1ZV0gcGFpcnMsIGNvbnN0cnVjdCBhIG1hcCB3aGVyZSB0aGUgdmFsdWVzIGZvclxyXG4gKiBlYWNoIGtleSBhcmUgY29sbGVjdGVkIGludG8gYW4gYXJyYXkgb2YgdmFsdWVzLCBpbiBvcmRlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0PEssIFY+KHBhaXJzOiAkUmVhZE9ubHlBcnJheTxbSywgVl0+KTogTWFwPEssIEFycmF5PFY+PiB7XHJcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xyXG4gIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xyXG4gICAgY29uc3QgW2ssIHZdID0gcGFpcjtcclxuICAgIGxldCBsaXN0ID0gcmVzdWx0LmdldChrKTtcclxuICAgIGlmIChsaXN0ID09IG51bGwpIHtcclxuICAgICAgbGlzdCA9IFtdO1xyXG4gICAgICByZXN1bHQuc2V0KGssIGxpc3QpO1xyXG4gICAgfVxyXG4gICAgbGlzdC5wdXNoKHYpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0RnJvbVBhaXJzPFQ6IHN0cmluZywgVT4oXHJcbiAgaXRlcmFibGU6IEl0ZXJhYmxlPFtULCBVXT4sXHJcbik6IHtbVF06IFV9IHtcclxuICBjb25zdCByZXN1bHQgPSB7fTtcclxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVyYWJsZSkge1xyXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdE1hcFZhbHVlczxULCBVLCBWPihcclxuICBvYmplY3Q6IHtbVDogc3RyaW5nXTogVX0sXHJcbiAgcHJvamVjdDogKHZhbHVlOiBVLCBrZXk6IFQpID0+IFYsXHJcbik6IHtbVF06IFZ9IHtcclxuICBjb25zdCByZXN1bHQgPSB7fTtcclxuICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goa2V5ID0+IHtcclxuICAgIHJlc3VsdFtrZXldID0gcHJvamVjdChvYmplY3Rba2V5XSwgKChrZXk6IGFueSk6IFQpKTtcclxuICB9KTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTXVsdGlNYXA8SywgVj4ge1xyXG4gIC8vIEludmFyaWFudDogbm8gZW1wdHkgc2V0cy4gVGhleSBzaG91bGQgYmUgcmVtb3ZlZCBpbnN0ZWFkLlxyXG4gIF9tYXA6IE1hcDxLLCBTZXQ8Vj4+O1xyXG5cclxuICAvLyBUT0RPIG1heSBiZSB3b3J0aCBkZWZpbmluZyBhIGdldHRlciBidXQgbm8gc2V0dGVyLCB0byBtaW1pYyBNYXAuIEJ1dCBwbGVhc2UganVzdCBiZWhhdmUgYW5kXHJcbiAgLy8gZG9uJ3QgbXV0YXRlIHRoaXMgZnJvbSBvdXRzaWRlIHRoaXMgY2xhc3MuXHJcbiAgLy9cclxuICAvLyBJbnZhcmlhbnQ6IGVxdWFsIHRvIHRoZSBzdW0gb2YgdGhlIHNpemVzIG9mIGFsbCB0aGUgc2V0cyBjb250YWluZWQgaW4gdGhpcy5fbWFwXHJcbiAgLyogVGhlIHRvdGFsIG51bWJlciBvZiBrZXktdmFsdWUgYmluZGluZ3MgY29udGFpbmVkICovXHJcbiAgc2l6ZTogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcclxuICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybnMgdGhlIHNldCBvZiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuIERvIG5vdCBtdXRhdGUgdGhlIGdpdmVuIHNldC4gQ29weSBpdFxyXG4gICAqIGlmIHlvdSBuZWVkIHRvIHN0b3JlIGl0IHBhc3QgdGhlIG5leHQgb3BlcmF0aW9uIG9uIHRoaXMgTXVsdGlNYXAuXHJcbiAgICovXHJcbiAgZ2V0KGtleTogSyk6IFNldDxWPiB7XHJcbiAgICBjb25zdCBzZXQgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XHJcbiAgICBpZiAoc2V0ID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzZXQ7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIE1pbWljcyB0aGUgTWFwLnByb3RvdHlwZS5zZXQgaW50ZXJmYWNlLiBEZWxpYmVyYXRlbHkgZGlkIG5vdCBjaG9vc2UgXCJzZXRcIiBhcyB0aGUgbmFtZSBzaW5jZSB0aGVcclxuICAgKiBpbXBsaWNhdGlvbiBpcyB0aGF0IGl0IHJlbW92ZXMgdGhlIHByZXZpb3VzIGJpbmRpbmcuXHJcbiAgICovXHJcbiAgYWRkKGtleTogSywgdmFsdWU6IFYpOiBNdWx0aU1hcDxLLCBWPiB7XHJcbiAgICBsZXQgc2V0ID0gdGhpcy5fbWFwLmdldChrZXkpO1xyXG4gICAgaWYgKHNldCA9PSBudWxsKSB7XHJcbiAgICAgIHNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgdGhpcy5fbWFwLnNldChrZXksIHNldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXNldC5oYXModmFsdWUpKSB7XHJcbiAgICAgIHNldC5hZGQodmFsdWUpO1xyXG4gICAgICB0aGlzLnNpemUrKztcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICAgKiBNaW1pY3MgdGhlIE1hcC5wcm90b3R5cGUuc2V0IGludGVyZmFjZS4gUmVwbGFjZXMgdGhlIHByZXZpb3VzIGJpbmRpbmcgd2l0aCBuZXcgdmFsdWVzLlxyXG4gICAqL1xyXG4gIHNldChrZXk6IEssIHZhbHVlczogSXRlcmFibGU8Vj4pOiB2b2lkIHtcclxuICAgIHRoaXMuZGVsZXRlQWxsKGtleSk7XHJcbiAgICBjb25zdCBuZXdTZXQgPSBuZXcgU2V0KHZhbHVlcyk7XHJcbiAgICBpZiAobmV3U2V0LnNpemUgIT09IDApIHtcclxuICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5ld1NldCk7XHJcbiAgICAgIHRoaXMuc2l6ZSArPSBuZXdTZXQuc2l6ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogRGVsZXRlcyBhIHNpbmdsZSBiaW5kaW5nLiBSZXR1cm5zIHRydWUgaWZmIHRoZSBiaW5kaW5nIGV4aXN0ZWQuXHJcbiAgICovXHJcbiAgZGVsZXRlKGtleTogSywgdmFsdWU6IFYpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHNldCA9IHRoaXMuZ2V0KGtleSk7XHJcbiAgICBjb25zdCBkaWRSZW1vdmUgPSBzZXQuZGVsZXRlKHZhbHVlKTtcclxuICAgIGlmIChzZXQuc2l6ZSA9PT0gMCkge1xyXG4gICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlkUmVtb3ZlKSB7XHJcbiAgICAgIHRoaXMuc2l6ZS0tO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZFJlbW92ZTtcclxuICB9XHJcblxyXG4gIC8qXHJcbiAgICogRGVsZXRlcyBhbGwgYmluZGluZ3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuIFJldHVybnMgdHJ1ZSBpZmYgYW55IGJpbmRpbmdzIHdlcmUgZGVsZXRlZC5cclxuICAgKi9cclxuICBkZWxldGVBbGwoa2V5OiBLKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBzZXQgPSB0aGlzLmdldChrZXkpO1xyXG4gICAgdGhpcy5zaXplIC09IHNldC5zaXplO1xyXG4gICAgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcclxuICB9XHJcblxyXG4gIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fbWFwLmNsZWFyKCk7XHJcbiAgICB0aGlzLnNpemUgPSAwO1xyXG4gIH1cclxuXHJcbiAgaGFzKGtleTogSywgdmFsdWU6IFYpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmdldChrZXkpLmhhcyh2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICBoYXNBbnkoa2V5OiBLKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhrZXkpO1xyXG4gIH1cclxuXHJcbiAgKnZhbHVlcygpOiBJdGVyYWJsZTxWPiB7XHJcbiAgICBmb3IgKGNvbnN0IHNldCBvZiB0aGlzLl9tYXAudmFsdWVzKCkpIHtcclxuICAgICAgeWllbGQqIHNldDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZvckVhY2goY2FsbGJhY2s6ICh2YWx1ZTogViwga2V5OiBLLCBvYmo6IE11bHRpTWFwPEssIFY+KSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgodmFsdWVzLCBrZXkpID0+XHJcbiAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IGNhbGxiYWNrKHZhbHVlLCBrZXksIHRoaXMpKSxcclxuICAgICk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0VmFsdWVzPFQ+KG9iajoge1trZXk6IHN0cmluZ106IFR9KTogQXJyYXk8VD4ge1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChrZXkgPT4gb2JqW2tleV0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0RW50cmllczxUPihvYmo6ID97W2tleTogc3RyaW5nXTogVH0pOiBBcnJheTxbc3RyaW5nLCBUXT4ge1xyXG4gIGlmIChvYmogPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xyXG4gIH1cclxuICBjb25zdCBlbnRyaWVzID0gW107XHJcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXHJcbiAgICAgIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSlcclxuICAgICkge1xyXG4gICAgICBlbnRyaWVzLnB1c2goW2tleSwgb2JqW2tleV1dKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGVudHJpZXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RGcm9tTWFwPFQ+KG1hcDogTWFwPHN0cmluZywgVD4pOiB7W2tleTogc3RyaW5nXTogVH0ge1xyXG4gIGNvbnN0IG9iaiA9IHt9O1xyXG4gIG1hcC5mb3JFYWNoKCh2LCBrKSA9PiB7XHJcbiAgICBvYmpba10gPSB2O1xyXG4gIH0pO1xyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiogY29uY2F0SXRlcmF0b3JzPFQ+KFxyXG4gIC4uLml0ZXJhdG9yczogJFJlYWRPbmx5QXJyYXk8SXRlcmFibGU8VD4+XHJcbik6IEl0ZXJhdG9yPFQ+IHtcclxuICBmb3IgKGNvbnN0IGl0ZXJhdG9yIG9mIGl0ZXJhdG9ycykge1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhdG9yKSB7XHJcbiAgICAgIHlpZWxkIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc29tZU9mSXRlcmFibGU8VD4oXHJcbiAgaXRlcmFibGU6IEl0ZXJhYmxlPFQ+LFxyXG4gIHByZWRpY2F0ZTogKGVsZW1lbnQ6IFQpID0+IGJvb2xlYW4sXHJcbik6IGJvb2xlYW4ge1xyXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xyXG4gICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmluZEluSXRlcmFibGU8VD4oXHJcbiAgaXRlcmFibGU6IEl0ZXJhYmxlPFQ+LFxyXG4gIHByZWRpY2F0ZTogKGVsZW1lbnQ6IFQpID0+IGJvb2xlYW4sXHJcbik6ID9UIHtcclxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudCkpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlPFQ+KFxyXG4gIGl0ZXJhYmxlOiBJdGVyYWJsZTxUPixcclxuICBwcmVkaWNhdGU6IChlbGVtZW50OiBUKSA9PiBib29sZWFuLFxyXG4pOiBJdGVyYWJsZTxUPiB7XHJcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XHJcbiAgICAgIHlpZWxkIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24qIG1hcEl0ZXJhYmxlPFQsIE0+KFxyXG4gIGl0ZXJhYmxlOiBJdGVyYWJsZTxUPixcclxuICBwcm9qZWN0b3JGbjogKGVsZW1lbnQ6IFQpID0+IE0sXHJcbik6IEl0ZXJhYmxlPE0+IHtcclxuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgaXRlcmFibGUpIHtcclxuICAgIHlpZWxkIHByb2plY3RvckZuKGVsZW1lbnQpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uKiB0YWtlSXRlcmFibGU8VD4oXHJcbiAgaXRlcmFibGU6IEl0ZXJhYmxlPFQ+LFxyXG4gIGxpbWl0OiBudW1iZXIsXHJcbik6IEl0ZXJhYmxlPFQ+IHtcclxuICBsZXQgaSA9IDA7XHJcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICBpZiAoKytpID4gbGltaXQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICB5aWVsZCBlbGVtZW50O1xyXG4gIH1cclxufVxyXG5cclxuLy8gUmV0dXJuIGFuIGl0ZXJhYmxlIG9mIHRoZSBudW1iZXJzIHN0YXJ0IChpbmNsdXNpdmUpIHRocm91Z2ggc3RvcCAoZXhjbHVzaXZlKVxyXG5leHBvcnQgZnVuY3Rpb24qIHJhbmdlKFxyXG4gIHN0YXJ0OiBudW1iZXIsXHJcbiAgc3RvcDogbnVtYmVyLFxyXG4gIHN0ZXA/OiBudW1iZXIgPSAxLFxyXG4pOiBJdGVyYWJsZTxudW1iZXI+IHtcclxuICAvLyBXZSBkb24ndCBjdXJyZW50bHkgc3VwcG9ydCBuZWdhdGl2ZSBzdGVwIHZhbHVlcy5cclxuICBpbnZhcmlhbnQoc3RlcCA+IDApO1xyXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0b3A7IGkgKz0gc3RlcCkge1xyXG4gICAgeWllbGQgaTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdE9mSXRlcmFibGU8VD4oaXRlcmFibGU6IEl0ZXJhYmxlPFQ+KTogP1Qge1xyXG4gIHJldHVybiBmaW5kSW5JdGVyYWJsZShpdGVyYWJsZSwgKCkgPT4gdHJ1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpdGVyYWJsZUlzRW1wdHk8VD4oaXRlcmFibGU6IEl0ZXJhYmxlPFQ+KTogYm9vbGVhbiB7XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXHJcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXRlcmFibGVDb250YWluczxUPihpdGVyYWJsZTogSXRlcmFibGU8VD4sIHZhbHVlOiBUKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuICFpdGVyYWJsZUlzRW1wdHkoXHJcbiAgICBmaWx0ZXJJdGVyYWJsZShpdGVyYWJsZSwgZWxlbWVudCA9PiBlbGVtZW50ID09PSB2YWx1ZSksXHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50PFQ+KGl0ZXJhYmxlOiBJdGVyYWJsZTxUPik6IG51bWJlciB7XHJcbiAgbGV0IHNpemUgPSAwO1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xyXG4gICAgc2l6ZSsrO1xyXG4gIH1cclxuICByZXR1cm4gc2l6ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzSXRlcmFibGUob2JqOiBhbnkpOiBib29sZWFuIHtcclxuICByZXR1cm4gdHlwZW9mIG9ialtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xyXG59XHJcblxyXG4vLyBUcmF2ZXJzZSBhbiBhcnJheSBmcm9tIHRoZSBpbnNpZGUgb3V0LCBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG5leHBvcnQgZnVuY3Rpb24qIGluc2lkZU91dDxUPihcclxuICBhcnI6ICRSZWFkT25seUFycmF5PFQ+LFxyXG4gIHN0YXJ0aW5nSW5kZXg/OiBudW1iZXIsXHJcbik6IEl0ZXJhYmxlPFtULCBudW1iZXJdPiB7XHJcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIGxldCBpID1cclxuICAgIHN0YXJ0aW5nSW5kZXggPT0gbnVsbFxyXG4gICAgICA/IE1hdGguZmxvb3IoYXJyLmxlbmd0aCAvIDIpXHJcbiAgICAgIDogTWF0aC5taW4oYXJyLmxlbmd0aCwgTWF0aC5tYXgoMCwgc3RhcnRpbmdJbmRleCkpO1xyXG4gIGxldCBqID0gaSAtIDE7XHJcblxyXG4gIHdoaWxlIChpIDwgYXJyLmxlbmd0aCB8fCBqID49IDApIHtcclxuICAgIGlmIChpIDwgYXJyLmxlbmd0aCkge1xyXG4gICAgICB5aWVsZCBbYXJyW2ldLCBpXTtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG4gICAgaWYgKGogPj0gMCkge1xyXG4gICAgICB5aWVsZCBbYXJyW2pdLCBqXTtcclxuICAgICAgai0tO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZyb21PYmplY3Q8VD4ob2JqOiB7W2tleTogc3RyaW5nXTogVH0pOiBNYXA8c3RyaW5nLCBUPiB7XHJcbiAgcmV0dXJuIG5ldyBNYXAob2JqZWN0RW50cmllcyhvYmopKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGxhc3RGcm9tQXJyYXk8VD4oYXJyOiAkUmVhZE9ubHlBcnJheTxUPik6IFQge1xyXG4gIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGlzdGluY3Q8VD4oYXJyYXk6IFRbXSwga2V5Rm4/OiAodDogVCkgPT4gc3RyaW5nKTogVFtdIHtcclxuICBpZiAoa2V5Rm4gPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheSkpO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc2VlbktleXMgPSBuZXcgU2V0KCk7XHJcbiAgcmV0dXJuIGFycmF5LmZpbHRlcihlbGVtID0+IHtcclxuICAgIGNvbnN0IGtleSA9IGtleUZuKGVsZW0pO1xyXG4gICAgaWYgKHNlZW5LZXlzLmhhcyhrZXkpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHNlZW5LZXlzLmFkZChrZXkpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0TWFwPEssIFY+IGV4dGVuZHMgTWFwPEssIFY+IHtcclxuICBfZmFjdG9yeTogSyA9PiBWO1xyXG5cclxuICBjb25zdHJ1Y3RvcihmYWN0b3J5OiBLID0+IFYsIGl0ZXJhYmxlOiA/SXRlcmFibGU8W0ssIFZdPikge1xyXG4gICAgc3VwZXIoaXRlcmFibGUpO1xyXG4gICAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5OiBLKTogViB7XHJcbiAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcclxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9mYWN0b3J5KGtleSk7XHJcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUga2V5IGlzIHByZXNlbnQgd2UgbXVzdCBoYXZlIGEgdmFsdWUgb2YgdHlwZSBWLlxyXG4gICAgcmV0dXJuIChzdXBlci5nZXQoa2V5KTogYW55KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0V2Vha01hcDxLOiB7fSwgVj4gZXh0ZW5kcyBXZWFrTWFwPEssIFY+IHtcclxuICBfZmFjdG9yeTogSyA9PiBWO1xyXG5cclxuICBjb25zdHJ1Y3RvcihmYWN0b3J5OiBLID0+IFYsIGl0ZXJhYmxlOiA/SXRlcmFibGU8W0ssIFZdPikge1xyXG4gICAgc3VwZXIoaXRlcmFibGUpO1xyXG4gICAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XHJcbiAgfVxyXG5cclxuICBnZXQoa2V5OiBLKTogViB7XHJcbiAgICBpZiAoIXRoaXMuaGFzKGtleSkpIHtcclxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9mYWN0b3J5KGtleSk7XHJcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUga2V5IGlzIHByZXNlbnQgd2UgbXVzdCBoYXZlIGEgdmFsdWUgb2YgdHlwZSBWLlxyXG4gICAgcmV0dXJuIChzdXBlci5nZXQoa2V5KTogYW55KTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGhpZ2hlc3QgcmFua2VkIGl0ZW0gaW4gYSBsaXN0LCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkIHJhbmtpbmcgZnVuY3Rpb24uIEEgbWF4IHJhbmtcclxuICogbWF5IG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgc28gdGhlIHdob2xlIGxpc3QgZG9lc24ndCBoYXZlIHRvIGJlIGl0ZXJhdGVkLiBJdGVtcyB3aXRoIHJhbmtzIG9mXHJcbiAqIHplcm8gb3IgbGVzcyBhcmUgbmV2ZXIgcmV0dXJuZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZFRvcFJhbmtlZDxUPihcclxuICBpdGVtczogSXRlcmFibGU8VD4sXHJcbiAgcmFua2VyOiBUID0+IG51bWJlcixcclxuICBtYXhSYW5rPzogbnVtYmVyLFxyXG4pOiA/VCB7XHJcbiAgbGV0IG1heFNlZW5SYW5rID0gMDtcclxuICBsZXQgbWF4UmFua2VkSXRlbTtcclxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcclxuICAgIGNvbnN0IHJhbmsgPSByYW5rZXIoaXRlbSk7XHJcbiAgICBpZiAocmFuayA9PT0gbWF4UmFuaykge1xyXG4gICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuICAgIGlmIChyYW5rID4gMCAmJiByYW5rID4gbWF4U2VlblJhbmspIHtcclxuICAgICAgbWF4U2VlblJhbmsgPSByYW5rO1xyXG4gICAgICBtYXhSYW5rZWRJdGVtID0gaXRlbTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG1heFJhbmtlZEl0ZW07XHJcbn1cclxuIl19