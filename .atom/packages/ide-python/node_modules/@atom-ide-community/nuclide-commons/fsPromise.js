"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _fsPlus = _interopRequireDefault(require("fs-plus"));

var _glob = _interopRequireDefault(require("glob"));

var _mkdirp = _interopRequireDefault(require("mkdirp"));

var _mv = _interopRequireDefault(require("mv"));

var _rimraf = _interopRequireDefault(require("rimraf"));

var _temp = _interopRequireDefault(require("temp"));

var _nuclideUri = _interopRequireDefault(require("./nuclideUri"));

var _process = require("./process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Create a temp directory with given prefix. The caller is responsible for cleaning up the
 *   drectory.
 * @param prefix optinal prefix for the temp directory name.
 * @return path to a temporary directory.
 */
function tempdir(prefix = '') {
  return new Promise((resolve, reject) => {
    _temp.default.mkdir(prefix, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}
/**
 * @return path to a temporary file. The caller is responsible for cleaning up
 *     the file.
 */


function tempfile(options) {
  return new Promise((resolve, reject) => {
    _temp.default.open(options, (err, info) => {
      if (err) {
        reject(err);
      } else {
        _fs.default.close(info.fd, closeErr => {
          if (closeErr) {
            reject(closeErr);
          } else {
            resolve(info.path);
          }
        });
      }
    });
  });
}
/**
 * Searches upward through the filesystem from pathToDirectory to find a file with
 * fileName.
 * @param fileName The name of the file to find.
 * @param pathToDirectory Where to begin the search. Must be a path to a directory,
 *   not a file.
 * @return directory that contains the nearest file or null.
 */


async function findNearestFile(fileName, pathToDirectory) {
  // TODO(5586355): If this becomes a bottleneck, we should consider memoizing
  // this function. The downside would be that if someone added a closer file
  // with fileName to pathToFile (or deleted the one that was cached), then we
  // would have a bug. This would probably be pretty rare, though.
  let currentPath = _nuclideUri.default.resolve(pathToDirectory);

  for (;;) {
    const fileToFind = _nuclideUri.default.join(currentPath, fileName); // eslint-disable-next-line no-await-in-loop


    const hasFile = await exists(fileToFind);

    if (hasFile) {
      return currentPath;
    }

    if (_nuclideUri.default.isRoot(currentPath)) {
      return null;
    }

    currentPath = _nuclideUri.default.dirname(currentPath);
  }
}

async function findNearestAncestorNamed(fileName, pathToDirectory) {
  const directory = await findNearestFile(fileName, pathToDirectory);

  if (directory != null) {
    return _nuclideUri.default.join(directory, fileName);
  } else {
    return null;
  }
}

function resolveRealPath(path) {
  return realpath(_nuclideUri.default.expandHomeDir(path));
}
/**
 * Searches upward through the filesystem from pathToDirectory to find the furthest
 * file with fileName.
 * @param fileName The name of the file to find.
 * @param pathToDirectory Where to begin the search. Must be a path to a directory,
 *   not a file.
 * @param stopOnMissing Stop searching when we reach a directory without fileName.
 * @return directory that contains the furthest file or null.
 */


async function findFurthestFile(fileName, pathToDirectory, stopOnMissing = false) {
  let currentPath = _nuclideUri.default.resolve(pathToDirectory);

  let result = null;

  for (;;) {
    const fileToFind = _nuclideUri.default.join(currentPath, fileName); // eslint-disable-next-line no-await-in-loop


    const hasFile = await exists(fileToFind);

    if (!hasFile && stopOnMissing || _nuclideUri.default.isRoot(currentPath)) {
      return result;
    } else if (hasFile) {
      result = currentPath;
    }

    currentPath = _nuclideUri.default.dirname(currentPath);
  }
}

function getCommonAncestorDirectory(filePaths) {
  let commonDirectoryPath = _nuclideUri.default.dirname(filePaths[0]);

  while (filePaths.some(filePath => !filePath.startsWith(commonDirectoryPath))) {
    commonDirectoryPath = _nuclideUri.default.dirname(commonDirectoryPath);
  }

  return commonDirectoryPath;
}

function exists(filePath) {
  return new Promise((resolve, reject) => {
    _fs.default.exists(filePath, resolve);
  });
}
/**
 * Runs the equivalent of `mkdir -p` with the given path.
 *
 * Like most implementations of mkdirp, if it fails, it is possible that
 * directories were created for some prefix of the given path.
 * @return true if the path was created; false if it already existed.
 */


async function mkdirp(filePath) {
  const isExistingDirectory = await exists(filePath);

  if (isExistingDirectory) {
    return false;
  } else {
    try {
      await (0, _mkdirp.default)(filePath);
      return true;
    } catch {
      return false;
    }
  }
}
/**
 * Removes directories even if they are non-empty. Does not fail if the directory doesn't exist.
 */


function rimrafWrapper(filePath) {
  return new Promise((resolve, reject) => {
    (0, _rimraf.default)(filePath, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

async function getFileSystemType(entityPath) {
  if (process.platform === 'linux' || process.platform === 'darwin') {
    try {
      const stdout = await (0, _process.runCommand)('stat', ['-f', '-L', '-c', '%T', entityPath]).toPromise();
      return stdout.trim();
    } catch (err) {
      return null;
    }
  } else {
    // TODO Handle other platforms (windows?)
    return null;
  }
}
/** @return true only if we are sure entityPath is on NFS. */


async function isNfs(entityPath) {
  return (await getFileSystemType(entityPath)) === 'nfs';
}
/** @return true only if we are sure entityPath is on a Fuse filesystem like
            dewey or gvfs.
*/


async function isFuse(entityPath) {
  return (await getFileSystemType(entityPath)) === 'fuseblk';
}

function glob(pattern, options) {
  return new Promise((resolve, reject) => {
    (0, _glob.default)(pattern, options, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

async function isNonNfsDirectory(directoryPath) {
  try {
    const stats = await stat(directoryPath);

    if (stats.isDirectory()) {
      return !(await isNfs(directoryPath));
    } else {
      return false;
    }
  } catch (e) {
    // If the directory cannot be probed for whatever reason, just
    // indicate that this is not a valid candidate directory.
    // Typically this is ENOENT for missing directory.
    return false;
  }
}
/**
 * Promisified wrappers around fs-plus functions.
 */


function copy(source, dest) {
  return new Promise((resolve, reject) => {
    _fsPlus.default.copy(source, dest, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

async function copyFilePermissions(sourcePath, destinationPath) {
  try {
    const {
      mode,
      uid,
      gid
    } = await stat(sourcePath);
    await Promise.all([// The user may not have permissions to use the uid/gid.
    chown(destinationPath, uid, gid).catch(() => {}), chmod(destinationPath, mode)]);
  } catch (e) {
    // If the file does not exist, then ENOENT will be thrown.
    if (e.code !== 'ENOENT') {
      throw e;
    } // For new files, use the default process file creation mask.


    await chmod(destinationPath, 0o666 & ~process.umask() // eslint-disable-line no-bitwise
    );
  }
}
/**
 * TODO: the fs-plus `writeFile` implementation runs `mkdirp` first.
 * We should use `fs.writeFile` and have callsites explicitly opt-in to this behaviour.
 */


function writeFile(filename, data, options) {
  return new Promise((resolve, reject) => {
    _fsPlus.default.writeFile(filename, data, options, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

async function writeFileAtomic(path, data, options) {
  const tempFilePath = await tempfile('nuclide');

  try {
    await writeFile(tempFilePath, data, options); // Expand the target path in case it contains symlinks.

    let realPath = path;

    try {
      realPath = await realpath(path);
    } catch (e) {// Fallback to using the specified path if it cannot be expanded.
      // Note: this is expected in cases where the remote file does not
      // actually exist.
    } // Ensure file still has original permissions:
    // https://github.com/facebook/nuclide/issues/157
    // We update the mode of the temp file rather than the destination file because
    // if we did the mv() then the chmod(), there would be a brief period between
    // those two operations where the destination file might have the wrong permissions.


    await copyFilePermissions(realPath, tempFilePath); // Ensure file has new permissions updated.

    const mode = typeof options !== 'string' ? options === null || options === void 0 ? void 0 : options.mode : null;

    if (mode != null) {
      await chmod(tempFilePath, mode);
    } // TODO: put renames into a queue so we don't write older save over new save.
    // Use mv as fs.rename doesn't work across partitions.


    await mv(tempFilePath, realPath, {
      mkdirp: true
    });
  } catch (err) {
    await unlink(tempFilePath);
    throw err;
  }
}
/**
 * Promisified wrappers around fs functions.
 */


function chmod(path, mode) {
  return new Promise((resolve, reject) => {
    _fs.default.chmod(path, mode, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function chown(path, uid, gid) {
  return new Promise((resolve, reject) => {
    _fs.default.chown(path, uid, gid, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function close(fd) {
  return new Promise((resolve, reject) => {
    _fs.default.close(fd, err => {
      if (err == null) {
        resolve();
      } else {
        reject(err);
      }
    });
  });
}

function fstat(fd) {
  return new Promise((resolve, reject) => {
    _fs.default.fstat(fd, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

async function fsync(fd) {
  return new Promise((resolve, reject) => {
    _fs.default.fsync(fd, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function ftruncate(fd, len) {
  return new Promise((resolve, reject) => {
    _fs.default.ftruncate(fd, len, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function lstat(path) {
  return new Promise((resolve, reject) => {
    _fs.default.lstat(path, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function mkdir(path, mode) {
  return new Promise((resolve, reject) => {
    _fs.default.mkdir(path, mode, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

/**
 * The key difference between 'mv' and 'rename' is that 'mv' works across devices.
 * It's not uncommon to have temporary files in a different disk, for instance.
 */
async function mv(sourcePath, destinationPath, options = {}) {
  // mv-node fails to account for the case where a destination directory exists
  // and `clobber` is false. This can result in the source directory getting
  // deleted but the destination not getting written.
  // https://github.com/andrewrk/node-mv/issues/30
  if (options.clobber === false && (await exists(destinationPath))) {
    const err = new Error('Destination file exists');
    err.code = 'EEXIST';
    err.path = destinationPath;
    throw err;
  }

  return new Promise((resolve, reject) => {
    (0, _mv.default)(sourcePath, destinationPath, options, error => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  });
}

function open(path, flags, mode = 0o666) {
  return new Promise((resolve, reject) => {
    _fs.default.open(path, flags, mode, (err, fd) => {
      if (err == null) {
        resolve(fd);
      } else {
        reject(err);
      }
    });
  });
}

function read(fd, buffer, offset, length, position) {
  return new Promise((resolve, reject) => {
    _fs.default.read(fd, buffer, offset, length, position, (err, bytesRead) => {
      if (err == null) {
        resolve(bytesRead);
      } else {
        reject(err);
      }
    });
  });
} // `fs.readFile` returns a Buffer unless an encoding is specified.
// This workaround is adapted from the Flow declarations.


const readFile = function (...args) {
  return new Promise((resolve, reject) => {
    // $FlowIssue: spread operator doesn't preserve any-type
    _fs.default.readFile(...args, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
};

function readdir(path) {
  return new Promise((resolve, reject) => {
    _fs.default.readdir(path, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function readlink(path) {
  return new Promise((resolve, reject) => {
    _fs.default.readlink(path, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function realpath(path, cache) {
  return new Promise((resolve, reject) => {
    _fs.default.realpath(path, cache, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function access(path, mode) {
  return new Promise((resolve, reject) => {
    _fs.default.access(path, mode, err => {
      if (err == null) {
        resolve(true);
      } else {
        resolve(false);
      }
    });
  });
}

function stat(path) {
  return new Promise((resolve, reject) => {
    _fs.default.stat(path, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function symlink(source, dest, type) {
  return new Promise((resolve, reject) => {
    _fs.default.symlink(source, dest, type, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}
/**
 * A utility function to grab the last N bytes from a file. Attempts to do so
 * without reading the entire file.
 */


async function tailBytes(file, maxBytes) {
  if (maxBytes <= 0) {
    throw new Error('tailbytes expects maxBytes > 0');
  } // Figure out the size so we know what strategy to use


  const {
    size: file_size
  } = await stat(file);

  if (file_size > maxBytes) {
    const fd = await open(file, 'r');
    const buffer = Buffer.alloc(maxBytes);
    const bytesRead = await read(fd, buffer, 0, // buffer offset
    maxBytes, // length to read
    file_size - maxBytes // file offset
    );
    await close(fd);
    /* If we meant to read the last 100 bytes but only read 50 bytes, then we've
     * failed to read the last 100 bytes. So throw. In the future, someone
     * could update this code to keep calling `read` until we read maxBytes.
     */

    if (bytesRead !== maxBytes) {
      throw new Error(`Failed to tail file. Intended to read ${maxBytes} bytes but ` + `only read ${bytesRead} bytes`);
    }

    return buffer;
  } else {
    return readFile(file);
  }
}

function unlink(path) {
  return new Promise((resolve, reject) => {
    _fs.default.unlink(path, (err, result) => {
      if (err == null) {
        resolve(result);
      } else {
        reject(err);
      }
    });
  });
}

function utimes(path, atime, mtime) {
  return new Promise((resolve, reject) => {
    _fs.default.utimes(path, atime, mtime, err => {
      if (err == null) {
        resolve();
      } else {
        reject(err);
      }
    });
  });
}

function rmdir(path) {
  return new Promise((resolve, reject) => {
    _fs.default.rmdir(path, err => {
      if (err == null) {
        resolve();
      } else {
        reject(err);
      }
    });
  });
}
/**
 * Attempts to resolve the physical path of the filename.
 * Sometimes filePath may not exist yet, in which case we need to look upwards
 * for the first prefix that actually does exist.
 */


async function guessRealPath(filePath) {
  if (_nuclideUri.default.isRemote(filePath)) {
    throw new Error('Only local paths can be used with guessRealPath');
  }

  const resolved = _nuclideUri.default.resolve(filePath);

  let prefix = resolved;
  let suffix = null;

  while (true) {
    try {
      // eslint-disable-next-line no-await-in-loop
      const realPath = await realpath(prefix);
      return suffix == null ? realPath : _nuclideUri.default.join(realPath, suffix);
    } catch (err) {
      if (err.code !== 'ENOENT') {
        throw err;
      }

      const basename = _nuclideUri.default.basename(prefix);

      if (basename === '') {
        // We've reached the filesystem root.
        break;
      }

      suffix = suffix == null ? basename : _nuclideUri.default.join(basename, suffix);
      prefix = _nuclideUri.default.dirname(prefix);
    }
  }

  return resolved;
}

var _default = {
  tempdir,
  tempfile,
  findNearestFile,
  findFurthestFile,
  getCommonAncestorDirectory,
  exists,
  mkdirp,
  rimraf: rimrafWrapper,
  isNfs,
  isFuse,
  glob,
  isNonNfsDirectory,
  copy,
  copyFilePermissions,
  writeFile,
  writeFileAtomic,
  chmod,
  chown,
  close,
  fstat,
  fsync,
  ftruncate,
  lstat,
  mkdir,
  mv,
  open,
  read,
  readFile,
  readdir,
  readlink,
  realpath,
  stat,
  symlink,
  tailBytes,
  unlink,
  utimes,
  rmdir,
  access,
  findNearestAncestorNamed,
  resolveRealPath,
  guessRealPath
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL2ZzUHJvbWlzZS5qcyJdLCJuYW1lcyI6WyJ0ZW1wZGlyIiwicHJlZml4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0ZW1wIiwibWtkaXIiLCJlcnIiLCJyZXN1bHQiLCJ0ZW1wZmlsZSIsIm9wdGlvbnMiLCJvcGVuIiwiaW5mbyIsImZzIiwiY2xvc2UiLCJmZCIsImNsb3NlRXJyIiwicGF0aCIsImZpbmROZWFyZXN0RmlsZSIsImZpbGVOYW1lIiwicGF0aFRvRGlyZWN0b3J5IiwiY3VycmVudFBhdGgiLCJudWNsaWRlVXJpIiwiZmlsZVRvRmluZCIsImpvaW4iLCJoYXNGaWxlIiwiZXhpc3RzIiwiaXNSb290IiwiZGlybmFtZSIsImZpbmROZWFyZXN0QW5jZXN0b3JOYW1lZCIsImRpcmVjdG9yeSIsInJlc29sdmVSZWFsUGF0aCIsInJlYWxwYXRoIiwiZXhwYW5kSG9tZURpciIsImZpbmRGdXJ0aGVzdEZpbGUiLCJzdG9wT25NaXNzaW5nIiwiZ2V0Q29tbW9uQW5jZXN0b3JEaXJlY3RvcnkiLCJmaWxlUGF0aHMiLCJjb21tb25EaXJlY3RvcnlQYXRoIiwic29tZSIsImZpbGVQYXRoIiwic3RhcnRzV2l0aCIsIm1rZGlycCIsImlzRXhpc3RpbmdEaXJlY3RvcnkiLCJyaW1yYWZXcmFwcGVyIiwiZ2V0RmlsZVN5c3RlbVR5cGUiLCJlbnRpdHlQYXRoIiwicHJvY2VzcyIsInBsYXRmb3JtIiwic3Rkb3V0IiwidG9Qcm9taXNlIiwidHJpbSIsImlzTmZzIiwiaXNGdXNlIiwiZ2xvYiIsInBhdHRlcm4iLCJpc05vbk5mc0RpcmVjdG9yeSIsImRpcmVjdG9yeVBhdGgiLCJzdGF0cyIsInN0YXQiLCJpc0RpcmVjdG9yeSIsImUiLCJjb3B5Iiwic291cmNlIiwiZGVzdCIsImZzUGx1cyIsImNvcHlGaWxlUGVybWlzc2lvbnMiLCJzb3VyY2VQYXRoIiwiZGVzdGluYXRpb25QYXRoIiwibW9kZSIsInVpZCIsImdpZCIsImFsbCIsImNob3duIiwiY2F0Y2giLCJjaG1vZCIsImNvZGUiLCJ1bWFzayIsIndyaXRlRmlsZSIsImZpbGVuYW1lIiwiZGF0YSIsIndyaXRlRmlsZUF0b21pYyIsInRlbXBGaWxlUGF0aCIsInJlYWxQYXRoIiwibXYiLCJ1bmxpbmsiLCJmc3RhdCIsImZzeW5jIiwiZnRydW5jYXRlIiwibGVuIiwibHN0YXQiLCJjbG9iYmVyIiwiRXJyb3IiLCJlcnJvciIsImZsYWdzIiwicmVhZCIsImJ1ZmZlciIsIm9mZnNldCIsImxlbmd0aCIsInBvc2l0aW9uIiwiYnl0ZXNSZWFkIiwicmVhZEZpbGUiLCJhcmdzIiwicmVhZGRpciIsInJlYWRsaW5rIiwiY2FjaGUiLCJhY2Nlc3MiLCJzeW1saW5rIiwidHlwZSIsInRhaWxCeXRlcyIsImZpbGUiLCJtYXhCeXRlcyIsInNpemUiLCJmaWxlX3NpemUiLCJCdWZmZXIiLCJhbGxvYyIsInV0aW1lcyIsImF0aW1lIiwibXRpbWUiLCJybWRpciIsImd1ZXNzUmVhbFBhdGgiLCJpc1JlbW90ZSIsInJlc29sdmVkIiwic3VmZml4IiwiYmFzZW5hbWUiLCJyaW1yYWYiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFZQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7OztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQSxPQUFULENBQWlCQyxNQUFjLEdBQUcsRUFBbEMsRUFBdUQ7QUFDckQsU0FBTyxJQUFJQyxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDQyxrQkFBS0MsS0FBTCxDQUFXTCxNQUFYLEVBQW1CLENBQUNNLEdBQUQsRUFBTUMsTUFBTixLQUFpQjtBQUNsQyxVQUFJRCxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPLENBQUNLLE1BQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMSixRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNFLFFBQVQsQ0FBa0JDLE9BQWxCLEVBQWlEO0FBQy9DLFNBQU8sSUFBSVIsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q0Msa0JBQUtNLElBQUwsQ0FBVUQsT0FBVixFQUFtQixDQUFDSCxHQUFELEVBQU1LLElBQU4sS0FBZTtBQUNoQyxVQUFJTCxHQUFKLEVBQVM7QUFDUEgsUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRCxPQUZELE1BRU87QUFDTE0sb0JBQUdDLEtBQUgsQ0FBU0YsSUFBSSxDQUFDRyxFQUFkLEVBQWtCQyxRQUFRLElBQUk7QUFDNUIsY0FBSUEsUUFBSixFQUFjO0FBQ1paLFlBQUFBLE1BQU0sQ0FBQ1ksUUFBRCxDQUFOO0FBQ0QsV0FGRCxNQUVPO0FBQ0xiLFlBQUFBLE9BQU8sQ0FBQ1MsSUFBSSxDQUFDSyxJQUFOLENBQVA7QUFDRDtBQUNGLFNBTkQ7QUFPRDtBQUNGLEtBWkQ7QUFhRCxHQWRNLENBQVA7QUFlRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGVBQWVDLGVBQWYsQ0FDRUMsUUFERixFQUVFQyxlQUZGLEVBR29CO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSUMsV0FBVyxHQUFHQyxvQkFBV25CLE9BQVgsQ0FBbUJpQixlQUFuQixDQUFsQjs7QUFDQSxXQUFTO0FBQ1AsVUFBTUcsVUFBVSxHQUFHRCxvQkFBV0UsSUFBWCxDQUFnQkgsV0FBaEIsRUFBNkJGLFFBQTdCLENBQW5CLENBRE8sQ0FFUDs7O0FBQ0EsVUFBTU0sT0FBTyxHQUFHLE1BQU1DLE1BQU0sQ0FBQ0gsVUFBRCxDQUE1Qjs7QUFDQSxRQUFJRSxPQUFKLEVBQWE7QUFDWCxhQUFPSixXQUFQO0FBQ0Q7O0FBQ0QsUUFBSUMsb0JBQVdLLE1BQVgsQ0FBa0JOLFdBQWxCLENBQUosRUFBb0M7QUFDbEMsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0RBLElBQUFBLFdBQVcsR0FBR0Msb0JBQVdNLE9BQVgsQ0FBbUJQLFdBQW5CLENBQWQ7QUFDRDtBQUNGOztBQUVELGVBQWVRLHdCQUFmLENBQ0VWLFFBREYsRUFFRUMsZUFGRixFQUdvQjtBQUNsQixRQUFNVSxTQUFTLEdBQUcsTUFBTVosZUFBZSxDQUFDQyxRQUFELEVBQVdDLGVBQVgsQ0FBdkM7O0FBQ0EsTUFBSVUsU0FBUyxJQUFJLElBQWpCLEVBQXVCO0FBQ3JCLFdBQU9SLG9CQUFXRSxJQUFYLENBQWdCTSxTQUFoQixFQUEyQlgsUUFBM0IsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU1ksZUFBVCxDQUF5QmQsSUFBekIsRUFBd0Q7QUFDdEQsU0FBT2UsUUFBUSxDQUFDVixvQkFBV1csYUFBWCxDQUF5QmhCLElBQXpCLENBQUQsQ0FBZjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxlQUFlaUIsZ0JBQWYsQ0FDRWYsUUFERixFQUVFQyxlQUZGLEVBR0VlLGFBQXNCLEdBQUcsS0FIM0IsRUFJb0I7QUFDbEIsTUFBSWQsV0FBVyxHQUFHQyxvQkFBV25CLE9BQVgsQ0FBbUJpQixlQUFuQixDQUFsQjs7QUFDQSxNQUFJWixNQUFNLEdBQUcsSUFBYjs7QUFDQSxXQUFTO0FBQ1AsVUFBTWUsVUFBVSxHQUFHRCxvQkFBV0UsSUFBWCxDQUFnQkgsV0FBaEIsRUFBNkJGLFFBQTdCLENBQW5CLENBRE8sQ0FFUDs7O0FBQ0EsVUFBTU0sT0FBTyxHQUFHLE1BQU1DLE1BQU0sQ0FBQ0gsVUFBRCxDQUE1Qjs7QUFDQSxRQUFLLENBQUNFLE9BQUQsSUFBWVUsYUFBYixJQUErQmIsb0JBQVdLLE1BQVgsQ0FBa0JOLFdBQWxCLENBQW5DLEVBQW1FO0FBQ2pFLGFBQU9iLE1BQVA7QUFDRCxLQUZELE1BRU8sSUFBSWlCLE9BQUosRUFBYTtBQUNsQmpCLE1BQUFBLE1BQU0sR0FBR2EsV0FBVDtBQUNEOztBQUNEQSxJQUFBQSxXQUFXLEdBQUdDLG9CQUFXTSxPQUFYLENBQW1CUCxXQUFuQixDQUFkO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTZSwwQkFBVCxDQUFvQ0MsU0FBcEMsRUFBc0U7QUFDcEUsTUFBSUMsbUJBQW1CLEdBQUdoQixvQkFBV00sT0FBWCxDQUFtQlMsU0FBUyxDQUFDLENBQUQsQ0FBNUIsQ0FBMUI7O0FBQ0EsU0FDRUEsU0FBUyxDQUFDRSxJQUFWLENBQWVDLFFBQVEsSUFBSSxDQUFDQSxRQUFRLENBQUNDLFVBQVQsQ0FBb0JILG1CQUFwQixDQUE1QixDQURGLEVBRUU7QUFDQUEsSUFBQUEsbUJBQW1CLEdBQUdoQixvQkFBV00sT0FBWCxDQUFtQlUsbUJBQW5CLENBQXRCO0FBQ0Q7O0FBQ0QsU0FBT0EsbUJBQVA7QUFDRDs7QUFFRCxTQUFTWixNQUFULENBQWdCYyxRQUFoQixFQUFvRDtBQUNsRCxTQUFPLElBQUl0QyxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBR2EsTUFBSCxDQUFVYyxRQUFWLEVBQW9CckMsT0FBcEI7QUFDRCxHQUZNLENBQVA7QUFHRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxlQUFldUMsTUFBZixDQUFzQkYsUUFBdEIsRUFBMEQ7QUFDeEQsUUFBTUcsbUJBQW1CLEdBQUcsTUFBTWpCLE1BQU0sQ0FBQ2MsUUFBRCxDQUF4Qzs7QUFDQSxNQUFJRyxtQkFBSixFQUF5QjtBQUN2QixXQUFPLEtBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJO0FBQ0YsWUFBTSxxQkFBVUgsUUFBVixDQUFOO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0FIRCxDQUdFLE1BQU07QUFDTixhQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFFRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNJLGFBQVQsQ0FBdUJKLFFBQXZCLEVBQXdEO0FBQ3RELFNBQU8sSUFBSXRDLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMseUJBQU9vQyxRQUFQLEVBQWlCLENBQUNqQyxHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDaEMsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxlQUFlc0MsaUJBQWYsQ0FBaUNDLFVBQWpDLEVBQXVFO0FBQ3JFLE1BQUlDLE9BQU8sQ0FBQ0MsUUFBUixLQUFxQixPQUFyQixJQUFnQ0QsT0FBTyxDQUFDQyxRQUFSLEtBQXFCLFFBQXpELEVBQW1FO0FBQ2pFLFFBQUk7QUFDRixZQUFNQyxNQUFNLEdBQUcsTUFBTSx5QkFBVyxNQUFYLEVBQW1CLENBQ3RDLElBRHNDLEVBRXRDLElBRnNDLEVBR3RDLElBSHNDLEVBSXRDLElBSnNDLEVBS3RDSCxVQUxzQyxDQUFuQixFQU1sQkksU0FOa0IsRUFBckI7QUFPQSxhQUFPRCxNQUFNLENBQUNFLElBQVAsRUFBUDtBQUNELEtBVEQsQ0FTRSxPQUFPNUMsR0FBUCxFQUFZO0FBQ1osYUFBTyxJQUFQO0FBQ0Q7QUFDRixHQWJELE1BYU87QUFDTDtBQUNBLFdBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFFRDs7O0FBQ0EsZUFBZTZDLEtBQWYsQ0FBcUJOLFVBQXJCLEVBQTJEO0FBQ3pELFNBQU8sQ0FBQyxNQUFNRCxpQkFBaUIsQ0FBQ0MsVUFBRCxDQUF4QixNQUEwQyxLQUFqRDtBQUNEO0FBRUQ7QUFDQTtBQUNBOzs7QUFDQSxlQUFlTyxNQUFmLENBQXNCUCxVQUF0QixFQUE0RDtBQUMxRCxTQUFPLENBQUMsTUFBTUQsaUJBQWlCLENBQUNDLFVBQUQsQ0FBeEIsTUFBMEMsU0FBakQ7QUFDRDs7QUFFRCxTQUFTUSxJQUFULENBQWNDLE9BQWQsRUFBK0I3QyxPQUEvQixFQUF5RTtBQUN2RSxTQUFPLElBQUlSLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMsdUJBQVFtRCxPQUFSLEVBQWlCN0MsT0FBakIsRUFBMEIsQ0FBQ0gsR0FBRCxFQUFNQyxNQUFOLEtBQWlCO0FBQ3pDLFVBQUlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU8sQ0FBQ0ssTUFBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xKLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsZUFBZWlELGlCQUFmLENBQWlDQyxhQUFqQyxFQUEwRTtBQUN4RSxNQUFJO0FBQ0YsVUFBTUMsS0FBSyxHQUFHLE1BQU1DLElBQUksQ0FBQ0YsYUFBRCxDQUF4Qjs7QUFDQSxRQUFJQyxLQUFLLENBQUNFLFdBQU4sRUFBSixFQUF5QjtBQUN2QixhQUFPLEVBQUUsTUFBTVIsS0FBSyxDQUFDSyxhQUFELENBQWIsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8sS0FBUDtBQUNEO0FBQ0YsR0FQRCxDQU9FLE9BQU9JLENBQVAsRUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFFRDtBQUNBO0FBQ0E7OztBQUVBLFNBQVNDLElBQVQsQ0FBY0MsTUFBZCxFQUE4QkMsSUFBOUIsRUFBMkQ7QUFDekQsU0FBTyxJQUFJOUQsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0QzZELG9CQUFPSCxJQUFQLENBQVlDLE1BQVosRUFBb0JDLElBQXBCLEVBQTBCLENBQUN6RCxHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDekMsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxlQUFlMkQsbUJBQWYsQ0FDRUMsVUFERixFQUVFQyxlQUZGLEVBR2lCO0FBQ2YsTUFBSTtBQUNGLFVBQU07QUFBQ0MsTUFBQUEsSUFBRDtBQUFPQyxNQUFBQSxHQUFQO0FBQVlDLE1BQUFBO0FBQVosUUFBbUIsTUFBTVosSUFBSSxDQUFDUSxVQUFELENBQW5DO0FBQ0EsVUFBTWpFLE9BQU8sQ0FBQ3NFLEdBQVIsQ0FBWSxDQUNoQjtBQUNBQyxJQUFBQSxLQUFLLENBQUNMLGVBQUQsRUFBa0JFLEdBQWxCLEVBQXVCQyxHQUF2QixDQUFMLENBQWlDRyxLQUFqQyxDQUF1QyxNQUFNLENBQUUsQ0FBL0MsQ0FGZ0IsRUFHaEJDLEtBQUssQ0FBQ1AsZUFBRCxFQUFrQkMsSUFBbEIsQ0FIVyxDQUFaLENBQU47QUFLRCxHQVBELENBT0UsT0FBT1IsQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxRQUFJQSxDQUFDLENBQUNlLElBQUYsS0FBVyxRQUFmLEVBQXlCO0FBQ3ZCLFlBQU1mLENBQU47QUFDRCxLQUpTLENBS1Y7OztBQUNBLFVBQU1jLEtBQUssQ0FDVFAsZUFEUyxFQUVULFFBQVEsQ0FBQ3JCLE9BQU8sQ0FBQzhCLEtBQVIsRUFGQSxDQUVpQjtBQUZqQixLQUFYO0FBSUQ7QUFDRjtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTQyxTQUFULENBQ0VDLFFBREYsRUFFRUMsSUFGRixFQUdFdEUsT0FIRixFQUlpQjtBQUNmLFNBQU8sSUFBSVIsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0QzZELG9CQUFPYSxTQUFQLENBQWlCQyxRQUFqQixFQUEyQkMsSUFBM0IsRUFBaUN0RSxPQUFqQyxFQUEwQyxDQUFDSCxHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDekQsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxlQUFlMEUsZUFBZixDQUNFaEUsSUFERixFQUVFK0QsSUFGRixFQUdFdEUsT0FIRixFQUlpQjtBQUNmLFFBQU13RSxZQUFZLEdBQUcsTUFBTXpFLFFBQVEsQ0FBQyxTQUFELENBQW5DOztBQUNBLE1BQUk7QUFDRixVQUFNcUUsU0FBUyxDQUFDSSxZQUFELEVBQWVGLElBQWYsRUFBcUJ0RSxPQUFyQixDQUFmLENBREUsQ0FHRjs7QUFDQSxRQUFJeUUsUUFBUSxHQUFHbEUsSUFBZjs7QUFDQSxRQUFJO0FBQ0ZrRSxNQUFBQSxRQUFRLEdBQUcsTUFBTW5ELFFBQVEsQ0FBQ2YsSUFBRCxDQUF6QjtBQUNELEtBRkQsQ0FFRSxPQUFPNEMsQ0FBUCxFQUFVLENBQ1Y7QUFDQTtBQUNBO0FBQ0QsS0FYQyxDQWFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFVBQU1LLG1CQUFtQixDQUFDaUIsUUFBRCxFQUFXRCxZQUFYLENBQXpCLENBbEJFLENBb0JGOztBQUNBLFVBQU1iLElBQUksR0FBRyxPQUFPM0QsT0FBUCxLQUFtQixRQUFuQixHQUE4QkEsT0FBOUIsYUFBOEJBLE9BQTlCLHVCQUE4QkEsT0FBTyxDQUFFMkQsSUFBdkMsR0FBOEMsSUFBM0Q7O0FBQ0EsUUFBSUEsSUFBSSxJQUFJLElBQVosRUFBa0I7QUFDaEIsWUFBTU0sS0FBSyxDQUFDTyxZQUFELEVBQWViLElBQWYsQ0FBWDtBQUNELEtBeEJDLENBMEJGO0FBQ0E7OztBQUNBLFVBQU1lLEVBQUUsQ0FBQ0YsWUFBRCxFQUFlQyxRQUFmLEVBQXlCO0FBQUN6QyxNQUFBQSxNQUFNLEVBQUU7QUFBVCxLQUF6QixDQUFSO0FBQ0QsR0E3QkQsQ0E2QkUsT0FBT25DLEdBQVAsRUFBWTtBQUNaLFVBQU04RSxNQUFNLENBQUNILFlBQUQsQ0FBWjtBQUNBLFVBQU0zRSxHQUFOO0FBQ0Q7QUFDRjtBQUVEO0FBQ0E7QUFDQTs7O0FBRUEsU0FBU29FLEtBQVQsQ0FBZTFELElBQWYsRUFBNkJvRCxJQUE3QixFQUFtRTtBQUNqRSxTQUFPLElBQUluRSxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBRzhELEtBQUgsQ0FBUzFELElBQVQsRUFBZW9ELElBQWYsRUFBcUIsQ0FBQzlELEdBQUQsRUFBTUMsTUFBTixLQUFpQjtBQUNwQyxVQUFJRCxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPLENBQUNLLE1BQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMSixRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNEOztBQUVELFNBQVNrRSxLQUFULENBQWV4RCxJQUFmLEVBQTZCcUQsR0FBN0IsRUFBMENDLEdBQTFDLEVBQXNFO0FBQ3BFLFNBQU8sSUFBSXJFLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHNEQsS0FBSCxDQUFTeEQsSUFBVCxFQUFlcUQsR0FBZixFQUFvQkMsR0FBcEIsRUFBeUIsQ0FBQ2hFLEdBQUQsRUFBTUMsTUFBTixLQUFpQjtBQUN4QyxVQUFJRCxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPLENBQUNLLE1BQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMSixRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNEOztBQUVELFNBQVNPLEtBQVQsQ0FBZUMsRUFBZixFQUEwQztBQUN4QyxTQUFPLElBQUliLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHQyxLQUFILENBQVNDLEVBQVQsRUFBYVIsR0FBRyxJQUFJO0FBQ2xCLFVBQUlBLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU87QUFDUixPQUZELE1BRU87QUFDTEMsUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxTQUFTK0UsS0FBVCxDQUFldkUsRUFBZixFQUE4QztBQUM1QyxTQUFPLElBQUliLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHeUUsS0FBSCxDQUFTdkUsRUFBVCxFQUFhLENBQUNSLEdBQUQsRUFBTUMsTUFBTixLQUFpQjtBQUM1QixVQUFJRCxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPLENBQUNLLE1BQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMSixRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNEOztBQUVELGVBQWVnRixLQUFmLENBQXFCeEUsRUFBckIsRUFBZ0Q7QUFDOUMsU0FBTyxJQUFJYixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBRzBFLEtBQUgsQ0FBU3hFLEVBQVQsRUFBYSxDQUFDUixHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDNUIsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxTQUFTaUYsU0FBVCxDQUFtQnpFLEVBQW5CLEVBQStCMEUsR0FBL0IsRUFBMkQ7QUFDekQsU0FBTyxJQUFJdkYsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q1MsZ0JBQUcyRSxTQUFILENBQWF6RSxFQUFiLEVBQWlCMEUsR0FBakIsRUFBc0IsQ0FBQ2xGLEdBQUQsRUFBTUMsTUFBTixLQUFpQjtBQUNyQyxVQUFJRCxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPLENBQUNLLE1BQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMSixRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNEOztBQUVELFNBQVNtRixLQUFULENBQWV6RSxJQUFmLEVBQWdEO0FBQzlDLFNBQU8sSUFBSWYsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q1MsZ0JBQUc2RSxLQUFILENBQVN6RSxJQUFULEVBQWUsQ0FBQ1YsR0FBRCxFQUFNQyxNQUFOLEtBQWlCO0FBQzlCLFVBQUlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU8sQ0FBQ0ssTUFBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xKLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsU0FBU0QsS0FBVCxDQUFlVyxJQUFmLEVBQTZCb0QsSUFBN0IsRUFBMkQ7QUFDekQsU0FBTyxJQUFJbkUsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q1MsZ0JBQUdQLEtBQUgsQ0FBU1csSUFBVCxFQUFlb0QsSUFBZixFQUFxQixDQUFDOUQsR0FBRCxFQUFNQyxNQUFOLEtBQWlCO0FBQ3BDLFVBQUlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU8sQ0FBQ0ssTUFBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xKLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBV0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlNkUsRUFBZixDQUNFakIsVUFERixFQUVFQyxlQUZGLEVBR0UxRCxPQUFtQixHQUFHLEVBSHhCLEVBSWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJQSxPQUFPLENBQUNpRixPQUFSLEtBQW9CLEtBQXBCLEtBQThCLE1BQU1qRSxNQUFNLENBQUMwQyxlQUFELENBQTFDLENBQUosRUFBa0U7QUFDaEUsVUFBTTdELEdBQWUsR0FBRyxJQUFJcUYsS0FBSixDQUFVLHlCQUFWLENBQXhCO0FBQ0FyRixJQUFBQSxHQUFHLENBQUNxRSxJQUFKLEdBQVcsUUFBWDtBQUNBckUsSUFBQUEsR0FBRyxDQUFDVSxJQUFKLEdBQVdtRCxlQUFYO0FBQ0EsVUFBTTdELEdBQU47QUFDRDs7QUFDRCxTQUFPLElBQUlMLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdEMscUJBQU0rRCxVQUFOLEVBQWtCQyxlQUFsQixFQUFtQzFELE9BQW5DLEVBQTRDbUYsS0FBSyxJQUFJO0FBQ25ELFVBQUlBLEtBQUosRUFBVztBQUNUekYsUUFBQUEsTUFBTSxDQUFDeUYsS0FBRCxDQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0wxRixRQUFBQSxPQUFPO0FBQ1I7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsU0FBU1EsSUFBVCxDQUNFTSxJQURGLEVBRUU2RSxLQUZGLEVBR0V6QixJQUFZLEdBQUcsS0FIakIsRUFJbUI7QUFDakIsU0FBTyxJQUFJbkUsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q1MsZ0JBQUdGLElBQUgsQ0FBUU0sSUFBUixFQUFjNkUsS0FBZCxFQUFxQnpCLElBQXJCLEVBQTJCLENBQUM5RCxHQUFELEVBQU1RLEVBQU4sS0FBYTtBQUN0QyxVQUFJUixHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPLENBQUNZLEVBQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMWCxRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNEOztBQUVELFNBQVN3RixJQUFULENBQ0VoRixFQURGLEVBRUVpRixNQUZGLEVBR0VDLE1BSEYsRUFJRUMsTUFKRixFQUtFQyxRQUxGLEVBTW1CO0FBQ2pCLFNBQU8sSUFBSWpHLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHa0YsSUFBSCxDQUFRaEYsRUFBUixFQUFZaUYsTUFBWixFQUFvQkMsTUFBcEIsRUFBNEJDLE1BQTVCLEVBQW9DQyxRQUFwQyxFQUE4QyxDQUFDNUYsR0FBRCxFQUFNNkYsU0FBTixLQUFvQjtBQUNoRSxVQUFJN0YsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDaUcsU0FBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xoRyxRQUFBQSxNQUFNLENBQUNHLEdBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBUk0sQ0FBUDtBQVNELEMsQ0FFRDtBQUNBOzs7QUFRQSxNQUFNOEYsUUFBc0IsR0FBSSxVQUFTLEdBQUdDLElBQVosRUFBOEI7QUFDNUQsU0FBTyxJQUFJcEcsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0QztBQUNBUyxnQkFBR3dGLFFBQUgsQ0FBWSxHQUFHQyxJQUFmLEVBQXFCLENBQUMvRixHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDcEMsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVRNLENBQVA7QUFVRCxDQVhEOztBQWFBLFNBQVNnRyxPQUFULENBQWlCdEYsSUFBakIsRUFBdUQ7QUFDckQsU0FBTyxJQUFJZixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBRzBGLE9BQUgsQ0FBV3RGLElBQVgsRUFBaUIsQ0FBQ1YsR0FBRCxFQUFNQyxNQUFOLEtBQWlCO0FBQ2hDLFVBQUlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU8sQ0FBQ0ssTUFBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xKLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsU0FBU2lHLFFBQVQsQ0FBa0J2RixJQUFsQixFQUFpRDtBQUMvQyxTQUFPLElBQUlmLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHMkYsUUFBSCxDQUFZdkYsSUFBWixFQUFrQixDQUFDVixHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDakMsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxTQUFTeUIsUUFBVCxDQUFrQmYsSUFBbEIsRUFBZ0N3RixLQUFoQyxFQUFpRTtBQUMvRCxTQUFPLElBQUl2RyxPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBR21CLFFBQUgsQ0FBWWYsSUFBWixFQUFrQndGLEtBQWxCLEVBQXlCLENBQUNsRyxHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDeEMsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxTQUFTbUcsTUFBVCxDQUFnQnpGLElBQWhCLEVBQThCb0QsSUFBOUIsRUFBOEQ7QUFDNUQsU0FBTyxJQUFJbkUsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q1MsZ0JBQUc2RixNQUFILENBQVV6RixJQUFWLEVBQWdCb0QsSUFBaEIsRUFBc0I5RCxHQUFHLElBQUk7QUFDM0IsVUFBSUEsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDLElBQUQsQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMQSxRQUFBQSxPQUFPLENBQUMsS0FBRCxDQUFQO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsU0FBU3dELElBQVQsQ0FBYzFDLElBQWQsRUFBK0M7QUFDN0MsU0FBTyxJQUFJZixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBRzhDLElBQUgsQ0FBUTFDLElBQVIsRUFBYyxDQUFDVixHQUFELEVBQU1DLE1BQU4sS0FBaUI7QUFDN0IsVUFBSUQsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkosUUFBQUEsT0FBTyxDQUFDSyxNQUFELENBQVA7QUFDRCxPQUZELE1BRU87QUFDTEosUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDs7QUFFRCxTQUFTb0csT0FBVCxDQUFpQjVDLE1BQWpCLEVBQWlDQyxJQUFqQyxFQUErQzRDLElBQS9DLEVBQTZFO0FBQzNFLFNBQU8sSUFBSTFHLE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHOEYsT0FBSCxDQUFXNUMsTUFBWCxFQUFtQkMsSUFBbkIsRUFBeUI0QyxJQUF6QixFQUErQixDQUFDckcsR0FBRCxFQUFNQyxNQUFOLEtBQWlCO0FBQzlDLFVBQUlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU8sQ0FBQ0ssTUFBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xKLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsZUFBZXNHLFNBQWYsQ0FBeUJDLElBQXpCLEVBQXVDQyxRQUF2QyxFQUEwRTtBQUN4RSxNQUFJQSxRQUFRLElBQUksQ0FBaEIsRUFBbUI7QUFDakIsVUFBTSxJQUFJbkIsS0FBSixDQUFVLGdDQUFWLENBQU47QUFDRCxHQUh1RSxDQUt4RTs7O0FBQ0EsUUFBTTtBQUFDb0IsSUFBQUEsSUFBSSxFQUFFQztBQUFQLE1BQW9CLE1BQU10RCxJQUFJLENBQUNtRCxJQUFELENBQXBDOztBQUVBLE1BQUlHLFNBQVMsR0FBR0YsUUFBaEIsRUFBMEI7QUFDeEIsVUFBTWhHLEVBQUUsR0FBRyxNQUFNSixJQUFJLENBQUNtRyxJQUFELEVBQU8sR0FBUCxDQUFyQjtBQUNBLFVBQU1kLE1BQU0sR0FBR2tCLE1BQU0sQ0FBQ0MsS0FBUCxDQUFhSixRQUFiLENBQWY7QUFDQSxVQUFNWCxTQUFTLEdBQUcsTUFBTUwsSUFBSSxDQUMxQmhGLEVBRDBCLEVBRTFCaUYsTUFGMEIsRUFHMUIsQ0FIMEIsRUFHdkI7QUFDSGUsSUFBQUEsUUFKMEIsRUFJaEI7QUFDVkUsSUFBQUEsU0FBUyxHQUFHRixRQUxjLENBS0o7QUFMSSxLQUE1QjtBQU9BLFVBQU1qRyxLQUFLLENBQUNDLEVBQUQsQ0FBWDtBQUVBO0FBQ0o7QUFDQTtBQUNBOztBQUNJLFFBQUlxRixTQUFTLEtBQUtXLFFBQWxCLEVBQTRCO0FBQzFCLFlBQU0sSUFBSW5CLEtBQUosQ0FDSCx5Q0FBd0NtQixRQUFTLGFBQWxELEdBQ0csYUFBWVgsU0FBVSxRQUZyQixDQUFOO0FBSUQ7O0FBQ0QsV0FBT0osTUFBUDtBQUNELEdBdkJELE1BdUJPO0FBQ0wsV0FBT0ssUUFBUSxDQUFDUyxJQUFELENBQWY7QUFDRDtBQUNGOztBQUVELFNBQVN6QixNQUFULENBQWdCcEUsSUFBaEIsRUFBNkM7QUFDM0MsU0FBTyxJQUFJZixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBR3dFLE1BQUgsQ0FBVXBFLElBQVYsRUFBZ0IsQ0FBQ1YsR0FBRCxFQUFNQyxNQUFOLEtBQWlCO0FBQy9CLFVBQUlELEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU8sQ0FBQ0ssTUFBRCxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0xKLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsU0FBUzZHLE1BQVQsQ0FDRW5HLElBREYsRUFFRW9HLEtBRkYsRUFHRUMsS0FIRixFQUlpQjtBQUNmLFNBQU8sSUFBSXBILE9BQUosQ0FBWSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDdENTLGdCQUFHdUcsTUFBSCxDQUFVbkcsSUFBVixFQUFnQm9HLEtBQWhCLEVBQXVCQyxLQUF2QixFQUE4Qi9HLEdBQUcsSUFBSTtBQUNuQyxVQUFJQSxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmSixRQUFBQSxPQUFPO0FBQ1IsT0FGRCxNQUVPO0FBQ0xDLFFBQUFBLE1BQU0sQ0FBQ0csR0FBRCxDQUFOO0FBQ0Q7QUFDRixLQU5EO0FBT0QsR0FSTSxDQUFQO0FBU0Q7O0FBRUQsU0FBU2dILEtBQVQsQ0FBZXRHLElBQWYsRUFBNEM7QUFDMUMsU0FBTyxJQUFJZixPQUFKLENBQVksQ0FBQ0MsT0FBRCxFQUFVQyxNQUFWLEtBQXFCO0FBQ3RDUyxnQkFBRzBHLEtBQUgsQ0FBU3RHLElBQVQsRUFBZVYsR0FBRyxJQUFJO0FBQ3BCLFVBQUlBLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZKLFFBQUFBLE9BQU87QUFDUixPQUZELE1BRU87QUFDTEMsUUFBQUEsTUFBTSxDQUFDRyxHQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7QUFPRCxHQVJNLENBQVA7QUFTRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGVBQWVpSCxhQUFmLENBQTZCaEYsUUFBN0IsRUFBZ0U7QUFDOUQsTUFBSWxCLG9CQUFXbUcsUUFBWCxDQUFvQmpGLFFBQXBCLENBQUosRUFBbUM7QUFDakMsVUFBTSxJQUFJb0QsS0FBSixDQUFVLGlEQUFWLENBQU47QUFDRDs7QUFDRCxRQUFNOEIsUUFBUSxHQUFHcEcsb0JBQVduQixPQUFYLENBQW1CcUMsUUFBbkIsQ0FBakI7O0FBQ0EsTUFBSXZDLE1BQU0sR0FBR3lILFFBQWI7QUFDQSxNQUFJQyxNQUFNLEdBQUcsSUFBYjs7QUFDQSxTQUFPLElBQVAsRUFBYTtBQUNYLFFBQUk7QUFDRjtBQUNBLFlBQU14QyxRQUFRLEdBQUcsTUFBTW5ELFFBQVEsQ0FBQy9CLE1BQUQsQ0FBL0I7QUFDQSxhQUFPMEgsTUFBTSxJQUFJLElBQVYsR0FBaUJ4QyxRQUFqQixHQUE0QjdELG9CQUFXRSxJQUFYLENBQWdCMkQsUUFBaEIsRUFBMEJ3QyxNQUExQixDQUFuQztBQUNELEtBSkQsQ0FJRSxPQUFPcEgsR0FBUCxFQUFZO0FBQ1osVUFBSUEsR0FBRyxDQUFDcUUsSUFBSixLQUFhLFFBQWpCLEVBQTJCO0FBQ3pCLGNBQU1yRSxHQUFOO0FBQ0Q7O0FBQ0QsWUFBTXFILFFBQVEsR0FBR3RHLG9CQUFXc0csUUFBWCxDQUFvQjNILE1BQXBCLENBQWpCOztBQUNBLFVBQUkySCxRQUFRLEtBQUssRUFBakIsRUFBcUI7QUFDbkI7QUFDQTtBQUNEOztBQUNERCxNQUFBQSxNQUFNLEdBQUdBLE1BQU0sSUFBSSxJQUFWLEdBQWlCQyxRQUFqQixHQUE0QnRHLG9CQUFXRSxJQUFYLENBQWdCb0csUUFBaEIsRUFBMEJELE1BQTFCLENBQXJDO0FBQ0ExSCxNQUFBQSxNQUFNLEdBQUdxQixvQkFBV00sT0FBWCxDQUFtQjNCLE1BQW5CLENBQVQ7QUFDRDtBQUNGOztBQUNELFNBQU95SCxRQUFQO0FBQ0Q7O2VBRWM7QUFDYjFILEVBQUFBLE9BRGE7QUFFYlMsRUFBQUEsUUFGYTtBQUdiUyxFQUFBQSxlQUhhO0FBSWJnQixFQUFBQSxnQkFKYTtBQUtiRSxFQUFBQSwwQkFMYTtBQU1iVixFQUFBQSxNQU5hO0FBT2JnQixFQUFBQSxNQVBhO0FBUWJtRixFQUFBQSxNQUFNLEVBQUVqRixhQVJLO0FBU2JRLEVBQUFBLEtBVGE7QUFVYkMsRUFBQUEsTUFWYTtBQVdiQyxFQUFBQSxJQVhhO0FBWWJFLEVBQUFBLGlCQVphO0FBY2JNLEVBQUFBLElBZGE7QUFlYkksRUFBQUEsbUJBZmE7QUFnQmJZLEVBQUFBLFNBaEJhO0FBaUJiRyxFQUFBQSxlQWpCYTtBQW1CYk4sRUFBQUEsS0FuQmE7QUFvQmJGLEVBQUFBLEtBcEJhO0FBcUJiM0QsRUFBQUEsS0FyQmE7QUFzQmJ3RSxFQUFBQSxLQXRCYTtBQXVCYkMsRUFBQUEsS0F2QmE7QUF3QmJDLEVBQUFBLFNBeEJhO0FBeUJiRSxFQUFBQSxLQXpCYTtBQTBCYnBGLEVBQUFBLEtBMUJhO0FBMkJiOEUsRUFBQUEsRUEzQmE7QUE0QmJ6RSxFQUFBQSxJQTVCYTtBQTZCYm9GLEVBQUFBLElBN0JhO0FBOEJiTSxFQUFBQSxRQTlCYTtBQStCYkUsRUFBQUEsT0EvQmE7QUFnQ2JDLEVBQUFBLFFBaENhO0FBaUNieEUsRUFBQUEsUUFqQ2E7QUFrQ2IyQixFQUFBQSxJQWxDYTtBQW1DYmdELEVBQUFBLE9BbkNhO0FBb0NiRSxFQUFBQSxTQXBDYTtBQXFDYnhCLEVBQUFBLE1BckNhO0FBc0NiK0IsRUFBQUEsTUF0Q2E7QUF1Q2JHLEVBQUFBLEtBdkNhO0FBd0NiYixFQUFBQSxNQXhDYTtBQTBDYjdFLEVBQUFBLHdCQTFDYTtBQTJDYkUsRUFBQUEsZUEzQ2E7QUE0Q2J5RixFQUFBQTtBQTVDYSxDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IGZzUGx1cyBmcm9tICdmcy1wbHVzJztcclxuaW1wb3J0IGdsb2JMaWIgZnJvbSAnZ2xvYic7XHJcbmltcG9ydCBta2RpcnBMaWIgZnJvbSAnbWtkaXJwJztcclxuaW1wb3J0IG12TGliIGZyb20gJ212JztcclxuaW1wb3J0IHJpbXJhZiBmcm9tICdyaW1yYWYnO1xyXG5pbXBvcnQgdGVtcCBmcm9tICd0ZW1wJztcclxuXHJcbmltcG9ydCBudWNsaWRlVXJpIGZyb20gJy4vbnVjbGlkZVVyaSc7XHJcbmltcG9ydCB7cnVuQ29tbWFuZH0gZnJvbSAnLi9wcm9jZXNzJztcclxuXHJcbnR5cGUgV3JpdGVPcHRpb25zID0ge1xyXG4gIGVuY29kaW5nPzogc3RyaW5nLFxyXG4gIG1vZGU/OiBudW1iZXIsXHJcbiAgZmxhZz86IHN0cmluZyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgYSB0ZW1wIGRpcmVjdG9yeSB3aXRoIGdpdmVuIHByZWZpeC4gVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgY2xlYW5pbmcgdXAgdGhlXHJcbiAqICAgZHJlY3RvcnkuXHJcbiAqIEBwYXJhbSBwcmVmaXggb3B0aW5hbCBwcmVmaXggZm9yIHRoZSB0ZW1wIGRpcmVjdG9yeSBuYW1lLlxyXG4gKiBAcmV0dXJuIHBhdGggdG8gYSB0ZW1wb3JhcnkgZGlyZWN0b3J5LlxyXG4gKi9cclxuZnVuY3Rpb24gdGVtcGRpcihwcmVmaXg6IHN0cmluZyA9ICcnKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgdGVtcC5ta2RpcihwcmVmaXgsIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICBpZiAoZXJyID09IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQHJldHVybiBwYXRoIHRvIGEgdGVtcG9yYXJ5IGZpbGUuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIGNsZWFuaW5nIHVwXHJcbiAqICAgICB0aGUgZmlsZS5cclxuICovXHJcbmZ1bmN0aW9uIHRlbXBmaWxlKG9wdGlvbnM6IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIHRlbXAub3BlbihvcHRpb25zLCAoZXJyLCBpbmZvKSA9PiB7XHJcbiAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmcy5jbG9zZShpbmZvLmZkLCBjbG9zZUVyciA9PiB7XHJcbiAgICAgICAgICBpZiAoY2xvc2VFcnIpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGNsb3NlRXJyKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoaW5mby5wYXRoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWFyY2hlcyB1cHdhcmQgdGhyb3VnaCB0aGUgZmlsZXN5c3RlbSBmcm9tIHBhdGhUb0RpcmVjdG9yeSB0byBmaW5kIGEgZmlsZSB3aXRoXHJcbiAqIGZpbGVOYW1lLlxyXG4gKiBAcGFyYW0gZmlsZU5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZmluZC5cclxuICogQHBhcmFtIHBhdGhUb0RpcmVjdG9yeSBXaGVyZSB0byBiZWdpbiB0aGUgc2VhcmNoLiBNdXN0IGJlIGEgcGF0aCB0byBhIGRpcmVjdG9yeSxcclxuICogICBub3QgYSBmaWxlLlxyXG4gKiBAcmV0dXJuIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBuZWFyZXN0IGZpbGUgb3IgbnVsbC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGZpbmROZWFyZXN0RmlsZShcclxuICBmaWxlTmFtZTogc3RyaW5nLFxyXG4gIHBhdGhUb0RpcmVjdG9yeTogc3RyaW5nLFxyXG4pOiBQcm9taXNlPD9zdHJpbmc+IHtcclxuICAvLyBUT0RPKDU1ODYzNTUpOiBJZiB0aGlzIGJlY29tZXMgYSBib3R0bGVuZWNrLCB3ZSBzaG91bGQgY29uc2lkZXIgbWVtb2l6aW5nXHJcbiAgLy8gdGhpcyBmdW5jdGlvbi4gVGhlIGRvd25zaWRlIHdvdWxkIGJlIHRoYXQgaWYgc29tZW9uZSBhZGRlZCBhIGNsb3NlciBmaWxlXHJcbiAgLy8gd2l0aCBmaWxlTmFtZSB0byBwYXRoVG9GaWxlIChvciBkZWxldGVkIHRoZSBvbmUgdGhhdCB3YXMgY2FjaGVkKSwgdGhlbiB3ZVxyXG4gIC8vIHdvdWxkIGhhdmUgYSBidWcuIFRoaXMgd291bGQgcHJvYmFibHkgYmUgcHJldHR5IHJhcmUsIHRob3VnaC5cclxuICBsZXQgY3VycmVudFBhdGggPSBudWNsaWRlVXJpLnJlc29sdmUocGF0aFRvRGlyZWN0b3J5KTtcclxuICBmb3IgKDs7KSB7XHJcbiAgICBjb25zdCBmaWxlVG9GaW5kID0gbnVjbGlkZVVyaS5qb2luKGN1cnJlbnRQYXRoLCBmaWxlTmFtZSk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxyXG4gICAgY29uc3QgaGFzRmlsZSA9IGF3YWl0IGV4aXN0cyhmaWxlVG9GaW5kKTtcclxuICAgIGlmIChoYXNGaWxlKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50UGF0aDtcclxuICAgIH1cclxuICAgIGlmIChudWNsaWRlVXJpLmlzUm9vdChjdXJyZW50UGF0aCkpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50UGF0aCA9IG51Y2xpZGVVcmkuZGlybmFtZShjdXJyZW50UGF0aCk7XHJcbiAgfVxyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBmaW5kTmVhcmVzdEFuY2VzdG9yTmFtZWQoXHJcbiAgZmlsZU5hbWU6IHN0cmluZyxcclxuICBwYXRoVG9EaXJlY3Rvcnk6IHN0cmluZyxcclxuKTogUHJvbWlzZTw/c3RyaW5nPiB7XHJcbiAgY29uc3QgZGlyZWN0b3J5ID0gYXdhaXQgZmluZE5lYXJlc3RGaWxlKGZpbGVOYW1lLCBwYXRoVG9EaXJlY3RvcnkpO1xyXG4gIGlmIChkaXJlY3RvcnkgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG51Y2xpZGVVcmkuam9pbihkaXJlY3RvcnksIGZpbGVOYW1lKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXNvbHZlUmVhbFBhdGgocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICByZXR1cm4gcmVhbHBhdGgobnVjbGlkZVVyaS5leHBhbmRIb21lRGlyKHBhdGgpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIHVwd2FyZCB0aHJvdWdoIHRoZSBmaWxlc3lzdGVtIGZyb20gcGF0aFRvRGlyZWN0b3J5IHRvIGZpbmQgdGhlIGZ1cnRoZXN0XHJcbiAqIGZpbGUgd2l0aCBmaWxlTmFtZS5cclxuICogQHBhcmFtIGZpbGVOYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGZpbmQuXHJcbiAqIEBwYXJhbSBwYXRoVG9EaXJlY3RvcnkgV2hlcmUgdG8gYmVnaW4gdGhlIHNlYXJjaC4gTXVzdCBiZSBhIHBhdGggdG8gYSBkaXJlY3RvcnksXHJcbiAqICAgbm90IGEgZmlsZS5cclxuICogQHBhcmFtIHN0b3BPbk1pc3NpbmcgU3RvcCBzZWFyY2hpbmcgd2hlbiB3ZSByZWFjaCBhIGRpcmVjdG9yeSB3aXRob3V0IGZpbGVOYW1lLlxyXG4gKiBAcmV0dXJuIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBmdXJ0aGVzdCBmaWxlIG9yIG51bGwuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBmaW5kRnVydGhlc3RGaWxlKFxyXG4gIGZpbGVOYW1lOiBzdHJpbmcsXHJcbiAgcGF0aFRvRGlyZWN0b3J5OiBzdHJpbmcsXHJcbiAgc3RvcE9uTWlzc2luZzogYm9vbGVhbiA9IGZhbHNlLFxyXG4pOiBQcm9taXNlPD9zdHJpbmc+IHtcclxuICBsZXQgY3VycmVudFBhdGggPSBudWNsaWRlVXJpLnJlc29sdmUocGF0aFRvRGlyZWN0b3J5KTtcclxuICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICBmb3IgKDs7KSB7XHJcbiAgICBjb25zdCBmaWxlVG9GaW5kID0gbnVjbGlkZVVyaS5qb2luKGN1cnJlbnRQYXRoLCBmaWxlTmFtZSk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxyXG4gICAgY29uc3QgaGFzRmlsZSA9IGF3YWl0IGV4aXN0cyhmaWxlVG9GaW5kKTtcclxuICAgIGlmICgoIWhhc0ZpbGUgJiYgc3RvcE9uTWlzc2luZykgfHwgbnVjbGlkZVVyaS5pc1Jvb3QoY3VycmVudFBhdGgpKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9IGVsc2UgaWYgKGhhc0ZpbGUpIHtcclxuICAgICAgcmVzdWx0ID0gY3VycmVudFBhdGg7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50UGF0aCA9IG51Y2xpZGVVcmkuZGlybmFtZShjdXJyZW50UGF0aCk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb21tb25BbmNlc3RvckRpcmVjdG9yeShmaWxlUGF0aHM6IEFycmF5PHN0cmluZz4pOiBzdHJpbmcge1xyXG4gIGxldCBjb21tb25EaXJlY3RvcnlQYXRoID0gbnVjbGlkZVVyaS5kaXJuYW1lKGZpbGVQYXRoc1swXSk7XHJcbiAgd2hpbGUgKFxyXG4gICAgZmlsZVBhdGhzLnNvbWUoZmlsZVBhdGggPT4gIWZpbGVQYXRoLnN0YXJ0c1dpdGgoY29tbW9uRGlyZWN0b3J5UGF0aCkpXHJcbiAgKSB7XHJcbiAgICBjb21tb25EaXJlY3RvcnlQYXRoID0gbnVjbGlkZVVyaS5kaXJuYW1lKGNvbW1vbkRpcmVjdG9yeVBhdGgpO1xyXG4gIH1cclxuICByZXR1cm4gY29tbW9uRGlyZWN0b3J5UGF0aDtcclxufVxyXG5cclxuZnVuY3Rpb24gZXhpc3RzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnMuZXhpc3RzKGZpbGVQYXRoLCByZXNvbHZlKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJ1bnMgdGhlIGVxdWl2YWxlbnQgb2YgYG1rZGlyIC1wYCB3aXRoIHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKiBMaWtlIG1vc3QgaW1wbGVtZW50YXRpb25zIG9mIG1rZGlycCwgaWYgaXQgZmFpbHMsIGl0IGlzIHBvc3NpYmxlIHRoYXRcclxuICogZGlyZWN0b3JpZXMgd2VyZSBjcmVhdGVkIGZvciBzb21lIHByZWZpeCBvZiB0aGUgZ2l2ZW4gcGF0aC5cclxuICogQHJldHVybiB0cnVlIGlmIHRoZSBwYXRoIHdhcyBjcmVhdGVkOyBmYWxzZSBpZiBpdCBhbHJlYWR5IGV4aXN0ZWQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBta2RpcnAoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIGNvbnN0IGlzRXhpc3RpbmdEaXJlY3RvcnkgPSBhd2FpdCBleGlzdHMoZmlsZVBhdGgpO1xyXG4gIGlmIChpc0V4aXN0aW5nRGlyZWN0b3J5KSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IG1rZGlycExpYihmaWxlUGF0aCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGRpcmVjdG9yaWVzIGV2ZW4gaWYgdGhleSBhcmUgbm9uLWVtcHR5LiBEb2VzIG5vdCBmYWlsIGlmIHRoZSBkaXJlY3RvcnkgZG9lc24ndCBleGlzdC5cclxuICovXHJcbmZ1bmN0aW9uIHJpbXJhZldyYXBwZXIoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICByaW1yYWYoZmlsZVBhdGgsIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICBpZiAoZXJyID09IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRGaWxlU3lzdGVtVHlwZShlbnRpdHlQYXRoOiBzdHJpbmcpOiBQcm9taXNlPD9zdHJpbmc+IHtcclxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3Rkb3V0ID0gYXdhaXQgcnVuQ29tbWFuZCgnc3RhdCcsIFtcclxuICAgICAgICAnLWYnLFxyXG4gICAgICAgICctTCcsXHJcbiAgICAgICAgJy1jJyxcclxuICAgICAgICAnJVQnLFxyXG4gICAgICAgIGVudGl0eVBhdGgsXHJcbiAgICAgIF0pLnRvUHJvbWlzZSgpO1xyXG4gICAgICByZXR1cm4gc3Rkb3V0LnRyaW0oKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgLy8gVE9ETyBIYW5kbGUgb3RoZXIgcGxhdGZvcm1zICh3aW5kb3dzPylcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqIEByZXR1cm4gdHJ1ZSBvbmx5IGlmIHdlIGFyZSBzdXJlIGVudGl0eVBhdGggaXMgb24gTkZTLiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpc05mcyhlbnRpdHlQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICByZXR1cm4gKGF3YWl0IGdldEZpbGVTeXN0ZW1UeXBlKGVudGl0eVBhdGgpKSA9PT0gJ25mcyc7XHJcbn1cclxuXHJcbi8qKiBAcmV0dXJuIHRydWUgb25seSBpZiB3ZSBhcmUgc3VyZSBlbnRpdHlQYXRoIGlzIG9uIGEgRnVzZSBmaWxlc3lzdGVtIGxpa2VcclxuICAgICAgICAgICAgZGV3ZXkgb3IgZ3Zmcy5cclxuKi9cclxuYXN5bmMgZnVuY3Rpb24gaXNGdXNlKGVudGl0eVBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHJldHVybiAoYXdhaXQgZ2V0RmlsZVN5c3RlbVR5cGUoZW50aXR5UGF0aCkpID09PSAnZnVzZWJsayc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdsb2IocGF0dGVybjogc3RyaW5nLCBvcHRpb25zPzogT2JqZWN0KTogUHJvbWlzZTxBcnJheTxzdHJpbmc+PiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGdsb2JMaWIocGF0dGVybiwgb3B0aW9ucywgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGlzTm9uTmZzRGlyZWN0b3J5KGRpcmVjdG9yeVBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHN0YXQoZGlyZWN0b3J5UGF0aCk7XHJcbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xyXG4gICAgICByZXR1cm4gIShhd2FpdCBpc05mcyhkaXJlY3RvcnlQYXRoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgLy8gSWYgdGhlIGRpcmVjdG9yeSBjYW5ub3QgYmUgcHJvYmVkIGZvciB3aGF0ZXZlciByZWFzb24sIGp1c3RcclxuICAgIC8vIGluZGljYXRlIHRoYXQgdGhpcyBpcyBub3QgYSB2YWxpZCBjYW5kaWRhdGUgZGlyZWN0b3J5LlxyXG4gICAgLy8gVHlwaWNhbGx5IHRoaXMgaXMgRU5PRU5UIGZvciBtaXNzaW5nIGRpcmVjdG9yeS5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm9taXNpZmllZCB3cmFwcGVycyBhcm91bmQgZnMtcGx1cyBmdW5jdGlvbnMuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY29weShzb3VyY2U6IHN0cmluZywgZGVzdDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzUGx1cy5jb3B5KHNvdXJjZSwgZGVzdCwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGNvcHlGaWxlUGVybWlzc2lvbnMoXHJcbiAgc291cmNlUGF0aDogc3RyaW5nLFxyXG4gIGRlc3RpbmF0aW9uUGF0aDogc3RyaW5nLFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qge21vZGUsIHVpZCwgZ2lkfSA9IGF3YWl0IHN0YXQoc291cmNlUGF0aCk7XHJcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgIC8vIFRoZSB1c2VyIG1heSBub3QgaGF2ZSBwZXJtaXNzaW9ucyB0byB1c2UgdGhlIHVpZC9naWQuXHJcbiAgICAgIGNob3duKGRlc3RpbmF0aW9uUGF0aCwgdWlkLCBnaWQpLmNhdGNoKCgpID0+IHt9KSxcclxuICAgICAgY2htb2QoZGVzdGluYXRpb25QYXRoLCBtb2RlKSxcclxuICAgIF0pO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vIElmIHRoZSBmaWxlIGRvZXMgbm90IGV4aXN0LCB0aGVuIEVOT0VOVCB3aWxsIGJlIHRocm93bi5cclxuICAgIGlmIChlLmNvZGUgIT09ICdFTk9FTlQnKSB7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcbiAgICAvLyBGb3IgbmV3IGZpbGVzLCB1c2UgdGhlIGRlZmF1bHQgcHJvY2VzcyBmaWxlIGNyZWF0aW9uIG1hc2suXHJcbiAgICBhd2FpdCBjaG1vZChcclxuICAgICAgZGVzdGluYXRpb25QYXRoLFxyXG4gICAgICAwbzY2NiAmIH5wcm9jZXNzLnVtYXNrKCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUT0RPOiB0aGUgZnMtcGx1cyBgd3JpdGVGaWxlYCBpbXBsZW1lbnRhdGlvbiBydW5zIGBta2RpcnBgIGZpcnN0LlxyXG4gKiBXZSBzaG91bGQgdXNlIGBmcy53cml0ZUZpbGVgIGFuZCBoYXZlIGNhbGxzaXRlcyBleHBsaWNpdGx5IG9wdC1pbiB0byB0aGlzIGJlaGF2aW91ci5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlRmlsZShcclxuICBmaWxlbmFtZTogc3RyaW5nLFxyXG4gIGRhdGE6IEJ1ZmZlciB8IHN0cmluZyxcclxuICBvcHRpb25zPzogV3JpdGVPcHRpb25zIHwgc3RyaW5nLFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnNQbHVzLndyaXRlRmlsZShmaWxlbmFtZSwgZGF0YSwgb3B0aW9ucywgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUF0b21pYyhcclxuICBwYXRoOiBzdHJpbmcsXHJcbiAgZGF0YTogQnVmZmVyIHwgc3RyaW5nLFxyXG4gIG9wdGlvbnM/OiBXcml0ZU9wdGlvbnMgfCBzdHJpbmcsXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IHRlbXBGaWxlUGF0aCA9IGF3YWl0IHRlbXBmaWxlKCdudWNsaWRlJyk7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IHdyaXRlRmlsZSh0ZW1wRmlsZVBhdGgsIGRhdGEsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIEV4cGFuZCB0aGUgdGFyZ2V0IHBhdGggaW4gY2FzZSBpdCBjb250YWlucyBzeW1saW5rcy5cclxuICAgIGxldCByZWFsUGF0aCA9IHBhdGg7XHJcbiAgICB0cnkge1xyXG4gICAgICByZWFsUGF0aCA9IGF3YWl0IHJlYWxwYXRoKHBhdGgpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBGYWxsYmFjayB0byB1c2luZyB0aGUgc3BlY2lmaWVkIHBhdGggaWYgaXQgY2Fubm90IGJlIGV4cGFuZGVkLlxyXG4gICAgICAvLyBOb3RlOiB0aGlzIGlzIGV4cGVjdGVkIGluIGNhc2VzIHdoZXJlIHRoZSByZW1vdGUgZmlsZSBkb2VzIG5vdFxyXG4gICAgICAvLyBhY3R1YWxseSBleGlzdC5cclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgZmlsZSBzdGlsbCBoYXMgb3JpZ2luYWwgcGVybWlzc2lvbnM6XHJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svbnVjbGlkZS9pc3N1ZXMvMTU3XHJcbiAgICAvLyBXZSB1cGRhdGUgdGhlIG1vZGUgb2YgdGhlIHRlbXAgZmlsZSByYXRoZXIgdGhhbiB0aGUgZGVzdGluYXRpb24gZmlsZSBiZWNhdXNlXHJcbiAgICAvLyBpZiB3ZSBkaWQgdGhlIG12KCkgdGhlbiB0aGUgY2htb2QoKSwgdGhlcmUgd291bGQgYmUgYSBicmllZiBwZXJpb2QgYmV0d2VlblxyXG4gICAgLy8gdGhvc2UgdHdvIG9wZXJhdGlvbnMgd2hlcmUgdGhlIGRlc3RpbmF0aW9uIGZpbGUgbWlnaHQgaGF2ZSB0aGUgd3JvbmcgcGVybWlzc2lvbnMuXHJcbiAgICBhd2FpdCBjb3B5RmlsZVBlcm1pc3Npb25zKHJlYWxQYXRoLCB0ZW1wRmlsZVBhdGgpO1xyXG5cclxuICAgIC8vIEVuc3VyZSBmaWxlIGhhcyBuZXcgcGVybWlzc2lvbnMgdXBkYXRlZC5cclxuICAgIGNvbnN0IG1vZGUgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ3N0cmluZycgPyBvcHRpb25zPy5tb2RlIDogbnVsbDtcclxuICAgIGlmIChtb2RlICE9IG51bGwpIHtcclxuICAgICAgYXdhaXQgY2htb2QodGVtcEZpbGVQYXRoLCBtb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPOiBwdXQgcmVuYW1lcyBpbnRvIGEgcXVldWUgc28gd2UgZG9uJ3Qgd3JpdGUgb2xkZXIgc2F2ZSBvdmVyIG5ldyBzYXZlLlxyXG4gICAgLy8gVXNlIG12IGFzIGZzLnJlbmFtZSBkb2Vzbid0IHdvcmsgYWNyb3NzIHBhcnRpdGlvbnMuXHJcbiAgICBhd2FpdCBtdih0ZW1wRmlsZVBhdGgsIHJlYWxQYXRoLCB7bWtkaXJwOiB0cnVlfSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBhd2FpdCB1bmxpbmsodGVtcEZpbGVQYXRoKTtcclxuICAgIHRocm93IGVycjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm9taXNpZmllZCB3cmFwcGVycyBhcm91bmQgZnMgZnVuY3Rpb25zLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIGNobW9kKHBhdGg6IHN0cmluZywgbW9kZTogbnVtYmVyIHwgc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLmNobW9kKHBhdGgsIG1vZGUsIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICBpZiAoZXJyID09IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaG93bihwYXRoOiBzdHJpbmcsIHVpZDogbnVtYmVyLCBnaWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBmcy5jaG93bihwYXRoLCB1aWQsIGdpZCwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb3NlKGZkOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnMuY2xvc2UoZmQsIGVyciA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZzdGF0KGZkOiBudW1iZXIpOiBQcm9taXNlPGZzLlN0YXRzPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLmZzdGF0KGZkLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZnN5bmMoZmQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBmcy5mc3luYyhmZCwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZ0cnVuY2F0ZShmZDogbnVtYmVyLCBsZW46IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBmcy5mdHJ1bmNhdGUoZmQsIGxlbiwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxzdGF0KHBhdGg6IHN0cmluZyk6IFByb21pc2U8ZnMuU3RhdHM+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnMubHN0YXQocGF0aCwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1rZGlyKHBhdGg6IHN0cmluZywgbW9kZT86IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBmcy5ta2RpcihwYXRoLCBtb2RlLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTXZPcHRpb25zID0ge1xyXG4gIC8vIFJ1biBta2RpcnAgZm9yIHRoZSBkaXJlY3RvcnkgZmlyc3QuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gIG1rZGlycD86IGJvb2xlYW4sXHJcbiAgLy8gT3ZlcndyaXRlIHRoZSBmaWxlIGlmIGl0IGV4aXN0cy4gRGVmYXVsdHMgdG8gdHJ1ZS5cclxuICBjbG9iYmVyPzogYm9vbGVhbixcclxuICAvLyBPcHRpb25hbDogdGhlIGNvbmN1cnJlbmN5IGxpbWl0IHdoZW4gbW92aW5nIGEgZGlyZWN0b3J5LlxyXG4gIGxpbWl0PzogbnVtYmVyLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBrZXkgZGlmZmVyZW5jZSBiZXR3ZWVuICdtdicgYW5kICdyZW5hbWUnIGlzIHRoYXQgJ212JyB3b3JrcyBhY3Jvc3MgZGV2aWNlcy5cclxuICogSXQncyBub3QgdW5jb21tb24gdG8gaGF2ZSB0ZW1wb3JhcnkgZmlsZXMgaW4gYSBkaWZmZXJlbnQgZGlzaywgZm9yIGluc3RhbmNlLlxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gbXYoXHJcbiAgc291cmNlUGF0aDogc3RyaW5nLFxyXG4gIGRlc3RpbmF0aW9uUGF0aDogc3RyaW5nLFxyXG4gIG9wdGlvbnM/OiBNdk9wdGlvbnMgPSB7fSxcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgLy8gbXYtbm9kZSBmYWlscyB0byBhY2NvdW50IGZvciB0aGUgY2FzZSB3aGVyZSBhIGRlc3RpbmF0aW9uIGRpcmVjdG9yeSBleGlzdHNcclxuICAvLyBhbmQgYGNsb2JiZXJgIGlzIGZhbHNlLiBUaGlzIGNhbiByZXN1bHQgaW4gdGhlIHNvdXJjZSBkaXJlY3RvcnkgZ2V0dGluZ1xyXG4gIC8vIGRlbGV0ZWQgYnV0IHRoZSBkZXN0aW5hdGlvbiBub3QgZ2V0dGluZyB3cml0dGVuLlxyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyZXdyay9ub2RlLW12L2lzc3Vlcy8zMFxyXG4gIGlmIChvcHRpb25zLmNsb2JiZXIgPT09IGZhbHNlICYmIChhd2FpdCBleGlzdHMoZGVzdGluYXRpb25QYXRoKSkpIHtcclxuICAgIGNvbnN0IGVycjogRXJybm9FcnJvciA9IG5ldyBFcnJvcignRGVzdGluYXRpb24gZmlsZSBleGlzdHMnKTtcclxuICAgIGVyci5jb2RlID0gJ0VFWElTVCc7XHJcbiAgICBlcnIucGF0aCA9IGRlc3RpbmF0aW9uUGF0aDtcclxuICAgIHRocm93IGVycjtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIG12TGliKHNvdXJjZVBhdGgsIGRlc3RpbmF0aW9uUGF0aCwgb3B0aW9ucywgZXJyb3IgPT4ge1xyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG9wZW4oXHJcbiAgcGF0aDogc3RyaW5nIHwgQnVmZmVyIHwgVVJMLFxyXG4gIGZsYWdzOiBzdHJpbmcgfCBudW1iZXIsXHJcbiAgbW9kZTogbnVtYmVyID0gMG82NjYsXHJcbik6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLm9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIChlcnIsIGZkKSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUoZmQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZChcclxuICBmZDogbnVtYmVyLFxyXG4gIGJ1ZmZlcjogQnVmZmVyLFxyXG4gIG9mZnNldDogbnVtYmVyLFxyXG4gIGxlbmd0aDogbnVtYmVyLFxyXG4gIHBvc2l0aW9uOiBudW1iZXIgfCBudWxsLFxyXG4pOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgKGVyciwgYnl0ZXNSZWFkKSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUoYnl0ZXNSZWFkKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIGBmcy5yZWFkRmlsZWAgcmV0dXJucyBhIEJ1ZmZlciB1bmxlc3MgYW4gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLlxyXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgYWRhcHRlZCBmcm9tIHRoZSBGbG93IGRlY2xhcmF0aW9ucy5cclxudHlwZSBSZWFkRmlsZVR5cGUgPSAoKGZpbGVuYW1lOiBzdHJpbmcsIGVuY29kaW5nOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPikgJlxyXG4gICgoXHJcbiAgICBmaWxlbmFtZTogc3RyaW5nLFxyXG4gICAgb3B0aW9uczoge2VuY29kaW5nOiBzdHJpbmcsIGZsYWc/OiBzdHJpbmd9LFxyXG4gICkgPT4gUHJvbWlzZTxzdHJpbmc+KSAmXHJcbiAgKChmaWxlbmFtZTogc3RyaW5nLCBvcHRpb25zPzoge2ZsYWc/OiBzdHJpbmd9KSA9PiBQcm9taXNlPEJ1ZmZlcj4pO1xyXG5cclxuY29uc3QgcmVhZEZpbGU6IFJlYWRGaWxlVHlwZSA9IChmdW5jdGlvbiguLi5hcmdzOiBBcnJheTxhbnk+KSB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIC8vICRGbG93SXNzdWU6IHNwcmVhZCBvcGVyYXRvciBkb2Vzbid0IHByZXNlcnZlIGFueS10eXBlXHJcbiAgICBmcy5yZWFkRmlsZSguLi5hcmdzLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufTogYW55KTtcclxuXHJcbmZ1bmN0aW9uIHJlYWRkaXIocGF0aDogc3RyaW5nKTogUHJvbWlzZTxBcnJheTxzdHJpbmc+PiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLnJlYWRkaXIocGF0aCwgKGVyciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRsaW5rKHBhdGg6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLnJlYWRsaW5rKHBhdGgsIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICBpZiAoZXJyID09IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFscGF0aChwYXRoOiBzdHJpbmcsIGNhY2hlPzogT2JqZWN0KTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnMucmVhbHBhdGgocGF0aCwgY2FjaGUsIChlcnIsIHJlc3VsdCkgPT4ge1xyXG4gICAgICBpZiAoZXJyID09IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhY2Nlc3MocGF0aDogc3RyaW5nLCBtb2RlOiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnMuYWNjZXNzKHBhdGgsIG1vZGUsIGVyciA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGF0KHBhdGg6IHN0cmluZyk6IFByb21pc2U8ZnMuU3RhdHM+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgZnMuc3RhdChwYXRoLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3ltbGluayhzb3VyY2U6IHN0cmluZywgZGVzdDogc3RyaW5nLCB0eXBlPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLnN5bWxpbmsoc291cmNlLCBkZXN0LCB0eXBlLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBncmFiIHRoZSBsYXN0IE4gYnl0ZXMgZnJvbSBhIGZpbGUuIEF0dGVtcHRzIHRvIGRvIHNvXHJcbiAqIHdpdGhvdXQgcmVhZGluZyB0aGUgZW50aXJlIGZpbGUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiB0YWlsQnl0ZXMoZmlsZTogc3RyaW5nLCBtYXhCeXRlczogbnVtYmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcclxuICBpZiAobWF4Qnl0ZXMgPD0gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCd0YWlsYnl0ZXMgZXhwZWN0cyBtYXhCeXRlcyA+IDAnKTtcclxuICB9XHJcblxyXG4gIC8vIEZpZ3VyZSBvdXQgdGhlIHNpemUgc28gd2Uga25vdyB3aGF0IHN0cmF0ZWd5IHRvIHVzZVxyXG4gIGNvbnN0IHtzaXplOiBmaWxlX3NpemV9ID0gYXdhaXQgc3RhdChmaWxlKTtcclxuXHJcbiAgaWYgKGZpbGVfc2l6ZSA+IG1heEJ5dGVzKSB7XHJcbiAgICBjb25zdCBmZCA9IGF3YWl0IG9wZW4oZmlsZSwgJ3InKTtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhtYXhCeXRlcyk7XHJcbiAgICBjb25zdCBieXRlc1JlYWQgPSBhd2FpdCByZWFkKFxyXG4gICAgICBmZCxcclxuICAgICAgYnVmZmVyLFxyXG4gICAgICAwLCAvLyBidWZmZXIgb2Zmc2V0XHJcbiAgICAgIG1heEJ5dGVzLCAvLyBsZW5ndGggdG8gcmVhZFxyXG4gICAgICBmaWxlX3NpemUgLSBtYXhCeXRlcywgLy8gZmlsZSBvZmZzZXRcclxuICAgICk7XHJcbiAgICBhd2FpdCBjbG9zZShmZCk7XHJcblxyXG4gICAgLyogSWYgd2UgbWVhbnQgdG8gcmVhZCB0aGUgbGFzdCAxMDAgYnl0ZXMgYnV0IG9ubHkgcmVhZCA1MCBieXRlcywgdGhlbiB3ZSd2ZVxyXG4gICAgICogZmFpbGVkIHRvIHJlYWQgdGhlIGxhc3QgMTAwIGJ5dGVzLiBTbyB0aHJvdy4gSW4gdGhlIGZ1dHVyZSwgc29tZW9uZVxyXG4gICAgICogY291bGQgdXBkYXRlIHRoaXMgY29kZSB0byBrZWVwIGNhbGxpbmcgYHJlYWRgIHVudGlsIHdlIHJlYWQgbWF4Qnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGlmIChieXRlc1JlYWQgIT09IG1heEJ5dGVzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgRmFpbGVkIHRvIHRhaWwgZmlsZS4gSW50ZW5kZWQgdG8gcmVhZCAke21heEJ5dGVzfSBieXRlcyBidXQgYCArXHJcbiAgICAgICAgICBgb25seSByZWFkICR7Ynl0ZXNSZWFkfSBieXRlc2AsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gcmVhZEZpbGUoZmlsZSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1bmxpbmsocGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLnVubGluayhwYXRoLCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgaWYgKGVyciA9PSBudWxsKSB7XHJcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gdXRpbWVzKFxyXG4gIHBhdGg6IHN0cmluZyxcclxuICBhdGltZTogbnVtYmVyIHwgRGF0ZSxcclxuICBtdGltZTogbnVtYmVyIHwgRGF0ZSxcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGZzLnV0aW1lcyhwYXRoLCBhdGltZSwgbXRpbWUsIGVyciA9PiB7XHJcbiAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJtZGlyKHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBmcy5ybWRpcihwYXRoLCBlcnIgPT4ge1xyXG4gICAgICBpZiAoZXJyID09IG51bGwpIHtcclxuICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSB0aGUgcGh5c2ljYWwgcGF0aCBvZiB0aGUgZmlsZW5hbWUuXHJcbiAqIFNvbWV0aW1lcyBmaWxlUGF0aCBtYXkgbm90IGV4aXN0IHlldCwgaW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvIGxvb2sgdXB3YXJkc1xyXG4gKiBmb3IgdGhlIGZpcnN0IHByZWZpeCB0aGF0IGFjdHVhbGx5IGRvZXMgZXhpc3QuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBndWVzc1JlYWxQYXRoKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGlmIChudWNsaWRlVXJpLmlzUmVtb3RlKGZpbGVQYXRoKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGxvY2FsIHBhdGhzIGNhbiBiZSB1c2VkIHdpdGggZ3Vlc3NSZWFsUGF0aCcpO1xyXG4gIH1cclxuICBjb25zdCByZXNvbHZlZCA9IG51Y2xpZGVVcmkucmVzb2x2ZShmaWxlUGF0aCk7XHJcbiAgbGV0IHByZWZpeCA9IHJlc29sdmVkO1xyXG4gIGxldCBzdWZmaXggPSBudWxsO1xyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYXdhaXQtaW4tbG9vcFxyXG4gICAgICBjb25zdCByZWFsUGF0aCA9IGF3YWl0IHJlYWxwYXRoKHByZWZpeCk7XHJcbiAgICAgIHJldHVybiBzdWZmaXggPT0gbnVsbCA/IHJlYWxQYXRoIDogbnVjbGlkZVVyaS5qb2luKHJlYWxQYXRoLCBzdWZmaXgpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGlmIChlcnIuY29kZSAhPT0gJ0VOT0VOVCcpIHtcclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYmFzZW5hbWUgPSBudWNsaWRlVXJpLmJhc2VuYW1lKHByZWZpeCk7XHJcbiAgICAgIGlmIChiYXNlbmFtZSA9PT0gJycpIHtcclxuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBmaWxlc3lzdGVtIHJvb3QuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgc3VmZml4ID0gc3VmZml4ID09IG51bGwgPyBiYXNlbmFtZSA6IG51Y2xpZGVVcmkuam9pbihiYXNlbmFtZSwgc3VmZml4KTtcclxuICAgICAgcHJlZml4ID0gbnVjbGlkZVVyaS5kaXJuYW1lKHByZWZpeCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXNvbHZlZDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHRlbXBkaXIsXHJcbiAgdGVtcGZpbGUsXHJcbiAgZmluZE5lYXJlc3RGaWxlLFxyXG4gIGZpbmRGdXJ0aGVzdEZpbGUsXHJcbiAgZ2V0Q29tbW9uQW5jZXN0b3JEaXJlY3RvcnksXHJcbiAgZXhpc3RzLFxyXG4gIG1rZGlycCxcclxuICByaW1yYWY6IHJpbXJhZldyYXBwZXIsXHJcbiAgaXNOZnMsXHJcbiAgaXNGdXNlLFxyXG4gIGdsb2IsXHJcbiAgaXNOb25OZnNEaXJlY3RvcnksXHJcblxyXG4gIGNvcHksXHJcbiAgY29weUZpbGVQZXJtaXNzaW9ucyxcclxuICB3cml0ZUZpbGUsXHJcbiAgd3JpdGVGaWxlQXRvbWljLFxyXG5cclxuICBjaG1vZCxcclxuICBjaG93bixcclxuICBjbG9zZSxcclxuICBmc3RhdCxcclxuICBmc3luYyxcclxuICBmdHJ1bmNhdGUsXHJcbiAgbHN0YXQsXHJcbiAgbWtkaXIsXHJcbiAgbXYsXHJcbiAgb3BlbixcclxuICByZWFkLFxyXG4gIHJlYWRGaWxlLFxyXG4gIHJlYWRkaXIsXHJcbiAgcmVhZGxpbmssXHJcbiAgcmVhbHBhdGgsXHJcbiAgc3RhdCxcclxuICBzeW1saW5rLFxyXG4gIHRhaWxCeXRlcyxcclxuICB1bmxpbmssXHJcbiAgdXRpbWVzLFxyXG4gIHJtZGlyLFxyXG4gIGFjY2VzcyxcclxuXHJcbiAgZmluZE5lYXJlc3RBbmNlc3Rvck5hbWVkLFxyXG4gIHJlc29sdmVSZWFsUGF0aCxcclxuICBndWVzc1JlYWxQYXRoLFxyXG59O1xyXG4iXX0=