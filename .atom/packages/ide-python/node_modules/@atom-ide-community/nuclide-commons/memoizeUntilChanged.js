"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _collection = require("./collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Create a memoized version of the provided function that caches only the latest result. This is
 * especially useful for optimizing React component methods without having to worry about
 * maintaining state explicitly. For example:
 *
 *     class MyComponent extends React.Component {
 *       constructor(props) {
 *         super(props);
 *         this._computeSomethingExpensive = memoizeUntilChanged(this._computeSomethingExpensive);
 *       }
 *       _computeSomethingExpensive(x) { ... }
 *       render() {
 *         const thingToRender = this._computeSomethingExpensive(this.props.value);
 *         return <div>{thingToRender}</div>;
 *       }
 *     }
 *
 * Sometimes, you need to customize how the arguments are compared. In this case you can pass a
 * key selector function (which derives a single value from the arguments), and an equality function
 * (which compares keys). For example:
 *
 *     class MyComponent extends React.Component {
 *       constructor(props) {
 *         super(props);
 *         this._computeSomethingExpensive = memoizeUntilChanged(
 *           this._computeSomethingExpensive,
 *           (x: Array<Object>, y: Array<Object>) => ({x, y}),
 *           (a, b) => arrayEqual(a.x, b.x) && arrayEqual(a.y, b.y),
 *         );
 *       }
 *       _computeSomethingExpensive(x: Array<Object>, y: Array<Object>) { ... }
 *       render() {
 *         const thingToRender = this._computeSomethingExpensive(this.props.value);
 *         return <div>{thingToRender}</div>;
 *       }
 *     }
 */
var _default = (func, keySelector_, compareKeys_) => {
  (0, _assert.default)(!(keySelector_ == null && compareKeys_ != null), "You can't provide a compare function without also providing a key selector.");
  let prevKey = null;
  let prevResult;
  const keySelector = keySelector_ || DEFAULT_KEY_SELECTOR;
  const compareKeys = compareKeys_ || _collection.arrayEqual;
  return function (...args) {
    const key = keySelector(...args);
    (0, _assert.default)(key != null, 'Key cannot be null');

    if (prevKey == null || !compareKeys(key, prevKey)) {
      prevKey = key;
      prevResult = func.apply(this, args);
    }

    return prevResult;
  };
};

exports.default = _default;

const DEFAULT_KEY_SELECTOR = (...args) => args;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL21lbW9pemVVbnRpbENoYW5nZWQuanMiXSwibmFtZXMiOlsiZnVuYyIsImtleVNlbGVjdG9yXyIsImNvbXBhcmVLZXlzXyIsInByZXZLZXkiLCJwcmV2UmVzdWx0Iiwia2V5U2VsZWN0b3IiLCJERUZBVUxUX0tFWV9TRUxFQ1RPUiIsImNvbXBhcmVLZXlzIiwiYXJyYXlFcXVhbCIsImFyZ3MiLCJrZXkiLCJhcHBseSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVlBOztBQUNBOzs7O0FBYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7ZUFDZ0IsQ0FBQ0EsSUFBRCxFQUFPQyxZQUFQLEVBQXNCQyxZQUF0QixLQUF3QztBQUN0RCx1QkFDRSxFQUFFRCxZQUFZLElBQUksSUFBaEIsSUFBd0JDLFlBQVksSUFBSSxJQUExQyxDQURGLEVBRUUsNkVBRkY7QUFLQSxNQUFJQyxPQUFPLEdBQUcsSUFBZDtBQUNBLE1BQUlDLFVBQUo7QUFDQSxRQUFNQyxXQUFXLEdBQUdKLFlBQVksSUFBSUssb0JBQXBDO0FBQ0EsUUFBTUMsV0FBVyxHQUFHTCxZQUFZLElBQUlNLHNCQUFwQztBQUNBLFNBQU8sVUFBUyxHQUFHQyxJQUFaLEVBQWtCO0FBQ3ZCLFVBQU1DLEdBQUcsR0FBSUwsV0FBRCxDQUF3QixHQUFHSSxJQUEzQixDQUFaO0FBQ0EseUJBQVVDLEdBQUcsSUFBSSxJQUFqQixFQUF1QixvQkFBdkI7O0FBQ0EsUUFBSVAsT0FBTyxJQUFJLElBQVgsSUFBbUIsQ0FBQ0ksV0FBVyxDQUFDRyxHQUFELEVBQU1QLE9BQU4sQ0FBbkMsRUFBbUQ7QUFDakRBLE1BQUFBLE9BQU8sR0FBR08sR0FBVjtBQUNBTixNQUFBQSxVQUFVLEdBQUlKLElBQUQsQ0FBaUJXLEtBQWpCLENBQXVCLElBQXZCLEVBQTZCRixJQUE3QixDQUFiO0FBQ0Q7O0FBQ0QsV0FBT0wsVUFBUDtBQUNELEdBUkQ7QUFTRCxDOzs7O0FBRUQsTUFBTUUsb0JBQW9CLEdBQUcsQ0FBQyxHQUFHRyxJQUFKLEtBQWFBLElBQTFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge2FycmF5RXF1YWx9IGZyb20gJy4vY29sbGVjdGlvbic7XHJcblxyXG50eXBlIG1lbW9pemVVbnRpbENoYW5nZWQgPSAoPEEsIEIsIEMsIEQsIEUsIFIsIFU+KFxyXG4gIGZ1bmM6IChBLCBCLCBDLCBELCBFKSA9PiBSLFxyXG4gIGtleVNlbGVjdG9yXz86IChBLCBCLCBDLCBELCBFKSA9PiBVLFxyXG4gIGNvbXBhcmVLZXlzXz86IChVLCBVKSA9PiBib29sZWFuLFxyXG4pID0+IChBLCBCLCBDLCBELCBFKSA9PiBSKSAmXHJcbiAgKDxBLCBCLCBDLCBELCBSLCBVPihcclxuICAgIGZ1bmM6IChBLCBCLCBDLCBEKSA9PiBSLFxyXG4gICAga2V5U2VsZWN0b3JfPzogKEEsIEIsIEMsIEQpID0+IFUsXHJcbiAgICBjb21wYXJlS2V5c18/OiAoVSwgVSkgPT4gYm9vbGVhbixcclxuICApID0+IChBLCBCLCBDLCBEKSA9PiBSKSAmXHJcbiAgKDxBLCBCLCBDLCBSLCBVPihcclxuICAgIGZ1bmM6IChBLCBCLCBDKSA9PiBSLFxyXG4gICAga2V5U2VsZWN0b3JfPzogKEEsIEIsIEMpID0+IFUsXHJcbiAgICBjb21wYXJlS2V5c18/OiAoVSwgVSkgPT4gYm9vbGVhbixcclxuICApID0+IChBLCBCLCBDKSA9PiBSKSAmXHJcbiAgKDxBLCBCLCBSLCBVPihcclxuICAgIGZ1bmM6IChBLCBCKSA9PiBSLFxyXG4gICAga2V5U2VsZWN0b3JfPzogKEEsIEIpID0+IFUsXHJcbiAgICBjb21wYXJlS2V5c18/OiAoVSwgVSkgPT4gYm9vbGVhbixcclxuICApID0+IChBLCBCKSA9PiBSKSAmXHJcbiAgKDxBLCBSLCBVPihcclxuICAgIGZ1bmM6IChBKSA9PiBSLFxyXG4gICAga2V5U2VsZWN0b3JfPzogKEEpID0+IFUsXHJcbiAgICBjb21wYXJlS2V5c18/OiAoVSwgVSkgPT4gYm9vbGVhbixcclxuICApID0+IEEgPT4gUikgJlxyXG4gICg8Uj4oZnVuYzogKCkgPT4gUikgPT4gKCkgPT4gUikgJlxyXG4gICg8VCwgUiwgVT4oXHJcbiAgICBmdW5jOiAoLi4uYW55OiAkUmVhZE9ubHlBcnJheTxUPikgPT4gUixcclxuICAgICguLi5hbnk6ICRSZWFkT25seUFycmF5PFQ+KSA9PiBVLFxyXG4gICAgY29tcGFyZUtleXNfPzogKFUsIFUpID0+IGJvb2xlYW4sXHJcbiAgKSA9PiAoLi4uYW55OiAkUmVhZE9ubHlBcnJheTxUPikgPT4gUik7XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGEgbWVtb2l6ZWQgdmVyc2lvbiBvZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gdGhhdCBjYWNoZXMgb25seSB0aGUgbGF0ZXN0IHJlc3VsdC4gVGhpcyBpc1xyXG4gKiBlc3BlY2lhbGx5IHVzZWZ1bCBmb3Igb3B0aW1pemluZyBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyB3aXRob3V0IGhhdmluZyB0byB3b3JyeSBhYm91dFxyXG4gKiBtYWludGFpbmluZyBzdGF0ZSBleHBsaWNpdGx5LiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICogICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICogICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAqICAgICAgICAgdGhpcy5fY29tcHV0ZVNvbWV0aGluZ0V4cGVuc2l2ZSA9IG1lbW9pemVVbnRpbENoYW5nZWQodGhpcy5fY29tcHV0ZVNvbWV0aGluZ0V4cGVuc2l2ZSk7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgX2NvbXB1dGVTb21ldGhpbmdFeHBlbnNpdmUoeCkgeyAuLi4gfVxyXG4gKiAgICAgICByZW5kZXIoKSB7XHJcbiAqICAgICAgICAgY29uc3QgdGhpbmdUb1JlbmRlciA9IHRoaXMuX2NvbXB1dGVTb21ldGhpbmdFeHBlbnNpdmUodGhpcy5wcm9wcy52YWx1ZSk7XHJcbiAqICAgICAgICAgcmV0dXJuIDxkaXY+e3RoaW5nVG9SZW5kZXJ9PC9kaXY+O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICB9XHJcbiAqXHJcbiAqIFNvbWV0aW1lcywgeW91IG5lZWQgdG8gY3VzdG9taXplIGhvdyB0aGUgYXJndW1lbnRzIGFyZSBjb21wYXJlZC4gSW4gdGhpcyBjYXNlIHlvdSBjYW4gcGFzcyBhXHJcbiAqIGtleSBzZWxlY3RvciBmdW5jdGlvbiAod2hpY2ggZGVyaXZlcyBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoZSBhcmd1bWVudHMpLCBhbmQgYW4gZXF1YWxpdHkgZnVuY3Rpb25cclxuICogKHdoaWNoIGNvbXBhcmVzIGtleXMpLiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogICAgIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuICogICAgICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICogICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAqICAgICAgICAgdGhpcy5fY29tcHV0ZVNvbWV0aGluZ0V4cGVuc2l2ZSA9IG1lbW9pemVVbnRpbENoYW5nZWQoXHJcbiAqICAgICAgICAgICB0aGlzLl9jb21wdXRlU29tZXRoaW5nRXhwZW5zaXZlLFxyXG4gKiAgICAgICAgICAgKHg6IEFycmF5PE9iamVjdD4sIHk6IEFycmF5PE9iamVjdD4pID0+ICh7eCwgeX0pLFxyXG4gKiAgICAgICAgICAgKGEsIGIpID0+IGFycmF5RXF1YWwoYS54LCBiLngpICYmIGFycmF5RXF1YWwoYS55LCBiLnkpLFxyXG4gKiAgICAgICAgICk7XHJcbiAqICAgICAgIH1cclxuICogICAgICAgX2NvbXB1dGVTb21ldGhpbmdFeHBlbnNpdmUoeDogQXJyYXk8T2JqZWN0PiwgeTogQXJyYXk8T2JqZWN0PikgeyAuLi4gfVxyXG4gKiAgICAgICByZW5kZXIoKSB7XHJcbiAqICAgICAgICAgY29uc3QgdGhpbmdUb1JlbmRlciA9IHRoaXMuX2NvbXB1dGVTb21ldGhpbmdFeHBlbnNpdmUodGhpcy5wcm9wcy52YWx1ZSk7XHJcbiAqICAgICAgICAgcmV0dXJuIDxkaXY+e3RoaW5nVG9SZW5kZXJ9PC9kaXY+O1xyXG4gKiAgICAgICB9XHJcbiAqICAgICB9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCAoKGZ1bmMsIGtleVNlbGVjdG9yXz8sIGNvbXBhcmVLZXlzXz8pID0+IHtcclxuICBpbnZhcmlhbnQoXHJcbiAgICAhKGtleVNlbGVjdG9yXyA9PSBudWxsICYmIGNvbXBhcmVLZXlzXyAhPSBudWxsKSxcclxuICAgIFwiWW91IGNhbid0IHByb3ZpZGUgYSBjb21wYXJlIGZ1bmN0aW9uIHdpdGhvdXQgYWxzbyBwcm92aWRpbmcgYSBrZXkgc2VsZWN0b3IuXCIsXHJcbiAgKTtcclxuXHJcbiAgbGV0IHByZXZLZXkgPSBudWxsO1xyXG4gIGxldCBwcmV2UmVzdWx0O1xyXG4gIGNvbnN0IGtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3JfIHx8IERFRkFVTFRfS0VZX1NFTEVDVE9SO1xyXG4gIGNvbnN0IGNvbXBhcmVLZXlzID0gY29tcGFyZUtleXNfIHx8IGFycmF5RXF1YWw7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuICAgIGNvbnN0IGtleSA9IChrZXlTZWxlY3RvcjogRnVuY3Rpb24pKC4uLmFyZ3MpO1xyXG4gICAgaW52YXJpYW50KGtleSAhPSBudWxsLCAnS2V5IGNhbm5vdCBiZSBudWxsJyk7XHJcbiAgICBpZiAocHJldktleSA9PSBudWxsIHx8ICFjb21wYXJlS2V5cyhrZXksIHByZXZLZXkpKSB7XHJcbiAgICAgIHByZXZLZXkgPSBrZXk7XHJcbiAgICAgIHByZXZSZXN1bHQgPSAoZnVuYzogRnVuY3Rpb24pLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByZXZSZXN1bHQ7XHJcbiAgfTtcclxufTogbWVtb2l6ZVVudGlsQ2hhbmdlZCk7XHJcblxyXG5jb25zdCBERUZBVUxUX0tFWV9TRUxFQ1RPUiA9ICguLi5hcmdzKSA9PiBhcmdzO1xyXG4iXX0=