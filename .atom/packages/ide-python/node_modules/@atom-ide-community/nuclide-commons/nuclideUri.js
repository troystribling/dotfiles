"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__TEST__ = exports.default = void 0;

var _vscodeUri = _interopRequireDefault(require("vscode-uri"));

var _assert = _interopRequireDefault(require("assert"));

var _path = _interopRequireDefault(require("path"));

var _os = _interopRequireDefault(require("os"));

var _string = require("./string");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
// NuclideUri's are either a local file path, or a URI
// of the form nuclide://<host><path>
//
// This package creates, queries and decomposes NuclideUris.
// eslint-disable-next-line nuclide-internal/prefer-nuclide-uri
const ARCHIVE_SEPARATOR = '!';
const KNOWN_ARCHIVE_EXTENSIONS = [];
const REMOTE_PATH_URI_PREFIX = 'nuclide://'; // TODO(ljw): following regex is incorrect. A URI scheme must start with
// [A-Za-z] not [0-9_-]. Also, not all schemes require // after them.

const URI_PREFIX_REGEX = /^[A-Za-z0-9_-]+:\/\/.*/;

function isRemote(uri) {
  return uri.startsWith(REMOTE_PATH_URI_PREFIX);
} // Atom often puts its URIs in places where we'd expect to see Nuclide URIs (or plain paths)


function isAtomUri(uri) {
  return uri.startsWith('atom://');
}

function isUri(uri) {
  return URI_PREFIX_REGEX.test(uri);
}

function isLocal(uri) {
  return !isRemote(uri) && !isUri(uri) && !isAtomUri(uri);
}

function createRemoteUri(hostname, remotePath) {
  (0, _assert.default)(remotePath != null && remotePath !== '', 'NuclideUri must include a path.');
  return `nuclide://${hostname}${remotePath}`;
}

function isInArchive(uri) {
  if (isAtomUri(uri) || uri.indexOf(ARCHIVE_SEPARATOR) < 0) {
    return false;
  }

  for (let i = uri.indexOf(ARCHIVE_SEPARATOR); i >= 0; i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)) {
    if (_isArchiveSeparator(uri, i)) {
      return true;
    }
  }

  return false;
}

function ancestorOutsideArchive(uri) {
  for (let i = uri.indexOf(ARCHIVE_SEPARATOR); i >= 0; i = uri.indexOf(ARCHIVE_SEPARATOR, i + 1)) {
    if (_isArchiveSeparator(uri, i)) {
      return uri.substring(0, i);
    }
  }

  return uri;
}
/**
 * Parses valid Nuclide URIs into the hostname and path components.
 * Throws an Error on invalid URIs. Invalid URIs are:
 *  1) Any URI that does not start with 'nuclide://' protocol.
 *  2) A URI starting with 'nuclide://' that doesn't contain either a hostname or a path
 *
 * Everything that does not contain a '://' is assumed to be a local path. Both POSIX and Windows
 * paths are legal
 */


function parse(uri) {
  if (uri.startsWith(REMOTE_PATH_URI_PREFIX)) {
    const hostAndPath = uri.substr(REMOTE_PATH_URI_PREFIX.length);
    const hostSep = hostAndPath.indexOf('/');
    (0, _assert.default)(hostSep !== -1, `Remote URIs must contain a hostname and a path. Failed to parse ${uri}`);
    const hostname = hostAndPath.substr(0, hostSep);
    (0, _assert.default)(hostname !== '', `Remote URIs must contain a hostname. Failed to parse ${uri}`);
    const path = hostAndPath.substr(hostSep);
    (0, _assert.default)(!_endsWithArchiveSeparator(uri), `Path cannot end with archive separator. Failed to parse ${uri}`);
    return {
      hostname,
      path
    };
  }

  (0, _assert.default)(!_endsWithArchiveSeparator(uri), `Path cannot end with archive separator. Failed to parse ${uri}`);
  return {
    hostname: null,
    path: uri
  };
}

function parseRemoteUri(remoteUri) {
  if (!isRemote(remoteUri)) {
    throw new Error('Expected remote uri. Got ' + remoteUri);
  }

  const parsedUri = parse(remoteUri);
  (0, _assert.default)( // flowlint-next-line sketchy-null-string:off
  parsedUri.hostname, `Remote Nuclide URIs must contain hostnames, '${(0, _string.maybeToString)(parsedUri.hostname)}' found while parsing '${remoteUri}'`); // Explicitly copying object properties appeases Flow's "maybe" type handling. Using the `...`
  // operator causes null/undefined errors, and `Object.assign` bypasses type checking.

  return {
    hostname: parsedUri.hostname,
    path: parsedUri.path
  };
}

function getPath(uri) {
  return parse(uri).path;
}

function getHostname(remoteUri) {
  return parseRemoteUri(remoteUri).hostname;
}

function getHostnameOpt(remoteUri) {
  if (remoteUri == null || !isRemote(remoteUri)) {
    return null;
  }

  return getHostname(remoteUri);
}

function join(uri, ...relativePath) {
  return joinArray(uri, relativePath);
}

function joinArray(uri, relativePath) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  if (isRemote(uri)) {
    const {
      hostname,
      path
    } = parseRemoteUri(uri);
    relativePath.splice(0, 0, path);

    _archiveEncodeArrayInPlace(uriPathModule, relativePath);

    return _archiveDecode(uriPathModule, createRemoteUri(hostname, uriPathModule.join.apply(null, relativePath)));
  } else {
    relativePath.splice(0, 0, uri);

    _archiveEncodeArrayInPlace(uriPathModule, relativePath);

    return _archiveDecode(uriPathModule, uriPathModule.join.apply(null, relativePath));
  }
}

function archiveJoin(uri, path) {
  _testForIllegalUri(uri);

  if (!KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext))) {
    throw new Error(`Cannot archiveJoin with non-archive ${uri} and ${path}`);
  }

  return uri + ARCHIVE_SEPARATOR + path;
}

function normalize(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  if (isRemote(uri)) {
    const {
      hostname,
      path
    } = parseRemoteUri(uri);

    const normal = _archiveDecode(uriPathModule, uriPathModule.normalize(_archiveEncode(uriPathModule, path)));

    return createRemoteUri(hostname, normal);
  } else {
    return _archiveDecode(uriPathModule, uriPathModule.normalize(_archiveEncode(uriPathModule, uri)));
  }
}

function normalizeDir(uri) {
  return ensureTrailingSeparator(normalize(uri));
}

function getParent(uri) {
  // TODO: Is this different than dirname?
  return normalize(join(uri, '..'));
}

function relative(uri, other) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  const remote = isRemote(uri);

  if (remote !== isRemote(other) || remote && getHostname(uri) !== getHostname(other)) {
    throw new Error(`Cannot relative urls on different hosts: ${uri} and ${other}`);
  }

  const uriEncode = _archiveEncode(uriPathModule, remote ? getPath(uri) : uri);

  const otherEncode = _archiveEncode(uriPathModule, remote ? getPath(other) : other);

  return _archiveDecode(uriPathModule, uriPathModule.relative(_matchTrailingArchive(uriEncode, otherEncode), _matchTrailingArchive(otherEncode, uriEncode)));
}

function basename(uri, ext = '') {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  return _archiveDecode(uriPathModule, uriPathModule.basename(_archiveEncode(uriPathModule, getPath(uri)), ext));
}

function dirname(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  if (isRemote(uri)) {
    const {
      hostname,
      path
    } = parseRemoteUri(uri);
    return createRemoteUri(hostname, _archiveDecode(uriPathModule, uriPathModule.dirname(_archiveEncode(uriPathModule, path))));
  } else {
    return _archiveDecode(uriPathModule, uriPathModule.dirname(_archiveEncode(uriPathModule, uri)));
  }
}

function extname(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  return _archiveDecode(uriPathModule, uriPathModule.extname(_archiveEncode(uriPathModule, getPath(uri))));
}

function stripExtension(uri) {
  _testForIllegalUri(uri);

  const ext = extname(uri);

  if (ext.length === 0) {
    return uri;
  }

  return uri.slice(0, -1 * ext.length);
}

function _isWindowsPath(path) {
  return _pathModuleFor(path) === _path.default.win32;
}

function _getWindowsPathFromWindowsFileUri(uri) {
  const prefix = 'file://';

  if (!uri.startsWith(prefix)) {
    return null;
  }

  const path = uri.substr(prefix.length);
  return _isWindowsPath(path) ? path : null;
}
/**
 * uri is either a file: uri, or a nuclide: uri.
 * must convert file: uri's to just a path for atom.
 *
 * Returns null if not a valid file: URI.
 */


function uriToNuclideUri(uri) {
  // file:// URIs should never normally contain Windows backslashes:
  // e.g. vscode-uri escapes C:\abc to file:///c:/abc.
  // This just handles any hacky users that simply prepended 'file://'.
  // (vscode-uri does not know how to handle file://C:\abc.)
  const windowsPathFromUri = _getWindowsPathFromWindowsFileUri(uri);

  if (windowsPathFromUri != null) {
    return windowsPathFromUri;
  }

  const lspUri = _vscodeUri.default.parse(uri);

  if (lspUri.scheme === 'file' && lspUri.path) {
    // only handle real files for now.
    return lspUri.fsPath;
  } else if (isRemote(uri)) {
    return uri;
  } else {
    return null;
  }
}
/**
 * Converts local paths to file: URI's. Leaves remote URI's alone.
 */


function nuclideUriToUri(uri) {
  _testForIllegalUri(uri);

  if (isRemote(uri)) {
    return uri;
  } else {
    return _vscodeUri.default.file(uri).toString();
  }
}
/**
 * Returns true if child is equal to, or is a proper descendant of parent.
 */


function contains(parent, child) {
  _testForIllegalUri(parent);

  _testForIllegalUri(child); // Can't just do startsWith here. If this directory is "www" and you
  // are trying to check "www-base", just using startsWith would return
  // true, even though "www-base" is at the same level as "Www", not
  // contained in it.
  // Also, there's an issue with a trailing separator ambiguity. A path
  // like /abc/ does contain /abc
  // This function is used in some performance-sensitive parts, so we
  // want to avoid doing unnecessary string copy, as those that would
  // result from an ensureTrailingSeparator() call
  //
  // First we'll check the lengths.
  // Then check startsWith. If so, then if the two path lengths are
  // equal OR if the next character in the path to check is a path
  // separator, then we know the checked path is in this path.


  if (child.length < parent.length) {
    // A strong indication of false
    // It could be a matter of a trailing separator, though
    if (child.length < parent.length - 1) {
      // It must be more than just the separator
      return false;
    }

    return parent.startsWith(child) && (endsWithSeparator(parent) || _isArchiveSeparator(child, parent.length));
  }

  if (!child.startsWith(parent)) {
    return false;
  }

  if (endsWithSeparator(parent) || parent.length === child.length) {
    return true;
  }

  const uriPathModule = _pathModuleFor(child);

  return _isArchiveSeparator(child, parent.length) || child.slice(parent.length).startsWith(uriPathModule.sep);
}
/**
 * Filter an array of paths to contain only the collapsed root paths, e.g.
 * [a/b/c, a/, c/d/, c/d/e] collapses to [a/, c/d/]
 */


function collapse(paths) {
  return paths.filter(p => !paths.some(fp => contains(fp, p) && fp !== p));
}

const hostFormatters = []; // A formatter which may shorten hostnames.
// Returns null if the formatter won't shorten the hostname.

// Registers a host formatter for nuclideUriToDisplayString
function registerHostnameFormatter(formatter) {
  hostFormatters.push(formatter);
  return {
    dispose: () => {
      const index = hostFormatters.indexOf(formatter);

      if (index >= 0) {
        hostFormatters.splice(index, 1);
      }
    }
  };
}

function hostnameToDisplayHostname(hostname) {
  return hostFormatters.reduce((current, formatter) => {
    const next = formatter(current);

    if (next != null && next !== '') {
      return next;
    } else {
      return current;
    }
  }, hostname);
}

function nuclideUriToDisplayHostname(uri) {
  _testForIllegalUri(uri);

  return isRemote(uri) ? hostnameToDisplayHostname(getHostname(uri)) : uri;
}
/**
 * NuclideUris should never be shown to humans.
 * This function returns a human usable string.
 */


function nuclideUriToDisplayString(uri) {
  _testForIllegalUri(uri);

  return isRemote(uri) ? `${nuclideUriToDisplayHostname(uri)}:${getPath(uri)}` : uri;
}

function ensureTrailingSeparator(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  if (uri.endsWith(uriPathModule.sep)) {
    return uri;
  }

  return uri + uriPathModule.sep;
}

function trimTrailingSeparator(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  let stripped = uri;

  while (stripped.endsWith(uriPathModule.sep) && !isRoot(stripped)) {
    stripped = stripped.slice(0, -1 * uriPathModule.sep.length);
  }

  return stripped;
}

function endsWithSeparator(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  return uri.endsWith(uriPathModule.sep);
}

function endsWithEdenDir(uri) {
  _testForIllegalUri(uri);

  return uri.endsWith('.eden');
}

function isAbsolute(uri) {
  _testForIllegalUri(uri);

  if (isRemote(uri)) {
    return true;
  } else {
    const uriPathModule = _pathModuleFor(uri);

    return uriPathModule.isAbsolute(uri);
  }
}

function resolve(uri, ...paths) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  if (isRemote(uri)) {
    const {
      hostname,
      path
    } = parseRemoteUri(uri);
    paths.splice(0, 0, path);

    _archiveEncodeArrayInPlace(uriPathModule, paths);

    return createRemoteUri(hostname, _archiveDecode(uriPathModule, uriPathModule.resolve.apply(null, paths)));
  } else {
    paths.splice(0, 0, uri);

    _archiveEncodeArrayInPlace(uriPathModule, paths);

    return _archiveDecode(uriPathModule, uriPathModule.resolve.apply(null, paths));
  }
}

function isHomeRelative(uri) {
  _testForIllegalUri(uri);

  return uri.startsWith('~');
}

function expandHomeDir(uri) {
  _testForIllegalUri(uri); // Do not expand non home relative uris


  if (!uri.startsWith('~')) {
    return uri;
  } // "home" on Windows is %UserProfile%. Note that Windows environment variables
  // are NOT case sensitive, but process.env is a magic object that wraps GetEnvironmentVariableW
  // on Windows, so asking for any case is expected to work.


  const {
    HOME,
    UserProfile
  } = process.env;
  const isWindows = !isRemote(uri) && _os.default.platform() === 'win32';
  const homePath = isWindows ? UserProfile : HOME;
  (0, _assert.default)(homePath != null);

  if (uri === '~') {
    return homePath;
  } // Uris like ~abc should not be expanded


  if (!uri.startsWith('~/') && (!isWindows || !uri.startsWith('~\\'))) {
    return uri;
  }

  return _path.default.resolve(homePath, uri.replace('~', '.'));
}
/**
 * Splits a string containing local paths by an OS-specific path delimiter
 * Useful for splitting env variables such as PATH
 *
 * Since remote URI might contain the delimiter, only local paths are allowed.
 */


function splitPathList(paths) {
  (0, _assert.default)(paths.indexOf(REMOTE_PATH_URI_PREFIX) < 0, 'Splitting remote URIs is not supported');

  const uriPathModule = _pathModuleFor(paths);

  return paths.split(uriPathModule.delimiter);
}
/**
 * Joins an array of local paths with an OS-specific path delimiter into a single string.
 * Useful for constructing env variables such as PATH
 *
 * Since remote URI might contain the delimiter, only local paths are allowed.
 */


function joinPathList(paths) {
  if (paths.length === 0) {
    return '';
  }

  (0, _assert.default)(paths.every(path => !isRemote(path)), 'Joining of remote URIs is not supported');

  const uriPathModule = _pathModuleFor(paths[0]);

  return paths.join(uriPathModule.delimiter);
}
/**
 * This function prepends the given relative path with a "current-folder" prefix
 * which is `./` on *nix and .\ on Windows
 */


function ensureLocalPrefix(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  (0, _assert.default)(!isRemote(uri), 'Local prefix can not be added to a remote path');
  (0, _assert.default)(!isAbsolute(uri), 'Local prefix can not be added to an absolute path');
  const localPrefix = `.${uriPathModule.sep}`;

  if (uri.startsWith(localPrefix)) {
    return uri;
  }

  return localPrefix + uri;
}

function isRoot(uri) {
  _testForIllegalUri(uri);

  return dirname(uri) === uri;
}

function parsePath(uri) {
  _testForIllegalUri(uri);

  const uriPathModule = _pathModuleFor(uri);

  const parsed = uriPathModule.parse(_archiveEncode(uriPathModule, getPath(uri)));
  return {
    root: _archiveDecode(uriPathModule, parsed.root),
    dir: _archiveDecode(uriPathModule, parsed.dir),
    base: _archiveDecode(uriPathModule, parsed.base),
    ext: _archiveDecode(uriPathModule, parsed.ext),
    name: _archiveDecode(uriPathModule, parsed.name)
  };
}

function pathSeparatorFor(uri) {
  return _pathModuleFor(uri).sep;
}

function split(uri) {
  const parts = [];
  let current = uri;
  let parent = dirname(current);

  while (current !== parent) {
    parts.push(basename(current));
    current = parent;
    parent = dirname(current);
  }

  if (isAbsolute(uri)) {
    parts.push(parent);
  }

  parts.reverse();
  return parts;
}

function hasKnownArchiveExtension(uri) {
  return KNOWN_ARCHIVE_EXTENSIONS.some(ext => uri.endsWith(ext));
}

function _pathModuleFor(uri) {
  (0, _assert.default)(!_endsWithArchiveSeparator(uri), `Path cannot end with archive separator. Failed to determine path module for ${uri}`);

  if (uri.startsWith(_path.default.posix.sep)) {
    return _path.default.posix;
  }

  if (uri.indexOf('://') > -1) {
    return _path.default.posix;
  }

  if (uri[1] === ':' && uri[2] === _path.default.win32.sep) {
    return _path.default.win32;
  } // This little russian roulette here is blocking T29990593. I didn't
  // clean it because we might see posix paths on windows and vice versa.


  if (uri.split(_path.default.win32.sep).length > uri.split(_path.default.posix.sep).length) {
    return _path.default.win32;
  } else {
    return _path.default.posix;
  }
} // Runs _archiveEncode in-place on array, and returns argument for convenience.


function _archiveEncodeArrayInPlace(uriPathModule, array) {
  array.forEach((uri, i, a) => a[i] = _archiveEncode(uriPathModule, uri));
  return array;
} // This adds a native separator after every archive separator
// so that the native path handling code sees them.


function _archiveEncode(uriPathModule, uri) {
  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {
    return uri;
  }

  return KNOWN_ARCHIVE_EXTENSIONS.reduce((acc, ext) => acc.replace(`${ext}${ARCHIVE_SEPARATOR}`, `${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`), uri);
} // This is the inverse of `encodeArchiveSeparators()` to put things
// back after the native path handler has run.


function _archiveDecode(uriPathModule, uri) {
  if (uri.indexOf(ARCHIVE_SEPARATOR) < 0) {
    return uri;
  }

  return _trimArchiveSuffix(KNOWN_ARCHIVE_EXTENSIONS.reduce((acc, ext) => acc.replace(`${ext}${ARCHIVE_SEPARATOR}${uriPathModule.sep}`, `${ext}${ARCHIVE_SEPARATOR}`), uri));
} // When working with encoded uri's, the archive separator is part of the name
// so we can manipulate paths with uriPathModule.  However, in `relative` if
// one uri contains the other, we need the names seen by uriPathModule to agree
// on whether there is an archive separator or not.  E.g. if we have:
//    /etc/file.zip
//    /etc/file.zip!abc
// When we encode these, we get:
//    /etc/file.zip
//    /etc/file.zip!/abc
// We need to add a trailing '!' to the first one so uriPathModule can see that
// the first contains the second.


function _matchTrailingArchive(uri, other) {
  if (uri.length < other.length && other.startsWith(uri) && _isArchiveSeparator(other, uri.length)) {
    return uri + ARCHIVE_SEPARATOR;
  } else {
    return uri;
  }
}

function _trimArchiveSuffix(path) {
  if (_endsWithArchiveSeparator(path)) {
    return path.substring(0, path.length - ARCHIVE_SEPARATOR.length);
  } else {
    return path;
  }
}

function _endsWithArchiveSeparator(path) {
  return _isArchiveSeparator(path, path.length - 1);
}

function _isArchiveSeparator(path, index) {
  return path.length > index && path.charAt(index) === ARCHIVE_SEPARATOR && KNOWN_ARCHIVE_EXTENSIONS.some(ext => {
    const extStart = index - ext.length;
    return path.indexOf(ext, extStart) === extStart;
  });
}

function _testForIllegalUri(uri) {
  if (uri != null) {
    if (_endsWithArchiveSeparator(uri)) {
      throw new Error(`Path operation invoked on URI ending with ${ARCHIVE_SEPARATOR}: ${uri}`);
    }
  }
}

const NUCLIDE_URI_TYPE_NAME = 'NuclideUri'; // If mustBeRemote is present then remote-ness must match, otherwise remote-ness
// is ignored.

function validate(uri, mustBeRemote) {
  // Be a little extra paranoid to catch places where the type system may be weak.
  (0, _assert.default)(uri != null, 'Unexpected null NuclideUri');
  (0, _assert.default)(typeof uri === 'string', `Unexpected NuclideUri type: ${String(uri)}`);

  if (isRemote(uri)) {
    parse(uri);
    (0, _assert.default)(mustBeRemote !== false, 'Expected remote NuclideUri');
  } else {
    (0, _assert.default)(uri !== '', 'NuclideUri must contain a non-empty path');
    (0, _assert.default)(mustBeRemote !== true, 'Expected local NuclideUri');
  }
}

const IMAGE_EXTENSIONS = new Set(['.bmp', '.gif', '.ico', '.jpeg', '.jpg', '.png', '.webp']);
/**
 * Returns true if this filename looks like an image that Nuclide can open; otherwise false.
 */

function looksLikeImageUri(uri) {
  const ext = extname(uri).toLowerCase();
  return IMAGE_EXTENSIONS.has(ext);
}

var _default = {
  basename,
  dirname,
  extname,
  stripExtension,
  isRemote,
  isLocal,
  createRemoteUri,
  isInArchive,
  ancestorOutsideArchive,
  parse,
  parseRemoteUri,
  validate,
  getPath,
  getHostname,
  getHostnameOpt,
  join,
  joinArray,
  archiveJoin,
  relative,
  looksLikeImageUri,
  normalize,
  normalizeDir,
  getParent,
  uriToNuclideUri,
  nuclideUriToUri,
  contains,
  collapse,
  nuclideUriToDisplayString,
  nuclideUriToDisplayHostname,
  hostnameToDisplayHostname,
  registerHostnameFormatter,
  ensureTrailingSeparator,
  trimTrailingSeparator,
  endsWithSeparator,
  endsWithEdenDir,
  isAbsolute,
  isHomeRelative,
  resolve,
  expandHomeDir,
  splitPathList,
  joinPathList,
  ensureLocalPrefix,
  isRoot,
  parsePath,
  split,
  pathSeparatorFor,
  hasKnownArchiveExtension,
  ARCHIVE_SEPARATOR,
  KNOWN_ARCHIVE_EXTENSIONS,
  NUCLIDE_URI_TYPE_NAME
};
exports.default = _default;
const __TEST__ = {
  _pathModuleFor
};
exports.__TEST__ = __TEST__;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL251Y2xpZGVVcmkuanMiXSwibmFtZXMiOlsiQVJDSElWRV9TRVBBUkFUT1IiLCJLTk9XTl9BUkNISVZFX0VYVEVOU0lPTlMiLCJSRU1PVEVfUEFUSF9VUklfUFJFRklYIiwiVVJJX1BSRUZJWF9SRUdFWCIsImlzUmVtb3RlIiwidXJpIiwic3RhcnRzV2l0aCIsImlzQXRvbVVyaSIsImlzVXJpIiwidGVzdCIsImlzTG9jYWwiLCJjcmVhdGVSZW1vdGVVcmkiLCJob3N0bmFtZSIsInJlbW90ZVBhdGgiLCJpc0luQXJjaGl2ZSIsImluZGV4T2YiLCJpIiwiX2lzQXJjaGl2ZVNlcGFyYXRvciIsImFuY2VzdG9yT3V0c2lkZUFyY2hpdmUiLCJzdWJzdHJpbmciLCJwYXJzZSIsImhvc3RBbmRQYXRoIiwic3Vic3RyIiwibGVuZ3RoIiwiaG9zdFNlcCIsInBhdGgiLCJfZW5kc1dpdGhBcmNoaXZlU2VwYXJhdG9yIiwicGFyc2VSZW1vdGVVcmkiLCJyZW1vdGVVcmkiLCJFcnJvciIsInBhcnNlZFVyaSIsImdldFBhdGgiLCJnZXRIb3N0bmFtZSIsImdldEhvc3RuYW1lT3B0Iiwiam9pbiIsInJlbGF0aXZlUGF0aCIsImpvaW5BcnJheSIsIl90ZXN0Rm9ySWxsZWdhbFVyaSIsInVyaVBhdGhNb2R1bGUiLCJfcGF0aE1vZHVsZUZvciIsInNwbGljZSIsIl9hcmNoaXZlRW5jb2RlQXJyYXlJblBsYWNlIiwiX2FyY2hpdmVEZWNvZGUiLCJhcHBseSIsImFyY2hpdmVKb2luIiwic29tZSIsImV4dCIsImVuZHNXaXRoIiwibm9ybWFsaXplIiwibm9ybWFsIiwiX2FyY2hpdmVFbmNvZGUiLCJub3JtYWxpemVEaXIiLCJlbnN1cmVUcmFpbGluZ1NlcGFyYXRvciIsImdldFBhcmVudCIsInJlbGF0aXZlIiwib3RoZXIiLCJyZW1vdGUiLCJ1cmlFbmNvZGUiLCJvdGhlckVuY29kZSIsIl9tYXRjaFRyYWlsaW5nQXJjaGl2ZSIsImJhc2VuYW1lIiwiZGlybmFtZSIsImV4dG5hbWUiLCJzdHJpcEV4dGVuc2lvbiIsInNsaWNlIiwiX2lzV2luZG93c1BhdGgiLCJwYXRoTW9kdWxlIiwid2luMzIiLCJfZ2V0V2luZG93c1BhdGhGcm9tV2luZG93c0ZpbGVVcmkiLCJwcmVmaXgiLCJ1cmlUb051Y2xpZGVVcmkiLCJ3aW5kb3dzUGF0aEZyb21VcmkiLCJsc3BVcmkiLCJMc3BVcmkiLCJzY2hlbWUiLCJmc1BhdGgiLCJudWNsaWRlVXJpVG9VcmkiLCJmaWxlIiwidG9TdHJpbmciLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwiZW5kc1dpdGhTZXBhcmF0b3IiLCJzZXAiLCJjb2xsYXBzZSIsInBhdGhzIiwiZmlsdGVyIiwicCIsImZwIiwiaG9zdEZvcm1hdHRlcnMiLCJyZWdpc3Rlckhvc3RuYW1lRm9ybWF0dGVyIiwiZm9ybWF0dGVyIiwicHVzaCIsImRpc3Bvc2UiLCJpbmRleCIsImhvc3RuYW1lVG9EaXNwbGF5SG9zdG5hbWUiLCJyZWR1Y2UiLCJjdXJyZW50IiwibmV4dCIsIm51Y2xpZGVVcmlUb0Rpc3BsYXlIb3N0bmFtZSIsIm51Y2xpZGVVcmlUb0Rpc3BsYXlTdHJpbmciLCJ0cmltVHJhaWxpbmdTZXBhcmF0b3IiLCJzdHJpcHBlZCIsImlzUm9vdCIsImVuZHNXaXRoRWRlbkRpciIsImlzQWJzb2x1dGUiLCJyZXNvbHZlIiwiaXNIb21lUmVsYXRpdmUiLCJleHBhbmRIb21lRGlyIiwiSE9NRSIsIlVzZXJQcm9maWxlIiwicHJvY2VzcyIsImVudiIsImlzV2luZG93cyIsIm9zIiwicGxhdGZvcm0iLCJob21lUGF0aCIsInJlcGxhY2UiLCJzcGxpdFBhdGhMaXN0Iiwic3BsaXQiLCJkZWxpbWl0ZXIiLCJqb2luUGF0aExpc3QiLCJldmVyeSIsImVuc3VyZUxvY2FsUHJlZml4IiwibG9jYWxQcmVmaXgiLCJwYXJzZVBhdGgiLCJwYXJzZWQiLCJyb290IiwiZGlyIiwiYmFzZSIsIm5hbWUiLCJwYXRoU2VwYXJhdG9yRm9yIiwicGFydHMiLCJyZXZlcnNlIiwiaGFzS25vd25BcmNoaXZlRXh0ZW5zaW9uIiwicG9zaXgiLCJhcnJheSIsImZvckVhY2giLCJhIiwiYWNjIiwiX3RyaW1BcmNoaXZlU3VmZml4IiwiY2hhckF0IiwiZXh0U3RhcnQiLCJOVUNMSURFX1VSSV9UWVBFX05BTUUiLCJ2YWxpZGF0ZSIsIm11c3RCZVJlbW90ZSIsIlN0cmluZyIsIklNQUdFX0VYVEVOU0lPTlMiLCJTZXQiLCJsb29rc0xpa2VJbWFnZVVyaSIsInRvTG93ZXJDYXNlIiwiaGFzIiwiX19URVNUX18iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFpQkE7O0FBc0JBOztBQUVBOztBQUVBOztBQUNBOzs7O0FBNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXlCQTtBQU1BLE1BQU1BLGlCQUFpQixHQUFHLEdBQTFCO0FBQ0EsTUFBTUMsd0JBQXdCLEdBQUcsRUFBakM7QUFFQSxNQUFNQyxzQkFBc0IsR0FBRyxZQUEvQixDLENBQ0E7QUFDQTs7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBRyx3QkFBekI7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQkMsR0FBbEIsRUFBNEM7QUFDMUMsU0FBT0EsR0FBRyxDQUFDQyxVQUFKLENBQWVKLHNCQUFmLENBQVA7QUFDRCxDLENBRUQ7OztBQUNBLFNBQVNLLFNBQVQsQ0FBbUJGLEdBQW5CLEVBQTZDO0FBQzNDLFNBQU9BLEdBQUcsQ0FBQ0MsVUFBSixDQUFlLFNBQWYsQ0FBUDtBQUNEOztBQUVELFNBQVNFLEtBQVQsQ0FBZUgsR0FBZixFQUFxQztBQUNuQyxTQUFPRixnQkFBZ0IsQ0FBQ00sSUFBakIsQ0FBc0JKLEdBQXRCLENBQVA7QUFDRDs7QUFFRCxTQUFTSyxPQUFULENBQWlCTCxHQUFqQixFQUEyQztBQUN6QyxTQUFPLENBQUNELFFBQVEsQ0FBQ0MsR0FBRCxDQUFULElBQWtCLENBQUNHLEtBQUssQ0FBQ0gsR0FBRCxDQUF4QixJQUFp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QmE7QUEwQmJHLEVBQUFBLFFBMUJhO0FBMkJiSyxFQUFBQSxRQTNCYTtBQTRCYmdCLEVBQUFBLHlCQTVCYTtBQTZCYkQsRUFBQUEsMkJBN0JhO0FBOEJiSixFQUFBQSx5QkE5QmE7QUErQmJMLEVBQUFBLHlCQS9CYTtBQWdDYnRDLEVBQUFBLHVCQWhDYTtBQWlDYmlELEVBQUFBLHFCQWpDYTtBQWtDYm5CLEVBQUFBLGlCQWxDYTtBQW1DYnNCLEVBQUFBLGVBbkNhO0FBb0NiQyxFQUFBQSxVQXBDYTtBQXFDYkUsRUFBQUEsY0FyQ2E7QUFzQ2JELEVBQUFBLE9BdENhO0FBdUNiRSxFQUFBQSxhQXZDYTtBQXdDYlUsRUFBQUEsYUF4Q2E7QUF5Q2JHLEVBQUFBLFlBekNhO0FBMENiRSxFQUFBQSxpQkExQ2E7QUEyQ2JwQixFQUFBQSxNQTNDYTtBQTRDYnNCLEVBQUFBLFNBNUNhO0FBNkNiTixFQUFBQSxLQTdDYTtBQThDYlksRUFBQUEsZ0JBOUNhO0FBK0NiRyxFQUFBQSx3QkEvQ2E7QUFnRGJ0SSxFQUFBQSxpQkFoRGE7QUFpRGJDLEVBQUFBLHdCQWpEYTtBQWtEYjhJLEVBQUFBO0FBbERhLEM7O0FBcURSLE1BQU1TLFFBQVEsR0FBRztBQUN0QmpILEVBQUFBO0FBRHNCLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvdyBzdHJpY3QtbG9jYWxcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbi8vIE51Y2xpZGVVcmkncyBhcmUgZWl0aGVyIGEgbG9jYWwgZmlsZSBwYXRoLCBvciBhIFVSSVxyXG4vLyBvZiB0aGUgZm9ybSBudWNsaWRlOi8vPGhvc3Q+PHBhdGg+XHJcbi8vXHJcbi8vIFRoaXMgcGFja2FnZSBjcmVhdGVzLCBxdWVyaWVzIGFuZCBkZWNvbXBvc2VzIE51Y2xpZGVVcmlzLlxyXG5cclxuaW1wb3J0IExzcFVyaSBmcm9tICd2c2NvZGUtdXJpJztcclxuXHJcbmV4cG9ydCB0eXBlIE51Y2xpZGVVcmkgPSBzdHJpbmc7XHJcblxyXG50eXBlIFBhcnNlZFVybCA9IHtcclxuICBob3N0bmFtZTogP3N0cmluZyxcclxuICBwYXRoOiBzdHJpbmcsXHJcbn07XHJcblxyXG50eXBlIFBhcnNlZFJlbW90ZVVybCA9IHtcclxuICBob3N0bmFtZTogc3RyaW5nLFxyXG4gIHBhdGg6IHN0cmluZyxcclxufTtcclxuXHJcbnR5cGUgUGFyc2VkUGF0aCA9IHtcclxuICByb290OiBzdHJpbmcsXHJcbiAgZGlyOiBzdHJpbmcsXHJcbiAgYmFzZTogc3RyaW5nLFxyXG4gIGV4dDogc3RyaW5nLFxyXG4gIG5hbWU6IHN0cmluZyxcclxufTtcclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG51Y2xpZGUtaW50ZXJuYWwvcHJlZmVyLW51Y2xpZGUtdXJpXHJcbmltcG9ydCBwYXRoTW9kdWxlIGZyb20gJ3BhdGgnO1xyXG5cclxuaW1wb3J0IG9zIGZyb20gJ29zJztcclxuaW1wb3J0IHttYXliZVRvU3RyaW5nfSBmcm9tICcuL3N0cmluZyc7XHJcblxyXG5jb25zdCBBUkNISVZFX1NFUEFSQVRPUiA9ICchJztcclxuY29uc3QgS05PV05fQVJDSElWRV9FWFRFTlNJT05TID0gW107XHJcblxyXG5jb25zdCBSRU1PVEVfUEFUSF9VUklfUFJFRklYID0gJ251Y2xpZGU6Ly8nO1xyXG4vLyBUT0RPKGxqdyk6IGZvbGxvd2luZyByZWdleCBpcyBpbmNvcnJlY3QuIEEgVVJJIHNjaGVtZSBtdXN0IHN0YXJ0IHdpdGhcclxuLy8gW0EtWmEtel0gbm90IFswLTlfLV0uIEFsc28sIG5vdCBhbGwgc2NoZW1lcyByZXF1aXJlIC8vIGFmdGVyIHRoZW0uXHJcbmNvbnN0IFVSSV9QUkVGSVhfUkVHRVggPSAvXltBLVphLXowLTlfLV0rOlxcL1xcLy4qLztcclxuXHJcbmZ1bmN0aW9uIGlzUmVtb3RlKHVyaTogTnVjbGlkZVVyaSk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiB1cmkuc3RhcnRzV2l0aChSRU1PVEVfUEFUSF9VUklfUFJFRklYKTtcclxufVxyXG5cclxuLy8gQXRvbSBvZnRlbiBwdXRzIGl0cyBVUklzIGluIHBsYWNlcyB3aGVyZSB3ZSdkIGV4cGVjdCB0byBzZWUgTnVjbGlkZSBVUklzIChvciBwbGFpbiBwYXRocylcclxuZnVuY3Rpb24gaXNBdG9tVXJpKHVyaTogTnVjbGlkZVVyaSk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiB1cmkuc3RhcnRzV2l0aCgnYXRvbTovLycpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1VyaSh1cmk6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gIHJldHVybiBVUklfUFJFRklYX1JFR0VYLnRlc3QodXJpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNMb2NhbCh1cmk6IE51Y2xpZGVVcmkpOiBib29sZWFuIHtcclxuICByZXR1cm4gIWlzUmVtb3RlKHVyaSkgJiYgIWlzVXJpKHVyaSkgJiYgIWlzQXRvbVVyaSh1cmkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVSZW1vdGVVcmkoaG9zdG5hbWU6IHN0cmluZywgcmVtb3RlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpbnZhcmlhbnQoXHJcbiAgICByZW1vdGVQYXRoICE9IG51bGwgJiYgcmVtb3RlUGF0aCAhPT0gJycsXHJcbiAgICAnTnVjbGlkZVVyaSBtdXN0IGluY2x1ZGUgYSBwYXRoLicsXHJcbiAgKTtcclxuICByZXR1cm4gYG51Y2xpZGU6Ly8ke2hvc3RuYW1lfSR7cmVtb3RlUGF0aH1gO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc0luQXJjaGl2ZSh1cmk6IE51Y2xpZGVVcmkpOiBib29sZWFuIHtcclxuICBpZiAoaXNBdG9tVXJpKHVyaSkgfHwgdXJpLmluZGV4T2YoQVJDSElWRV9TRVBBUkFUT1IpIDwgMCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBmb3IgKFxyXG4gICAgbGV0IGkgPSB1cmkuaW5kZXhPZihBUkNISVZFX1NFUEFSQVRPUik7XHJcbiAgICBpID49IDA7XHJcbiAgICBpID0gdXJpLmluZGV4T2YoQVJDSElWRV9TRVBBUkFUT1IsIGkgKyAxKVxyXG4gICkge1xyXG4gICAgaWYgKF9pc0FyY2hpdmVTZXBhcmF0b3IodXJpLCBpKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbmNlc3Rvck91dHNpZGVBcmNoaXZlKHVyaTogTnVjbGlkZVVyaSk6IE51Y2xpZGVVcmkge1xyXG4gIGZvciAoXHJcbiAgICBsZXQgaSA9IHVyaS5pbmRleE9mKEFSQ0hJVkVfU0VQQVJBVE9SKTtcclxuICAgIGkgPj0gMDtcclxuICAgIGkgPSB1cmkuaW5kZXhPZihBUkNISVZFX1NFUEFSQVRPUiwgaSArIDEpXHJcbiAgKSB7XHJcbiAgICBpZiAoX2lzQXJjaGl2ZVNlcGFyYXRvcih1cmksIGkpKSB7XHJcbiAgICAgIHJldHVybiB1cmkuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdXJpO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIHZhbGlkIE51Y2xpZGUgVVJJcyBpbnRvIHRoZSBob3N0bmFtZSBhbmQgcGF0aCBjb21wb25lbnRzLlxyXG4gKiBUaHJvd3MgYW4gRXJyb3Igb24gaW52YWxpZCBVUklzLiBJbnZhbGlkIFVSSXMgYXJlOlxyXG4gKiAgMSkgQW55IFVSSSB0aGF0IGRvZXMgbm90IHN0YXJ0IHdpdGggJ251Y2xpZGU6Ly8nIHByb3RvY29sLlxyXG4gKiAgMikgQSBVUkkgc3RhcnRpbmcgd2l0aCAnbnVjbGlkZTovLycgdGhhdCBkb2Vzbid0IGNvbnRhaW4gZWl0aGVyIGEgaG9zdG5hbWUgb3IgYSBwYXRoXHJcbiAqXHJcbiAqIEV2ZXJ5dGhpbmcgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgJzovLycgaXMgYXNzdW1lZCB0byBiZSBhIGxvY2FsIHBhdGguIEJvdGggUE9TSVggYW5kIFdpbmRvd3NcclxuICogcGF0aHMgYXJlIGxlZ2FsXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZSh1cmk6IE51Y2xpZGVVcmkpOiBQYXJzZWRVcmwge1xyXG4gIGlmICh1cmkuc3RhcnRzV2l0aChSRU1PVEVfUEFUSF9VUklfUFJFRklYKSkge1xyXG4gICAgY29uc3QgaG9zdEFuZFBhdGggPSB1cmkuc3Vic3RyKFJFTU9URV9QQVRIX1VSSV9QUkVGSVgubGVuZ3RoKTtcclxuICAgIGNvbnN0IGhvc3RTZXAgPSBob3N0QW5kUGF0aC5pbmRleE9mKCcvJyk7XHJcblxyXG4gICAgaW52YXJpYW50KFxyXG4gICAgICBob3N0U2VwICE9PSAtMSxcclxuICAgICAgYFJlbW90ZSBVUklzIG11c3QgY29udGFpbiBhIGhvc3RuYW1lIGFuZCBhIHBhdGguIEZhaWxlZCB0byBwYXJzZSAke3VyaX1gLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBob3N0bmFtZSA9IGhvc3RBbmRQYXRoLnN1YnN0cigwLCBob3N0U2VwKTtcclxuICAgIGludmFyaWFudChcclxuICAgICAgaG9zdG5hbWUgIT09ICcnLFxyXG4gICAgICBgUmVtb3RlIFVSSXMgbXVzdCBjb250YWluIGEgaG9zdG5hbWUuIEZhaWxlZCB0byBwYXJzZSAke3VyaX1gLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBwYXRoID0gaG9zdEFuZFBhdGguc3Vic3RyKGhvc3RTZXApO1xyXG4gICAgaW52YXJpYW50KFxyXG4gICAgICAhX2VuZHNXaXRoQXJjaGl2ZVNlcGFyYXRvcih1cmkpLFxyXG4gICAgICBgUGF0aCBjYW5ub3QgZW5kIHdpdGggYXJjaGl2ZSBzZXBhcmF0b3IuIEZhaWxlZCB0byBwYXJzZSAke3VyaX1gLFxyXG4gICAgKTtcclxuICAgIHJldHVybiB7aG9zdG5hbWUsIHBhdGh9O1xyXG4gIH1cclxuXHJcbiAgaW52YXJpYW50KFxyXG4gICAgIV9lbmRzV2l0aEFyY2hpdmVTZXBhcmF0b3IodXJpKSxcclxuICAgIGBQYXRoIGNhbm5vdCBlbmQgd2l0aCBhcmNoaXZlIHNlcGFyYXRvci4gRmFpbGVkIHRvIHBhcnNlICR7dXJpfWAsXHJcbiAgKTtcclxuICByZXR1cm4ge2hvc3RuYW1lOiBudWxsLCBwYXRoOiB1cml9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVJlbW90ZVVyaShyZW1vdGVVcmk6IE51Y2xpZGVVcmkpOiBQYXJzZWRSZW1vdGVVcmwge1xyXG4gIGlmICghaXNSZW1vdGUocmVtb3RlVXJpKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZW1vdGUgdXJpLiBHb3QgJyArIHJlbW90ZVVyaSk7XHJcbiAgfVxyXG4gIGNvbnN0IHBhcnNlZFVyaSA9IHBhcnNlKHJlbW90ZVVyaSk7XHJcbiAgaW52YXJpYW50KFxyXG4gICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHNrZXRjaHktbnVsbC1zdHJpbmc6b2ZmXHJcbiAgICBwYXJzZWRVcmkuaG9zdG5hbWUsXHJcbiAgICBgUmVtb3RlIE51Y2xpZGUgVVJJcyBtdXN0IGNvbnRhaW4gaG9zdG5hbWVzLCAnJHttYXliZVRvU3RyaW5nKFxyXG4gICAgICBwYXJzZWRVcmkuaG9zdG5hbWUsXHJcbiAgICApfScgZm91bmQgd2hpbGUgcGFyc2luZyAnJHtyZW1vdGVVcml9J2AsXHJcbiAgKTtcclxuXHJcbiAgLy8gRXhwbGljaXRseSBjb3B5aW5nIG9iamVjdCBwcm9wZXJ0aWVzIGFwcGVhc2VzIEZsb3cncyBcIm1heWJlXCIgdHlwZSBoYW5kbGluZy4gVXNpbmcgdGhlIGAuLi5gXHJcbiAgLy8gb3BlcmF0b3IgY2F1c2VzIG51bGwvdW5kZWZpbmVkIGVycm9ycywgYW5kIGBPYmplY3QuYXNzaWduYCBieXBhc3NlcyB0eXBlIGNoZWNraW5nLlxyXG4gIHJldHVybiB7XHJcbiAgICBob3N0bmFtZTogcGFyc2VkVXJpLmhvc3RuYW1lLFxyXG4gICAgcGF0aDogcGFyc2VkVXJpLnBhdGgsXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0UGF0aCh1cmk6IE51Y2xpZGVVcmkpOiBzdHJpbmcge1xyXG4gIHJldHVybiBwYXJzZSh1cmkpLnBhdGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhvc3RuYW1lKHJlbW90ZVVyaTogTnVjbGlkZVVyaSk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHBhcnNlUmVtb3RlVXJpKHJlbW90ZVVyaSkuaG9zdG5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhvc3RuYW1lT3B0KHJlbW90ZVVyaTogP051Y2xpZGVVcmkpOiA/c3RyaW5nIHtcclxuICBpZiAocmVtb3RlVXJpID09IG51bGwgfHwgIWlzUmVtb3RlKHJlbW90ZVVyaSkpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGdldEhvc3RuYW1lKHJlbW90ZVVyaSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGpvaW4odXJpOiBOdWNsaWRlVXJpLCAuLi5yZWxhdGl2ZVBhdGg6IEFycmF5PHN0cmluZz4pOiBOdWNsaWRlVXJpIHtcclxuICByZXR1cm4gam9pbkFycmF5KHVyaSwgcmVsYXRpdmVQYXRoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gam9pbkFycmF5KHVyaTogTnVjbGlkZVVyaSwgcmVsYXRpdmVQYXRoOiBBcnJheTxzdHJpbmc+KTogTnVjbGlkZVVyaSB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgY29uc3QgdXJpUGF0aE1vZHVsZSA9IF9wYXRoTW9kdWxlRm9yKHVyaSk7XHJcbiAgaWYgKGlzUmVtb3RlKHVyaSkpIHtcclxuICAgIGNvbnN0IHtob3N0bmFtZSwgcGF0aH0gPSBwYXJzZVJlbW90ZVVyaSh1cmkpO1xyXG4gICAgcmVsYXRpdmVQYXRoLnNwbGljZSgwLCAwLCBwYXRoKTtcclxuICAgIF9hcmNoaXZlRW5jb2RlQXJyYXlJblBsYWNlKHVyaVBhdGhNb2R1bGUsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICByZXR1cm4gX2FyY2hpdmVEZWNvZGUoXHJcbiAgICAgIHVyaVBhdGhNb2R1bGUsXHJcbiAgICAgIGNyZWF0ZVJlbW90ZVVyaShob3N0bmFtZSwgdXJpUGF0aE1vZHVsZS5qb2luLmFwcGx5KG51bGwsIHJlbGF0aXZlUGF0aCkpLFxyXG4gICAgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmVsYXRpdmVQYXRoLnNwbGljZSgwLCAwLCB1cmkpO1xyXG4gICAgX2FyY2hpdmVFbmNvZGVBcnJheUluUGxhY2UodXJpUGF0aE1vZHVsZSwgcmVsYXRpdmVQYXRoKTtcclxuICAgIHJldHVybiBfYXJjaGl2ZURlY29kZShcclxuICAgICAgdXJpUGF0aE1vZHVsZSxcclxuICAgICAgdXJpUGF0aE1vZHVsZS5qb2luLmFwcGx5KG51bGwsIHJlbGF0aXZlUGF0aCksXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXJjaGl2ZUpvaW4odXJpOiBOdWNsaWRlVXJpLCBwYXRoOiBzdHJpbmcpOiBOdWNsaWRlVXJpIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBpZiAoIUtOT1dOX0FSQ0hJVkVfRVhURU5TSU9OUy5zb21lKGV4dCA9PiB1cmkuZW5kc1dpdGgoZXh0KSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFyY2hpdmVKb2luIHdpdGggbm9uLWFyY2hpdmUgJHt1cml9IGFuZCAke3BhdGh9YCk7XHJcbiAgfVxyXG4gIHJldHVybiB1cmkgKyBBUkNISVZFX1NFUEFSQVRPUiArIHBhdGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmk6IE51Y2xpZGVVcmkpOiBOdWNsaWRlVXJpIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IodXJpKTtcclxuICBpZiAoaXNSZW1vdGUodXJpKSkge1xyXG4gICAgY29uc3Qge2hvc3RuYW1lLCBwYXRofSA9IHBhcnNlUmVtb3RlVXJpKHVyaSk7XHJcbiAgICBjb25zdCBub3JtYWwgPSBfYXJjaGl2ZURlY29kZShcclxuICAgICAgdXJpUGF0aE1vZHVsZSxcclxuICAgICAgdXJpUGF0aE1vZHVsZS5ub3JtYWxpemUoX2FyY2hpdmVFbmNvZGUodXJpUGF0aE1vZHVsZSwgcGF0aCkpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBjcmVhdGVSZW1vdGVVcmkoaG9zdG5hbWUsIG5vcm1hbCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBfYXJjaGl2ZURlY29kZShcclxuICAgICAgdXJpUGF0aE1vZHVsZSxcclxuICAgICAgdXJpUGF0aE1vZHVsZS5ub3JtYWxpemUoX2FyY2hpdmVFbmNvZGUodXJpUGF0aE1vZHVsZSwgdXJpKSksXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyKHVyaTogTnVjbGlkZVVyaSk6IE51Y2xpZGVVcmkge1xyXG4gIHJldHVybiBlbnN1cmVUcmFpbGluZ1NlcGFyYXRvcihub3JtYWxpemUodXJpKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBhcmVudCh1cmk6IE51Y2xpZGVVcmkpOiBOdWNsaWRlVXJpIHtcclxuICAvLyBUT0RPOiBJcyB0aGlzIGRpZmZlcmVudCB0aGFuIGRpcm5hbWU/XHJcbiAgcmV0dXJuIG5vcm1hbGl6ZShqb2luKHVyaSwgJy4uJykpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWxhdGl2ZSh1cmk6IE51Y2xpZGVVcmksIG90aGVyOiBOdWNsaWRlVXJpKTogc3RyaW5nIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IodXJpKTtcclxuICBjb25zdCByZW1vdGUgPSBpc1JlbW90ZSh1cmkpO1xyXG4gIGlmIChcclxuICAgIHJlbW90ZSAhPT0gaXNSZW1vdGUob3RoZXIpIHx8XHJcbiAgICAocmVtb3RlICYmIGdldEhvc3RuYW1lKHVyaSkgIT09IGdldEhvc3RuYW1lKG90aGVyKSlcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYENhbm5vdCByZWxhdGl2ZSB1cmxzIG9uIGRpZmZlcmVudCBob3N0czogJHt1cml9IGFuZCAke290aGVyfWAsXHJcbiAgICApO1xyXG4gIH1cclxuICBjb25zdCB1cmlFbmNvZGUgPSBfYXJjaGl2ZUVuY29kZSh1cmlQYXRoTW9kdWxlLCByZW1vdGUgPyBnZXRQYXRoKHVyaSkgOiB1cmkpO1xyXG4gIGNvbnN0IG90aGVyRW5jb2RlID0gX2FyY2hpdmVFbmNvZGUoXHJcbiAgICB1cmlQYXRoTW9kdWxlLFxyXG4gICAgcmVtb3RlID8gZ2V0UGF0aChvdGhlcikgOiBvdGhlcixcclxuICApO1xyXG4gIHJldHVybiBfYXJjaGl2ZURlY29kZShcclxuICAgIHVyaVBhdGhNb2R1bGUsXHJcbiAgICB1cmlQYXRoTW9kdWxlLnJlbGF0aXZlKFxyXG4gICAgICBfbWF0Y2hUcmFpbGluZ0FyY2hpdmUodXJpRW5jb2RlLCBvdGhlckVuY29kZSksXHJcbiAgICAgIF9tYXRjaFRyYWlsaW5nQXJjaGl2ZShvdGhlckVuY29kZSwgdXJpRW5jb2RlKSxcclxuICAgICksXHJcbiAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYmFzZW5hbWUodXJpOiBOdWNsaWRlVXJpLCBleHQ6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IodXJpKTtcclxuICByZXR1cm4gX2FyY2hpdmVEZWNvZGUoXHJcbiAgICB1cmlQYXRoTW9kdWxlLFxyXG4gICAgdXJpUGF0aE1vZHVsZS5iYXNlbmFtZShfYXJjaGl2ZUVuY29kZSh1cmlQYXRoTW9kdWxlLCBnZXRQYXRoKHVyaSkpLCBleHQpLFxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRpcm5hbWUodXJpOiBOdWNsaWRlVXJpKTogTnVjbGlkZVVyaSB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgY29uc3QgdXJpUGF0aE1vZHVsZSA9IF9wYXRoTW9kdWxlRm9yKHVyaSk7XHJcbiAgaWYgKGlzUmVtb3RlKHVyaSkpIHtcclxuICAgIGNvbnN0IHtob3N0bmFtZSwgcGF0aH0gPSBwYXJzZVJlbW90ZVVyaSh1cmkpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlbW90ZVVyaShcclxuICAgICAgaG9zdG5hbWUsXHJcbiAgICAgIF9hcmNoaXZlRGVjb2RlKFxyXG4gICAgICAgIHVyaVBhdGhNb2R1bGUsXHJcbiAgICAgICAgdXJpUGF0aE1vZHVsZS5kaXJuYW1lKF9hcmNoaXZlRW5jb2RlKHVyaVBhdGhNb2R1bGUsIHBhdGgpKSxcclxuICAgICAgKSxcclxuICAgICk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBfYXJjaGl2ZURlY29kZShcclxuICAgICAgdXJpUGF0aE1vZHVsZSxcclxuICAgICAgdXJpUGF0aE1vZHVsZS5kaXJuYW1lKF9hcmNoaXZlRW5jb2RlKHVyaVBhdGhNb2R1bGUsIHVyaSkpLFxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4dG5hbWUodXJpOiBOdWNsaWRlVXJpKTogc3RyaW5nIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IodXJpKTtcclxuICByZXR1cm4gX2FyY2hpdmVEZWNvZGUoXHJcbiAgICB1cmlQYXRoTW9kdWxlLFxyXG4gICAgdXJpUGF0aE1vZHVsZS5leHRuYW1lKF9hcmNoaXZlRW5jb2RlKHVyaVBhdGhNb2R1bGUsIGdldFBhdGgodXJpKSkpLFxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmlwRXh0ZW5zaW9uKHVyaTogTnVjbGlkZVVyaSk6IE51Y2xpZGVVcmkge1xyXG4gIF90ZXN0Rm9ySWxsZWdhbFVyaSh1cmkpO1xyXG4gIGNvbnN0IGV4dCA9IGV4dG5hbWUodXJpKTtcclxuICBpZiAoZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIHVyaTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1cmkuc2xpY2UoMCwgLTEgKiBleHQubGVuZ3RoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2lzV2luZG93c1BhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIF9wYXRoTW9kdWxlRm9yKHBhdGgpID09PSBwYXRoTW9kdWxlLndpbjMyO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfZ2V0V2luZG93c1BhdGhGcm9tV2luZG93c0ZpbGVVcmkodXJpOiBzdHJpbmcpOiA/c3RyaW5nIHtcclxuICBjb25zdCBwcmVmaXggPSAnZmlsZTovLyc7XHJcbiAgaWYgKCF1cmkuc3RhcnRzV2l0aChwcmVmaXgpKSB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHBhdGggPSB1cmkuc3Vic3RyKHByZWZpeC5sZW5ndGgpO1xyXG4gIHJldHVybiBfaXNXaW5kb3dzUGF0aChwYXRoKSA/IHBhdGggOiBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogdXJpIGlzIGVpdGhlciBhIGZpbGU6IHVyaSwgb3IgYSBudWNsaWRlOiB1cmkuXHJcbiAqIG11c3QgY29udmVydCBmaWxlOiB1cmkncyB0byBqdXN0IGEgcGF0aCBmb3IgYXRvbS5cclxuICpcclxuICogUmV0dXJucyBudWxsIGlmIG5vdCBhIHZhbGlkIGZpbGU6IFVSSS5cclxuICovXHJcbmZ1bmN0aW9uIHVyaVRvTnVjbGlkZVVyaSh1cmk6IHN0cmluZyk6ID9zdHJpbmcge1xyXG4gIC8vIGZpbGU6Ly8gVVJJcyBzaG91bGQgbmV2ZXIgbm9ybWFsbHkgY29udGFpbiBXaW5kb3dzIGJhY2tzbGFzaGVzOlxyXG4gIC8vIGUuZy4gdnNjb2RlLXVyaSBlc2NhcGVzIEM6XFxhYmMgdG8gZmlsZTovLy9jOi9hYmMuXHJcbiAgLy8gVGhpcyBqdXN0IGhhbmRsZXMgYW55IGhhY2t5IHVzZXJzIHRoYXQgc2ltcGx5IHByZXBlbmRlZCAnZmlsZTovLycuXHJcbiAgLy8gKHZzY29kZS11cmkgZG9lcyBub3Qga25vdyBob3cgdG8gaGFuZGxlIGZpbGU6Ly9DOlxcYWJjLilcclxuICBjb25zdCB3aW5kb3dzUGF0aEZyb21VcmkgPSBfZ2V0V2luZG93c1BhdGhGcm9tV2luZG93c0ZpbGVVcmkodXJpKTtcclxuICBpZiAod2luZG93c1BhdGhGcm9tVXJpICE9IG51bGwpIHtcclxuICAgIHJldHVybiB3aW5kb3dzUGF0aEZyb21Vcmk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBsc3BVcmkgPSBMc3BVcmkucGFyc2UodXJpKTtcclxuICBpZiAobHNwVXJpLnNjaGVtZSA9PT0gJ2ZpbGUnICYmIGxzcFVyaS5wYXRoKSB7XHJcbiAgICAvLyBvbmx5IGhhbmRsZSByZWFsIGZpbGVzIGZvciBub3cuXHJcbiAgICByZXR1cm4gbHNwVXJpLmZzUGF0aDtcclxuICB9IGVsc2UgaWYgKGlzUmVtb3RlKHVyaSkpIHtcclxuICAgIHJldHVybiB1cmk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGxvY2FsIHBhdGhzIHRvIGZpbGU6IFVSSSdzLiBMZWF2ZXMgcmVtb3RlIFVSSSdzIGFsb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gbnVjbGlkZVVyaVRvVXJpKHVyaTogTnVjbGlkZVVyaSk6IHN0cmluZyB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgaWYgKGlzUmVtb3RlKHVyaSkpIHtcclxuICAgIHJldHVybiB1cmk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBMc3BVcmkuZmlsZSh1cmkpLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGNoaWxkIGlzIGVxdWFsIHRvLCBvciBpcyBhIHByb3BlciBkZXNjZW5kYW50IG9mIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudDogTnVjbGlkZVVyaSwgY2hpbGQ6IE51Y2xpZGVVcmkpOiBib29sZWFuIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkocGFyZW50KTtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkoY2hpbGQpO1xyXG5cclxuICAvLyBDYW4ndCBqdXN0IGRvIHN0YXJ0c1dpdGggaGVyZS4gSWYgdGhpcyBkaXJlY3RvcnkgaXMgXCJ3d3dcIiBhbmQgeW91XHJcbiAgLy8gYXJlIHRyeWluZyB0byBjaGVjayBcInd3dy1iYXNlXCIsIGp1c3QgdXNpbmcgc3RhcnRzV2l0aCB3b3VsZCByZXR1cm5cclxuICAvLyB0cnVlLCBldmVuIHRob3VnaCBcInd3dy1iYXNlXCIgaXMgYXQgdGhlIHNhbWUgbGV2ZWwgYXMgXCJXd3dcIiwgbm90XHJcbiAgLy8gY29udGFpbmVkIGluIGl0LlxyXG4gIC8vIEFsc28sIHRoZXJlJ3MgYW4gaXNzdWUgd2l0aCBhIHRyYWlsaW5nIHNlcGFyYXRvciBhbWJpZ3VpdHkuIEEgcGF0aFxyXG4gIC8vIGxpa2UgL2FiYy8gZG9lcyBjb250YWluIC9hYmNcclxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gc29tZSBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgcGFydHMsIHNvIHdlXHJcbiAgLy8gd2FudCB0byBhdm9pZCBkb2luZyB1bm5lY2Vzc2FyeSBzdHJpbmcgY29weSwgYXMgdGhvc2UgdGhhdCB3b3VsZFxyXG4gIC8vIHJlc3VsdCBmcm9tIGFuIGVuc3VyZVRyYWlsaW5nU2VwYXJhdG9yKCkgY2FsbFxyXG4gIC8vXHJcbiAgLy8gRmlyc3Qgd2UnbGwgY2hlY2sgdGhlIGxlbmd0aHMuXHJcbiAgLy8gVGhlbiBjaGVjayBzdGFydHNXaXRoLiBJZiBzbywgdGhlbiBpZiB0aGUgdHdvIHBhdGggbGVuZ3RocyBhcmVcclxuICAvLyBlcXVhbCBPUiBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaW4gdGhlIHBhdGggdG8gY2hlY2sgaXMgYSBwYXRoXHJcbiAgLy8gc2VwYXJhdG9yLCB0aGVuIHdlIGtub3cgdGhlIGNoZWNrZWQgcGF0aCBpcyBpbiB0aGlzIHBhdGguXHJcblxyXG4gIGlmIChjaGlsZC5sZW5ndGggPCBwYXJlbnQubGVuZ3RoKSB7XHJcbiAgICAvLyBBIHN0cm9uZyBpbmRpY2F0aW9uIG9mIGZhbHNlXHJcbiAgICAvLyBJdCBjb3VsZCBiZSBhIG1hdHRlciBvZiBhIHRyYWlsaW5nIHNlcGFyYXRvciwgdGhvdWdoXHJcbiAgICBpZiAoY2hpbGQubGVuZ3RoIDwgcGFyZW50Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgLy8gSXQgbXVzdCBiZSBtb3JlIHRoYW4ganVzdCB0aGUgc2VwYXJhdG9yXHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBwYXJlbnQuc3RhcnRzV2l0aChjaGlsZCkgJiZcclxuICAgICAgKGVuZHNXaXRoU2VwYXJhdG9yKHBhcmVudCkgfHwgX2lzQXJjaGl2ZVNlcGFyYXRvcihjaGlsZCwgcGFyZW50Lmxlbmd0aCkpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFjaGlsZC5zdGFydHNXaXRoKHBhcmVudCkpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChlbmRzV2l0aFNlcGFyYXRvcihwYXJlbnQpIHx8IHBhcmVudC5sZW5ndGggPT09IGNoaWxkLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IoY2hpbGQpO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgX2lzQXJjaGl2ZVNlcGFyYXRvcihjaGlsZCwgcGFyZW50Lmxlbmd0aCkgfHxcclxuICAgIGNoaWxkLnNsaWNlKHBhcmVudC5sZW5ndGgpLnN0YXJ0c1dpdGgodXJpUGF0aE1vZHVsZS5zZXApXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbHRlciBhbiBhcnJheSBvZiBwYXRocyB0byBjb250YWluIG9ubHkgdGhlIGNvbGxhcHNlZCByb290IHBhdGhzLCBlLmcuXHJcbiAqIFthL2IvYywgYS8sIGMvZC8sIGMvZC9lXSBjb2xsYXBzZXMgdG8gW2EvLCBjL2QvXVxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGFwc2UocGF0aHM6IEFycmF5PE51Y2xpZGVVcmk+KTogQXJyYXk8TnVjbGlkZVVyaT4ge1xyXG4gIHJldHVybiBwYXRocy5maWx0ZXIocCA9PiAhcGF0aHMuc29tZShmcCA9PiBjb250YWlucyhmcCwgcCkgJiYgZnAgIT09IHApKTtcclxufVxyXG5cclxuY29uc3QgaG9zdEZvcm1hdHRlcnMgPSBbXTtcclxuXHJcbi8vIEEgZm9ybWF0dGVyIHdoaWNoIG1heSBzaG9ydGVuIGhvc3RuYW1lcy5cclxuLy8gUmV0dXJucyBudWxsIGlmIHRoZSBmb3JtYXR0ZXIgd29uJ3Qgc2hvcnRlbiB0aGUgaG9zdG5hbWUuXHJcbmV4cG9ydCB0eXBlIEhvc3RuYW1lRm9ybWF0dGVyID0gKHVyaTogTnVjbGlkZVVyaSkgPT4gP3N0cmluZztcclxuXHJcbi8vIFJlZ2lzdGVycyBhIGhvc3QgZm9ybWF0dGVyIGZvciBudWNsaWRlVXJpVG9EaXNwbGF5U3RyaW5nXHJcbmZ1bmN0aW9uIHJlZ2lzdGVySG9zdG5hbWVGb3JtYXR0ZXIoZm9ybWF0dGVyOiBIb3N0bmFtZUZvcm1hdHRlcik6IElEaXNwb3NhYmxlIHtcclxuICBob3N0Rm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XHJcbiAgcmV0dXJuIHtcclxuICAgIGRpc3Bvc2U6ICgpID0+IHtcclxuICAgICAgY29uc3QgaW5kZXggPSBob3N0Rm9ybWF0dGVycy5pbmRleE9mKGZvcm1hdHRlcik7XHJcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgaG9zdEZvcm1hdHRlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBob3N0bmFtZVRvRGlzcGxheUhvc3RuYW1lKGhvc3RuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBob3N0Rm9ybWF0dGVycy5yZWR1Y2UoKGN1cnJlbnQsIGZvcm1hdHRlcikgPT4ge1xyXG4gICAgY29uc3QgbmV4dCA9IGZvcm1hdHRlcihjdXJyZW50KTtcclxuICAgIGlmIChuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gJycpIHtcclxuICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuICB9LCBob3N0bmFtZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG51Y2xpZGVVcmlUb0Rpc3BsYXlIb3N0bmFtZSh1cmk6IE51Y2xpZGVVcmkpOiBzdHJpbmcge1xyXG4gIF90ZXN0Rm9ySWxsZWdhbFVyaSh1cmkpO1xyXG4gIHJldHVybiBpc1JlbW90ZSh1cmkpID8gaG9zdG5hbWVUb0Rpc3BsYXlIb3N0bmFtZShnZXRIb3N0bmFtZSh1cmkpKSA6IHVyaTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE51Y2xpZGVVcmlzIHNob3VsZCBuZXZlciBiZSBzaG93biB0byBodW1hbnMuXHJcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGh1bWFuIHVzYWJsZSBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBudWNsaWRlVXJpVG9EaXNwbGF5U3RyaW5nKHVyaTogTnVjbGlkZVVyaSk6IHN0cmluZyB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgcmV0dXJuIGlzUmVtb3RlKHVyaSlcclxuICAgID8gYCR7bnVjbGlkZVVyaVRvRGlzcGxheUhvc3RuYW1lKHVyaSl9OiR7Z2V0UGF0aCh1cmkpfWBcclxuICAgIDogdXJpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NlcGFyYXRvcih1cmk6IE51Y2xpZGVVcmkpOiBOdWNsaWRlVXJpIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IodXJpKTtcclxuICBpZiAodXJpLmVuZHNXaXRoKHVyaVBhdGhNb2R1bGUuc2VwKSkge1xyXG4gICAgcmV0dXJuIHVyaTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1cmkgKyB1cmlQYXRoTW9kdWxlLnNlcDtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpbVRyYWlsaW5nU2VwYXJhdG9yKHVyaTogTnVjbGlkZVVyaSk6IE51Y2xpZGVVcmkge1xyXG4gIF90ZXN0Rm9ySWxsZWdhbFVyaSh1cmkpO1xyXG4gIGNvbnN0IHVyaVBhdGhNb2R1bGUgPSBfcGF0aE1vZHVsZUZvcih1cmkpO1xyXG4gIGxldCBzdHJpcHBlZCA9IHVyaTtcclxuXHJcbiAgd2hpbGUgKHN0cmlwcGVkLmVuZHNXaXRoKHVyaVBhdGhNb2R1bGUuc2VwKSAmJiAhaXNSb290KHN0cmlwcGVkKSkge1xyXG4gICAgc3RyaXBwZWQgPSBzdHJpcHBlZC5zbGljZSgwLCAtMSAqIHVyaVBhdGhNb2R1bGUuc2VwLmxlbmd0aCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyaXBwZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuZHNXaXRoU2VwYXJhdG9yKHVyaTogTnVjbGlkZVVyaSk6IGJvb2xlYW4ge1xyXG4gIF90ZXN0Rm9ySWxsZWdhbFVyaSh1cmkpO1xyXG4gIGNvbnN0IHVyaVBhdGhNb2R1bGUgPSBfcGF0aE1vZHVsZUZvcih1cmkpO1xyXG4gIHJldHVybiB1cmkuZW5kc1dpdGgodXJpUGF0aE1vZHVsZS5zZXApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlbmRzV2l0aEVkZW5EaXIodXJpOiBOdWNsaWRlVXJpKTogYm9vbGVhbiB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgcmV0dXJuIHVyaS5lbmRzV2l0aCgnLmVkZW4nKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNBYnNvbHV0ZSh1cmk6IE51Y2xpZGVVcmkpOiBib29sZWFuIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBpZiAoaXNSZW1vdGUodXJpKSkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHVyaVBhdGhNb2R1bGUgPSBfcGF0aE1vZHVsZUZvcih1cmkpO1xyXG4gICAgcmV0dXJuIHVyaVBhdGhNb2R1bGUuaXNBYnNvbHV0ZSh1cmkpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVzb2x2ZSh1cmk6IE51Y2xpZGVVcmksIC4uLnBhdGhzOiBBcnJheTxzdHJpbmc+KTogTnVjbGlkZVVyaSB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgY29uc3QgdXJpUGF0aE1vZHVsZSA9IF9wYXRoTW9kdWxlRm9yKHVyaSk7XHJcbiAgaWYgKGlzUmVtb3RlKHVyaSkpIHtcclxuICAgIGNvbnN0IHtob3N0bmFtZSwgcGF0aH0gPSBwYXJzZVJlbW90ZVVyaSh1cmkpO1xyXG4gICAgcGF0aHMuc3BsaWNlKDAsIDAsIHBhdGgpO1xyXG4gICAgX2FyY2hpdmVFbmNvZGVBcnJheUluUGxhY2UodXJpUGF0aE1vZHVsZSwgcGF0aHMpO1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlbW90ZVVyaShcclxuICAgICAgaG9zdG5hbWUsXHJcbiAgICAgIF9hcmNoaXZlRGVjb2RlKHVyaVBhdGhNb2R1bGUsIHVyaVBhdGhNb2R1bGUucmVzb2x2ZS5hcHBseShudWxsLCBwYXRocykpLFxyXG4gICAgKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcGF0aHMuc3BsaWNlKDAsIDAsIHVyaSk7XHJcbiAgICBfYXJjaGl2ZUVuY29kZUFycmF5SW5QbGFjZSh1cmlQYXRoTW9kdWxlLCBwYXRocyk7XHJcbiAgICByZXR1cm4gX2FyY2hpdmVEZWNvZGUoXHJcbiAgICAgIHVyaVBhdGhNb2R1bGUsXHJcbiAgICAgIHVyaVBhdGhNb2R1bGUucmVzb2x2ZS5hcHBseShudWxsLCBwYXRocyksXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gaXNIb21lUmVsYXRpdmUodXJpOiBOdWNsaWRlVXJpKTogYm9vbGVhbiB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgcmV0dXJuIHVyaS5zdGFydHNXaXRoKCd+Jyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGV4cGFuZEhvbWVEaXIodXJpOiBOdWNsaWRlVXJpKTogTnVjbGlkZVVyaSB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcblxyXG4gIC8vIERvIG5vdCBleHBhbmQgbm9uIGhvbWUgcmVsYXRpdmUgdXJpc1xyXG4gIGlmICghdXJpLnN0YXJ0c1dpdGgoJ34nKSkge1xyXG4gICAgcmV0dXJuIHVyaTtcclxuICB9XHJcblxyXG4gIC8vIFwiaG9tZVwiIG9uIFdpbmRvd3MgaXMgJVVzZXJQcm9maWxlJS4gTm90ZSB0aGF0IFdpbmRvd3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXHJcbiAgLy8gYXJlIE5PVCBjYXNlIHNlbnNpdGl2ZSwgYnV0IHByb2Nlc3MuZW52IGlzIGEgbWFnaWMgb2JqZWN0IHRoYXQgd3JhcHMgR2V0RW52aXJvbm1lbnRWYXJpYWJsZVdcclxuICAvLyBvbiBXaW5kb3dzLCBzbyBhc2tpbmcgZm9yIGFueSBjYXNlIGlzIGV4cGVjdGVkIHRvIHdvcmsuXHJcbiAgY29uc3Qge0hPTUUsIFVzZXJQcm9maWxlfSA9IHByb2Nlc3MuZW52O1xyXG5cclxuICBjb25zdCBpc1dpbmRvd3MgPSAhaXNSZW1vdGUodXJpKSAmJiBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInO1xyXG4gIGNvbnN0IGhvbWVQYXRoID0gaXNXaW5kb3dzID8gVXNlclByb2ZpbGUgOiBIT01FO1xyXG4gIGludmFyaWFudChob21lUGF0aCAhPSBudWxsKTtcclxuXHJcbiAgaWYgKHVyaSA9PT0gJ34nKSB7XHJcbiAgICByZXR1cm4gaG9tZVBhdGg7XHJcbiAgfVxyXG5cclxuICAvLyBVcmlzIGxpa2UgfmFiYyBzaG91bGQgbm90IGJlIGV4cGFuZGVkXHJcbiAgaWYgKCF1cmkuc3RhcnRzV2l0aCgnfi8nKSAmJiAoIWlzV2luZG93cyB8fCAhdXJpLnN0YXJ0c1dpdGgoJ35cXFxcJykpKSB7XHJcbiAgICByZXR1cm4gdXJpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhdGhNb2R1bGUucmVzb2x2ZShob21lUGF0aCwgdXJpLnJlcGxhY2UoJ34nLCAnLicpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNwbGl0cyBhIHN0cmluZyBjb250YWluaW5nIGxvY2FsIHBhdGhzIGJ5IGFuIE9TLXNwZWNpZmljIHBhdGggZGVsaW1pdGVyXHJcbiAqIFVzZWZ1bCBmb3Igc3BsaXR0aW5nIGVudiB2YXJpYWJsZXMgc3VjaCBhcyBQQVRIXHJcbiAqXHJcbiAqIFNpbmNlIHJlbW90ZSBVUkkgbWlnaHQgY29udGFpbiB0aGUgZGVsaW1pdGVyLCBvbmx5IGxvY2FsIHBhdGhzIGFyZSBhbGxvd2VkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BsaXRQYXRoTGlzdChwYXRoczogc3RyaW5nKTogQXJyYXk8TnVjbGlkZVVyaT4ge1xyXG4gIGludmFyaWFudChcclxuICAgIHBhdGhzLmluZGV4T2YoUkVNT1RFX1BBVEhfVVJJX1BSRUZJWCkgPCAwLFxyXG4gICAgJ1NwbGl0dGluZyByZW1vdGUgVVJJcyBpcyBub3Qgc3VwcG9ydGVkJyxcclxuICApO1xyXG4gIGNvbnN0IHVyaVBhdGhNb2R1bGUgPSBfcGF0aE1vZHVsZUZvcihwYXRocyk7XHJcblxyXG4gIHJldHVybiBwYXRocy5zcGxpdCh1cmlQYXRoTW9kdWxlLmRlbGltaXRlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBKb2lucyBhbiBhcnJheSBvZiBsb2NhbCBwYXRocyB3aXRoIGFuIE9TLXNwZWNpZmljIHBhdGggZGVsaW1pdGVyIGludG8gYSBzaW5nbGUgc3RyaW5nLlxyXG4gKiBVc2VmdWwgZm9yIGNvbnN0cnVjdGluZyBlbnYgdmFyaWFibGVzIHN1Y2ggYXMgUEFUSFxyXG4gKlxyXG4gKiBTaW5jZSByZW1vdGUgVVJJIG1pZ2h0IGNvbnRhaW4gdGhlIGRlbGltaXRlciwgb25seSBsb2NhbCBwYXRocyBhcmUgYWxsb3dlZC5cclxuICovXHJcbmZ1bmN0aW9uIGpvaW5QYXRoTGlzdChwYXRoczogQXJyYXk8TnVjbGlkZVVyaT4pOiBzdHJpbmcge1xyXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiAnJztcclxuICB9XHJcblxyXG4gIGludmFyaWFudChcclxuICAgIHBhdGhzLmV2ZXJ5KHBhdGggPT4gIWlzUmVtb3RlKHBhdGgpKSxcclxuICAgICdKb2luaW5nIG9mIHJlbW90ZSBVUklzIGlzIG5vdCBzdXBwb3J0ZWQnLFxyXG4gICk7XHJcblxyXG4gIGNvbnN0IHVyaVBhdGhNb2R1bGUgPSBfcGF0aE1vZHVsZUZvcihwYXRoc1swXSk7XHJcbiAgcmV0dXJuIHBhdGhzLmpvaW4odXJpUGF0aE1vZHVsZS5kZWxpbWl0ZXIpO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBwcmVwZW5kcyB0aGUgZ2l2ZW4gcmVsYXRpdmUgcGF0aCB3aXRoIGEgXCJjdXJyZW50LWZvbGRlclwiIHByZWZpeFxyXG4gKiB3aGljaCBpcyBgLi9gIG9uICpuaXggYW5kIC5cXCBvbiBXaW5kb3dzXHJcbiAqL1xyXG5mdW5jdGlvbiBlbnN1cmVMb2NhbFByZWZpeCh1cmk6IE51Y2xpZGVVcmkpOiBOdWNsaWRlVXJpIHtcclxuICBfdGVzdEZvcklsbGVnYWxVcmkodXJpKTtcclxuICBjb25zdCB1cmlQYXRoTW9kdWxlID0gX3BhdGhNb2R1bGVGb3IodXJpKTtcclxuXHJcbiAgaW52YXJpYW50KCFpc1JlbW90ZSh1cmkpLCAnTG9jYWwgcHJlZml4IGNhbiBub3QgYmUgYWRkZWQgdG8gYSByZW1vdGUgcGF0aCcpO1xyXG4gIGludmFyaWFudChcclxuICAgICFpc0Fic29sdXRlKHVyaSksXHJcbiAgICAnTG9jYWwgcHJlZml4IGNhbiBub3QgYmUgYWRkZWQgdG8gYW4gYWJzb2x1dGUgcGF0aCcsXHJcbiAgKTtcclxuXHJcbiAgY29uc3QgbG9jYWxQcmVmaXggPSBgLiR7dXJpUGF0aE1vZHVsZS5zZXB9YDtcclxuICBpZiAodXJpLnN0YXJ0c1dpdGgobG9jYWxQcmVmaXgpKSB7XHJcbiAgICByZXR1cm4gdXJpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxvY2FsUHJlZml4ICsgdXJpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1Jvb3QodXJpOiBOdWNsaWRlVXJpKTogYm9vbGVhbiB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgcmV0dXJuIGRpcm5hbWUodXJpKSA9PT0gdXJpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVBhdGgodXJpOiBOdWNsaWRlVXJpKTogUGFyc2VkUGF0aCB7XHJcbiAgX3Rlc3RGb3JJbGxlZ2FsVXJpKHVyaSk7XHJcbiAgY29uc3QgdXJpUGF0aE1vZHVsZSA9IF9wYXRoTW9kdWxlRm9yKHVyaSk7XHJcbiAgY29uc3QgcGFyc2VkID0gdXJpUGF0aE1vZHVsZS5wYXJzZShcclxuICAgIF9hcmNoaXZlRW5jb2RlKHVyaVBhdGhNb2R1bGUsIGdldFBhdGgodXJpKSksXHJcbiAgKTtcclxuICByZXR1cm4ge1xyXG4gICAgcm9vdDogX2FyY2hpdmVEZWNvZGUodXJpUGF0aE1vZHVsZSwgcGFyc2VkLnJvb3QpLFxyXG4gICAgZGlyOiBfYXJjaGl2ZURlY29kZSh1cmlQYXRoTW9kdWxlLCBwYXJzZWQuZGlyKSxcclxuICAgIGJhc2U6IF9hcmNoaXZlRGVjb2RlKHVyaVBhdGhNb2R1bGUsIHBhcnNlZC5iYXNlKSxcclxuICAgIGV4dDogX2FyY2hpdmVEZWNvZGUodXJpUGF0aE1vZHVsZSwgcGFyc2VkLmV4dCksXHJcbiAgICBuYW1lOiBfYXJjaGl2ZURlY29kZSh1cmlQYXRoTW9kdWxlLCBwYXJzZWQubmFtZSksXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gcGF0aFNlcGFyYXRvckZvcih1cmk6IE51Y2xpZGVVcmkpOiBzdHJpbmcge1xyXG4gIHJldHVybiBfcGF0aE1vZHVsZUZvcih1cmkpLnNlcDtcclxufVxyXG5cclxuZnVuY3Rpb24gc3BsaXQodXJpOiBOdWNsaWRlVXJpKTogQXJyYXk8c3RyaW5nPiB7XHJcbiAgY29uc3QgcGFydHMgPSBbXTtcclxuICBsZXQgY3VycmVudCA9IHVyaTtcclxuICBsZXQgcGFyZW50ID0gZGlybmFtZShjdXJyZW50KTtcclxuXHJcbiAgd2hpbGUgKGN1cnJlbnQgIT09IHBhcmVudCkge1xyXG4gICAgcGFydHMucHVzaChiYXNlbmFtZShjdXJyZW50KSk7XHJcblxyXG4gICAgY3VycmVudCA9IHBhcmVudDtcclxuICAgIHBhcmVudCA9IGRpcm5hbWUoY3VycmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNBYnNvbHV0ZSh1cmkpKSB7XHJcbiAgICBwYXJ0cy5wdXNoKHBhcmVudCk7XHJcbiAgfVxyXG4gIHBhcnRzLnJldmVyc2UoKTtcclxuICByZXR1cm4gcGFydHM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhc0tub3duQXJjaGl2ZUV4dGVuc2lvbih1cmk6IE51Y2xpZGVVcmkpOiBib29sZWFuIHtcclxuICByZXR1cm4gS05PV05fQVJDSElWRV9FWFRFTlNJT05TLnNvbWUoZXh0ID0+IHVyaS5lbmRzV2l0aChleHQpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX3BhdGhNb2R1bGVGb3IodXJpOiBOdWNsaWRlVXJpKTogdHlwZW9mIHBhdGhNb2R1bGUge1xyXG4gIGludmFyaWFudChcclxuICAgICFfZW5kc1dpdGhBcmNoaXZlU2VwYXJhdG9yKHVyaSksXHJcbiAgICBgUGF0aCBjYW5ub3QgZW5kIHdpdGggYXJjaGl2ZSBzZXBhcmF0b3IuIEZhaWxlZCB0byBkZXRlcm1pbmUgcGF0aCBtb2R1bGUgZm9yICR7dXJpfWAsXHJcbiAgKTtcclxuICBpZiAodXJpLnN0YXJ0c1dpdGgocGF0aE1vZHVsZS5wb3NpeC5zZXApKSB7XHJcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5wb3NpeDtcclxuICB9XHJcbiAgaWYgKHVyaS5pbmRleE9mKCc6Ly8nKSA+IC0xKSB7XHJcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5wb3NpeDtcclxuICB9XHJcbiAgaWYgKHVyaVsxXSA9PT0gJzonICYmIHVyaVsyXSA9PT0gcGF0aE1vZHVsZS53aW4zMi5zZXApIHtcclxuICAgIHJldHVybiBwYXRoTW9kdWxlLndpbjMyO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhpcyBsaXR0bGUgcnVzc2lhbiByb3VsZXR0ZSBoZXJlIGlzIGJsb2NraW5nIFQyOTk5MDU5My4gSSBkaWRuJ3RcclxuICAvLyBjbGVhbiBpdCBiZWNhdXNlIHdlIG1pZ2h0IHNlZSBwb3NpeCBwYXRocyBvbiB3aW5kb3dzIGFuZCB2aWNlIHZlcnNhLlxyXG4gIGlmIChcclxuICAgIHVyaS5zcGxpdChwYXRoTW9kdWxlLndpbjMyLnNlcCkubGVuZ3RoID5cclxuICAgIHVyaS5zcGxpdChwYXRoTW9kdWxlLnBvc2l4LnNlcCkubGVuZ3RoXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gcGF0aE1vZHVsZS53aW4zMjtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHBhdGhNb2R1bGUucG9zaXg7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBSdW5zIF9hcmNoaXZlRW5jb2RlIGluLXBsYWNlIG9uIGFycmF5LCBhbmQgcmV0dXJucyBhcmd1bWVudCBmb3IgY29udmVuaWVuY2UuXHJcbmZ1bmN0aW9uIF9hcmNoaXZlRW5jb2RlQXJyYXlJblBsYWNlKFxyXG4gIHVyaVBhdGhNb2R1bGU6IHR5cGVvZiBwYXRoTW9kdWxlLFxyXG4gIGFycmF5OiBBcnJheTxOdWNsaWRlVXJpPixcclxuKTogQXJyYXk8TnVjbGlkZVVyaT4ge1xyXG4gIGFycmF5LmZvckVhY2goKHVyaSwgaSwgYSkgPT4gKGFbaV0gPSBfYXJjaGl2ZUVuY29kZSh1cmlQYXRoTW9kdWxlLCB1cmkpKSk7XHJcbiAgcmV0dXJuIGFycmF5O1xyXG59XHJcblxyXG4vLyBUaGlzIGFkZHMgYSBuYXRpdmUgc2VwYXJhdG9yIGFmdGVyIGV2ZXJ5IGFyY2hpdmUgc2VwYXJhdG9yXHJcbi8vIHNvIHRoYXQgdGhlIG5hdGl2ZSBwYXRoIGhhbmRsaW5nIGNvZGUgc2VlcyB0aGVtLlxyXG5mdW5jdGlvbiBfYXJjaGl2ZUVuY29kZShcclxuICB1cmlQYXRoTW9kdWxlOiB0eXBlb2YgcGF0aE1vZHVsZSxcclxuICB1cmk6IE51Y2xpZGVVcmksXHJcbik6IE51Y2xpZGVVcmkge1xyXG4gIGlmICh1cmkuaW5kZXhPZihBUkNISVZFX1NFUEFSQVRPUikgPCAwKSB7XHJcbiAgICByZXR1cm4gdXJpO1xyXG4gIH1cclxuICByZXR1cm4gS05PV05fQVJDSElWRV9FWFRFTlNJT05TLnJlZHVjZShcclxuICAgIChhY2MsIGV4dCkgPT5cclxuICAgICAgYWNjLnJlcGxhY2UoXHJcbiAgICAgICAgYCR7ZXh0fSR7QVJDSElWRV9TRVBBUkFUT1J9YCxcclxuICAgICAgICBgJHtleHR9JHtBUkNISVZFX1NFUEFSQVRPUn0ke3VyaVBhdGhNb2R1bGUuc2VwfWAsXHJcbiAgICAgICksXHJcbiAgICB1cmksXHJcbiAgKTtcclxufVxyXG5cclxuLy8gVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgZW5jb2RlQXJjaGl2ZVNlcGFyYXRvcnMoKWAgdG8gcHV0IHRoaW5nc1xyXG4vLyBiYWNrIGFmdGVyIHRoZSBuYXRpdmUgcGF0aCBoYW5kbGVyIGhhcyBydW4uXHJcbmZ1bmN0aW9uIF9hcmNoaXZlRGVjb2RlKFxyXG4gIHVyaVBhdGhNb2R1bGU6IHR5cGVvZiBwYXRoTW9kdWxlLFxyXG4gIHVyaTogTnVjbGlkZVVyaSxcclxuKTogTnVjbGlkZVVyaSB7XHJcbiAgaWYgKHVyaS5pbmRleE9mKEFSQ0hJVkVfU0VQQVJBVE9SKSA8IDApIHtcclxuICAgIHJldHVybiB1cmk7XHJcbiAgfVxyXG4gIHJldHVybiBfdHJpbUFyY2hpdmVTdWZmaXgoXHJcbiAgICBLTk9XTl9BUkNISVZFX0VYVEVOU0lPTlMucmVkdWNlKFxyXG4gICAgICAoYWNjLCBleHQpID0+XHJcbiAgICAgICAgYWNjLnJlcGxhY2UoXHJcbiAgICAgICAgICBgJHtleHR9JHtBUkNISVZFX1NFUEFSQVRPUn0ke3VyaVBhdGhNb2R1bGUuc2VwfWAsXHJcbiAgICAgICAgICBgJHtleHR9JHtBUkNISVZFX1NFUEFSQVRPUn1gLFxyXG4gICAgICAgICksXHJcbiAgICAgIHVyaSxcclxuICAgICksXHJcbiAgKTtcclxufVxyXG5cclxuLy8gV2hlbiB3b3JraW5nIHdpdGggZW5jb2RlZCB1cmkncywgdGhlIGFyY2hpdmUgc2VwYXJhdG9yIGlzIHBhcnQgb2YgdGhlIG5hbWVcclxuLy8gc28gd2UgY2FuIG1hbmlwdWxhdGUgcGF0aHMgd2l0aCB1cmlQYXRoTW9kdWxlLiAgSG93ZXZlciwgaW4gYHJlbGF0aXZlYCBpZlxyXG4vLyBvbmUgdXJpIGNvbnRhaW5zIHRoZSBvdGhlciwgd2UgbmVlZCB0aGUgbmFtZXMgc2VlbiBieSB1cmlQYXRoTW9kdWxlIHRvIGFncmVlXHJcbi8vIG9uIHdoZXRoZXIgdGhlcmUgaXMgYW4gYXJjaGl2ZSBzZXBhcmF0b3Igb3Igbm90LiAgRS5nLiBpZiB3ZSBoYXZlOlxyXG4vLyAgICAvZXRjL2ZpbGUuemlwXHJcbi8vICAgIC9ldGMvZmlsZS56aXAhYWJjXHJcbi8vIFdoZW4gd2UgZW5jb2RlIHRoZXNlLCB3ZSBnZXQ6XHJcbi8vICAgIC9ldGMvZmlsZS56aXBcclxuLy8gICAgL2V0Yy9maWxlLnppcCEvYWJjXHJcbi8vIFdlIG5lZWQgdG8gYWRkIGEgdHJhaWxpbmcgJyEnIHRvIHRoZSBmaXJzdCBvbmUgc28gdXJpUGF0aE1vZHVsZSBjYW4gc2VlIHRoYXRcclxuLy8gdGhlIGZpcnN0IGNvbnRhaW5zIHRoZSBzZWNvbmQuXHJcbmZ1bmN0aW9uIF9tYXRjaFRyYWlsaW5nQXJjaGl2ZSh1cmk6IHN0cmluZywgb3RoZXI6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKFxyXG4gICAgdXJpLmxlbmd0aCA8IG90aGVyLmxlbmd0aCAmJlxyXG4gICAgb3RoZXIuc3RhcnRzV2l0aCh1cmkpICYmXHJcbiAgICBfaXNBcmNoaXZlU2VwYXJhdG9yKG90aGVyLCB1cmkubGVuZ3RoKVxyXG4gICkge1xyXG4gICAgcmV0dXJuIHVyaSArIEFSQ0hJVkVfU0VQQVJBVE9SO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdXJpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX3RyaW1BcmNoaXZlU3VmZml4KHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKF9lbmRzV2l0aEFyY2hpdmVTZXBhcmF0b3IocGF0aCkpIHtcclxuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIEFSQ0hJVkVfU0VQQVJBVE9SLmxlbmd0aCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBwYXRoO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX2VuZHNXaXRoQXJjaGl2ZVNlcGFyYXRvcihwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICByZXR1cm4gX2lzQXJjaGl2ZVNlcGFyYXRvcihwYXRoLCBwYXRoLmxlbmd0aCAtIDEpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfaXNBcmNoaXZlU2VwYXJhdG9yKHBhdGg6IHN0cmluZywgaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gIHJldHVybiAoXHJcbiAgICBwYXRoLmxlbmd0aCA+IGluZGV4ICYmXHJcbiAgICBwYXRoLmNoYXJBdChpbmRleCkgPT09IEFSQ0hJVkVfU0VQQVJBVE9SICYmXHJcbiAgICBLTk9XTl9BUkNISVZFX0VYVEVOU0lPTlMuc29tZShleHQgPT4ge1xyXG4gICAgICBjb25zdCBleHRTdGFydCA9IGluZGV4IC0gZXh0Lmxlbmd0aDtcclxuICAgICAgcmV0dXJuIHBhdGguaW5kZXhPZihleHQsIGV4dFN0YXJ0KSA9PT0gZXh0U3RhcnQ7XHJcbiAgICB9KVxyXG4gICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF90ZXN0Rm9ySWxsZWdhbFVyaSh1cmk6ID9OdWNsaWRlVXJpKTogdm9pZCB7XHJcbiAgaWYgKHVyaSAhPSBudWxsKSB7XHJcbiAgICBpZiAoX2VuZHNXaXRoQXJjaGl2ZVNlcGFyYXRvcih1cmkpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgUGF0aCBvcGVyYXRpb24gaW52b2tlZCBvbiBVUkkgZW5kaW5nIHdpdGggJHtBUkNISVZFX1NFUEFSQVRPUn06ICR7dXJpfWAsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5jb25zdCBOVUNMSURFX1VSSV9UWVBFX05BTUUgPSAnTnVjbGlkZVVyaSc7XHJcblxyXG4vLyBJZiBtdXN0QmVSZW1vdGUgaXMgcHJlc2VudCB0aGVuIHJlbW90ZS1uZXNzIG11c3QgbWF0Y2gsIG90aGVyd2lzZSByZW1vdGUtbmVzc1xyXG4vLyBpcyBpZ25vcmVkLlxyXG5mdW5jdGlvbiB2YWxpZGF0ZSh1cmk6IE51Y2xpZGVVcmksIG11c3RCZVJlbW90ZT86IGJvb2xlYW4pOiB2b2lkIHtcclxuICAvLyBCZSBhIGxpdHRsZSBleHRyYSBwYXJhbm9pZCB0byBjYXRjaCBwbGFjZXMgd2hlcmUgdGhlIHR5cGUgc3lzdGVtIG1heSBiZSB3ZWFrLlxyXG4gIGludmFyaWFudCh1cmkgIT0gbnVsbCwgJ1VuZXhwZWN0ZWQgbnVsbCBOdWNsaWRlVXJpJyk7XHJcbiAgaW52YXJpYW50KFxyXG4gICAgdHlwZW9mIHVyaSA9PT0gJ3N0cmluZycsXHJcbiAgICBgVW5leHBlY3RlZCBOdWNsaWRlVXJpIHR5cGU6ICR7U3RyaW5nKHVyaSl9YCxcclxuICApO1xyXG5cclxuICBpZiAoaXNSZW1vdGUodXJpKSkge1xyXG4gICAgcGFyc2UodXJpKTtcclxuICAgIGludmFyaWFudChtdXN0QmVSZW1vdGUgIT09IGZhbHNlLCAnRXhwZWN0ZWQgcmVtb3RlIE51Y2xpZGVVcmknKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaW52YXJpYW50KHVyaSAhPT0gJycsICdOdWNsaWRlVXJpIG11c3QgY29udGFpbiBhIG5vbi1lbXB0eSBwYXRoJyk7XHJcbiAgICBpbnZhcmlhbnQobXVzdEJlUmVtb3RlICE9PSB0cnVlLCAnRXhwZWN0ZWQgbG9jYWwgTnVjbGlkZVVyaScpO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgSU1BR0VfRVhURU5TSU9OUyA9IG5ldyBTZXQoW1xyXG4gICcuYm1wJyxcclxuICAnLmdpZicsXHJcbiAgJy5pY28nLFxyXG4gICcuanBlZycsXHJcbiAgJy5qcGcnLFxyXG4gICcucG5nJyxcclxuICAnLndlYnAnLFxyXG5dKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBmaWxlbmFtZSBsb29rcyBsaWtlIGFuIGltYWdlIHRoYXQgTnVjbGlkZSBjYW4gb3Blbjsgb3RoZXJ3aXNlIGZhbHNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9va3NMaWtlSW1hZ2VVcmkodXJpOiBOdWNsaWRlVXJpKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgZXh0ID0gZXh0bmFtZSh1cmkpLnRvTG93ZXJDYXNlKCk7XHJcbiAgcmV0dXJuIElNQUdFX0VYVEVOU0lPTlMuaGFzKGV4dCk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBiYXNlbmFtZSxcclxuICBkaXJuYW1lLFxyXG4gIGV4dG5hbWUsXHJcbiAgc3RyaXBFeHRlbnNpb24sXHJcbiAgaXNSZW1vdGUsXHJcbiAgaXNMb2NhbCxcclxuICBjcmVhdGVSZW1vdGVVcmksXHJcbiAgaXNJbkFyY2hpdmUsXHJcbiAgYW5jZXN0b3JPdXRzaWRlQXJjaGl2ZSxcclxuICBwYXJzZSxcclxuICBwYXJzZVJlbW90ZVVyaSxcclxuICB2YWxpZGF0ZSxcclxuICBnZXRQYXRoLFxyXG4gIGdldEhvc3RuYW1lLFxyXG4gIGdldEhvc3RuYW1lT3B0LFxyXG4gIGpvaW4sXHJcbiAgam9pbkFycmF5LFxyXG4gIGFyY2hpdmVKb2luLFxyXG4gIHJlbGF0aXZlLFxyXG4gIGxvb2tzTGlrZUltYWdlVXJpLFxyXG4gIG5vcm1hbGl6ZSxcclxuICBub3JtYWxpemVEaXIsXHJcbiAgZ2V0UGFyZW50LFxyXG4gIHVyaVRvTnVjbGlkZVVyaSxcclxuICBudWNsaWRlVXJpVG9VcmksXHJcbiAgY29udGFpbnMsXHJcbiAgY29sbGFwc2UsXHJcbiAgbnVjbGlkZVVyaVRvRGlzcGxheVN0cmluZyxcclxuICBudWNsaWRlVXJpVG9EaXNwbGF5SG9zdG5hbWUsXHJcbiAgaG9zdG5hbWVUb0Rpc3BsYXlIb3N0bmFtZSxcclxuICByZWdpc3Rlckhvc3RuYW1lRm9ybWF0dGVyLFxyXG4gIGVuc3VyZVRyYWlsaW5nU2VwYXJhdG9yLFxyXG4gIHRyaW1UcmFpbGluZ1NlcGFyYXRvcixcclxuICBlbmRzV2l0aFNlcGFyYXRvcixcclxuICBlbmRzV2l0aEVkZW5EaXIsXHJcbiAgaXNBYnNvbHV0ZSxcclxuICBpc0hvbWVSZWxhdGl2ZSxcclxuICByZXNvbHZlLFxyXG4gIGV4cGFuZEhvbWVEaXIsXHJcbiAgc3BsaXRQYXRoTGlzdCxcclxuICBqb2luUGF0aExpc3QsXHJcbiAgZW5zdXJlTG9jYWxQcmVmaXgsXHJcbiAgaXNSb290LFxyXG4gIHBhcnNlUGF0aCxcclxuICBzcGxpdCxcclxuICBwYXRoU2VwYXJhdG9yRm9yLFxyXG4gIGhhc0tub3duQXJjaGl2ZUV4dGVuc2lvbixcclxuICBBUkNISVZFX1NFUEFSQVRPUixcclxuICBLTk9XTl9BUkNISVZFX0VYVEVOU0lPTlMsXHJcbiAgTlVDTElERV9VUklfVFlQRV9OQU1FLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IF9fVEVTVF9fID0ge1xyXG4gIF9wYXRoTW9kdWxlRm9yLFxyXG59O1xyXG4iXX0=