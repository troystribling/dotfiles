"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitStream = splitStream;
exports.bufferUntil = bufferUntil;
exports.cacheWhileSubscribed = cacheWhileSubscribed;
exports.diffSets = diffSets;
exports.reconcileSetDiffs = reconcileSetDiffs;
exports.reconcileSets = reconcileSets;
exports.toggle = toggle;
exports.compact = compact;
exports.takeWhileInclusive = takeWhileInclusive;
exports.concatLatest = concatLatest;
exports.throttle = throttle;
exports.completingSwitchMap = completingSwitchMap;
exports.mergeUntilAnyComplete = mergeUntilAnyComplete;
exports.fastDebounce = fastDebounce;
exports.fromAbortablePromise = fromAbortablePromise;
exports.toAbortablePromise = toAbortablePromise;
exports.takeUntilAbort = takeUntilAbort;
exports.poll = poll;
exports.SingletonExecutor = exports.nextAnimationFrame = exports.macrotask = exports.microtask = void 0;

var _UniversalDisposable = _interopRequireDefault(require("./UniversalDisposable"));

var _assert = _interopRequireDefault(require("assert"));

var _domexception = _interopRequireDefault(require("domexception"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _AbortController = _interopRequireDefault(require("./AbortController"));

var _collection = require("./collection");

var _debounce = _interopRequireDefault(require("./debounce"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* global requestAnimationFrame, cancelAnimationFrame */
// NOTE: Custom operators that require arguments should be written as higher-order functions. That
// is, they should accept the arguments and return a function that accepts only an observable. This
// allows a nice ergonomic way of using them with '.let()' (or a potential future pipe operator):
//
//     const makeExciting = (excitementLevel: number = 1) =>
//       (source: Observable<string>) =>
//         source.map(x => x + '!'.repeat(excitementLevel));
//
//     Observable.of('hey', 'everybody')
//       .let(makeExciting())
//       .subscribe(x => console.log(x));
// Note: DOMException is usable in Chrome but not in Node.

/**
 * Splits a stream of strings on newlines.
 * Includes the newlines in the resulting stream (if includeNewlines is true).
 * Sends any non-newline terminated data before closing.
 * Does not ensure a trailing newline.
 */
function splitStream(input, includeNewlines = true) {
  return _rxjsCompatUmdMin.Observable.create(observer => {
    let current = '';

    function onEnd() {
      if (current !== '') {
        observer.next(current);
        current = '';
      }
    }

    return input.subscribe(value => {
      const lines = value.split('\n');
      lines[0] = current + lines[0];
      current = lines.pop();

      if (includeNewlines) {
        lines.forEach(line => observer.next(line + '\n'));
      } else {
        lines.forEach(line => observer.next(line));
      }
    }, error => {
      onEnd();
      observer.error(error);
    }, () => {
      onEnd();
      observer.complete();
    });
  });
}
/**
 * Buffers until the predicate matches an element, then opens a new buffer.
 *
 * @param stream - The observable to buffer
 * @param predicate - A function that will be called every time an element is emitted from the
 *     source. The predicate is passed the current element as well as the buffer at that point
 *     (which includes the element). IMPORTANT: DO NOT MUTATE THE BUFFER. It returns a boolean
 *     specifying whether to complete the buffer (and begin a new one).
 */


function bufferUntil(condition) {
  return stream => _rxjsCompatUmdMin.Observable.create(observer => {
    let buffer = null;

    const flush = () => {
      if (buffer != null) {
        observer.next(buffer);
        buffer = null;
      }
    };

    return stream.subscribe(x => {
      if (buffer == null) {
        buffer = [];
      }

      buffer.push(x);

      if (condition(x, buffer)) {
        flush();
      }
    }, err => {
      flush();
      observer.error(err);
    }, () => {
      flush();
      observer.complete();
    });
  });
}
/**
 * Caches the latest element as long as there are subscribers. This is useful so that if consumers
 * unsubscribe and then subscribe much later, they do not get an ancient cached value.
 *
 * This is intended to be used with cold Observables. If you have a hot Observable, `cache(1)` will
 * be just fine because the hot Observable will continue producing values even when there are no
 * subscribers, so you can be assured that the cached values are up-to-date.
 */


function cacheWhileSubscribed(input) {
  return input.multicast(() => new _rxjsCompatUmdMin.ReplaySubject(1)).refCount();
}

/**
 * Given a stream of sets, return a stream of diffs.
 * **IMPORTANT:** These sets are assumed to be immutable by convention. Don't mutate them!
 */
function diffSets(hash) {
  return sets => _rxjsCompatUmdMin.Observable.concat(_rxjsCompatUmdMin.Observable.of(new Set()), // Always start with no items with an empty set
  sets).pairwise().map(([previous, next]) => ({
    added: (0, _collection.setDifference)(next, previous, hash),
    removed: (0, _collection.setDifference)(previous, next, hash)
  })).filter(diff => diff.added.size > 0 || diff.removed.size > 0);
}
/**
 * Give a stream of diffs, perform an action for each added item and dispose of the returned
 * disposable when the item is removed.
 */


function reconcileSetDiffs(diffs, addAction, hash_) {
  const hash = hash_ || (x => x);

  const itemsToDisposables = new Map();

  const disposeItem = item => {
    const disposable = itemsToDisposables.get(hash(item));
    (0, _assert.default)(disposable != null);
    disposable.dispose();
    itemsToDisposables.delete(item);
  };

  const disposeAll = () => {
    itemsToDisposables.forEach(disposable => {
      disposable.dispose();
    });
    itemsToDisposables.clear();
  };

  return new _UniversalDisposable.default(diffs.subscribe(diff => {
    // For every item that got added, perform the add action.
    diff.added.forEach(item => {
      itemsToDisposables.set(hash(item), addAction(item));
    }); // "Undo" the add action for each item that got removed.

    diff.removed.forEach(disposeItem);
  }), disposeAll);
}
/**
 * Given a stream of sets, perform a side-effect whenever an item is added (i.e. is present in a
 * set but wasn't in the previous set in the stream), and a corresponding cleanup when it's removed.
 * **IMPORTANT:** These sets are assumed to be immutable by convention. Don't mutate them!
 *
 * Example:
 *
 *    const dogs = Observable.of(
 *      new Set([{name: 'Winston', id: 1}, {name: 'Penelope', id: 2}]),
 *      new Set([{name: 'Winston', id: 1}]),
 *    );
 *    const disposable = reconcileSets(
 *      dogs,
 *      dog => {
 *        const notification = atom.notifications.addSuccess(
 *          `${dog.name} was added!`,
 *          {dismissable: true},
 *        );
 *        return new Disposable(() => { notification.dismiss(); });
 *      },
 *      dog => dog.id,
 *    );
 *
 * The above code will first add notifications saying "Winston was added!" and "Penelope was
 * added!", then dismiss the "Penelope" notification. Since the Winston object is in the final set
 * of the dogs observable, his notification will remain until `disposable.dispose()` is called, at
 * which point the cleanup for all remaining items will be performed.
 */


function reconcileSets(sets, addAction, hash) {
  const diffs = sets.let(diffSets(hash));
  return reconcileSetDiffs(diffs, addAction, hash);
}

function toggle(toggler) {
  return source => toggler.distinctUntilChanged().switchMap(enabled => enabled ? source : _rxjsCompatUmdMin.Observable.empty());
}

function compact(source) {
  // Flow does not understand the semantics of `filter`
  return source.filter(x => x != null);
}
/**
 * Like `takeWhile`, but includes the first item that doesn't match the predicate.
 */


function takeWhileInclusive(predicate) {
  return source => _rxjsCompatUmdMin.Observable.create(observer => source.subscribe(x => {
    observer.next(x);

    if (!predicate(x)) {
      observer.complete();
    }
  }, err => {
    observer.error(err);
  }, () => {
    observer.complete();
  }));
} // Concatenate the latest values from each input observable into one big list.
// Observables who have not emitted a value yet are treated as empty.


function concatLatest(...observables) {
  // First, tag all input observables with their index.
  // Flow errors with ambiguity without the explicit annotation.
  const tagged = observables.map((observable, index) => observable.map(list => [list, index]));
  return _rxjsCompatUmdMin.Observable.merge(...tagged).scan((accumulator, [list, index]) => {
    accumulator[index] = list;
    return accumulator;
  }, observables.map(x => [])).map(accumulator => [].concat(...accumulator));
} // Use a sentinel so we can distinguish between when `null` is emitted and when
// nothing is.


const NONE = {};

function throttle(delay, options = {
  leading: true
}) {
  let getDelay;

  switch (typeof delay) {
    case 'number':
      getDelay = () => _rxjsCompatUmdMin.Observable.timer(delay);

      break;

    case 'function':
      getDelay = delay;
      break;

    case 'object':
      getDelay = () => delay;

      break;

    default:
      throw new Error(`Invalid delay: ${delay}`);
  }

  return function doThrottle(source) {
    return _rxjsCompatUmdMin.Observable.create(observer => {
      const {
        leading = true
      } = options;
      const timerStarts = new _rxjsCompatUmdMin.Subject();
      let latestValue = NONE;
      let latestValueIsLeading = false;
      let shouldIgnore = false;

      const checkShouldNext = () => {
        if (!shouldIgnore && latestValue !== NONE) {
          // At this point, latestValue must be of type T
          latestValue = latestValue;
          const valueToDispatch = latestValue;
          shouldIgnore = true;

          if (leading || !latestValueIsLeading) {
            latestValue = NONE;
            observer.next(valueToDispatch);
          }

          timerStarts.next(valueToDispatch);
        }
      };

      const sub = new _rxjsCompatUmdMin.Subscription();
      sub.add(timerStarts.switchMap(x => {
        const timer = getDelay(x);

        if (timer instanceof _rxjsCompatUmdMin.Observable) {
          return timer.take(1);
        } else {
          return timer;
        }
      }).subscribe(() => {
        shouldIgnore = false;
        latestValueIsLeading = false;
        checkShouldNext();
      }));
      sub.add(source.subscribe({
        next: x => {
          latestValue = x;
          latestValueIsLeading = true;
          checkShouldNext();
        },
        error: err => {
          observer.error(err);
        },
        complete: () => {
          // Ensure we don't hold a reference to the last value.
          latestValue = NONE;
          observer.complete();
        }
      }));
      return sub;
    });
  };
}
/**
 * Returns a new function which takes an `observable` and returns
 * `observable.switchMap(project)`, except that it completes
 * when the outer observable completes.
 *
 * Example:
 *
 *   Observable.of(1)
 *     .let(completingSwitchMap(x => Observable.never()))
 *
 * ends up returning an Observable that completes immediately.
 * With a regular switchMap, this would never terminate.
 */


function completingSwitchMap(project) {
  // An alternative implementation is to materialize the input observable,
  // but this avoids the creation of extra notifier objects.
  const completedSymbol = Symbol('completed');
  return observable => _rxjsCompatUmdMin.Observable.concat(observable, _rxjsCompatUmdMin.Observable.of(completedSymbol)).switchMap((input, index) => {
    if (input === completedSymbol) {
      return _rxjsCompatUmdMin.Observable.empty();
    }

    return project(input, index);
  });
}
/**
 * Returns a new observable consisting of the merged values from the passed
 * observables and completes when the first inner observable completes.
 */


function mergeUntilAnyComplete(...observables) {
  const notifications = _rxjsCompatUmdMin.Observable.merge(...observables.map(o => o.materialize())); // $FlowFixMe add dematerialize to rxjs Flow types


  return notifications.dematerialize();
}
/**
 * RxJS's debounceTime is actually fairly inefficient:
 * on each event, it always clears its interval and [creates a new one][1].
 * Until this is fixed, this uses our debounce implementation which
 * reuses a timeout and just sets a timestamp when possible.
 *
 * This may seem like a micro-optimization but we often use debounces
 * for very hot events, like keypresses. Exceeding the frame budget can easily lead
 * to increased key latency!
 *
 * [1]: https://github.com/ReactiveX/rxjs/blob/master/src/operators/debounceTime.ts#L106
 */


function fastDebounce(delay) {
  return observable => _rxjsCompatUmdMin.Observable.create(observer => {
    const debouncedNext = (0, _debounce.default)(x => observer.next(x), delay);
    const subscription = observable.subscribe(debouncedNext, observer.error.bind(observer), observer.complete.bind(observer));
    return new _UniversalDisposable.default(subscription, debouncedNext);
  });
}

const microtask = _rxjsCompatUmdMin.Observable.create(observer => {
  process.nextTick(() => {
    observer.next();
    observer.complete();
  });
});

exports.microtask = microtask;

const macrotask = _rxjsCompatUmdMin.Observable.create(observer => {
  const timerId = setImmediate(() => {
    observer.next();
    observer.complete();
  });
  return () => {
    clearImmediate(timerId);
  };
});

exports.macrotask = macrotask;

const nextAnimationFrame = _rxjsCompatUmdMin.Observable.create(observer => {
  if (typeof requestAnimationFrame === 'undefined') {
    throw new Error('This util can only be used in Atom');
  }

  const id = requestAnimationFrame(() => {
    observer.next();
    observer.complete();
  });
  return () => {
    cancelAnimationFrame(id);
  };
});
/**
 * Creates an Observable around an abortable promise.
 * Unsubscriptions are forwarded to the AbortController as an `abort()`.
 * Example usage (with an abortable fetch):
 *
 *   fromPromise(signal => fetch(url, {...options, signal}))
 *     .switchMap(....)
 *
 * Note that this can take a normal `() => Promise<T>` too
 * (in which case this acts as just a plain `Observable.defer`).
 */


exports.nextAnimationFrame = nextAnimationFrame;

function fromAbortablePromise(func) {
  return _rxjsCompatUmdMin.Observable.create(observer => {
    let completed = false;
    const abortController = new _AbortController.default();
    func(abortController.signal).then(value => {
      completed = true;
      observer.next(value);
      observer.complete();
    }, error => {
      completed = true;
      observer.error(error);
    });
    return () => {
      if (!completed) {
        abortController.abort(); // If the promise adheres to the spec, it should throw.
        // The error will be captured above but go into the void.
      }
    };
  });
}
/**
 * Converts an observable + AbortSignal into a cancellable Promise,
 * which rejects with an AbortError DOMException on abort.
 * Useful when writing the internals of a cancellable promise.
 *
 * Usage:
 *
 *   function abortableFunction(arg1: blah, options?: {signal?: AbortSignal}): Promise {
 *     return toPromise(
 *       observableFunction(arg1, options),
 *       options && options.signal,
 *     );
 *   }
 *
 * Could eventually be replaced by Observable.first if
 * https://github.com/whatwg/dom/issues/544 goes through.
 *
 * It's currently unclear if this should be usable with let/pipe:
 * https://github.com/ReactiveX/rxjs/issues/3445
 */


function toAbortablePromise(observable, signal) {
  if (signal == null) {
    return observable.toPromise();
  }

  if (signal.aborted) {
    return Promise.reject((0, _domexception.default)('Aborted', 'AbortError'));
  }

  return observable.race(_rxjsCompatUmdMin.Observable.fromEvent(signal, 'abort').map(() => {
    throw new _domexception.default('Aborted', 'AbortError');
  })).toPromise();
}
/**
 * When using Observables with AbortSignals, be sure to use this -
 * it's really easy to miss the case when the signal is already aborted!
 * Recommended to use this with let/pipe:
 *
 *   myObservable
 *     .let(takeUntilAbort(signal))
 */


function takeUntilAbort(signal) {
  return observable => _rxjsCompatUmdMin.Observable.defer(() => {
    if (signal.aborted) {
      return _rxjsCompatUmdMin.Observable.empty();
    }

    return observable.takeUntil(_rxjsCompatUmdMin.Observable.fromEvent(signal, 'abort'));
  });
} // Executes tasks. Ensures that at most one task is running at a time.
// This class is handy for expensive tasks like processes, provided
// you never want the result of a previous task after a new task has started.


class SingletonExecutor {
  constructor() {
    this._abortController = null;
  }

  // Executes(subscribes to) the task.
  // Will terminate(unsubscribe) to any previously executing task.
  // Subsequent executes() will terminate this task if called before
  // this task completes.
  async execute(createTask) {
    // Kill any previously running processes
    this.cancel(); // Start a new process

    const controller = new _AbortController.default();
    this._abortController = controller; // Wait for the process to complete or be canceled ...

    try {
      return await toAbortablePromise(createTask, controller.signal);
    } finally {
      // ... and always clean up if we haven't been canceled already.
      if (controller === this._abortController) {
        this._abortController = null;
      }
    }
  }

  isExecuting() {
    return this._abortController != null;
  } // Cancels any currently executing tasks.


  cancel() {
    if (this._abortController != null) {
      this._abortController.abort();

      this._abortController = null;
    }
  }

}
/**
 * Repeatedly subscribe to an observable every `delay` milliseconds, waiting for the observable to
 * complete each time. This is preferable to, say, `Observable.interval(d).switchMap(() => source)`
 * because, in the case that `source` takes longer than `d` milliseconds to produce a value, that
 * formulation will never produce a value (while continuing to incur the overhead of subscribing to
 * source).
 *
 * Example:
 *
 *    // Ask what time it is every second until it's Friday.
 *    runCommand('date')
 *      .let(poll(1000))
 *      .filter(output => output.startsWith('Fri'))
 *      .take(1)
 *      .subscribe(() => {
 *        console.log("IT'S FRIDAY!!")
 *      });
 *
 */


exports.SingletonExecutor = SingletonExecutor;

function poll(delay) {
  return source => _rxjsCompatUmdMin.Observable.defer(() => {
    const delays = new _rxjsCompatUmdMin.Subject();
    return delays.switchMap(n => _rxjsCompatUmdMin.Observable.timer(n)).merge(_rxjsCompatUmdMin.Observable.of(null)).switchMap(() => {
      const subscribedAt = Date.now();
      return source.do({
        complete: () => {
          const timeElapsed = Date.now() - subscribedAt;
          delays.next(Math.max(0, delay - timeElapsed));
        }
      });
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL29ic2VydmFibGUuanMiXSwibmFtZXMiOlsic3BsaXRTdHJlYW0iLCJpbnB1dCIsImluY2x1ZGVOZXdsaW5lcyIsIk9ic2VydmFibGUiLCJjcmVhdGUiLCJvYnNlcnZlciIsImN1cnJlbnQiLCJvbkVuZCIsIm5leHQiLCJzdWJzY3JpYmUiLCJ2YWx1ZSIsImxpbmVzIiwic3BsaXQiLCJwb3AiLCJmb3JFYWNoIiwibGluZSIsImVycm9yIiwiY29tcGxldGUiLCJidWZmZXJVbnRpbCIsImNvbmRpdGlvbiIsInN0cmVhbSIsImJ1ZmZlciIsImZsdXNoIiwieCIsInB1c2giLCJlcnIiLCJjYWNoZVdoaWxlU3Vic2NyaWJlZCIsIm11bHRpY2FzdCIsIlJlcGxheVN1YmplY3QiLCJyZWZDb3VudCIsImRpZmZTZXRzIiwiaGFzaCIsInNldHMiLCJjb25jYXQiLCJvZiIsIlNldCIsInBhaXJ3aXNlIiwibWFwIiwicHJldmlvdXMiLCJhZGRlZCIsInJlbW92ZWQiLCJmaWx0ZXIiLCJkaWZmIiwic2l6ZSIsInJlY29uY2lsZVNldERpZmZzIiwiZGlmZnMiLCJhZGRBY3Rpb24iLCJoYXNoXyIsIml0ZW1zVG9EaXNwb3NhYmxlcyIsIk1hcCIsImRpc3Bvc2VJdGVtIiwiaXRlbSIsImRpc3Bvc2FibGUiLCJnZXQiLCJkaXNwb3NlIiwiZGVsZXRlIiwiZGlzcG9zZUFsbCIsImNsZWFyIiwiVW5pdmVyc2FsRGlzcG9zYWJsZSIsInNldCIsInJlY29uY2lsZVNldHMiLCJsZXQiLCJ0b2dnbGUiLCJ0b2dnbGVyIiwic291cmNlIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJzd2l0Y2hNYXAiLCJlbmFibGVkIiwiZW1wdHkiLCJjb21wYWN0IiwidGFrZVdoaWxlSW5jbHVzaXZlIiwicHJlZGljYXRlIiwiY29uY2F0TGF0ZXN0Iiwib2JzZXJ2YWJsZXMiLCJ0YWdnZWQiLCJvYnNlcnZhYmxlIiwiaW5kZXgiLCJsaXN0IiwibWVyZ2UiLCJzY2FuIiwiYWNjdW11bGF0b3IiLCJOT05FIiwidGhyb3R0bGUiLCJkZWxheSIsIm9wdGlvbnMiLCJsZWFkaW5nIiwiZ2V0RGVsYXkiLCJ0aW1lciIsIkVycm9yIiwiZG9UaHJvdHRsZSIsInRpbWVyU3RhcnRzIiwiU3ViamVjdCIsImxhdGVzdFZhbHVlIiwibGF0ZXN0VmFsdWVJc0xlYWRpbmciLCJzaG91bGRJZ25vcmUiLCJjaGVja1Nob3VsZE5leHQiLCJ2YWx1ZVRvRGlzcGF0Y2giLCJzdWIiLCJTdWJzY3JpcHRpb24iLCJhZGQiLCJ0YWtlIiwiY29tcGxldGluZ1N3aXRjaE1hcCIsInByb2plY3QiLCJjb21wbGV0ZWRTeW1ib2wiLCJTeW1ib2wiLCJtZXJnZVVudGlsQW55Q29tcGxldGUiLCJub3RpZmljYXRpb25zIiwibyIsIm1hdGVyaWFsaXplIiwiZGVtYXRlcmlhbGl6ZSIsImZhc3REZWJvdW5jZSIsImRlYm91bmNlZE5leHQiLCJzdWJzY3JpcHRpb24iLCJiaW5kIiwibWljcm90YXNrIiwicHJvY2VzcyIsIm5leHRUaWNrIiwibWFjcm90YXNrIiwidGltZXJJZCIsInNldEltbWVkaWF0ZSIsImNsZWFySW1tZWRpYXRlIiwibmV4dEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImZyb21BYm9ydGFibGVQcm9taXNlIiwiZnVuYyIsImNvbXBsZXRlZCIsImFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsInRoZW4iLCJhYm9ydCIsInRvQWJvcnRhYmxlUHJvbWlzZSIsInRvUHJvbWlzZSIsImFib3J0ZWQiLCJQcm9taXNlIiwicmVqZWN0IiwicmFjZSIsImZyb21FdmVudCIsIkRPTUV4Y2VwdGlvbiIsInRha2VVbnRpbEFib3J0IiwiZGVmZXIiLCJ0YWtlVW50aWwiLCJTaW5nbGV0b25FeGVjdXRvciIsIl9hYm9ydENvbnRyb2xsZXIiLCJleGVjdXRlIiwiY3JlYXRlVGFzayIsImNhbmNlbCIsImNvbnRyb2xsZXIiLCJpc0V4ZWN1dGluZyIsInBvbGwiLCJkZWxheXMiLCJuIiwic3Vic2NyaWJlZEF0IiwiRGF0ZSIsIm5vdyIsImRvIiwidGltZUVsYXBzZWQiLCJNYXRoIiwibWF4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EsV0FBVCxDQUNMQyxLQURLLEVBRUxDLGVBQXlCLEdBQUcsSUFGdkIsRUFHZTtBQUNwQixTQUFPQyw2QkFBV0MsTUFBWCxDQUFrQkMsUUFBUSxJQUFJO0FBQ25DLFFBQUlDLE9BQWUsR0FBRyxFQUF0Qjs7QUFFQSxhQUFTQyxLQUFULEdBQWlCO0FBQ2YsVUFBSUQsT0FBTyxLQUFLLEVBQWhCLEVBQW9CO0FBQ2xCRCxRQUFBQSxRQUFRLENBQUNHLElBQVQsQ0FBY0YsT0FBZDtBQUNBQSxRQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0wsS0FBSyxDQUFDUSxTQUFOLENBQ0xDLEtBQUssSUFBSTtBQUNQLFlBQU1DLEtBQUssR0FBR0QsS0FBSyxDQUFDRSxLQUFOLENBQVksSUFBWixDQUFkO0FBQ0FELE1BQUFBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBV0wsT0FBTyxHQUFHSyxLQUFLLENBQUMsQ0FBRCxDQUExQjtBQUNBTCxNQUFBQSxPQUFPLEdBQUdLLEtBQUssQ0FBQ0UsR0FBTixFQUFWOztBQUNBLFVBQUlYLGVBQUosRUFBcUI7QUFDbkJTLFFBQUFBLEtBQUssQ0FBQ0csT0FBTixDQUFjQyxJQUFJLElBQUlWLFFBQVEsQ0FBQ0cs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QUFLYSxnQkFBTCxHQUF3QixJQUF4QjtBQUNEO0FBQ0Y7O0FBcEMrQjtBQXVDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ08sU0FBU00sSUFBVCxDQUFpQnBFLEtBQWpCLEVBQWtFO0FBQ3ZFLFNBQVFuQixNQUFELElBQ0w3RCw2QkFBVzJJLEtBQVgsQ0FBaUIsTUFBTTtBQUNyQixVQUFNVSxNQUFNLEdBQUcsSUFBSTdELHlCQUFKLEVBQWY7QUFDQSxXQUFPNkQsTUFBTSxDQUNWdEYsU0FESSxDQUNNdUYsQ0FBQyxJQUFJdEosNkJBQVdvRixLQUFYLENBQWlCa0UsQ0FBakIsQ0FEWCxFQUVKM0UsS0FGSSxDQUVFM0UsNkJBQVcrQixFQUFYLENBQWMsSUFBZCxDQUZGLEVBR0pnQyxTQUhJLENBR00sTUFBTTtBQUNmLFlBQU13RixZQUFZLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxFQUFyQjtBQUNBLGFBQU81RixNQUFNLENBQUM2RixFQUFQLENBQVU7QUFDZjVJLFFBQUFBLFFBQVEsRUFBRSxNQUFNO0FBQ2QsZ0JBQU02SSxXQUFXLEdBQUdILElBQUksQ0FBQ0MsR0FBTCxLQUFhRixZQUFqQztBQUNBRixVQUFBQSxNQUFNLENBQUNoSixJQUFQLENBQVl1SixJQUFJLENBQUNDLEdBQUwsQ0FBUyxDQUFULEVBQVk3RSxLQUFLLEdBQUcyRSxXQUFwQixDQUFaO0FBQ0Q7QUFKYyxPQUFWLENBQVA7QUFNRCxLQVhJLENBQVA7QUFZRCxHQWRELENBREY7QUFnQkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG4vKiBnbG9iYWwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xyXG5cclxuLy8gTk9URTogQ3VzdG9tIG9wZXJhdG9ycyB0aGF0IHJlcXVpcmUgYXJndW1lbnRzIHNob3VsZCBiZSB3cml0dGVuIGFzIGhpZ2hlci1vcmRlciBmdW5jdGlvbnMuIFRoYXRcclxuLy8gaXMsIHRoZXkgc2hvdWxkIGFjY2VwdCB0aGUgYXJndW1lbnRzIGFuZCByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25seSBhbiBvYnNlcnZhYmxlLiBUaGlzXHJcbi8vIGFsbG93cyBhIG5pY2UgZXJnb25vbWljIHdheSBvZiB1c2luZyB0aGVtIHdpdGggJy5sZXQoKScgKG9yIGEgcG90ZW50aWFsIGZ1dHVyZSBwaXBlIG9wZXJhdG9yKTpcclxuLy9cclxuLy8gICAgIGNvbnN0IG1ha2VFeGNpdGluZyA9IChleGNpdGVtZW50TGV2ZWw6IG51bWJlciA9IDEpID0+XHJcbi8vICAgICAgIChzb3VyY2U6IE9ic2VydmFibGU8c3RyaW5nPikgPT5cclxuLy8gICAgICAgICBzb3VyY2UubWFwKHggPT4geCArICchJy5yZXBlYXQoZXhjaXRlbWVudExldmVsKSk7XHJcbi8vXHJcbi8vICAgICBPYnNlcnZhYmxlLm9mKCdoZXknLCAnZXZlcnlib2R5JylcclxuLy8gICAgICAgLmxldChtYWtlRXhjaXRpbmcoKSlcclxuLy8gICAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcclxuXHJcbmltcG9ydCB0eXBlIHtBYm9ydFNpZ25hbH0gZnJvbSAnLi9BYm9ydENvbnRyb2xsZXInO1xyXG5cclxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSAnLi9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG4vLyBOb3RlOiBET01FeGNlcHRpb24gaXMgdXNhYmxlIGluIENocm9tZSBidXQgbm90IGluIE5vZGUuXHJcbmltcG9ydCBET01FeGNlcHRpb24gZnJvbSAnZG9tZXhjZXB0aW9uJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCBTdWJqZWN0LCBTdWJzY3JpcHRpb259IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCBBYm9ydENvbnRyb2xsZXIgZnJvbSAnLi9BYm9ydENvbnRyb2xsZXInO1xyXG5pbXBvcnQge3NldERpZmZlcmVuY2V9IGZyb20gJy4vY29sbGVjdGlvbic7XHJcbmltcG9ydCBkZWJvdW5jZSBmcm9tICcuL2RlYm91bmNlJztcclxuXHJcbi8qKlxyXG4gKiBTcGxpdHMgYSBzdHJlYW0gb2Ygc3RyaW5ncyBvbiBuZXdsaW5lcy5cclxuICogSW5jbHVkZXMgdGhlIG5ld2xpbmVzIGluIHRoZSByZXN1bHRpbmcgc3RyZWFtIChpZiBpbmNsdWRlTmV3bGluZXMgaXMgdHJ1ZSkuXHJcbiAqIFNlbmRzIGFueSBub24tbmV3bGluZSB0ZXJtaW5hdGVkIGRhdGEgYmVmb3JlIGNsb3NpbmcuXHJcbiAqIERvZXMgbm90IGVuc3VyZSBhIHRyYWlsaW5nIG5ld2xpbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRTdHJlYW0oXHJcbiAgaW5wdXQ6IE9ic2VydmFibGU8c3RyaW5nPixcclxuICBpbmNsdWRlTmV3bGluZXM/OiBib29sZWFuID0gdHJ1ZSxcclxuKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUob2JzZXJ2ZXIgPT4ge1xyXG4gICAgbGV0IGN1cnJlbnQ6IHN0cmluZyA9ICcnO1xyXG5cclxuICAgIGZ1bmN0aW9uIG9uRW5kKCkge1xyXG4gICAgICBpZiAoY3VycmVudCAhPT0gJycpIHtcclxuICAgICAgICBvYnNlcnZlci5uZXh0KGN1cnJlbnQpO1xyXG4gICAgICAgIGN1cnJlbnQgPSAnJztcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbnB1dC5zdWJzY3JpYmUoXHJcbiAgICAgIHZhbHVlID0+IHtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IHZhbHVlLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICBsaW5lc1swXSA9IGN1cnJlbnQgKyBsaW5lc1swXTtcclxuICAgICAgICBjdXJyZW50ID0gbGluZXMucG9wKCk7XHJcbiAgICAgICAgaWYgKGluY2x1ZGVOZXdsaW5lcykge1xyXG4gICAgICAgICAgbGluZXMuZm9yRWFjaChsaW5lID0+IG9ic2VydmVyLm5leHQobGluZSArICdcXG4nKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGxpbmVzLmZvckVhY2gobGluZSA9PiBvYnNlcnZlci5uZXh0KGxpbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGVycm9yID0+IHtcclxuICAgICAgICBvbkVuZCgpO1xyXG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcclxuICAgICAgfSxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIG9uRW5kKCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgfSxcclxuICAgICk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCdWZmZXJzIHVudGlsIHRoZSBwcmVkaWNhdGUgbWF0Y2hlcyBhbiBlbGVtZW50LCB0aGVuIG9wZW5zIGEgbmV3IGJ1ZmZlci5cclxuICpcclxuICogQHBhcmFtIHN0cmVhbSAtIFRoZSBvYnNlcnZhYmxlIHRvIGJ1ZmZlclxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgYW4gZWxlbWVudCBpcyBlbWl0dGVkIGZyb20gdGhlXHJcbiAqICAgICBzb3VyY2UuIFRoZSBwcmVkaWNhdGUgaXMgcGFzc2VkIHRoZSBjdXJyZW50IGVsZW1lbnQgYXMgd2VsbCBhcyB0aGUgYnVmZmVyIGF0IHRoYXQgcG9pbnRcclxuICogICAgICh3aGljaCBpbmNsdWRlcyB0aGUgZWxlbWVudCkuIElNUE9SVEFOVDogRE8gTk9UIE1VVEFURSBUSEUgQlVGRkVSLiBJdCByZXR1cm5zIGEgYm9vbGVhblxyXG4gKiAgICAgc3BlY2lmeWluZyB3aGV0aGVyIHRvIGNvbXBsZXRlIHRoZSBidWZmZXIgKGFuZCBiZWdpbiBhIG5ldyBvbmUpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclVudGlsPFQ+KFxyXG4gIGNvbmRpdGlvbjogKGl0ZW06IFQsIGJ1ZmZlcjogQXJyYXk8VD4pID0+IGJvb2xlYW4sXHJcbik6IChPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPEFycmF5PFQ+PiB7XHJcbiAgcmV0dXJuIChzdHJlYW06IE9ic2VydmFibGU8VD4pID0+XHJcbiAgICBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgICAgIGxldCBidWZmZXIgPSBudWxsO1xyXG4gICAgICBjb25zdCBmbHVzaCA9ICgpID0+IHtcclxuICAgICAgICBpZiAoYnVmZmVyICE9IG51bGwpIHtcclxuICAgICAgICAgIG9ic2VydmVyLm5leHQoYnVmZmVyKTtcclxuICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gc3RyZWFtLnN1YnNjcmliZShcclxuICAgICAgICB4ID0+IHtcclxuICAgICAgICAgIGlmIChidWZmZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJ1ZmZlci5wdXNoKHgpO1xyXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbih4LCBidWZmZXIpKSB7XHJcbiAgICAgICAgICAgIGZsdXNoKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnIgPT4ge1xyXG4gICAgICAgICAgZmx1c2goKTtcclxuICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICBmbHVzaCgpO1xyXG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWNoZXMgdGhlIGxhdGVzdCBlbGVtZW50IGFzIGxvbmcgYXMgdGhlcmUgYXJlIHN1YnNjcmliZXJzLiBUaGlzIGlzIHVzZWZ1bCBzbyB0aGF0IGlmIGNvbnN1bWVyc1xyXG4gKiB1bnN1YnNjcmliZSBhbmQgdGhlbiBzdWJzY3JpYmUgbXVjaCBsYXRlciwgdGhleSBkbyBub3QgZ2V0IGFuIGFuY2llbnQgY2FjaGVkIHZhbHVlLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aCBjb2xkIE9ic2VydmFibGVzLiBJZiB5b3UgaGF2ZSBhIGhvdCBPYnNlcnZhYmxlLCBgY2FjaGUoMSlgIHdpbGxcclxuICogYmUganVzdCBmaW5lIGJlY2F1c2UgdGhlIGhvdCBPYnNlcnZhYmxlIHdpbGwgY29udGludWUgcHJvZHVjaW5nIHZhbHVlcyBldmVuIHdoZW4gdGhlcmUgYXJlIG5vXHJcbiAqIHN1YnNjcmliZXJzLCBzbyB5b3UgY2FuIGJlIGFzc3VyZWQgdGhhdCB0aGUgY2FjaGVkIHZhbHVlcyBhcmUgdXAtdG8tZGF0ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWNoZVdoaWxlU3Vic2NyaWJlZDxUPihpbnB1dDogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4ge1xyXG4gIHJldHVybiBpbnB1dC5tdWx0aWNhc3QoKCkgPT4gbmV3IFJlcGxheVN1YmplY3QoMSkpLnJlZkNvdW50KCk7XHJcbn1cclxuXHJcbnR5cGUgRGlmZjxUPiA9IHtcclxuICBhZGRlZDogU2V0PFQ+LFxyXG4gIHJlbW92ZWQ6IFNldDxUPixcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhIHN0cmVhbSBvZiBzZXRzLCByZXR1cm4gYSBzdHJlYW0gb2YgZGlmZnMuXHJcbiAqICoqSU1QT1JUQU5UOioqIFRoZXNlIHNldHMgYXJlIGFzc3VtZWQgdG8gYmUgaW1tdXRhYmxlIGJ5IGNvbnZlbnRpb24uIERvbid0IG11dGF0ZSB0aGVtIVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZTZXRzPFQ+KFxyXG4gIGhhc2g/OiAodjogVCkgPT4gYW55LFxyXG4pOiAoT2JzZXJ2YWJsZTxTZXQ8VD4+KSA9PiBPYnNlcnZhYmxlPERpZmY8VD4+IHtcclxuICByZXR1cm4gKHNldHM6IE9ic2VydmFibGU8U2V0PFQ+PikgPT5cclxuICAgIE9ic2VydmFibGUuY29uY2F0KFxyXG4gICAgICBPYnNlcnZhYmxlLm9mKG5ldyBTZXQoKSksIC8vIEFsd2F5cyBzdGFydCB3aXRoIG5vIGl0ZW1zIHdpdGggYW4gZW1wdHkgc2V0XHJcbiAgICAgIHNldHMsXHJcbiAgICApXHJcbiAgICAgIC5wYWlyd2lzZSgpXHJcbiAgICAgIC5tYXAoKFtwcmV2aW91cywgbmV4dF0pID0+ICh7XHJcbiAgICAgICAgYWRkZWQ6IHNldERpZmZlcmVuY2UobmV4dCwgcHJldmlvdXMsIGhhc2gpLFxyXG4gICAgICAgIHJlbW92ZWQ6IHNldERpZmZlcmVuY2UocHJldmlvdXMsIG5leHQsIGhhc2gpLFxyXG4gICAgICB9KSlcclxuICAgICAgLmZpbHRlcihkaWZmID0+IGRpZmYuYWRkZWQuc2l6ZSA+IDAgfHwgZGlmZi5yZW1vdmVkLnNpemUgPiAwKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmUgYSBzdHJlYW0gb2YgZGlmZnMsIHBlcmZvcm0gYW4gYWN0aW9uIGZvciBlYWNoIGFkZGVkIGl0ZW0gYW5kIGRpc3Bvc2Ugb2YgdGhlIHJldHVybmVkXHJcbiAqIGRpc3Bvc2FibGUgd2hlbiB0aGUgaXRlbSBpcyByZW1vdmVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlY29uY2lsZVNldERpZmZzPFQ+KFxyXG4gIGRpZmZzOiBPYnNlcnZhYmxlPERpZmY8VD4+LFxyXG4gIGFkZEFjdGlvbjogKGFkZGVkSXRlbTogVCkgPT4gSURpc3Bvc2FibGUsXHJcbiAgaGFzaF8/OiAodjogVCkgPT4gYW55LFxyXG4pOiBJRGlzcG9zYWJsZSB7XHJcbiAgY29uc3QgaGFzaCA9IGhhc2hfIHx8ICh4ID0+IHgpO1xyXG4gIGNvbnN0IGl0ZW1zVG9EaXNwb3NhYmxlcyA9IG5ldyBNYXAoKTtcclxuICBjb25zdCBkaXNwb3NlSXRlbSA9IGl0ZW0gPT4ge1xyXG4gICAgY29uc3QgZGlzcG9zYWJsZSA9IGl0ZW1zVG9EaXNwb3NhYmxlcy5nZXQoaGFzaChpdGVtKSk7XHJcbiAgICBpbnZhcmlhbnQoZGlzcG9zYWJsZSAhPSBudWxsKTtcclxuICAgIGRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgaXRlbXNUb0Rpc3Bvc2FibGVzLmRlbGV0ZShpdGVtKTtcclxuICB9O1xyXG4gIGNvbnN0IGRpc3Bvc2VBbGwgPSAoKSA9PiB7XHJcbiAgICBpdGVtc1RvRGlzcG9zYWJsZXMuZm9yRWFjaChkaXNwb3NhYmxlID0+IHtcclxuICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICB9KTtcclxuICAgIGl0ZW1zVG9EaXNwb3NhYmxlcy5jbGVhcigpO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShcclxuICAgIGRpZmZzLnN1YnNjcmliZShkaWZmID0+IHtcclxuICAgICAgLy8gRm9yIGV2ZXJ5IGl0ZW0gdGhhdCBnb3QgYWRkZWQsIHBlcmZvcm0gdGhlIGFkZCBhY3Rpb24uXHJcbiAgICAgIGRpZmYuYWRkZWQuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBpdGVtc1RvRGlzcG9zYWJsZXMuc2V0KGhhc2goaXRlbSksIGFkZEFjdGlvbihpdGVtKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gXCJVbmRvXCIgdGhlIGFkZCBhY3Rpb24gZm9yIGVhY2ggaXRlbSB0aGF0IGdvdCByZW1vdmVkLlxyXG4gICAgICBkaWZmLnJlbW92ZWQuZm9yRWFjaChkaXNwb3NlSXRlbSk7XHJcbiAgICB9KSxcclxuICAgIGRpc3Bvc2VBbGwsXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGEgc3RyZWFtIG9mIHNldHMsIHBlcmZvcm0gYSBzaWRlLWVmZmVjdCB3aGVuZXZlciBhbiBpdGVtIGlzIGFkZGVkIChpLmUuIGlzIHByZXNlbnQgaW4gYVxyXG4gKiBzZXQgYnV0IHdhc24ndCBpbiB0aGUgcHJldmlvdXMgc2V0IGluIHRoZSBzdHJlYW0pLCBhbmQgYSBjb3JyZXNwb25kaW5nIGNsZWFudXAgd2hlbiBpdCdzIHJlbW92ZWQuXHJcbiAqICoqSU1QT1JUQU5UOioqIFRoZXNlIHNldHMgYXJlIGFzc3VtZWQgdG8gYmUgaW1tdXRhYmxlIGJ5IGNvbnZlbnRpb24uIERvbid0IG11dGF0ZSB0aGVtIVxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICBjb25zdCBkb2dzID0gT2JzZXJ2YWJsZS5vZihcclxuICogICAgICBuZXcgU2V0KFt7bmFtZTogJ1dpbnN0b24nLCBpZDogMX0sIHtuYW1lOiAnUGVuZWxvcGUnLCBpZDogMn1dKSxcclxuICogICAgICBuZXcgU2V0KFt7bmFtZTogJ1dpbnN0b24nLCBpZDogMX1dKSxcclxuICogICAgKTtcclxuICogICAgY29uc3QgZGlzcG9zYWJsZSA9IHJlY29uY2lsZVNldHMoXHJcbiAqICAgICAgZG9ncyxcclxuICogICAgICBkb2cgPT4ge1xyXG4gKiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gYXRvbS5ub3RpZmljYXRpb25zLmFkZFN1Y2Nlc3MoXHJcbiAqICAgICAgICAgIGAke2RvZy5uYW1lfSB3YXMgYWRkZWQhYCxcclxuICogICAgICAgICAge2Rpc21pc3NhYmxlOiB0cnVlfSxcclxuICogICAgICAgICk7XHJcbiAqICAgICAgICByZXR1cm4gbmV3IERpc3Bvc2FibGUoKCkgPT4geyBub3RpZmljYXRpb24uZGlzbWlzcygpOyB9KTtcclxuICogICAgICB9LFxyXG4gKiAgICAgIGRvZyA9PiBkb2cuaWQsXHJcbiAqICAgICk7XHJcbiAqXHJcbiAqIFRoZSBhYm92ZSBjb2RlIHdpbGwgZmlyc3QgYWRkIG5vdGlmaWNhdGlvbnMgc2F5aW5nIFwiV2luc3RvbiB3YXMgYWRkZWQhXCIgYW5kIFwiUGVuZWxvcGUgd2FzXHJcbiAqIGFkZGVkIVwiLCB0aGVuIGRpc21pc3MgdGhlIFwiUGVuZWxvcGVcIiBub3RpZmljYXRpb24uIFNpbmNlIHRoZSBXaW5zdG9uIG9iamVjdCBpcyBpbiB0aGUgZmluYWwgc2V0XHJcbiAqIG9mIHRoZSBkb2dzIG9ic2VydmFibGUsIGhpcyBub3RpZmljYXRpb24gd2lsbCByZW1haW4gdW50aWwgYGRpc3Bvc2FibGUuZGlzcG9zZSgpYCBpcyBjYWxsZWQsIGF0XHJcbiAqIHdoaWNoIHBvaW50IHRoZSBjbGVhbnVwIGZvciBhbGwgcmVtYWluaW5nIGl0ZW1zIHdpbGwgYmUgcGVyZm9ybWVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlY29uY2lsZVNldHM8VD4oXHJcbiAgc2V0czogT2JzZXJ2YWJsZTxTZXQ8VD4+LFxyXG4gIGFkZEFjdGlvbjogKGFkZGVkSXRlbTogVCkgPT4gSURpc3Bvc2FibGUsXHJcbiAgaGFzaD86ICh2OiBUKSA9PiBhbnksXHJcbik6IElEaXNwb3NhYmxlIHtcclxuICBjb25zdCBkaWZmcyA9IHNldHMubGV0KGRpZmZTZXRzKGhhc2gpKTtcclxuICByZXR1cm4gcmVjb25jaWxlU2V0RGlmZnMoZGlmZnMsIGFkZEFjdGlvbiwgaGFzaCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0b2dnbGU8VD4oXHJcbiAgdG9nZ2xlcjogT2JzZXJ2YWJsZTxib29sZWFuPixcclxuKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xyXG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PlxyXG4gICAgdG9nZ2xlclxyXG4gICAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxyXG4gICAgICAuc3dpdGNoTWFwKGVuYWJsZWQgPT4gKGVuYWJsZWQgPyBzb3VyY2UgOiBPYnNlcnZhYmxlLmVtcHR5KCkpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhY3Q8VD4oc291cmNlOiBPYnNlcnZhYmxlPD9UPik6IE9ic2VydmFibGU8VD4ge1xyXG4gIC8vIEZsb3cgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGUgc2VtYW50aWNzIG9mIGBmaWx0ZXJgXHJcbiAgcmV0dXJuIChzb3VyY2UuZmlsdGVyKHggPT4geCAhPSBudWxsKTogYW55KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpa2UgYHRha2VXaGlsZWAsIGJ1dCBpbmNsdWRlcyB0aGUgZmlyc3QgaXRlbSB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHByZWRpY2F0ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0YWtlV2hpbGVJbmNsdXNpdmU8VD4oXHJcbiAgcHJlZGljYXRlOiAodmFsdWU6IFQpID0+IGJvb2xlYW4sXHJcbik6IChPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+IHtcclxuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT5cclxuICAgIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+XHJcbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICAgICAgeCA9PiB7XHJcbiAgICAgICAgICBvYnNlcnZlci5uZXh0KHgpO1xyXG4gICAgICAgICAgaWYgKCFwcmVkaWNhdGUoeCkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVyciA9PiB7XHJcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICApLFxyXG4gICAgKTtcclxufVxyXG5cclxuLy8gQ29uY2F0ZW5hdGUgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IG9ic2VydmFibGUgaW50byBvbmUgYmlnIGxpc3QuXHJcbi8vIE9ic2VydmFibGVzIHdobyBoYXZlIG5vdCBlbWl0dGVkIGEgdmFsdWUgeWV0IGFyZSB0cmVhdGVkIGFzIGVtcHR5LlxyXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0TGF0ZXN0PFQ+KFxyXG4gIC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlPEFycmF5PFQ+Pj5cclxuKTogT2JzZXJ2YWJsZTxBcnJheTxUPj4ge1xyXG4gIC8vIEZpcnN0LCB0YWcgYWxsIGlucHV0IG9ic2VydmFibGVzIHdpdGggdGhlaXIgaW5kZXguXHJcbiAgLy8gRmxvdyBlcnJvcnMgd2l0aCBhbWJpZ3VpdHkgd2l0aG91dCB0aGUgZXhwbGljaXQgYW5ub3RhdGlvbi5cclxuICBjb25zdCB0YWdnZWQ6IEFycmF5PE9ic2VydmFibGU8W0FycmF5PFQ+LCBudW1iZXJdPj4gPSBvYnNlcnZhYmxlcy5tYXAoXHJcbiAgICAob2JzZXJ2YWJsZSwgaW5kZXgpID0+IG9ic2VydmFibGUubWFwKGxpc3QgPT4gW2xpc3QsIGluZGV4XSksXHJcbiAgKTtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZSguLi50YWdnZWQpXHJcbiAgICAuc2NhbigoYWNjdW11bGF0b3IsIFtsaXN0LCBpbmRleF0pID0+IHtcclxuICAgICAgYWNjdW11bGF0b3JbaW5kZXhdID0gbGlzdDtcclxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xyXG4gICAgfSwgb2JzZXJ2YWJsZXMubWFwKHggPT4gW10pKVxyXG4gICAgLm1hcChhY2N1bXVsYXRvciA9PiBbXS5jb25jYXQoLi4uYWNjdW11bGF0b3IpKTtcclxufVxyXG5cclxuLy8gVXNlIGEgc2VudGluZWwgc28gd2UgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW4gd2hlbiBgbnVsbGAgaXMgZW1pdHRlZCBhbmQgd2hlblxyXG4vLyBub3RoaW5nIGlzLlxyXG5jb25zdCBOT05FID0ge307XHJcblxyXG50eXBlIFRocm90dGxlT3B0aW9ucyA9IHt8XHJcbiAgbGVhZGluZz86IGJvb2xlYW4sXHJcbnx9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlPFQ+KFxyXG4gIGRlbGF5OlxyXG4gICAgfCBudW1iZXJcclxuICAgIHwgKCh2YWx1ZTogVCkgPT4gT2JzZXJ2YWJsZTxhbnk+IHwgUHJvbWlzZTxhbnk+KVxyXG4gICAgfCBPYnNlcnZhYmxlPGFueT5cclxuICAgIHwgUHJvbWlzZTxhbnk+LFxyXG4gIG9wdGlvbnM/OiBUaHJvdHRsZU9wdGlvbnMgPSB7bGVhZGluZzogdHJ1ZX0sXHJcbik6IChvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+IHtcclxuICBsZXQgZ2V0RGVsYXk6ICh2YWx1ZTogVCkgPT4gT2JzZXJ2YWJsZTxhbnk+IHwgUHJvbWlzZTxhbnk+O1xyXG4gIHN3aXRjaCAodHlwZW9mIGRlbGF5KSB7XHJcbiAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICBnZXREZWxheSA9ICgpID0+IE9ic2VydmFibGUudGltZXIoZGVsYXkpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcclxuICAgICAgZ2V0RGVsYXkgPSBkZWxheTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICBnZXREZWxheSA9ICgpID0+IGRlbGF5O1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZWxheTogJHtkZWxheX1gKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBkb1Rocm90dGxlKHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICAgICAgY29uc3Qge2xlYWRpbmcgPSB0cnVlfSA9IG9wdGlvbnM7XHJcbiAgICAgIGNvbnN0IHRpbWVyU3RhcnRzID0gbmV3IFN1YmplY3QoKTtcclxuICAgICAgbGV0IGxhdGVzdFZhbHVlID0gTk9ORTtcclxuICAgICAgbGV0IGxhdGVzdFZhbHVlSXNMZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgIGxldCBzaG91bGRJZ25vcmUgPSBmYWxzZTtcclxuXHJcbiAgICAgIGNvbnN0IGNoZWNrU2hvdWxkTmV4dCA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIXNob3VsZElnbm9yZSAmJiBsYXRlc3RWYWx1ZSAhPT0gTk9ORSkge1xyXG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgbGF0ZXN0VmFsdWUgbXVzdCBiZSBvZiB0eXBlIFRcclxuICAgICAgICAgIGxhdGVzdFZhbHVlID0gKChsYXRlc3RWYWx1ZTogYW55KTogVCk7XHJcblxyXG4gICAgICAgICAgY29uc3QgdmFsdWVUb0Rpc3BhdGNoID0gbGF0ZXN0VmFsdWU7XHJcbiAgICAgICAgICBzaG91bGRJZ25vcmUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGlmIChsZWFkaW5nIHx8ICFsYXRlc3RWYWx1ZUlzTGVhZGluZykge1xyXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZSA9IE5PTkU7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWVUb0Rpc3BhdGNoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRpbWVyU3RhcnRzLm5leHQodmFsdWVUb0Rpc3BhdGNoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XHJcbiAgICAgIHN1Yi5hZGQoXHJcbiAgICAgICAgdGltZXJTdGFydHNcclxuICAgICAgICAgIC5zd2l0Y2hNYXAoeCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gZ2V0RGVsYXkoeCk7XHJcbiAgICAgICAgICAgIGlmICh0aW1lciBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGltZXIudGFrZSgxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcclxuICAgICAgICAgICAgc2hvdWxkSWdub3JlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxhdGVzdFZhbHVlSXNMZWFkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNoZWNrU2hvdWxkTmV4dCgpO1xyXG4gICAgICAgICAgfSksXHJcbiAgICAgICk7XHJcbiAgICAgIHN1Yi5hZGQoXHJcbiAgICAgICAgc291cmNlLnN1YnNjcmliZSh7XHJcbiAgICAgICAgICBuZXh0OiB4ID0+IHtcclxuICAgICAgICAgICAgbGF0ZXN0VmFsdWUgPSB4O1xyXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZUlzTGVhZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGNoZWNrU2hvdWxkTmV4dCgpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGVycm9yOiBlcnIgPT4ge1xyXG4gICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBob2xkIGEgcmVmZXJlbmNlIHRvIHRoZSBsYXN0IHZhbHVlLlxyXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZSA9IE5PTkU7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgcmV0dXJuIHN1YjtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIHdoaWNoIHRha2VzIGFuIGBvYnNlcnZhYmxlYCBhbmQgcmV0dXJuc1xyXG4gKiBgb2JzZXJ2YWJsZS5zd2l0Y2hNYXAocHJvamVjdClgLCBleGNlcHQgdGhhdCBpdCBjb21wbGV0ZXNcclxuICogd2hlbiB0aGUgb3V0ZXIgb2JzZXJ2YWJsZSBjb21wbGV0ZXMuXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgT2JzZXJ2YWJsZS5vZigxKVxyXG4gKiAgICAgLmxldChjb21wbGV0aW5nU3dpdGNoTWFwKHggPT4gT2JzZXJ2YWJsZS5uZXZlcigpKSlcclxuICpcclxuICogZW5kcyB1cCByZXR1cm5pbmcgYW4gT2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyBpbW1lZGlhdGVseS5cclxuICogV2l0aCBhIHJlZ3VsYXIgc3dpdGNoTWFwLCB0aGlzIHdvdWxkIG5ldmVyIHRlcm1pbmF0ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wbGV0aW5nU3dpdGNoTWFwPFQsIFU+KFxyXG4gIHByb2plY3Q6IChpbnB1dDogVCwgaW5kZXg6IG51bWJlcikgPT4gcnhqcyRPYnNlcnZhYmxlSW5wdXQ8VT4sXHJcbik6IChPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFU+IHtcclxuICAvLyBBbiBhbHRlcm5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB0byBtYXRlcmlhbGl6ZSB0aGUgaW5wdXQgb2JzZXJ2YWJsZSxcclxuICAvLyBidXQgdGhpcyBhdm9pZHMgdGhlIGNyZWF0aW9uIG9mIGV4dHJhIG5vdGlmaWVyIG9iamVjdHMuXHJcbiAgY29uc3QgY29tcGxldGVkU3ltYm9sID0gU3ltYm9sKCdjb21wbGV0ZWQnKTtcclxuICByZXR1cm4gKG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4pID0+XHJcbiAgICBPYnNlcnZhYmxlLmNvbmNhdChcclxuICAgICAgb2JzZXJ2YWJsZSxcclxuICAgICAgT2JzZXJ2YWJsZS5vZigoY29tcGxldGVkU3ltYm9sOiBhbnkpKSxcclxuICAgICkuc3dpdGNoTWFwKChpbnB1dCwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKGlucHV0ID09PSBjb21wbGV0ZWRTeW1ib2wpIHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5lbXB0eSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBwcm9qZWN0KGlucHV0LCBpbmRleCk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgb2JzZXJ2YWJsZSBjb25zaXN0aW5nIG9mIHRoZSBtZXJnZWQgdmFsdWVzIGZyb20gdGhlIHBhc3NlZFxyXG4gKiBvYnNlcnZhYmxlcyBhbmQgY29tcGxldGVzIHdoZW4gdGhlIGZpcnN0IGlubmVyIG9ic2VydmFibGUgY29tcGxldGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlVW50aWxBbnlDb21wbGV0ZTxUPihcclxuICAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZTxUPj5cclxuKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IE9ic2VydmFibGUubWVyZ2UoXHJcbiAgICAuLi5vYnNlcnZhYmxlcy5tYXAobyA9PiBvLm1hdGVyaWFsaXplKCkpLFxyXG4gICk7XHJcbiAgLy8gJEZsb3dGaXhNZSBhZGQgZGVtYXRlcmlhbGl6ZSB0byByeGpzIEZsb3cgdHlwZXNcclxuICByZXR1cm4gbm90aWZpY2F0aW9ucy5kZW1hdGVyaWFsaXplKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSeEpTJ3MgZGVib3VuY2VUaW1lIGlzIGFjdHVhbGx5IGZhaXJseSBpbmVmZmljaWVudDpcclxuICogb24gZWFjaCBldmVudCwgaXQgYWx3YXlzIGNsZWFycyBpdHMgaW50ZXJ2YWwgYW5kIFtjcmVhdGVzIGEgbmV3IG9uZV1bMV0uXHJcbiAqIFVudGlsIHRoaXMgaXMgZml4ZWQsIHRoaXMgdXNlcyBvdXIgZGVib3VuY2UgaW1wbGVtZW50YXRpb24gd2hpY2hcclxuICogcmV1c2VzIGEgdGltZW91dCBhbmQganVzdCBzZXRzIGEgdGltZXN0YW1wIHdoZW4gcG9zc2libGUuXHJcbiAqXHJcbiAqIFRoaXMgbWF5IHNlZW0gbGlrZSBhIG1pY3JvLW9wdGltaXphdGlvbiBidXQgd2Ugb2Z0ZW4gdXNlIGRlYm91bmNlc1xyXG4gKiBmb3IgdmVyeSBob3QgZXZlbnRzLCBsaWtlIGtleXByZXNzZXMuIEV4Y2VlZGluZyB0aGUgZnJhbWUgYnVkZ2V0IGNhbiBlYXNpbHkgbGVhZFxyXG4gKiB0byBpbmNyZWFzZWQga2V5IGxhdGVuY3khXHJcbiAqXHJcbiAqIFsxXTogaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0aXZlWC9yeGpzL2Jsb2IvbWFzdGVyL3NyYy9vcGVyYXRvcnMvZGVib3VuY2VUaW1lLnRzI0wxMDZcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYXN0RGVib3VuY2U8VD4oXHJcbiAgZGVsYXk6IG51bWJlcixcclxuKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xyXG4gIHJldHVybiAob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUPikgPT5cclxuICAgIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICAgICAgY29uc3QgZGVib3VuY2VkTmV4dCA9IGRlYm91bmNlKCh4OiBUKSA9PiBvYnNlcnZlci5uZXh0KHgpLCBkZWxheSk7XHJcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKFxyXG4gICAgICAgIGRlYm91bmNlZE5leHQsXHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciksXHJcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlciksXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBuZXcgVW5pdmVyc2FsRGlzcG9zYWJsZShzdWJzY3JpcHRpb24sIGRlYm91bmNlZE5leHQpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBtaWNyb3Rhc2sgPSBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XHJcbiAgICBvYnNlcnZlci5uZXh0KCk7XHJcbiAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gIH0pO1xyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBtYWNyb3Rhc2sgPSBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgY29uc3QgdGltZXJJZCA9IHNldEltbWVkaWF0ZSgoKSA9PiB7XHJcbiAgICBvYnNlcnZlci5uZXh0KCk7XHJcbiAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gIH0pO1xyXG4gIHJldHVybiAoKSA9PiB7XHJcbiAgICBjbGVhckltbWVkaWF0ZSh0aW1lcklkKTtcclxuICB9O1xyXG59KTtcclxuXHJcbmV4cG9ydCBjb25zdCBuZXh0QW5pbWF0aW9uRnJhbWUgPSBPYnNlcnZhYmxlLmNyZWF0ZShvYnNlcnZlciA9PiB7XHJcbiAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdXRpbCBjYW4gb25seSBiZSB1c2VkIGluIEF0b20nKTtcclxuICB9XHJcbiAgY29uc3QgaWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgb2JzZXJ2ZXIubmV4dCgpO1xyXG4gICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICB9KTtcclxuICByZXR1cm4gKCkgPT4ge1xyXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBhcm91bmQgYW4gYWJvcnRhYmxlIHByb21pc2UuXHJcbiAqIFVuc3Vic2NyaXB0aW9ucyBhcmUgZm9yd2FyZGVkIHRvIHRoZSBBYm9ydENvbnRyb2xsZXIgYXMgYW4gYGFib3J0KClgLlxyXG4gKiBFeGFtcGxlIHVzYWdlICh3aXRoIGFuIGFib3J0YWJsZSBmZXRjaCk6XHJcbiAqXHJcbiAqICAgZnJvbVByb21pc2Uoc2lnbmFsID0+IGZldGNoKHVybCwgey4uLm9wdGlvbnMsIHNpZ25hbH0pKVxyXG4gKiAgICAgLnN3aXRjaE1hcCguLi4uKVxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBjYW4gdGFrZSBhIG5vcm1hbCBgKCkgPT4gUHJvbWlzZTxUPmAgdG9vXHJcbiAqIChpbiB3aGljaCBjYXNlIHRoaXMgYWN0cyBhcyBqdXN0IGEgcGxhaW4gYE9ic2VydmFibGUuZGVmZXJgKS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJvcnRhYmxlUHJvbWlzZTxUPihcclxuICBmdW5jOiAoc2lnbmFsOiBBYm9ydFNpZ25hbCkgPT4gUHJvbWlzZTxUPixcclxuKTogT2JzZXJ2YWJsZTxUPiB7XHJcbiAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKG9ic2VydmVyID0+IHtcclxuICAgIGxldCBjb21wbGV0ZWQgPSBmYWxzZTtcclxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGZ1bmMoYWJvcnRDb250cm9sbGVyLnNpZ25hbCkudGhlbihcclxuICAgICAgdmFsdWUgPT4ge1xyXG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgfSxcclxuICAgICAgZXJyb3IgPT4ge1xyXG4gICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmICghY29tcGxldGVkKSB7XHJcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XHJcbiAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgYWRoZXJlcyB0byB0aGUgc3BlYywgaXQgc2hvdWxkIHRocm93LlxyXG4gICAgICAgIC8vIFRoZSBlcnJvciB3aWxsIGJlIGNhcHR1cmVkIGFib3ZlIGJ1dCBnbyBpbnRvIHRoZSB2b2lkLlxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgYW4gb2JzZXJ2YWJsZSArIEFib3J0U2lnbmFsIGludG8gYSBjYW5jZWxsYWJsZSBQcm9taXNlLFxyXG4gKiB3aGljaCByZWplY3RzIHdpdGggYW4gQWJvcnRFcnJvciBET01FeGNlcHRpb24gb24gYWJvcnQuXHJcbiAqIFVzZWZ1bCB3aGVuIHdyaXRpbmcgdGhlIGludGVybmFscyBvZiBhIGNhbmNlbGxhYmxlIHByb21pc2UuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiAgIGZ1bmN0aW9uIGFib3J0YWJsZUZ1bmN0aW9uKGFyZzE6IGJsYWgsIG9wdGlvbnM/OiB7c2lnbmFsPzogQWJvcnRTaWduYWx9KTogUHJvbWlzZSB7XHJcbiAqICAgICByZXR1cm4gdG9Qcm9taXNlKFxyXG4gKiAgICAgICBvYnNlcnZhYmxlRnVuY3Rpb24oYXJnMSwgb3B0aW9ucyksXHJcbiAqICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduYWwsXHJcbiAqICAgICApO1xyXG4gKiAgIH1cclxuICpcclxuICogQ291bGQgZXZlbnR1YWxseSBiZSByZXBsYWNlZCBieSBPYnNlcnZhYmxlLmZpcnN0IGlmXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZG9tL2lzc3Vlcy81NDQgZ29lcyB0aHJvdWdoLlxyXG4gKlxyXG4gKiBJdCdzIGN1cnJlbnRseSB1bmNsZWFyIGlmIHRoaXMgc2hvdWxkIGJlIHVzYWJsZSB3aXRoIGxldC9waXBlOlxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RpdmVYL3J4anMvaXNzdWVzLzM0NDVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0b0Fib3J0YWJsZVByb21pc2U8VD4oXHJcbiAgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUPixcclxuICBzaWduYWw/OiA/QWJvcnRTaWduYWwsXHJcbik6IFByb21pc2U8VD4ge1xyXG4gIGlmIChzaWduYWwgPT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG9ic2VydmFibGUudG9Qcm9taXNlKCk7XHJcbiAgfVxyXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xyXG4gIH1cclxuICByZXR1cm4gb2JzZXJ2YWJsZVxyXG4gICAgLnJhY2UoXHJcbiAgICAgIE9ic2VydmFibGUuZnJvbUV2ZW50KHNpZ25hbCwgJ2Fib3J0JykubWFwKCgpID0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKTtcclxuICAgICAgfSksXHJcbiAgICApXHJcbiAgICAudG9Qcm9taXNlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXaGVuIHVzaW5nIE9ic2VydmFibGVzIHdpdGggQWJvcnRTaWduYWxzLCBiZSBzdXJlIHRvIHVzZSB0aGlzIC1cclxuICogaXQncyByZWFsbHkgZWFzeSB0byBtaXNzIHRoZSBjYXNlIHdoZW4gdGhlIHNpZ25hbCBpcyBhbHJlYWR5IGFib3J0ZWQhXHJcbiAqIFJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIHdpdGggbGV0L3BpcGU6XHJcbiAqXHJcbiAqICAgbXlPYnNlcnZhYmxlXHJcbiAqICAgICAubGV0KHRha2VVbnRpbEFib3J0KHNpZ25hbCkpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdGFrZVVudGlsQWJvcnQ8VD4oXHJcbiAgc2lnbmFsOiBBYm9ydFNpZ25hbCxcclxuKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xyXG4gIHJldHVybiBvYnNlcnZhYmxlID0+XHJcbiAgICBPYnNlcnZhYmxlLmRlZmVyKCgpID0+IHtcclxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuZW1wdHkoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZS50YWtlVW50aWwoT2JzZXJ2YWJsZS5mcm9tRXZlbnQoc2lnbmFsLCAnYWJvcnQnKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gRXhlY3V0ZXMgdGFza3MuIEVuc3VyZXMgdGhhdCBhdCBtb3N0IG9uZSB0YXNrIGlzIHJ1bm5pbmcgYXQgYSB0aW1lLlxyXG4vLyBUaGlzIGNsYXNzIGlzIGhhbmR5IGZvciBleHBlbnNpdmUgdGFza3MgbGlrZSBwcm9jZXNzZXMsIHByb3ZpZGVkXHJcbi8vIHlvdSBuZXZlciB3YW50IHRoZSByZXN1bHQgb2YgYSBwcmV2aW91cyB0YXNrIGFmdGVyIGEgbmV3IHRhc2sgaGFzIHN0YXJ0ZWQuXHJcbmV4cG9ydCBjbGFzcyBTaW5nbGV0b25FeGVjdXRvcjxUPiB7XHJcbiAgX2Fib3J0Q29udHJvbGxlcjogP0Fib3J0Q29udHJvbGxlciA9IG51bGw7XHJcblxyXG4gIC8vIEV4ZWN1dGVzKHN1YnNjcmliZXMgdG8pIHRoZSB0YXNrLlxyXG4gIC8vIFdpbGwgdGVybWluYXRlKHVuc3Vic2NyaWJlKSB0byBhbnkgcHJldmlvdXNseSBleGVjdXRpbmcgdGFzay5cclxuICAvLyBTdWJzZXF1ZW50IGV4ZWN1dGVzKCkgd2lsbCB0ZXJtaW5hdGUgdGhpcyB0YXNrIGlmIGNhbGxlZCBiZWZvcmVcclxuICAvLyB0aGlzIHRhc2sgY29tcGxldGVzLlxyXG4gIGFzeW5jIGV4ZWN1dGUoY3JlYXRlVGFzazogT2JzZXJ2YWJsZTxUPik6IFByb21pc2U8VD4ge1xyXG4gICAgLy8gS2lsbCBhbnkgcHJldmlvdXNseSBydW5uaW5nIHByb2Nlc3Nlc1xyXG4gICAgdGhpcy5jYW5jZWwoKTtcclxuXHJcbiAgICAvLyBTdGFydCBhIG5ldyBwcm9jZXNzXHJcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gY29udHJvbGxlcjtcclxuXHJcbiAgICAvLyBXYWl0IGZvciB0aGUgcHJvY2VzcyB0byBjb21wbGV0ZSBvciBiZSBjYW5jZWxlZCAuLi5cclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0b0Fib3J0YWJsZVByb21pc2UoY3JlYXRlVGFzaywgY29udHJvbGxlci5zaWduYWwpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgLy8gLi4uIGFuZCBhbHdheXMgY2xlYW4gdXAgaWYgd2UgaGF2ZW4ndCBiZWVuIGNhbmNlbGVkIGFscmVhZHkuXHJcbiAgICAgIGlmIChjb250cm9sbGVyID09PSB0aGlzLl9hYm9ydENvbnRyb2xsZXIpIHtcclxuICAgICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpc0V4ZWN1dGluZygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9hYm9ydENvbnRyb2xsZXIgIT0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIENhbmNlbHMgYW55IGN1cnJlbnRseSBleGVjdXRpbmcgdGFza3MuXHJcbiAgY2FuY2VsKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2Fib3J0Q29udHJvbGxlciAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xyXG4gICAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlcGVhdGVkbHkgc3Vic2NyaWJlIHRvIGFuIG9ic2VydmFibGUgZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHdhaXRpbmcgZm9yIHRoZSBvYnNlcnZhYmxlIHRvXHJcbiAqIGNvbXBsZXRlIGVhY2ggdGltZS4gVGhpcyBpcyBwcmVmZXJhYmxlIHRvLCBzYXksIGBPYnNlcnZhYmxlLmludGVydmFsKGQpLnN3aXRjaE1hcCgoKSA9PiBzb3VyY2UpYFxyXG4gKiBiZWNhdXNlLCBpbiB0aGUgY2FzZSB0aGF0IGBzb3VyY2VgIHRha2VzIGxvbmdlciB0aGFuIGBkYCBtaWxsaXNlY29uZHMgdG8gcHJvZHVjZSBhIHZhbHVlLCB0aGF0XHJcbiAqIGZvcm11bGF0aW9uIHdpbGwgbmV2ZXIgcHJvZHVjZSBhIHZhbHVlICh3aGlsZSBjb250aW51aW5nIHRvIGluY3VyIHRoZSBvdmVyaGVhZCBvZiBzdWJzY3JpYmluZyB0b1xyXG4gKiBzb3VyY2UpLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICAvLyBBc2sgd2hhdCB0aW1lIGl0IGlzIGV2ZXJ5IHNlY29uZCB1bnRpbCBpdCdzIEZyaWRheS5cclxuICogICAgcnVuQ29tbWFuZCgnZGF0ZScpXHJcbiAqICAgICAgLmxldChwb2xsKDEwMDApKVxyXG4gKiAgICAgIC5maWx0ZXIob3V0cHV0ID0+IG91dHB1dC5zdGFydHNXaXRoKCdGcmknKSlcclxuICogICAgICAudGFrZSgxKVxyXG4gKiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gKiAgICAgICAgY29uc29sZS5sb2coXCJJVCdTIEZSSURBWSEhXCIpXHJcbiAqICAgICAgfSk7XHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9sbDxUPihkZWxheTogbnVtYmVyKTogKE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4ge1xyXG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PlxyXG4gICAgT2JzZXJ2YWJsZS5kZWZlcigoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGRlbGF5cyA9IG5ldyBTdWJqZWN0KCk7XHJcbiAgICAgIHJldHVybiBkZWxheXNcclxuICAgICAgICAuc3dpdGNoTWFwKG4gPT4gT2JzZXJ2YWJsZS50aW1lcihuKSlcclxuICAgICAgICAubWVyZ2UoT2JzZXJ2YWJsZS5vZihudWxsKSlcclxuICAgICAgICAuc3dpdGNoTWFwKCgpID0+IHtcclxuICAgICAgICAgIGNvbnN0IHN1YnNjcmliZWRBdCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICByZXR1cm4gc291cmNlLmRvKHtcclxuICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICBjb25zdCB0aW1lRWxhcHNlZCA9IERhdGUubm93KCkgLSBzdWJzY3JpYmVkQXQ7XHJcbiAgICAgICAgICAgICAgZGVsYXlzLm5leHQoTWF0aC5tYXgoMCwgZGVsYXkgLSB0aW1lRWxhcHNlZCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iXX0=