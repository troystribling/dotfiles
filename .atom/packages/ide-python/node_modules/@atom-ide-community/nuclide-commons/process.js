"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runCommand = runCommand;
exports.observeProcess = observeProcess;
exports.runCommandDetailed = runCommandDetailed;
exports.observeProcessRaw = observeProcessRaw;
exports.spawn = spawn;
exports.fork = fork;
exports.getOutputStream = getOutputStream;
exports.scriptifyCommand = scriptifyCommand;
exports.killProcess = killProcess;
exports.killPid = killPid;
exports.getOriginalEnvironment = getOriginalEnvironment;
exports.getOriginalEnvironmentArray = getOriginalEnvironmentArray;
exports.getEnvironment = getEnvironment;
exports.exitEventToMessage = exitEventToMessage;
exports.getChildrenOfProcess = getChildrenOfProcess;
exports.psTree = psTree;
exports.parsePsOutput = parsePsOutput;
exports.memoryUsagePerPid = memoryUsagePerPid;
exports.preventStreamsFromThrowing = preventStreamsFromThrowing;
exports.logStreamErrors = logStreamErrors;
exports.getAbsoluteBinaryPathForPid = getAbsoluteBinaryPathForPid;
exports.killUnixProcessTree = killUnixProcessTree;
exports.loggedCalls = exports.ProcessLoggingEvent = exports.ProcessTimeoutError = exports.MaxBufferExceededError = exports.ProcessSystemError = exports.ProcessExitError = exports.LOG_CATEGORY = void 0;

var _child_process = _interopRequireDefault(require("child_process"));

var _idx = _interopRequireDefault(require("idx"));

var _log4js = require("log4js");

var _assert = _interopRequireDefault(require("assert"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

var _util = _interopRequireDefault(require("util"));

var _UniversalDisposable = _interopRequireDefault(require("./UniversalDisposable"));

var _nuclideUri = _interopRequireDefault(require("./nuclideUri"));

var _performanceNow = _interopRequireDefault(require("./performanceNow"));

var _collection = require("./collection");

var _event = require("./event");

var _stream = require("./stream");

var _observable = require("./observable");

var _string = require("./string");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
//
//                 __   __   __   __   ___  __   __         __
//                |__) |__) /  \ /  ` |__  /__` /__`     | /__`
//                |    |  \ \__/ \__, |___ .__/ .__/ .\__/ .__/
//
// This module contains utilities for spawning processes in Nuclide. In general:
//
// - They accept similar arguments.
// - They return an observable.
// - The process is spawned if/when you subscribe to the observable.
// - If you unsubscribe before the observable completes, the process is killed.
// - The observable errors if the process completes with a non-zero exit code (by default; this can
//   be changed) or if the process can't be spawned.
//
// The most important functions in this module are `runCommand()`--for running a quick command and
// getting its output--and `observeProcess()`--for streaming output from a process. They'll handle
// the majority of use cases.
//
// ## Why observables?
//
// Unlike Promises, observables have a standardized, composable cancellation mechanism _today_.
// Moreover, observables integrate nicely with Atom's callback + IDisposable formula for cancelable,
// async APIs. Along with React, [RxJS] is one of the core libraries utilized by Nuclide.
//
// ## Why errors?
//
// In the past, we had some process APIs that used errors and some that used return values.
// Consistency has obvious benefits; standardizing on errors makes sense because:
//
// - The error-throwing APIs were the most used, by a large margin.
// - Unhandled errors can be caught and logged at the top level.
// - Observables have a separate channel for errors which allows for cool, error-aware operators
//   like `retry()` and caching.
// - Errors in observables are stream-ending. This means you won't continue to do work in a chain of
//   operators accidentally.
//
// [RxJS]: http://reactivex.io/rxjs/
const LOG_CATEGORY = '@atom-ide-community/nuclide-commons/process';
exports.LOG_CATEGORY = LOG_CATEGORY;
const NUCLIDE_DO_NOT_LOG = global.NUCLIDE_DO_NOT_LOG;
const logger = (0, _log4js.getLogger)(LOG_CATEGORY);
/**
 * Run a command, accumulate the output. Errors are surfaced as stream errors and unsubscribing will
 * kill the process. In addition to the options accepted by Node's [`child_process.spawn()`][1]
 * function, `runCommand()` also accepts the following:
 *
 * - `input` {string | Observable<string>} Text to write to the new process's stdin.
 * - `killTreeWhenDone` {boolean} `false` by default. If you pass `true`, unsubscribing from the
 *   observable will kill not only this process but also its descendants.
 * - `isExitError` {function} Determines whether a ProcessExitError should be raised based on the
 *   exit message. By default, this is a function that returns `true` if the exit code is non-zero.
 * - `maxBuffer` {number} The maximum amount of stdout and stderror to accumulate. If the process
 *   produces more of either, a MaxBufferExceededError will be emitted.
 * - `timeout` {number} The number of milliseconds to wait before killing the process and emitting
 *   an error. This is mostly provided for backwards compatibility, as you can get the same result
 *   by using the `.timeout()` operator on the returned observable.
 *
 * The observable returned by this function can error with any of the following:
 *
 * - `ProcessSystemError` Wrap [Node System Errors][2] (which are just augmented `Error` objects)
 *    and include things like `ENOENT`. These contain all of the properties of node system errors
 *    as well as a reference to the process.
 * - `ProcessExitError` Indicate that the process has ended cleanly, but with an unsuccessful exit
 *    code. Whether a `ProcessExitError` is thrown is determined by the `isExitError` option. This
 *    error includes the exit code as well as accumulated stdout and stderr. See its definition for
 *    more information.
 * - `MaxBufferExceededError` Thrown if either the stdout or stderr exceeds the value specified by
 *    the `maxBuffer` option.
 * - `ProcessTimeoutError` Thrown if the process doesn't complete within the time specified by the
 *   `timeout` option.
 *
 * Example:
 *
 * ```js
 * const subscription = runCommand('ps', ['-e', '-o', 'pid,comm'])
 *   .map(stdout => {
 *     return stdout.split('\n')
 *       .slice(1)
 *       .map(line => {
 *         const words = line.trim().split(' ');
 *         return {
 *           pid: words[0],
 *           command: words.slice(1).join(' '),
 *         };
 *       })
 *       .sort((p1, p2) => p2.pid - p1.pid);
 *   })
 *   .subscribe(processes => {
 *     console.log(`The process with the highest pid is ${processes[0].command}`);
 *   });
 * ```
 *
 * [1]: https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options
 * [2]: https://nodejs.org/api/errors.html#errors_class_system_error
 */

function runCommand(command, args = [], options = {}, rest) {
  return runCommandDetailed(command, args, options).map(event => event.stdout);
}
/**
 * Returns an observable that spawns a process and emits events on stdout, stderr and exit. Output
 * is buffered by line. Unsubscribing before the observable completes will kill the process. This
 * function accepts the same options as `runCommand()`, and throws the same errors.
 *
 * Besides emitting multiple events, another difference with `runCommand()` is the ProcessExitErrors
 * thrown by `observeProcess()`. Whereas ProcessExitErrors thrown by `runCommand()` contain the
 * entirety of stdout and stderr, those thrown by `observeProcess()` contain a truncated amount of
 * stderr and no stdout. This is because `observeProcess()` is usually used with long-running
 * processes that may continue to produce output for a long while. The abbreviated stderr is
 * included to help with debugging.
 *
 * Example:
 *
 * ```js
 * const filesToTail: Observable<NuclideUri> = f();
 * const subscription = filesToTail
 *   // `switchMap()` means only one file will be tailed at a time.
 *   .switchMap(path => observeProcess('tail', ['-f', path]))
 *   .filter(event => event.kind === 'stdout')
 *   .map(event => event.data)
 *   .subscribe(line => {
 *     console.log(line);
 *   });
 * ```
 */


function observeProcess(command, args, options) {
  return spawn(command, args, options).flatMap(proc => getOutputStream(proc, options));
}

/**
 * Identical to `runCommand()`, but instead of only emitting the accumulated stdout, the returned
 * observable emits an object containing the accumulated stdout, the accumulated stderr, and the
 * exit code.
 *
 * In general, you should prefer `runCommand()`, however, this function is useful for when stderr is
 * needed even if the process exits successfully.
 */
function runCommandDetailed(command, args = [], options = {}, rest) {
  const maxBuffer = (0, _idx.default)(options, _ => _.maxBuffer) || DEFAULT_MAX_BUFFER;
  return observeProcess(command, args, { ...options,
    maxBuffer
  }).catch(error => {
    // Catch ProcessExitErrors so that we can add stdout to them.
    if (error instanceof ProcessExitError) {
      return _rxjsCompatUmdMin.Observable.of({
        kind: 'process-exit-error',
        error
      });
    }

    throw error;
  }).reduce((acc, event) => {
    switch (event.kind) {
      case 'stdout':
        return { ...acc,
          stdout: acc.stdout + event.data
        };

      case 'stderr':
        return { ...acc,
          stderr: acc.stderr + event.data
        };

      case 'exit':
        return { ...acc,
          exitCode: event.exitCode
        };

      case 'process-exit-error':
        const {
          error
        } = event;
        throw new ProcessExitError(error.exitCode, error.signal, error.process, acc.stderr, acc.stdout);

      default:
        event.kind;
        throw new Error(`Invalid event kind: ${event.kind}`);
    }
  }, {
    stdout: '',
    stderr: '',
    exitCode: null
  });
}
/**
 * Identical to `observeProcess()`, but doesn't buffer by line.
 */


function observeProcessRaw(command, args, options) {
  return spawn(command, args, options).flatMap(proc => getOutputStream(proc, { ...options,
    splitByLines: false
  }));
} //
// # Lower-level APIs
//
// The following functions are used to create the higher-level APIs above. It's rare that you'll
// need to use them by themselves.
//

/**
 * Creates an observable that spawns a process and emits it. Like with `runCommand()` and
 * `observeProcess()`, if you unsubscribe from the returned observable, the process will be killed
 * (or, if it hasn't yet been spawned, it won't be created).
 *
 * Unlike `observeProcess()`, the returned observable won't throw ProcessExitErrors--only system
 * errors raised when trying to spawn the process. This is because it's meant to be composed with
 * `getOutputStream` which terminates based on the "close" event whereas this terminates on the
 * "exit" event to ensure that you don't try to interact with a dead process.
 *
 * This function is useful when, for example, you need access to the process in order to send IPC
 * messages to it. It can be composed with `getOutputStream()` to give the same functionality of
 * `observeProcess()`:
 *
 * ```js
 * const subscription = spawn(...)
 *   .map(proc => {
 *     // With access to the process, you can send IPC messages.
 *
 *     return getOutputStream(proc);
 *   })
 *   .subscribe(event => {
 *     // These events are the same as those emitted by `observeProcess()`.
 *   });
 * ```
 */


function spawn(command, args, options) {
  return createProcessStream('spawn', command, args, options);
}
/**
 * Identical to `spawn()` (above), but uses `child_process.fork()` to create the process.
 */


function fork(modulePath, args, options) {
  return createProcessStream('fork', modulePath, args, options);
}
/**
 * Creates a stream of sensibly-ordered stdout, stdin, and exit messages from a process. Generally,
 * you shouldn't use this function and should instead use `observeProcess()` (which makes use of
 * this for you).
 *
 * IMPORTANT: If you must use this function, it's very important that the process you give it was
 * just synchronously created. Otherwise, you can end up missing messages.
 *
 * This function intentionally does not close the process when you unsubscribe. It's usually used in
 * conjunction with `spawn()` which does that already.
 */


function getOutputStream(proc, options, rest) {
  const chunk = (0, _idx.default)(options, _ => _.splitByLines) === false ? x => x : _observable.splitStream;
  const maxBuffer = (0, _idx.default)(options, _ => _.maxBuffer);
  const isExitError = (0, _idx.default)(options, _ => _.isExitError) || isExitErrorDefault;
  const exitErrorBufferSize = (0, _idx.default)(options, _ => _.exitErrorBufferSize) || 2000;
  return _rxjsCompatUmdMin.Observable.defer(() => {
    const stdoutEvents = chunk(limitBufferSize((0, _stream.observeStream)(proc.stdout), maxBuffer, 'stdout')).map(data => ({
      kind: 'stdout',
      data
    }));
    const stderrEvents = chunk(limitBufferSize((0, _stream.observeStream)(proc.stderr), maxBuffer, 'stderr')).map(data => ({
      kind: 'stderr',
      data
    })).share(); // Accumulate the first `exitErrorBufferSize` bytes of stderr so that we can give feedback about
    // about exit errors (then stop so we don't fill up memory with it).

    const accumulatedStderr = stderrEvents.scan((acc, event) => (acc + event.data).slice(0, exitErrorBufferSize), '').startWith('').let((0, _observable.takeWhileInclusive)(acc => acc.length < exitErrorBufferSize)); // We need to start listening for the exit event immediately, but defer emitting it until the
    // (buffered) output streams end.

    const closeEvents = _rxjsCompatUmdMin.Observable.fromEvent(proc, // We listen to the "close" event instead of "exit" because we want to get all of the stdout
    // and stderr.
    'close', (exitCode, signal) => ({
      kind: 'exit',
      exitCode,
      signal
    })).filter(isRealExit).take(1).withLatestFrom(accumulatedStderr).map(([event, stderr]) => {
      if (isExitError(event)) {
        throw new ProcessExitError(event.exitCode, event.signal, proc, stderr);
      }

      return event;
    }).publishReplay();

    const exitSub = closeEvents.connect();
    return _rxjsCompatUmdMin.Observable.merge(stdoutEvents, stderrEvents).concat(closeEvents).let((0, _observable.takeWhileInclusive)(event => event.kind !== 'error' && event.kind !== 'exit')).finally(() => {
      exitSub.unsubscribe();
    });
  });
} //
// # Miscellaneous Utilities
//
// The following utilities don't spawn processes or necessarily use observables. Instead, they're
// used to format arguments to the above functions or for acting on already-spawned processes.
//

/**
 * Takes the arguments that you would normally pass to `spawn()` and returns an array of new
 * arguments to use to run the command under `script`.
 *
 * Example:
 *
 * ```js
 * observeProcess(...scriptifyCommand('hg', ['diff'])).subscribe(...);
 * ```
 *
 * See also `nicifyCommand()` which does a similar thing but for `nice`.
 */


function scriptifyCommand(command, args = [], options) {
  if (process.platform === 'darwin') {
    // On OS X, script takes the program to run and its arguments as varargs at the end.
    return ['script', ['-q', '/dev/null', command].concat(args), options];
  } else {
    // On Linux, script takes the command to run as the -c parameter so we have to combine all of
    // the arguments into a single string.
    const joined = (0, _string.shellQuote)([command, ...args]); // flowlint-next-line sketchy-null-mixed:off

    const opts = options || {}; // flowlint-next-line sketchy-null-mixed:off

    const env = opts.env || {};
    return ['script', ['-q', '/dev/null', '-c', joined], // `script` will use `SHELL`, but shells have different behaviors with regard to escaping. To
    // make sure that out escaping is correct, we need to force a particular shell.
    { ...opts,
      env: { ...env,
        SHELL: '/bin/bash'
      }
    }];
  }
}
/**
 * Kills a process and, optionally, its descendants.
 */


function killProcess(proc, killTree, killTreeSignal) {
  _killProcess(proc, killTree, killTreeSignal).then(() => {}, error => {
    logger.error(`Killing process ${proc.pid} failed`, error);
  });
}
/**
 * Kill the process with the provided pid.
 */


function killPid(pid) {
  try {
    process.kill(pid);
  } catch (err) {
    if (err.code !== 'ESRCH') {
      throw err;
    }
  }
} // Inside FB, Nuclide's RPC process doesn't inherit its parent environment and sets up its own instead.
// It does this to prevent difficult-to-diagnose issues caused by unexpected code in users' dotfiles.
// Before overwriting it, the original environment is base64-encoded in NUCLIDE_ORIGINAL_ENV.
// WARNING: This function returns the environment that would have been inherited under normal conditions.
// You can use it with a child process to let the user set its environment variables. By doing so, you are creating
// an even more complicated mess of inheritance and non-inheritance in the process tree.


let cachedOriginalEnvironment = null;

async function getOriginalEnvironment() {
  await new Promise(resolve => {
    whenShellEnvironmentLoaded(resolve);
  });

  if (cachedOriginalEnvironment != null) {
    return cachedOriginalEnvironment;
  }

  const {
    NUCLIDE_ORIGINAL_ENV
  } = process.env;

  if (NUCLIDE_ORIGINAL_ENV != null && NUCLIDE_ORIGINAL_ENV.trim() !== '') {
    const envString = new Buffer(NUCLIDE_ORIGINAL_ENV, 'base64').toString();
    cachedOriginalEnvironment = {};

    for (const envVar of envString.split('\0')) {
      // envVar should look like A=value_of_A
      const equalIndex = envVar.indexOf('=');

      if (equalIndex !== -1) {
        cachedOriginalEnvironment[envVar.substring(0, equalIndex)] = envVar.substring(equalIndex + 1);
      }
    } // Guard against invalid original environments.


    if (!Object.keys(cachedOriginalEnvironment).length) {
      cachedOriginalEnvironment = process.env;
    }
  } else {
    cachedOriginalEnvironment = process.env;
  }

  return cachedOriginalEnvironment;
} // See getOriginalEnvironment above.


async function getOriginalEnvironmentArray() {
  await new Promise(resolve => {
    whenShellEnvironmentLoaded(resolve);
  });
  const {
    NUCLIDE_ORIGINAL_ENV
  } = process.env;

  if (NUCLIDE_ORIGINAL_ENV != null && NUCLIDE_ORIGINAL_ENV.trim() !== '') {
    const envString = new Buffer(NUCLIDE_ORIGINAL_ENV, 'base64').toString();
    return envString.split('\0');
  }

  return [];
}

async function getEnvironment() {
  await new Promise(resolve => {
    whenShellEnvironmentLoaded(resolve);
  });
  return process.env;
}
/**
 * Returns a string suitable for including in displayed error messages.
 */


function exitEventToMessage(event) {
  if (event.exitCode != null) {
    return `exit code ${event.exitCode}`;
  } else {
    (0, _assert.default)(event.signal != null);
    return `signal ${event.signal}`;
  }
}

async function getChildrenOfProcess(processId) {
  const processes = await psTree();
  return processes.filter(processInfo => processInfo.parentPid === processId);
}
/**
 * Get a list of descendants, sorted by increasing depth (including the one with the provided pid).
 */


async function getDescendantsOfProcess(pid) {
  const processes = await psTree();
  let rootProcessInfo;
  const pidToChildren = new _collection.MultiMap();
  processes.forEach(info => {
    if (info.pid === pid) {
      rootProcessInfo = info;
    }

    pidToChildren.add(info.parentPid, info);
  });
  const descendants = rootProcessInfo == null ? [] : [rootProcessInfo]; // Walk through the array, adding the children of the current element to the end. This
  // breadth-first traversal means that the elements will be sorted by depth.

  for (let i = 0; i < descendants.length; i++) {
    const info = descendants[i];
    const children = pidToChildren.get(info.pid);
    descendants.push(...Array.from(children));
  }

  return descendants;
}

async function psTree() {
  if (isWindowsPlatform()) {
    return psTreeWindows();
  }

  const [commands, withArgs] = await Promise.all([runCommand('ps', ['-A', '-o', 'ppid,pid,comm']).toPromise(), runCommand('ps', ['-A', '-ww', '-o', 'pid,args']).toPromise()]);
  return parsePsOutput(commands, withArgs);
}

async function psTreeWindows() {
  const stdout = await runCommand('wmic.exe', ['PROCESS', 'GET', 'ParentProcessId,ProcessId,Name']).toPromise();
  return parsePsOutput(stdout);
}

function parsePsOutput(psOutput, argsOutput) {
  // Remove the first header line.
  const lines = psOutput.trim().split(/\n|\r\n/).slice(1);
  let withArgs = new Map();

  if (argsOutput != null) {
    withArgs = new Map(argsOutput.trim().split(/\n|\r\n/).slice(1).map(line => {
      const columns = line.trim().split(/\s+/);
      const pid = parseInt(columns[0], 10);
      const command = columns.slice(1).join(' ');
      return [pid, command];
    }));
  }

  return lines.map(line => {
    const columns = line.trim().split(/\s+/);
    const [parentPid, pidStr] = columns;
    const pid = parseInt(pidStr, 10);
    const command = columns.slice(2).join(' ');
    const commandWithArgs = withArgs.get(pid);
    return {
      command,
      parentPid: parseInt(parentPid, 10),
      pid,
      commandWithArgs: commandWithArgs == null ? command : commandWithArgs
    };
  });
} // Use `ps` to get memory usage in kb for an array of process id's as a map.


async function memoryUsagePerPid(pids) {
  const usage = new Map();

  if (pids.length >= 1) {
    try {
      const stdout = await runCommand('ps', ['-p', pids.join(','), '-o', 'pid=', '-o', 'rss=']).toPromise();
      stdout.split('\n').forEach(line => {
        const parts = line.trim().split(/\s+/);

        if (parts.length === 2) {
          const [pid, rss] = parts.map(x => parseInt(x, 10));
          usage.set(pid, rss);
        }
      });
    } catch (err) {// Ignore errors.
    }
  }

  return usage;
}
/**
 * Add no-op error handlers to the process's streams so that Node doesn't throw them.
 */


function preventStreamsFromThrowing(proc) {
  return new _UniversalDisposable.default(getStreamErrorEvents(proc).subscribe());
}
/**
 * Log errors from a process's streams. This function returns an `rxjs$ISubscription` so that it
 * can easily be used with `Observable.using()`.
 */


function logStreamErrors(proc, command, args, options) {
  return new _UniversalDisposable.default(getStreamErrorEvents(proc).do(([err, streamName]) => {
    logger.error(`stream error on stream ${streamName} with command:`, command, args, options, 'error:', err);
  }).subscribe());
} //
// Types
//
// Exactly one of exitCode and signal will be non-null.
// Killing a process will result in a null exitCode but a non-null signal.


//
// Errors
//

/**
 * An error thrown by process utils when the process exits with an error code. This type has all the
 * properties of ProcessExitMessage (except "kind").
 *
 * Note that the `stderr` property will only contain the complete stderr when thrown by the
 * output-accumulating functions (`runCommand()`, `runCommandDetailed()`). For others, like
 * `observeProcess()`, it will be truncated. Similarly, `stdout` will only be populated when the
 * error is thrown by output-accumulating functions. For others, it will always be `null`.
 */
class ProcessExitError extends Error {
  constructor(exitCode, signal, proc, stderr, stdout) {
    // $FlowIssue: This isn't typed in the Flow node type defs
    const {
      spawnargs
    } = proc;
    const argsAndCommand = spawnargs[0] === process.execPath ? spawnargs.slice(1) : spawnargs;
    const [command, ...args] = argsAndCommand;
    super(`"${command}" failed with ${exitEventToMessage({
      exitCode,
      signal
    })}\n\n${stderr}\n\n${argsAndCommand.join(' ')}`);
    this.exitCode = void 0;
    this.signal = void 0;
    this.stderr = void 0;
    this.stdout = void 0;
    this.command = void 0;
    this.args = void 0;
    this.process = void 0;
    this.name = 'ProcessExitError';
    this.exitCode = exitCode;
    this.signal = signal;
    this.stderr = stderr;
    this.stdout = stdout;
    this.command = command;
    this.args = args;
    this.process = proc;
  }

}
/**
 * Process system errors are just augmented Error objects. We wrap the errors and expose the process
 * since our utilities throw the errors before returning the process.
 */


exports.ProcessExitError = ProcessExitError;

class ProcessSystemError extends Error {
  constructor(err, proc) {
    super(err.message);
    this.errno = void 0;
    this.code = void 0;
    this.path = void 0;
    this.syscall = void 0;
    this.process = void 0;
    this.name = 'ProcessSystemError';
    this.errno = err.errno;
    this.code = err.code;
    this.path = err.path;
    this.syscall = err.syscall;
    this.process = proc;
  }

}

exports.ProcessSystemError = ProcessSystemError;

class MaxBufferExceededError extends Error {
  constructor(streamName) {
    super(`${streamName} maxBuffer exceeded`);
    this.name = 'MaxBufferExceededError';
  }

}

exports.MaxBufferExceededError = MaxBufferExceededError;

class ProcessTimeoutError extends Error {
  constructor(timeout, proc) {
    // $FlowIssue: This isn't typed in the Flow node type defs
    const {
      spawnargs
    } = proc;
    const commandName = spawnargs[0] === process.execPath ? spawnargs[1] : spawnargs[0];
    super(`"${commandName}" timed out after ${timeout}ms`);
    this.name = 'ProcessTimeoutError';
  }

} //
// Internal Stuff
//
// Pay no attention! This is just stuff that's used internally to implement the good stuff.
//
// Node crashes if we allow buffers that are too large.


exports.ProcessTimeoutError = ProcessTimeoutError;
const DEFAULT_MAX_BUFFER = 100 * 1024 * 1024;
const MAX_LOGGED_CALLS = 100;
const NUM_PRESERVED_HISTORY_CALLS = 50;
const noopDisposable = {
  dispose: () => {}
};
const whenShellEnvironmentLoaded = typeof atom !== 'undefined' && !atom.inSpecMode() ? atom.whenShellEnvironmentLoaded.bind(atom) : cb => {
  cb();
  return noopDisposable;
};
/**
 * Log custom events to log4js so that we can easily hook into process events
 * using a custom log4js appender (e.g. for analytics purposes).
 */

class ProcessLoggingEvent {
  constructor(command, duration) {
    this.command = void 0;
    this.duration = void 0;
    this.command = command;
    this.duration = duration; // log4js uses util.inspect to convert log arguments to strings.
    // Note: computed property methods aren't supported by Flow yet.

    this[_util.default.inspect.custom] = () => {
      return `${this.duration}ms: ${this.command}`;
    };
  }

}

exports.ProcessLoggingEvent = ProcessLoggingEvent;
const loggedCalls = [];
exports.loggedCalls = loggedCalls;

function logCall(duration, command, args) {
  // Trim the history once in a while, to avoid doing expensive array
  // manipulation all the time after we reached the end of the history
  if (loggedCalls.length > MAX_LOGGED_CALLS) {
    loggedCalls.splice(0, loggedCalls.length - NUM_PRESERVED_HISTORY_CALLS, {
      command: '... history stripped ...',
      duration: 0,
      time: new Date()
    });
  }

  const fullCommand = (0, _string.shellQuote)([command, ...args]);
  loggedCalls.push({
    command: fullCommand,
    duration,
    time: new Date()
  });
  logger.info(new ProcessLoggingEvent(fullCommand, duration));
}
/**
 * Attempt to get the fully qualified binary name from a process id. This is
 * surprisingly tricky. 'ps' only reports the path as invoked, and in some cases
 * not even that.
 *
 * On Linux, the /proc filesystem can be used to find it.
 * macOS doesn't have /proc, so we rely on the fact that the process holds
 * an open FD to the executable. This can fail for various reasons (mostly
 * not having permissions to execute lsof on the pid.)
 */


async function getAbsoluteBinaryPathForPid(pid) {
  if (process.platform === 'linux') {
    return _getLinuxBinaryPathForPid(pid);
  }

  if (process.platform === 'darwin') {
    return _getDarwinBinaryPathForPid(pid);
  }

  return null;
}

async function _getLinuxBinaryPathForPid(pid) {
  const exeLink = `/proc/${pid}/exe`; // /proc/xxx/exe is a symlink to the real binary in the file system.

  return runCommand('/bin/realpath', ['-q', '-e', exeLink]).catch(_ => runCommand('/bin/sudo', ['-n', '--', '/bin/realpath', '-q', '-e', exeLink])).catch(_ => _rxjsCompatUmdMin.Observable.of(null)).toPromise();
}

async function _getDarwinBinaryPathForPid(pid) {
  return runCommand('/usr/sbin/lsof', ['-p', `${pid}`]).catch(_ => {
    return _rxjsCompatUmdMin.Observable.of(null);
  }).map(stdout => stdout == null ? null : stdout.split('\n').map(line => line.trim().split(/\s+/)).filter(line => line[3] === 'txt').map(line => line[8])[0]).take(1).toPromise();
}
/**
 * Creates an observable with the following properties:
 *
 * 1. It contains a process that's created using the provided factory when you subscribe.
 * 2. It doesn't complete until the process exits (or errors).
 * 3. The process is killed when you unsubscribe.
 *
 * This means that a single observable instance can be used to spawn multiple processes. Indeed, if
 * you subscribe multiple times, multiple processes *will* be spawned.
 *
 * IMPORTANT: The exit event does NOT mean that all stdout and stderr events have been received.
 */


function createProcessStream(type = 'spawn', commandOrModulePath, args = [], options = {}) {
  const inputOption = options.input;
  let input;

  if (inputOption != null) {
    input = typeof inputOption === 'string' ? _rxjsCompatUmdMin.Observable.of(inputOption) : inputOption;
  }

  return (0, _event.observableFromSubscribeFunction)(whenShellEnvironmentLoaded).take(1).switchMap(() => {
    const {
      dontLogInNuclide,
      killTreeWhenDone,
      killTreeSignal,
      timeout
    } = options; // flowlint-next-line sketchy-null-number:off

    const enforceTimeout = timeout ? x => x.timeoutWith(timeout, _rxjsCompatUmdMin.Observable.throw(new ProcessTimeoutError(timeout, proc))) : x => x;

    const proc = _child_process.default[type](_nuclideUri.default.expandHomeDir(commandOrModulePath), args, // $FlowFixMe: child_process$spawnOpts and child_process$forkOpts have incompatible stdio types.
    { ...options
    }); // Don't let Node throw stream errors and crash the process. Note that we never dispose of
    // this because stream errors can still occur after the user unsubscribes from our process
    // observable. That's okay; when the streams close, the listeners will be removed.


    preventStreamsFromThrowing(proc); // If we were to connect the error handler as part of the returned observable, unsubscribing
    // would cause it to be removed. That would leave no attached error handler, so node would
    // throw, triggering Atom's uncaught exception handler.

    const errors = _rxjsCompatUmdMin.Observable.fromEvent(proc, 'error').flatMap(_rxjsCompatUmdMin.Observable.throw).publish();

    errors.connect();

    const exitEvents = _rxjsCompatUmdMin.Observable.fromEvent(proc, 'exit', (exitCode, signal) => ({
      kind: 'exit',
      exitCode,
      signal
    })).filter(isRealExit).take(1);

    if (dontLogInNuclide !== true && NUCLIDE_DO_NOT_LOG !== true) {
      // Log the completion of the process. Note that we intentionally don't merge this with the
      // returned observable because we don't want to cancel the side-effect when the user
      // unsubscribes or when the process exits ("close" events come after "exit" events).
      const now = (0, _performanceNow.default)();

      _rxjsCompatUmdMin.Observable.fromEvent(proc, 'close').do(() => {
        logCall(Math.round((0, _performanceNow.default)() - now), commandOrModulePath, args);
      }).subscribe();
    }

    let finished = false;
    return enforceTimeout(_rxjsCompatUmdMin.Observable.using( // Log stream errors, but only for as long as you're subscribed to the process observable.
    () => logStreamErrors(proc, commandOrModulePath, args, options), () => _rxjsCompatUmdMin.Observable.merge( // Node [delays the emission of process errors][1] by a tick in order to give
    // consumers a chance to subscribe to the error event. This means that our observable
    // would normally emit the process and then, a tick later, error. However, it's more
    // convenient to never emit the process if there was an error. Although observables
    // don't require the error to be delayed at all, the underlying event emitter
    // abstraction does, so we'll just roll with that and use `pid == null` as a signal
    // that an error is forthcoming.
    //
    // [1]: https://github.com/nodejs/node/blob/v7.10.0/lib/internal/child_process.js#L301
    proc.pid == null ? _rxjsCompatUmdMin.Observable.empty() : _rxjsCompatUmdMin.Observable.of(proc), _rxjsCompatUmdMin.Observable.never() // Don't complete until we say so!
    )).merge( // Write any input to stdin. This is just for the side-effect. We merge it here to
    // ensure that writing to the stdin stream happens after our event listeners are added.
    input == null ? _rxjsCompatUmdMin.Observable.empty() : input.do({
      next: str => {
        proc.stdin.write(str);
      },
      complete: () => {
        proc.stdin.end();
      }
    }).ignoreElements()).takeUntil(errors).takeUntil(exitEvents).do({
      error: () => {
        finished = true;
      },
      complete: () => {
        finished = true;
      }
    })).catch(err => {
      // Since this utility errors *before* emitting the process, add the process to the error
      // so that users can get whatever info they need off of it.
      if (err instanceof Error && err.name === 'Error' && 'errno' in err) {
        throw new ProcessSystemError(err, proc);
      }

      throw err;
    }).finally(() => {
      // $FlowFixMe(>=0.68.0) Flow suppress (T27187857)
      if (!proc.wasKilled && !finished) {
        killProcess(proc, Boolean(killTreeWhenDone), killTreeSignal);
      }
    });
  });
}

function isRealExit(event) {
  // An exit signal from SIGUSR1 doesn't actually exit the process, so skip that.
  return event.signal !== 'SIGUSR1';
}

async function _killProcess(proc, killTree, killTreeSignal) {
  proc.wasKilled = true;

  if (!killTree) {
    if (killTreeSignal != null && killTreeSignal !== '') {
      proc.kill(killTreeSignal);
    } else {
      proc.kill();
    }

    return;
  }

  if (/^win/.test(process.platform)) {
    await killWindowsProcessTree(proc.pid);
  } else {
    await killUnixProcessTree(proc);
  }
}

function killWindowsProcessTree(pid) {
  return new Promise((resolve, reject) => {
    _child_process.default.exec(`taskkill /pid ${pid} /T /F`, error => {
      if (error == null) {
        reject(error);
      } else {
        resolve();
      }
    });
  });
}

async function killUnixProcessTree(proc) {
  const descendants = await getDescendantsOfProcess(proc.pid); // Kill the processes, starting with those of greatest depth.

  for (const info of descendants.reverse()) {
    killPid(info.pid);
  }
}

function isExitErrorDefault(exit) {
  return exit.exitCode !== 0;
}

function isWindowsPlatform() {
  return /^win/.test(process.platform);
}

function limitBufferSize(stream, maxBuffer, streamName) {
  if (maxBuffer == null) {
    return stream;
  }

  return _rxjsCompatUmdMin.Observable.defer(() => {
    let totalSize = 0;
    return stream.do(data => {
      totalSize += data.length;

      if (totalSize > maxBuffer) {
        throw new MaxBufferExceededError(streamName);
      }
    });
  });
}
/**
 * Get an observable of error events for a process's streams. Note that these are represented as
 * normal elements, not observable errors.
 */


function getStreamErrorEvents(proc) {
  const streams = [['stdin', proc.stdin], ['stdout', proc.stdout], ['stderr', proc.stderr]];
  return _rxjsCompatUmdMin.Observable.merge(...streams.map(([name, stream]) => stream == null ? _rxjsCompatUmdMin.Observable.empty() : _rxjsCompatUmdMin.Observable.fromEvent(stream, 'error').map(err => [err, name])));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3Byb2Nlc3MuanMiXSwibmFtZXMiOlsiTE9HX0NBVEVHT1JZIiwiTlVDTElERV9ET19OT1RfTE9HIiwiZ2xvYmFsIiwibG9nZ2VyIiwicnVuQ29tbWFuZCIsImNvbW1hbmQiLCJhcmdzIiwib3B0aW9ucyIsInJlc3QiLCJydW5Db21tYW5kRGV0YWlsZWQiLCJtYXAiLCJldmVudCIsInN0ZG91dCIsIm9ic2VydmVQcm9jZXNzIiwic3Bhd24iLCJmbGF0TWFwIiwicHJvYyIsImdldE91dHB1dFN0cmVhbSIsIm1heEJ1ZmZlciIsIl8iLCJERUZBVUxUX01BWF9CVUZGRVIiLCJjYXRjaCIsImVycm9yIiwiUHJvY2Vzc0V4aXRFcnJvciIsIk9ic2VydmFibGUiLCJvZiIsImtpbmQiLCJyZWR1Y2UiLCJhY2MiLCJkYXRhIiwic3RkZXJyIiwiZXhpdENvZGUiLCJzaWduYWwiLCJwcm9jZXNzIiwiRXJyb3IiLCJvYnNlcnZlUHJvY2Vzc1JhdyIsInNwbGl0QnlMaW5lcyIsImNyZWF0ZVByb2Nlc3NTdHJlYW0iLCJmb3JrIiwibW9kdWxlUGF0aCIsImNodW5rIiwieCIsInNwbGl0U3RyZWFtIiwiaXNFeGl0RXJyb3IiLCJpc0V4aXRFcnJvckRlZmF1bHQiLCJleGl0RXJyb3JCdWZmZXJTaXplIiwiZGVmZXIiLCJzdGRvdXRFdmVudHMiLCJsaW1pdEJ1ZmZlclNpemUiLCJzdGRlcnJFdmVudHMiLCJzaGFyZSIsImFjY3VtdWxhdGVkU3RkZXJyIiwic2NhbiIsInNsaWNlIiwic3RhcnRXaXRoIiwibGV0IiwibGVuZ3RoIiwiY2xvc2VFdmVudHMiLCJmcm9tRXZlbnQiLCJmaWx0ZXIiLCJpc1JlYWxFeGl0IiwidGFrZSIsIndpdGhMYXRlc3RGcm9tIiwicHVibGlzaFJlcGxheSIsImV4aXRTdWIiLCJjb25uZWN0IiwibWVyZ2UiLCJjb25jYXQiLCJmaW5hbGx5IiwidW5zdWJzY3JpYmUiLCJzY3JpcHRpZnlDb21tYW5kIiwicGxhdGZvcm0iLCJqb2luZWQiLCJvcHRzIiwiZW52IiwiU0hFTEwiLCJraWxsUHJvY2VzcyIsImtpbGxUcmVlIiwia2lsbFRyZWVTaWduYWwiLCJfa2lsbFByb2Nlc3MiLCJ0aGVuIiwicGlkIiwia2lsbFBpZCIsImtpbGwiLCJlcnIiLCJjb2RlIiwiY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudCIsImdldE9yaWdpbmFsRW52aXJvbm1lbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIndoZW5TaGVsbEVudmlyb25tZW50TG9hZGVkIiwiTlVDTElERV9PUklHSU5BTF9FTlYiLCJ0cmltIiwiZW52U3RyaW5nIiwiQnVmZmVyIiwidG9TdHJpbmciLCJlbnZWYXIiLCJzcGxpdCIsImVxdWFsSW5kZXgiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwiT2JqZWN0Iiwia2V5cyIsImdldE9yaWdpbmFsRW52aXJvbm1lbnRBcnJheSIsImdldEVudmlyb25tZW50IiwiZXhpdEV2ZW50VG9NZXNzYWdlIiwiZ2V0Q2hpbGRyZW5PZlByb2Nlc3MiLCJwcm9jZXNzSWQiLCJwcm9jZXNzZXMiLCJwc1RyZWUiLCJwcm9jZXNzSW5mbyIsInBhcmVudFBpZCIsImdldERlc2NlbmRhbnRzT2ZQcm9jZXNzIiwicm9vdFByb2Nlc3NJbmZvIiwicGlkVG9DaGlsZHJlbiIsIk11bHRpTWFwIiwiZm9yRWFjaCIsImluZm8iLCJhZGQiLCJkZXNjZW5kYW50cyIsImkiLCJjaGlsZHJlbiIsImdldCIsInB1c2giLCJBcnJheSIsImZyb20iLCJpc1dpbmRvd3NQbGF0Zm9ybSIsInBzVHJlZVdpbmRvd3MiLCJjb21tYW5kcyIsIndpdGhBcmdzIiwiYWxsIiwidG9Qcm9taXNlIiwicGFyc2VQc091dHB1dCIsInBzT3V0cHV0IiwiYXJnc091dHB1dCIsImxpbmVzIiwiTWFwIiwibGluZSIsImNvbHVtbnMiLCJwYXJzZUludCIsImpvaW4iLCJwaWRTdHIiLCJjb21tYW5kV2l0aEFyZ3MiLCJtZW1vcnlVc2FnZVBlclBpZCIsInBpZHMiLCJ1c2FnZSIsInBhcnRzIiwicnNzIiwic2V0IiwicHJldmVudFN0cmVhbXNGcm9tVGhyb3dpbmciLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwiZ2V0U3RyZWFtRXJyb3JFdmVudHMiLCJzdWJzY3JpYmUiLCJsb2dTdHJlYW1FcnJvcnMiLCJkbyIsInN0cmVhbU5hbWUiLCJjb25zdHJ1Y3RvciIsInNwYXduYXJncyIsImFyZ3NBbmRDb21tYW5kIiwiZXhlY1BhdGgiLCJuYW1lIiwiUHJvY2Vzc1N5c3RlbUVycm9yIiwibWVzc2FnZSIsImVycm5vIiwicGF0aCIsInN5c2NhbGwiLCJNYXhCdWZmZXJFeGNlZWRlZEVycm9yIiwiUHJvY2Vzc1RpbWVvdXRFcnJvciIsInRpbWVvdXQiLCJjb21tYW5kTmFtZSIsIk1BWF9MT0dHRURfQ0FMTFMiLCJOVU1fUFJFU0VSVkVEX0hJU1RPUllfQ0FMTFMiLCJub29wRGlzcG9zYWJsZSIsImRpc3Bvc2UiLCJhdG9tIiwiaW5TcGVjTW9kZSIsImJpbmQiLCJjYiIsIlByb2Nlc3NMb2dnaW5nRXZlbnQiLCJkdXJhdGlvbiIsInV0aWwiLCJpbnNwZWN0IiwiY3VzdG9tIiwibG9nZ2VkQ2FsbHMiLCJsb2dDYWxsIiwic3BsaWNlIiwidGltZSIsIkRhdGUiLCJmdWxsQ29tbWFuZCIsImdldEFic29sdXRlQmluYXJ5UGF0aEZvclBpZCIsIl9nZXRMaW51eEJpbmFyeVBhdGhGb3JQaWQiLCJfZ2V0RGFyd2luQmluYXJ5UGF0aEZvclBpZCIsImV4ZUxpbmsiLCJ0eXBlIiwiY29tbWFuZE9yTW9kdWxlUGF0aCIsImlucHV0T3B0aW9uIiwiaW5wdXQiLCJzd2l0Y2hNYXAiLCJkb250TG9nSW5OdWNsaWRlIiwia2lsbFRyZWVXaGVuRG9uZSIsImVuZm9yY2VUaW1lb3V0IiwidGltZW91dFdpdGgiLCJ0aHJvdyIsImNoaWxkX3Byb2Nlc3MiLCJudWNsaWRlVXJpIiwiZXhwYW5kSG9tZURpciIsImVycm9ycyIsInB1Ymxpc2giLCJleGl0RXZlbnRzIiwibm93IiwiTWF0aCIsInJvdW5kIiwiZmluaXNoZWQiLCJ1c2luZyIsImVtcHR5IiwibmV2ZXIiLCJuZXh0Iiwic3RyIiwic3RkaW4iLCJ3cml0ZSIsImNvbXBsZXRlIiwiZW5kIiwiaWdub3JlRWxlbWVudHMiLCJ0YWtlVW50aWwiLCJ3YXNLaWxsZWQiLCJCb29sZWFuIiwidGVzdCIsImtpbGxXaW5kb3dzUHJvY2Vzc1RyZWUiLCJraWxsVW5peFByb2Nlc3NUcmVlIiwicmVqZWN0IiwiZXhlYyIsInJldmVyc2UiLCJleGl0Iiwic3RyZWFtIiwidG90YWxTaXplIiwic3RyZWFtcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrREE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JPLE1BQU1BLFlBQVksR0FBRyw2Q0FBckI7O0FBRVAsTUFBTUMsa0JBQWtCLEdBQUdDLE1BQU0sQ0FBQ0Qsa0JBQWxDO0FBRUEsTUFBTUUsTUFBTSxHQUFHLHVCQUFVSCxZQUFWLENBQWY7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVUzTixJQUFJLENBQUMwTSxLQUFmLENBRGMsRUFFZCxDQUFDLFFBQUQsRUFBVzFNLElBQUksQ0FBQ0osTUFBaEIsQ0FGYyxFQUdkLENBQUMsUUFBRCxFQUFXSSxJQUFJLENBQUNjLE1BQWhCLENBSGMsQ0FBaEI7QUFLQSxTQUFPTiw2QkFBVzBDLEtBQVgsQ0FDTCxHQUFHeUssT0FBTyxDQUFDak8sR0FBUixDQUNELENBQUMsQ0FBQ3NKLElBQUQsRUFBT3lFLE1BQVAsQ0FBRCxLQUNFQSxNQUFNLElBQUksSUFBVixHQUNJak4sNkJBQVc4TCxLQUFYLEVBREosR0FFSTlMLDZCQUFXa0MsU0FBWCxDQUFxQitLLE1BQXJCLEVBQTZCLE9BQTdCLEVBQXNDL04sR0FBdEMsQ0FBMEMwRSxHQUFHLElBQUksQ0FBQ0EsR0FBRCxFQUFNNEUsSUFBTixDQUFqRCxDQUpMLENBREUsQ0FBUDtBQVFEIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuLy9cclxuLy8gICAgICAgICAgICAgICAgIF9fICAgX18gICBfXyAgIF9fICAgX19fICBfXyAgIF9fICAgICAgICAgX19cclxuLy8gICAgICAgICAgICAgICAgfF9fKSB8X18pIC8gIFxcIC8gIGAgfF9fICAvX19gIC9fX2AgICAgIHwgL19fYFxyXG4vLyAgICAgICAgICAgICAgICB8ICAgIHwgIFxcIFxcX18vIFxcX18sIHxfX18gLl9fLyAuX18vIC5cXF9fLyAuX18vXHJcbi8vXHJcbi8vIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHV0aWxpdGllcyBmb3Igc3Bhd25pbmcgcHJvY2Vzc2VzIGluIE51Y2xpZGUuIEluIGdlbmVyYWw6XHJcbi8vXHJcbi8vIC0gVGhleSBhY2NlcHQgc2ltaWxhciBhcmd1bWVudHMuXHJcbi8vIC0gVGhleSByZXR1cm4gYW4gb2JzZXJ2YWJsZS5cclxuLy8gLSBUaGUgcHJvY2VzcyBpcyBzcGF3bmVkIGlmL3doZW4geW91IHN1YnNjcmliZSB0byB0aGUgb2JzZXJ2YWJsZS5cclxuLy8gLSBJZiB5b3UgdW5zdWJzY3JpYmUgYmVmb3JlIHRoZSBvYnNlcnZhYmxlIGNvbXBsZXRlcywgdGhlIHByb2Nlc3MgaXMga2lsbGVkLlxyXG4vLyAtIFRoZSBvYnNlcnZhYmxlIGVycm9ycyBpZiB0aGUgcHJvY2VzcyBjb21wbGV0ZXMgd2l0aCBhIG5vbi16ZXJvIGV4aXQgY29kZSAoYnkgZGVmYXVsdDsgdGhpcyBjYW5cclxuLy8gICBiZSBjaGFuZ2VkKSBvciBpZiB0aGUgcHJvY2VzcyBjYW4ndCBiZSBzcGF3bmVkLlxyXG4vL1xyXG4vLyBUaGUgbW9zdCBpbXBvcnRhbnQgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIGFyZSBgcnVuQ29tbWFuZCgpYC0tZm9yIHJ1bm5pbmcgYSBxdWljayBjb21tYW5kIGFuZFxyXG4vLyBnZXR0aW5nIGl0cyBvdXRwdXQtLWFuZCBgb2JzZXJ2ZVByb2Nlc3MoKWAtLWZvciBzdHJlYW1pbmcgb3V0cHV0IGZyb20gYSBwcm9jZXNzLiBUaGV5J2xsIGhhbmRsZVxyXG4vLyB0aGUgbWFqb3JpdHkgb2YgdXNlIGNhc2VzLlxyXG4vL1xyXG4vLyAjIyBXaHkgb2JzZXJ2YWJsZXM/XHJcbi8vXHJcbi8vIFVubGlrZSBQcm9taXNlcywgb2JzZXJ2YWJsZXMgaGF2ZSBhIHN0YW5kYXJkaXplZCwgY29tcG9zYWJsZSBjYW5jZWxsYXRpb24gbWVjaGFuaXNtIF90b2RheV8uXHJcbi8vIE1vcmVvdmVyLCBvYnNlcnZhYmxlcyBpbnRlZ3JhdGUgbmljZWx5IHdpdGggQXRvbSdzIGNhbGxiYWNrICsgSURpc3Bvc2FibGUgZm9ybXVsYSBmb3IgY2FuY2VsYWJsZSxcclxuLy8gYXN5bmMgQVBJcy4gQWxvbmcgd2l0aCBSZWFjdCwgW1J4SlNdIGlzIG9uZSBvZiB0aGUgY29yZSBsaWJyYXJpZXMgdXRpbGl6ZWQgYnkgTnVjbGlkZS5cclxuLy9cclxuLy8gIyMgV2h5IGVycm9ycz9cclxuLy9cclxuLy8gSW4gdGhlIHBhc3QsIHdlIGhhZCBzb21lIHByb2Nlc3MgQVBJcyB0aGF0IHVzZWQgZXJyb3JzIGFuZCBzb21lIHRoYXQgdXNlZCByZXR1cm4gdmFsdWVzLlxyXG4vLyBDb25zaXN0ZW5jeSBoYXMgb2J2aW91cyBiZW5lZml0czsgc3RhbmRhcmRpemluZyBvbiBlcnJvcnMgbWFrZXMgc2Vuc2UgYmVjYXVzZTpcclxuLy9cclxuLy8gLSBUaGUgZXJyb3ItdGhyb3dpbmcgQVBJcyB3ZXJlIHRoZSBtb3N0IHVzZWQsIGJ5IGEgbGFyZ2UgbWFyZ2luLlxyXG4vLyAtIFVuaGFuZGxlZCBlcnJvcnMgY2FuIGJlIGNhdWdodCBhbmQgbG9nZ2VkIGF0IHRoZSB0b3AgbGV2ZWwuXHJcbi8vIC0gT2JzZXJ2YWJsZXMgaGF2ZSBhIHNlcGFyYXRlIGNoYW5uZWwgZm9yIGVycm9ycyB3aGljaCBhbGxvd3MgZm9yIGNvb2wsIGVycm9yLWF3YXJlIG9wZXJhdG9yc1xyXG4vLyAgIGxpa2UgYHJldHJ5KClgIGFuZCBjYWNoaW5nLlxyXG4vLyAtIEVycm9ycyBpbiBvYnNlcnZhYmxlcyBhcmUgc3RyZWFtLWVuZGluZy4gVGhpcyBtZWFucyB5b3Ugd29uJ3QgY29udGludWUgdG8gZG8gd29yayBpbiBhIGNoYWluIG9mXHJcbi8vICAgb3BlcmF0b3JzIGFjY2lkZW50YWxseS5cclxuLy9cclxuLy8gW1J4SlNdOiBodHRwOi8vcmVhY3RpdmV4LmlvL3J4anMvXHJcblxyXG5pbXBvcnQgY2hpbGRfcHJvY2VzcyBmcm9tICdjaGlsZF9wcm9jZXNzJztcclxuaW1wb3J0IGlkeCBmcm9tICdpZHgnO1xyXG5pbXBvcnQge2dldExvZ2dlcn0gZnJvbSAnbG9nNGpzJztcclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcyc7XHJcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xyXG5cclxuaW1wb3J0IFVuaXZlcnNhbERpc3Bvc2FibGUgZnJvbSAnLi9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IG51Y2xpZGVVcmkgZnJvbSAnLi9udWNsaWRlVXJpJztcclxuaW1wb3J0IHBlcmZvcm1hbmNlTm93IGZyb20gJy4vcGVyZm9ybWFuY2VOb3cnO1xyXG5pbXBvcnQge011bHRpTWFwfSBmcm9tICcuL2NvbGxlY3Rpb24nO1xyXG5pbXBvcnQge29ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb259IGZyb20gJy4vZXZlbnQnO1xyXG5pbXBvcnQge29ic2VydmVTdHJlYW19IGZyb20gJy4vc3RyZWFtJztcclxuaW1wb3J0IHtzcGxpdFN0cmVhbSwgdGFrZVdoaWxlSW5jbHVzaXZlfSBmcm9tICcuL29ic2VydmFibGUnO1xyXG5pbXBvcnQge3NoZWxsUXVvdGV9IGZyb20gJy4vc3RyaW5nJztcclxuXHJcbmV4cG9ydCBjb25zdCBMT0dfQ0FURUdPUlkgPSAnQGF0b20taWRlLWNvbW11bml0eS9udWNsaWRlLWNvbW1vbnMvcHJvY2Vzcyc7XHJcblxyXG5jb25zdCBOVUNMSURFX0RPX05PVF9MT0cgPSBnbG9iYWwuTlVDTElERV9ET19OT1RfTE9HO1xyXG5cclxuY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKExPR19DQVRFR09SWSk7XHJcblxyXG4vKipcclxuICogUnVuIGEgY29tbWFuZCwgYWNjdW11bGF0ZSB0aGUgb3V0cHV0LiBFcnJvcnMgYXJlIHN1cmZhY2VkIGFzIHN0cmVhbSBlcnJvcnMgYW5kIHVuc3Vic2NyaWJpbmcgd2lsbFxyXG4gKiBraWxsIHRoZSBwcm9jZXNzLiBJbiBhZGRpdGlvbiB0byB0aGUgb3B0aW9ucyBhY2NlcHRlZCBieSBOb2RlJ3MgW2BjaGlsZF9wcm9jZXNzLnNwYXduKClgXVsxXVxyXG4gKiBmdW5jdGlvbiwgYHJ1bkNvbW1hbmQoKWAgYWxzbyBhY2NlcHRzIHRoZSBmb2xsb3dpbmc6XHJcbiAqXHJcbiAqIC0gYGlucHV0YCB7c3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+fSBUZXh0IHRvIHdyaXRlIHRvIHRoZSBuZXcgcHJvY2VzcydzIHN0ZGluLlxyXG4gKiAtIGBraWxsVHJlZVdoZW5Eb25lYCB7Ym9vbGVhbn0gYGZhbHNlYCBieSBkZWZhdWx0LiBJZiB5b3UgcGFzcyBgdHJ1ZWAsIHVuc3Vic2NyaWJpbmcgZnJvbSB0aGVcclxuICogICBvYnNlcnZhYmxlIHdpbGwga2lsbCBub3Qgb25seSB0aGlzIHByb2Nlc3MgYnV0IGFsc28gaXRzIGRlc2NlbmRhbnRzLlxyXG4gKiAtIGBpc0V4aXRFcnJvcmAge2Z1bmN0aW9ufSBEZXRlcm1pbmVzIHdoZXRoZXIgYSBQcm9jZXNzRXhpdEVycm9yIHNob3VsZCBiZSByYWlzZWQgYmFzZWQgb24gdGhlXHJcbiAqICAgZXhpdCBtZXNzYWdlLiBCeSBkZWZhdWx0LCB0aGlzIGlzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZXhpdCBjb2RlIGlzIG5vbi16ZXJvLlxyXG4gKiAtIGBtYXhCdWZmZXJgIHtudW1iZXJ9IFRoZSBtYXhpbXVtIGFtb3VudCBvZiBzdGRvdXQgYW5kIHN0ZGVycm9yIHRvIGFjY3VtdWxhdGUuIElmIHRoZSBwcm9jZXNzXHJcbiAqICAgcHJvZHVjZXMgbW9yZSBvZiBlaXRoZXIsIGEgTWF4QnVmZmVyRXhjZWVkZWRFcnJvciB3aWxsIGJlIGVtaXR0ZWQuXHJcbiAqIC0gYHRpbWVvdXRgIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIGtpbGxpbmcgdGhlIHByb2Nlc3MgYW5kIGVtaXR0aW5nXHJcbiAqICAgYW4gZXJyb3IuIFRoaXMgaXMgbW9zdGx5IHByb3ZpZGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYXMgeW91IGNhbiBnZXQgdGhlIHNhbWUgcmVzdWx0XHJcbiAqICAgYnkgdXNpbmcgdGhlIGAudGltZW91dCgpYCBvcGVyYXRvciBvbiB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZS5cclxuICpcclxuICogVGhlIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBjYW4gZXJyb3Igd2l0aCBhbnkgb2YgdGhlIGZvbGxvd2luZzpcclxuICpcclxuICogLSBgUHJvY2Vzc1N5c3RlbUVycm9yYCBXcmFwIFtOb2RlIFN5c3RlbSBFcnJvcnNdWzJdICh3aGljaCBhcmUganVzdCBhdWdtZW50ZWQgYEVycm9yYCBvYmplY3RzKVxyXG4gKiAgICBhbmQgaW5jbHVkZSB0aGluZ3MgbGlrZSBgRU5PRU5UYC4gVGhlc2UgY29udGFpbiBhbGwgb2YgdGhlIHByb3BlcnRpZXMgb2Ygbm9kZSBzeXN0ZW0gZXJyb3JzXHJcbiAqICAgIGFzIHdlbGwgYXMgYSByZWZlcmVuY2UgdG8gdGhlIHByb2Nlc3MuXHJcbiAqIC0gYFByb2Nlc3NFeGl0RXJyb3JgIEluZGljYXRlIHRoYXQgdGhlIHByb2Nlc3MgaGFzIGVuZGVkIGNsZWFubHksIGJ1dCB3aXRoIGFuIHVuc3VjY2Vzc2Z1bCBleGl0XHJcbiAqICAgIGNvZGUuIFdoZXRoZXIgYSBgUHJvY2Vzc0V4aXRFcnJvcmAgaXMgdGhyb3duIGlzIGRldGVybWluZWQgYnkgdGhlIGBpc0V4aXRFcnJvcmAgb3B0aW9uLiBUaGlzXHJcbiAqICAgIGVycm9yIGluY2x1ZGVzIHRoZSBleGl0IGNvZGUgYXMgd2VsbCBhcyBhY2N1bXVsYXRlZCBzdGRvdXQgYW5kIHN0ZGVyci4gU2VlIGl0cyBkZWZpbml0aW9uIGZvclxyXG4gKiAgICBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKiAtIGBNYXhCdWZmZXJFeGNlZWRlZEVycm9yYCBUaHJvd24gaWYgZWl0aGVyIHRoZSBzdGRvdXQgb3Igc3RkZXJyIGV4Y2VlZHMgdGhlIHZhbHVlIHNwZWNpZmllZCBieVxyXG4gKiAgICB0aGUgYG1heEJ1ZmZlcmAgb3B0aW9uLlxyXG4gKiAtIGBQcm9jZXNzVGltZW91dEVycm9yYCBUaHJvd24gaWYgdGhlIHByb2Nlc3MgZG9lc24ndCBjb21wbGV0ZSB3aXRoaW4gdGhlIHRpbWUgc3BlY2lmaWVkIGJ5IHRoZVxyXG4gKiAgIGB0aW1lb3V0YCBvcHRpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHJ1bkNvbW1hbmQoJ3BzJywgWyctZScsICctbycsICdwaWQsY29tbSddKVxyXG4gKiAgIC5tYXAoc3Rkb3V0ID0+IHtcclxuICogICAgIHJldHVybiBzdGRvdXQuc3BsaXQoJ1xcbicpXHJcbiAqICAgICAgIC5zbGljZSgxKVxyXG4gKiAgICAgICAubWFwKGxpbmUgPT4ge1xyXG4gKiAgICAgICAgIGNvbnN0IHdvcmRzID0gbGluZS50cmltKCkuc3BsaXQoJyAnKTtcclxuICogICAgICAgICByZXR1cm4ge1xyXG4gKiAgICAgICAgICAgcGlkOiB3b3Jkc1swXSxcclxuICogICAgICAgICAgIGNvbW1hbmQ6IHdvcmRzLnNsaWNlKDEpLmpvaW4oJyAnKSxcclxuICogICAgICAgICB9O1xyXG4gKiAgICAgICB9KVxyXG4gKiAgICAgICAuc29ydCgocDEsIHAyKSA9PiBwMi5waWQgLSBwMS5waWQpO1xyXG4gKiAgIH0pXHJcbiAqICAgLnN1YnNjcmliZShwcm9jZXNzZXMgPT4ge1xyXG4gKiAgICAgY29uc29sZS5sb2coYFRoZSBwcm9jZXNzIHdpdGggdGhlIGhpZ2hlc3QgcGlkIGlzICR7cHJvY2Vzc2VzWzBdLmNvbW1hbmR9YCk7XHJcbiAqICAgfSk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBbMV06IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY2hpbGRfcHJvY2Vzcy5odG1sI2NoaWxkX3Byb2Nlc3NfY2hpbGRfcHJvY2Vzc19zcGF3bl9jb21tYW5kX2FyZ3Nfb3B0aW9uc1xyXG4gKiBbMl06IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXJyb3JzLmh0bWwjZXJyb3JzX2NsYXNzX3N5c3RlbV9lcnJvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkNvbW1hbmQoXHJcbiAgY29tbWFuZDogc3RyaW5nLFxyXG4gIGFyZ3M/OiBBcnJheTxzdHJpbmc+ID0gW10sXHJcbiAgb3B0aW9ucz86IE9ic2VydmVQcm9jZXNzT3B0aW9ucyA9IHt9LFxyXG4gIHJlc3Q6IHZvaWQsXHJcbik6IE9ic2VydmFibGU8c3RyaW5nPiB7XHJcbiAgcmV0dXJuIHJ1bkNvbW1hbmREZXRhaWxlZChjb21tYW5kLCBhcmdzLCBvcHRpb25zKS5tYXAoZXZlbnQgPT4gZXZlbnQuc3Rkb3V0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IHNwYXducyBhIHByb2Nlc3MgYW5kIGVtaXRzIGV2ZW50cyBvbiBzdGRvdXQsIHN0ZGVyciBhbmQgZXhpdC4gT3V0cHV0XHJcbiAqIGlzIGJ1ZmZlcmVkIGJ5IGxpbmUuIFVuc3Vic2NyaWJpbmcgYmVmb3JlIHRoZSBvYnNlcnZhYmxlIGNvbXBsZXRlcyB3aWxsIGtpbGwgdGhlIHByb2Nlc3MuIFRoaXNcclxuICogZnVuY3Rpb24gYWNjZXB0cyB0aGUgc2FtZSBvcHRpb25zIGFzIGBydW5Db21tYW5kKClgLCBhbmQgdGhyb3dzIHRoZSBzYW1lIGVycm9ycy5cclxuICpcclxuICogQmVzaWRlcyBlbWl0dGluZyBtdWx0aXBsZSBldmVudHMsIGFub3RoZXIgZGlmZmVyZW5jZSB3aXRoIGBydW5Db21tYW5kKClgIGlzIHRoZSBQcm9jZXNzRXhpdEVycm9yc1xyXG4gKiB0aHJvd24gYnkgYG9ic2VydmVQcm9jZXNzKClgLiBXaGVyZWFzIFByb2Nlc3NFeGl0RXJyb3JzIHRocm93biBieSBgcnVuQ29tbWFuZCgpYCBjb250YWluIHRoZVxyXG4gKiBlbnRpcmV0eSBvZiBzdGRvdXQgYW5kIHN0ZGVyciwgdGhvc2UgdGhyb3duIGJ5IGBvYnNlcnZlUHJvY2VzcygpYCBjb250YWluIGEgdHJ1bmNhdGVkIGFtb3VudCBvZlxyXG4gKiBzdGRlcnIgYW5kIG5vIHN0ZG91dC4gVGhpcyBpcyBiZWNhdXNlIGBvYnNlcnZlUHJvY2VzcygpYCBpcyB1c3VhbGx5IHVzZWQgd2l0aCBsb25nLXJ1bm5pbmdcclxuICogcHJvY2Vzc2VzIHRoYXQgbWF5IGNvbnRpbnVlIHRvIHByb2R1Y2Ugb3V0cHV0IGZvciBhIGxvbmcgd2hpbGUuIFRoZSBhYmJyZXZpYXRlZCBzdGRlcnIgaXNcclxuICogaW5jbHVkZWQgdG8gaGVscCB3aXRoIGRlYnVnZ2luZy5cclxuICpcclxuICogRXhhbXBsZTpcclxuICpcclxuICogYGBganNcclxuICogY29uc3QgZmlsZXNUb1RhaWw6IE9ic2VydmFibGU8TnVjbGlkZVVyaT4gPSBmKCk7XHJcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGZpbGVzVG9UYWlsXHJcbiAqICAgLy8gYHN3aXRjaE1hcCgpYCBtZWFucyBvbmx5IG9uZSBmaWxlIHdpbGwgYmUgdGFpbGVkIGF0IGEgdGltZS5cclxuICogICAuc3dpdGNoTWFwKHBhdGggPT4gb2JzZXJ2ZVByb2Nlc3MoJ3RhaWwnLCBbJy1mJywgcGF0aF0pKVxyXG4gKiAgIC5maWx0ZXIoZXZlbnQgPT4gZXZlbnQua2luZCA9PT0gJ3N0ZG91dCcpXHJcbiAqICAgLm1hcChldmVudCA9PiBldmVudC5kYXRhKVxyXG4gKiAgIC5zdWJzY3JpYmUobGluZSA9PiB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhsaW5lKTtcclxuICogICB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZVByb2Nlc3MoXHJcbiAgY29tbWFuZDogc3RyaW5nLFxyXG4gIGFyZ3M/OiBBcnJheTxzdHJpbmc+LFxyXG4gIG9wdGlvbnM/OiBPYnNlcnZlUHJvY2Vzc09wdGlvbnMsXHJcbik6IE9ic2VydmFibGU8UHJvY2Vzc01lc3NhZ2U+IHtcclxuICByZXR1cm4gc3Bhd24oY29tbWFuZCwgYXJncywgb3B0aW9ucykuZmxhdE1hcChwcm9jID0+XHJcbiAgICBnZXRPdXRwdXRTdHJlYW0ocHJvYywgb3B0aW9ucyksXHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgRGV0YWlsZWRQcm9jZXNzUmVzdWx0ID0ge1xyXG4gIHN0ZG91dDogc3RyaW5nLFxyXG4gIHN0ZGVycjogc3RyaW5nLFxyXG4gIGV4aXRDb2RlOiA/bnVtYmVyLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIElkZW50aWNhbCB0byBgcnVuQ29tbWFuZCgpYCwgYnV0IGluc3RlYWQgb2Ygb25seSBlbWl0dGluZyB0aGUgYWNjdW11bGF0ZWQgc3Rkb3V0LCB0aGUgcmV0dXJuZWRcclxuICogb2JzZXJ2YWJsZSBlbWl0cyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYWNjdW11bGF0ZWQgc3Rkb3V0LCB0aGUgYWNjdW11bGF0ZWQgc3RkZXJyLCBhbmQgdGhlXHJcbiAqIGV4aXQgY29kZS5cclxuICpcclxuICogSW4gZ2VuZXJhbCwgeW91IHNob3VsZCBwcmVmZXIgYHJ1bkNvbW1hbmQoKWAsIGhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciB3aGVuIHN0ZGVyciBpc1xyXG4gKiBuZWVkZWQgZXZlbiBpZiB0aGUgcHJvY2VzcyBleGl0cyBzdWNjZXNzZnVsbHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcnVuQ29tbWFuZERldGFpbGVkKFxyXG4gIGNvbW1hbmQ6IHN0cmluZyxcclxuICBhcmdzPzogQXJyYXk8c3RyaW5nPiA9IFtdLFxyXG4gIG9wdGlvbnM/OiBPYnNlcnZlUHJvY2Vzc09wdGlvbnMgPSB7fSxcclxuICByZXN0OiB2b2lkLFxyXG4pOiBPYnNlcnZhYmxlPERldGFpbGVkUHJvY2Vzc1Jlc3VsdD4ge1xyXG4gIGNvbnN0IG1heEJ1ZmZlciA9IGlkeChvcHRpb25zLCBfID0+IF8ubWF4QnVmZmVyKSB8fCBERUZBVUxUX01BWF9CVUZGRVI7XHJcbiAgcmV0dXJuIG9ic2VydmVQcm9jZXNzKGNvbW1hbmQsIGFyZ3MsIHsuLi5vcHRpb25zLCBtYXhCdWZmZXJ9KVxyXG4gICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgLy8gQ2F0Y2ggUHJvY2Vzc0V4aXRFcnJvcnMgc28gdGhhdCB3ZSBjYW4gYWRkIHN0ZG91dCB0byB0aGVtLlxyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQcm9jZXNzRXhpdEVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUub2Yoe2tpbmQ6ICdwcm9jZXNzLWV4aXQtZXJyb3InLCBlcnJvcn0pO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfSlcclxuICAgIC5yZWR1Y2UoXHJcbiAgICAgIChhY2MsIGV2ZW50KSA9PiB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC5raW5kKSB7XHJcbiAgICAgICAgICBjYXNlICdzdGRvdXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gey4uLmFjYywgc3Rkb3V0OiBhY2Muc3Rkb3V0ICsgZXZlbnQuZGF0YX07XHJcbiAgICAgICAgICBjYXNlICdzdGRlcnInOlxyXG4gICAgICAgICAgICByZXR1cm4gey4uLmFjYywgc3RkZXJyOiBhY2Muc3RkZXJyICsgZXZlbnQuZGF0YX07XHJcbiAgICAgICAgICBjYXNlICdleGl0JzpcclxuICAgICAgICAgICAgcmV0dXJuIHsuLi5hY2MsIGV4aXRDb2RlOiBldmVudC5leGl0Q29kZX07XHJcbiAgICAgICAgICBjYXNlICdwcm9jZXNzLWV4aXQtZXJyb3InOlxyXG4gICAgICAgICAgICBjb25zdCB7ZXJyb3J9ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBQcm9jZXNzRXhpdEVycm9yKFxyXG4gICAgICAgICAgICAgIGVycm9yLmV4aXRDb2RlLFxyXG4gICAgICAgICAgICAgIGVycm9yLnNpZ25hbCxcclxuICAgICAgICAgICAgICBlcnJvci5wcm9jZXNzLFxyXG4gICAgICAgICAgICAgIGFjYy5zdGRlcnIsXHJcbiAgICAgICAgICAgICAgYWNjLnN0ZG91dCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIChldmVudC5raW5kOiBlbXB0eSk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBldmVudCBraW5kOiAke2V2ZW50LmtpbmR9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB7c3Rkb3V0OiAnJywgc3RkZXJyOiAnJywgZXhpdENvZGU6IG51bGx9LFxyXG4gICAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIElkZW50aWNhbCB0byBgb2JzZXJ2ZVByb2Nlc3MoKWAsIGJ1dCBkb2Vzbid0IGJ1ZmZlciBieSBsaW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmVQcm9jZXNzUmF3KFxyXG4gIGNvbW1hbmQ6IHN0cmluZyxcclxuICBhcmdzPzogQXJyYXk8c3RyaW5nPixcclxuICBvcHRpb25zPzogT2JzZXJ2ZVByb2Nlc3NPcHRpb25zLFxyXG4pOiBPYnNlcnZhYmxlPFByb2Nlc3NNZXNzYWdlPiB7XHJcbiAgcmV0dXJuIHNwYXduKGNvbW1hbmQsIGFyZ3MsIG9wdGlvbnMpLmZsYXRNYXAocHJvYyA9PlxyXG4gICAgZ2V0T3V0cHV0U3RyZWFtKHByb2MsIHsuLi5vcHRpb25zLCBzcGxpdEJ5TGluZXM6IGZhbHNlfSksXHJcbiAgKTtcclxufVxyXG5cclxuLy9cclxuLy8gIyBMb3dlci1sZXZlbCBBUElzXHJcbi8vXHJcbi8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGFyZSB1c2VkIHRvIGNyZWF0ZSB0aGUgaGlnaGVyLWxldmVsIEFQSXMgYWJvdmUuIEl0J3MgcmFyZSB0aGF0IHlvdSdsbFxyXG4vLyBuZWVkIHRvIHVzZSB0aGVtIGJ5IHRoZW1zZWx2ZXMuXHJcbi8vXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHRoYXQgc3Bhd25zIGEgcHJvY2VzcyBhbmQgZW1pdHMgaXQuIExpa2Ugd2l0aCBgcnVuQ29tbWFuZCgpYCBhbmRcclxuICogYG9ic2VydmVQcm9jZXNzKClgLCBpZiB5b3UgdW5zdWJzY3JpYmUgZnJvbSB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSwgdGhlIHByb2Nlc3Mgd2lsbCBiZSBraWxsZWRcclxuICogKG9yLCBpZiBpdCBoYXNuJ3QgeWV0IGJlZW4gc3Bhd25lZCwgaXQgd29uJ3QgYmUgY3JlYXRlZCkuXHJcbiAqXHJcbiAqIFVubGlrZSBgb2JzZXJ2ZVByb2Nlc3MoKWAsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdvbid0IHRocm93IFByb2Nlc3NFeGl0RXJyb3JzLS1vbmx5IHN5c3RlbVxyXG4gKiBlcnJvcnMgcmFpc2VkIHdoZW4gdHJ5aW5nIHRvIHNwYXduIHRoZSBwcm9jZXNzLiBUaGlzIGlzIGJlY2F1c2UgaXQncyBtZWFudCB0byBiZSBjb21wb3NlZCB3aXRoXHJcbiAqIGBnZXRPdXRwdXRTdHJlYW1gIHdoaWNoIHRlcm1pbmF0ZXMgYmFzZWQgb24gdGhlIFwiY2xvc2VcIiBldmVudCB3aGVyZWFzIHRoaXMgdGVybWluYXRlcyBvbiB0aGVcclxuICogXCJleGl0XCIgZXZlbnQgdG8gZW5zdXJlIHRoYXQgeW91IGRvbid0IHRyeSB0byBpbnRlcmFjdCB3aXRoIGEgZGVhZCBwcm9jZXNzLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuLCBmb3IgZXhhbXBsZSwgeW91IG5lZWQgYWNjZXNzIHRvIHRoZSBwcm9jZXNzIGluIG9yZGVyIHRvIHNlbmQgSVBDXHJcbiAqIG1lc3NhZ2VzIHRvIGl0LiBJdCBjYW4gYmUgY29tcG9zZWQgd2l0aCBgZ2V0T3V0cHV0U3RyZWFtKClgIHRvIGdpdmUgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBvZlxyXG4gKiBgb2JzZXJ2ZVByb2Nlc3MoKWA6XHJcbiAqXHJcbiAqIGBgYGpzXHJcbiAqIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHNwYXduKC4uLilcclxuICogICAubWFwKHByb2MgPT4ge1xyXG4gKiAgICAgLy8gV2l0aCBhY2Nlc3MgdG8gdGhlIHByb2Nlc3MsIHlvdSBjYW4gc2VuZCBJUEMgbWVzc2FnZXMuXHJcbiAqXHJcbiAqICAgICByZXR1cm4gZ2V0T3V0cHV0U3RyZWFtKHByb2MpO1xyXG4gKiAgIH0pXHJcbiAqICAgLnN1YnNjcmliZShldmVudCA9PiB7XHJcbiAqICAgICAvLyBUaGVzZSBldmVudHMgYXJlIHRoZSBzYW1lIGFzIHRob3NlIGVtaXR0ZWQgYnkgYG9ic2VydmVQcm9jZXNzKClgLlxyXG4gKiAgIH0pO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGF3bihcclxuICBjb21tYW5kOiBzdHJpbmcsXHJcbiAgYXJncz86IEFycmF5PHN0cmluZz4sXHJcbiAgb3B0aW9ucz86IFNwYXduUHJvY2Vzc09wdGlvbnMsXHJcbik6IE9ic2VydmFibGU8Y2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M+IHtcclxuICByZXR1cm4gY3JlYXRlUHJvY2Vzc1N0cmVhbSgnc3Bhd24nLCBjb21tYW5kLCBhcmdzLCBvcHRpb25zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIElkZW50aWNhbCB0byBgc3Bhd24oKWAgKGFib3ZlKSwgYnV0IHVzZXMgYGNoaWxkX3Byb2Nlc3MuZm9yaygpYCB0byBjcmVhdGUgdGhlIHByb2Nlc3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9yayhcclxuICBtb2R1bGVQYXRoOiBzdHJpbmcsXHJcbiAgYXJncz86IEFycmF5PHN0cmluZz4sXHJcbiAgb3B0aW9ucz86IEZvcmtQcm9jZXNzT3B0aW9ucyxcclxuKTogT2JzZXJ2YWJsZTxjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcz4ge1xyXG4gIHJldHVybiBjcmVhdGVQcm9jZXNzU3RyZWFtKCdmb3JrJywgbW9kdWxlUGF0aCwgYXJncywgb3B0aW9ucyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc3RyZWFtIG9mIHNlbnNpYmx5LW9yZGVyZWQgc3Rkb3V0LCBzdGRpbiwgYW5kIGV4aXQgbWVzc2FnZXMgZnJvbSBhIHByb2Nlc3MuIEdlbmVyYWxseSxcclxuICogeW91IHNob3VsZG4ndCB1c2UgdGhpcyBmdW5jdGlvbiBhbmQgc2hvdWxkIGluc3RlYWQgdXNlIGBvYnNlcnZlUHJvY2VzcygpYCAod2hpY2ggbWFrZXMgdXNlIG9mXHJcbiAqIHRoaXMgZm9yIHlvdSkuXHJcbiAqXHJcbiAqIElNUE9SVEFOVDogSWYgeW91IG11c3QgdXNlIHRoaXMgZnVuY3Rpb24sIGl0J3MgdmVyeSBpbXBvcnRhbnQgdGhhdCB0aGUgcHJvY2VzcyB5b3UgZ2l2ZSBpdCB3YXNcclxuICoganVzdCBzeW5jaHJvbm91c2x5IGNyZWF0ZWQuIE90aGVyd2lzZSwgeW91IGNhbiBlbmQgdXAgbWlzc2luZyBtZXNzYWdlcy5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpbnRlbnRpb25hbGx5IGRvZXMgbm90IGNsb3NlIHRoZSBwcm9jZXNzIHdoZW4geW91IHVuc3Vic2NyaWJlLiBJdCdzIHVzdWFsbHkgdXNlZCBpblxyXG4gKiBjb25qdW5jdGlvbiB3aXRoIGBzcGF3bigpYCB3aGljaCBkb2VzIHRoYXQgYWxyZWFkeS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRPdXRwdXRTdHJlYW0oXHJcbiAgcHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXHJcbiAgb3B0aW9ucz86IEdldE91dHB1dFN0cmVhbU9wdGlvbnMsXHJcbiAgcmVzdDogdm9pZCxcclxuKTogT2JzZXJ2YWJsZTxQcm9jZXNzTWVzc2FnZT4ge1xyXG4gIGNvbnN0IGNodW5rID1cclxuICAgIGlkeChvcHRpb25zLCBfID0+IF8uc3BsaXRCeUxpbmVzKSA9PT0gZmFsc2UgPyB4ID0+IHggOiBzcGxpdFN0cmVhbTtcclxuICBjb25zdCBtYXhCdWZmZXIgPSBpZHgob3B0aW9ucywgXyA9PiBfLm1heEJ1ZmZlcik7XHJcbiAgY29uc3QgaXNFeGl0RXJyb3IgPSBpZHgob3B0aW9ucywgXyA9PiBfLmlzRXhpdEVycm9yKSB8fCBpc0V4aXRFcnJvckRlZmF1bHQ7XHJcbiAgY29uc3QgZXhpdEVycm9yQnVmZmVyU2l6ZSA9IGlkeChvcHRpb25zLCBfID0+IF8uZXhpdEVycm9yQnVmZmVyU2l6ZSkgfHwgMjAwMDtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5kZWZlcigoKSA9PiB7XHJcbiAgICBjb25zdCBzdGRvdXRFdmVudHMgPSBjaHVuayhcclxuICAgICAgbGltaXRCdWZmZXJTaXplKG9ic2VydmVTdHJlYW0ocHJvYy5zdGRvdXQpLCBtYXhCdWZmZXIsICdzdGRvdXQnKSxcclxuICAgICkubWFwKGRhdGEgPT4gKHtraW5kOiAnc3Rkb3V0JywgZGF0YX0pKTtcclxuICAgIGNvbnN0IHN0ZGVyckV2ZW50cyA9IGNodW5rKFxyXG4gICAgICBsaW1pdEJ1ZmZlclNpemUob2JzZXJ2ZVN0cmVhbShwcm9jLnN0ZGVyciksIG1heEJ1ZmZlciwgJ3N0ZGVycicpLFxyXG4gICAgKVxyXG4gICAgICAubWFwKGRhdGEgPT4gKHtraW5kOiAnc3RkZXJyJywgZGF0YX0pKVxyXG4gICAgICAuc2hhcmUoKTtcclxuXHJcbiAgICAvLyBBY2N1bXVsYXRlIHRoZSBmaXJzdCBgZXhpdEVycm9yQnVmZmVyU2l6ZWAgYnl0ZXMgb2Ygc3RkZXJyIHNvIHRoYXQgd2UgY2FuIGdpdmUgZmVlZGJhY2sgYWJvdXRcclxuICAgIC8vIGFib3V0IGV4aXQgZXJyb3JzICh0aGVuIHN0b3Agc28gd2UgZG9uJ3QgZmlsbCB1cCBtZW1vcnkgd2l0aCBpdCkuXHJcbiAgICBjb25zdCBhY2N1bXVsYXRlZFN0ZGVyciA9IHN0ZGVyckV2ZW50c1xyXG4gICAgICAuc2NhbihcclxuICAgICAgICAoYWNjLCBldmVudCkgPT4gKGFjYyArIGV2ZW50LmRhdGEpLnNsaWNlKDAsIGV4aXRFcnJvckJ1ZmZlclNpemUpLFxyXG4gICAgICAgICcnLFxyXG4gICAgICApXHJcbiAgICAgIC5zdGFydFdpdGgoJycpXHJcbiAgICAgIC5sZXQodGFrZVdoaWxlSW5jbHVzaXZlKGFjYyA9PiBhY2MubGVuZ3RoIDwgZXhpdEVycm9yQnVmZmVyU2l6ZSkpO1xyXG5cclxuICAgIC8vIFdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIGZvciB0aGUgZXhpdCBldmVudCBpbW1lZGlhdGVseSwgYnV0IGRlZmVyIGVtaXR0aW5nIGl0IHVudGlsIHRoZVxyXG4gICAgLy8gKGJ1ZmZlcmVkKSBvdXRwdXQgc3RyZWFtcyBlbmQuXHJcbiAgICBjb25zdCBjbG9zZUV2ZW50cyA9IE9ic2VydmFibGUuZnJvbUV2ZW50KFxyXG4gICAgICBwcm9jLFxyXG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlIFwiY2xvc2VcIiBldmVudCBpbnN0ZWFkIG9mIFwiZXhpdFwiIGJlY2F1c2Ugd2Ugd2FudCB0byBnZXQgYWxsIG9mIHRoZSBzdGRvdXRcclxuICAgICAgLy8gYW5kIHN0ZGVyci5cclxuICAgICAgJ2Nsb3NlJyxcclxuICAgICAgKGV4aXRDb2RlOiA/bnVtYmVyLCBzaWduYWw6ID9zdHJpbmcpID0+ICh7XHJcbiAgICAgICAga2luZDogJ2V4aXQnLFxyXG4gICAgICAgIGV4aXRDb2RlLFxyXG4gICAgICAgIHNpZ25hbCxcclxuICAgICAgfSksXHJcbiAgICApXHJcbiAgICAgIC5maWx0ZXIoaXNSZWFsRXhpdClcclxuICAgICAgLnRha2UoMSlcclxuICAgICAgLndpdGhMYXRlc3RGcm9tKGFjY3VtdWxhdGVkU3RkZXJyKVxyXG4gICAgICAubWFwKChbZXZlbnQsIHN0ZGVycl0pID0+IHtcclxuICAgICAgICBpZiAoaXNFeGl0RXJyb3IoZXZlbnQpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgUHJvY2Vzc0V4aXRFcnJvcihcclxuICAgICAgICAgICAgZXZlbnQuZXhpdENvZGUsXHJcbiAgICAgICAgICAgIGV2ZW50LnNpZ25hbCxcclxuICAgICAgICAgICAgcHJvYyxcclxuICAgICAgICAgICAgc3RkZXJyLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICB9KVxyXG4gICAgICAucHVibGlzaFJlcGxheSgpO1xyXG4gICAgY29uc3QgZXhpdFN1YiA9IGNsb3NlRXZlbnRzLmNvbm5lY3QoKTtcclxuXHJcbiAgICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZShzdGRvdXRFdmVudHMsIHN0ZGVyckV2ZW50cylcclxuICAgICAgLmNvbmNhdChjbG9zZUV2ZW50cylcclxuICAgICAgLmxldChcclxuICAgICAgICB0YWtlV2hpbGVJbmNsdXNpdmUoXHJcbiAgICAgICAgICBldmVudCA9PiBldmVudC5raW5kICE9PSAnZXJyb3InICYmIGV2ZW50LmtpbmQgIT09ICdleGl0JyxcclxuICAgICAgICApLFxyXG4gICAgICApXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICBleGl0U3ViLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vL1xyXG4vLyAjIE1pc2NlbGxhbmVvdXMgVXRpbGl0aWVzXHJcbi8vXHJcbi8vIFRoZSBmb2xsb3dpbmcgdXRpbGl0aWVzIGRvbid0IHNwYXduIHByb2Nlc3NlcyBvciBuZWNlc3NhcmlseSB1c2Ugb2JzZXJ2YWJsZXMuIEluc3RlYWQsIHRoZXkncmVcclxuLy8gdXNlZCB0byBmb3JtYXQgYXJndW1lbnRzIHRvIHRoZSBhYm92ZSBmdW5jdGlvbnMgb3IgZm9yIGFjdGluZyBvbiBhbHJlYWR5LXNwYXduZWQgcHJvY2Vzc2VzLlxyXG4vL1xyXG5cclxuLyoqXHJcbiAqIFRha2VzIHRoZSBhcmd1bWVudHMgdGhhdCB5b3Ugd291bGQgbm9ybWFsbHkgcGFzcyB0byBgc3Bhd24oKWAgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgbmV3XHJcbiAqIGFyZ3VtZW50cyB0byB1c2UgdG8gcnVuIHRoZSBjb21tYW5kIHVuZGVyIGBzY3JpcHRgLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBvYnNlcnZlUHJvY2VzcyguLi5zY3JpcHRpZnlDb21tYW5kKCdoZycsIFsnZGlmZiddKSkuc3Vic2NyaWJlKC4uLik7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBTZWUgYWxzbyBgbmljaWZ5Q29tbWFuZCgpYCB3aGljaCBkb2VzIGEgc2ltaWxhciB0aGluZyBidXQgZm9yIGBuaWNlYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY3JpcHRpZnlDb21tYW5kPFQ+KFxyXG4gIGNvbW1hbmQ6IHN0cmluZyxcclxuICBhcmdzPzogQXJyYXk8c3RyaW5nPiA9IFtdLFxyXG4gIG9wdGlvbnM6IFQsXHJcbik6IFtzdHJpbmcsIEFycmF5PHN0cmluZz4sIFRdIHtcclxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcclxuICAgIC8vIE9uIE9TIFgsIHNjcmlwdCB0YWtlcyB0aGUgcHJvZ3JhbSB0byBydW4gYW5kIGl0cyBhcmd1bWVudHMgYXMgdmFyYXJncyBhdCB0aGUgZW5kLlxyXG4gICAgcmV0dXJuIFsnc2NyaXB0JywgWyctcScsICcvZGV2L251bGwnLCBjb21tYW5kXS5jb25jYXQoYXJncyksIG9wdGlvbnNdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBPbiBMaW51eCwgc2NyaXB0IHRha2VzIHRoZSBjb21tYW5kIHRvIHJ1biBhcyB0aGUgLWMgcGFyYW1ldGVyIHNvIHdlIGhhdmUgdG8gY29tYmluZSBhbGwgb2ZcclxuICAgIC8vIHRoZSBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBzdHJpbmcuXHJcbiAgICBjb25zdCBqb2luZWQgPSBzaGVsbFF1b3RlKFtjb21tYW5kLCAuLi5hcmdzXSk7XHJcbiAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgc2tldGNoeS1udWxsLW1peGVkOm9mZlxyXG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgc2tldGNoeS1udWxsLW1peGVkOm9mZlxyXG4gICAgY29uc3QgZW52ID0gb3B0cy5lbnYgfHwge307XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAnc2NyaXB0JyxcclxuICAgICAgWyctcScsICcvZGV2L251bGwnLCAnLWMnLCBqb2luZWRdLFxyXG4gICAgICAvLyBgc2NyaXB0YCB3aWxsIHVzZSBgU0hFTExgLCBidXQgc2hlbGxzIGhhdmUgZGlmZmVyZW50IGJlaGF2aW9ycyB3aXRoIHJlZ2FyZCB0byBlc2NhcGluZy4gVG9cclxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgb3V0IGVzY2FwaW5nIGlzIGNvcnJlY3QsIHdlIG5lZWQgdG8gZm9yY2UgYSBwYXJ0aWN1bGFyIHNoZWxsLlxyXG4gICAgICB7Li4ub3B0cywgZW52OiB7Li4uZW52LCBTSEVMTDogJy9iaW4vYmFzaCd9fSxcclxuICAgIF07XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogS2lsbHMgYSBwcm9jZXNzIGFuZCwgb3B0aW9uYWxseSwgaXRzIGRlc2NlbmRhbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGtpbGxQcm9jZXNzKFxyXG4gIHByb2M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzLFxyXG4gIGtpbGxUcmVlOiBib29sZWFuLFxyXG4gIGtpbGxUcmVlU2lnbmFsOiA/c3RyaW5nLFxyXG4pOiB2b2lkIHtcclxuICBfa2lsbFByb2Nlc3MocHJvYywga2lsbFRyZWUsIGtpbGxUcmVlU2lnbmFsKS50aGVuKFxyXG4gICAgKCkgPT4ge30sXHJcbiAgICBlcnJvciA9PiB7XHJcbiAgICAgIGxvZ2dlci5lcnJvcihgS2lsbGluZyBwcm9jZXNzICR7cHJvYy5waWR9IGZhaWxlZGAsIGVycm9yKTtcclxuICAgIH0sXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEtpbGwgdGhlIHByb2Nlc3Mgd2l0aCB0aGUgcHJvdmlkZWQgcGlkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGtpbGxQaWQocGlkOiBudW1iZXIpOiB2b2lkIHtcclxuICB0cnkge1xyXG4gICAgcHJvY2Vzcy5raWxsKHBpZCk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBpZiAoZXJyLmNvZGUgIT09ICdFU1JDSCcpIHtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gSW5zaWRlIEZCLCBOdWNsaWRlJ3MgUlBDIHByb2Nlc3MgZG9lc24ndCBpbmhlcml0IGl0cyBwYXJlbnQgZW52aXJvbm1lbnQgYW5kIHNldHMgdXAgaXRzIG93biBpbnN0ZWFkLlxyXG4vLyBJdCBkb2VzIHRoaXMgdG8gcHJldmVudCBkaWZmaWN1bHQtdG8tZGlhZ25vc2UgaXNzdWVzIGNhdXNlZCBieSB1bmV4cGVjdGVkIGNvZGUgaW4gdXNlcnMnIGRvdGZpbGVzLlxyXG4vLyBCZWZvcmUgb3ZlcndyaXRpbmcgaXQsIHRoZSBvcmlnaW5hbCBlbnZpcm9ubWVudCBpcyBiYXNlNjQtZW5jb2RlZCBpbiBOVUNMSURFX09SSUdJTkFMX0VOVi5cclxuLy8gV0FSTklORzogVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBlbnZpcm9ubWVudCB0aGF0IHdvdWxkIGhhdmUgYmVlbiBpbmhlcml0ZWQgdW5kZXIgbm9ybWFsIGNvbmRpdGlvbnMuXHJcbi8vIFlvdSBjYW4gdXNlIGl0IHdpdGggYSBjaGlsZCBwcm9jZXNzIHRvIGxldCB0aGUgdXNlciBzZXQgaXRzIGVudmlyb25tZW50IHZhcmlhYmxlcy4gQnkgZG9pbmcgc28sIHlvdSBhcmUgY3JlYXRpbmdcclxuLy8gYW4gZXZlbiBtb3JlIGNvbXBsaWNhdGVkIG1lc3Mgb2YgaW5oZXJpdGFuY2UgYW5kIG5vbi1pbmhlcml0YW5jZSBpbiB0aGUgcHJvY2VzcyB0cmVlLlxyXG5sZXQgY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudCA9IG51bGw7XHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmlnaW5hbEVudmlyb25tZW50KCk6IFByb21pc2U8T2JqZWN0PiB7XHJcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICB3aGVuU2hlbGxFbnZpcm9ubWVudExvYWRlZChyZXNvbHZlKTtcclxuICB9KTtcclxuICBpZiAoY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudCAhPSBudWxsKSB7XHJcbiAgICByZXR1cm4gY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudDtcclxuICB9XHJcblxyXG4gIGNvbnN0IHtOVUNMSURFX09SSUdJTkFMX0VOVn0gPSBwcm9jZXNzLmVudjtcclxuICBpZiAoTlVDTElERV9PUklHSU5BTF9FTlYgIT0gbnVsbCAmJiBOVUNMSURFX09SSUdJTkFMX0VOVi50cmltKCkgIT09ICcnKSB7XHJcbiAgICBjb25zdCBlbnZTdHJpbmcgPSBuZXcgQnVmZmVyKE5VQ0xJREVfT1JJR0lOQUxfRU5WLCAnYmFzZTY0JykudG9TdHJpbmcoKTtcclxuICAgIGNhY2hlZE9yaWdpbmFsRW52aXJvbm1lbnQgPSB7fTtcclxuICAgIGZvciAoY29uc3QgZW52VmFyIG9mIGVudlN0cmluZy5zcGxpdCgnXFwwJykpIHtcclxuICAgICAgLy8gZW52VmFyIHNob3VsZCBsb29rIGxpa2UgQT12YWx1ZV9vZl9BXHJcbiAgICAgIGNvbnN0IGVxdWFsSW5kZXggPSBlbnZWYXIuaW5kZXhPZignPScpO1xyXG4gICAgICBpZiAoZXF1YWxJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBjYWNoZWRPcmlnaW5hbEVudmlyb25tZW50W1xyXG4gICAgICAgICAgZW52VmFyLnN1YnN0cmluZygwLCBlcXVhbEluZGV4KVxyXG4gICAgICAgIF0gPSBlbnZWYXIuc3Vic3RyaW5nKGVxdWFsSW5kZXggKyAxKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gR3VhcmQgYWdhaW5zdCBpbnZhbGlkIG9yaWdpbmFsIGVudmlyb25tZW50cy5cclxuICAgIGlmICghT2JqZWN0LmtleXMoY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudCkubGVuZ3RoKSB7XHJcbiAgICAgIGNhY2hlZE9yaWdpbmFsRW52aXJvbm1lbnQgPSBwcm9jZXNzLmVudjtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudCA9IHByb2Nlc3MuZW52O1xyXG4gIH1cclxuICByZXR1cm4gY2FjaGVkT3JpZ2luYWxFbnZpcm9ubWVudDtcclxufVxyXG5cclxuLy8gU2VlIGdldE9yaWdpbmFsRW52aXJvbm1lbnQgYWJvdmUuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPcmlnaW5hbEVudmlyb25tZW50QXJyYXkoKTogUHJvbWlzZTxBcnJheTxzdHJpbmc+PiB7XHJcbiAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICB3aGVuU2hlbGxFbnZpcm9ubWVudExvYWRlZChyZXNvbHZlKTtcclxuICB9KTtcclxuICBjb25zdCB7TlVDTElERV9PUklHSU5BTF9FTlZ9ID0gcHJvY2Vzcy5lbnY7XHJcbiAgaWYgKE5VQ0xJREVfT1JJR0lOQUxfRU5WICE9IG51bGwgJiYgTlVDTElERV9PUklHSU5BTF9FTlYudHJpbSgpICE9PSAnJykge1xyXG4gICAgY29uc3QgZW52U3RyaW5nID0gbmV3IEJ1ZmZlcihOVUNMSURFX09SSUdJTkFMX0VOViwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XHJcbiAgICByZXR1cm4gZW52U3RyaW5nLnNwbGl0KCdcXDAnKTtcclxuICB9XHJcbiAgcmV0dXJuIFtdO1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW52aXJvbm1lbnQoKTogUHJvbWlzZTxPYmplY3Q+IHtcclxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIHdoZW5TaGVsbEVudmlyb25tZW50TG9hZGVkKHJlc29sdmUpO1xyXG4gIH0pO1xyXG4gIHJldHVybiBwcm9jZXNzLmVudjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgc3VpdGFibGUgZm9yIGluY2x1ZGluZyBpbiBkaXNwbGF5ZWQgZXJyb3IgbWVzc2FnZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXhpdEV2ZW50VG9NZXNzYWdlKGV2ZW50OiB7XHJcbiAgZXhpdENvZGU6ID9udW1iZXIsXHJcbiAgc2lnbmFsOiA/c3RyaW5nLFxyXG59KTogc3RyaW5nIHtcclxuICBpZiAoZXZlbnQuZXhpdENvZGUgIT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIGBleGl0IGNvZGUgJHtldmVudC5leGl0Q29kZX1gO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpbnZhcmlhbnQoZXZlbnQuc2lnbmFsICE9IG51bGwpO1xyXG4gICAgcmV0dXJuIGBzaWduYWwgJHtldmVudC5zaWduYWx9YDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDaGlsZHJlbk9mUHJvY2VzcyhcclxuICBwcm9jZXNzSWQ6IG51bWJlcixcclxuKTogUHJvbWlzZTxBcnJheTxQcm9jZXNzSW5mbz4+IHtcclxuICBjb25zdCBwcm9jZXNzZXMgPSBhd2FpdCBwc1RyZWUoKTtcclxuXHJcbiAgcmV0dXJuIHByb2Nlc3Nlcy5maWx0ZXIocHJvY2Vzc0luZm8gPT4gcHJvY2Vzc0luZm8ucGFyZW50UGlkID09PSBwcm9jZXNzSWQpO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgbGlzdCBvZiBkZXNjZW5kYW50cywgc29ydGVkIGJ5IGluY3JlYXNpbmcgZGVwdGggKGluY2x1ZGluZyB0aGUgb25lIHdpdGggdGhlIHByb3ZpZGVkIHBpZCkuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBnZXREZXNjZW5kYW50c09mUHJvY2VzcyhcclxuICBwaWQ6IG51bWJlcixcclxuKTogUHJvbWlzZTxBcnJheTxQcm9jZXNzSW5mbz4+IHtcclxuICBjb25zdCBwcm9jZXNzZXMgPSBhd2FpdCBwc1RyZWUoKTtcclxuICBsZXQgcm9vdFByb2Nlc3NJbmZvO1xyXG4gIGNvbnN0IHBpZFRvQ2hpbGRyZW4gPSBuZXcgTXVsdGlNYXAoKTtcclxuICBwcm9jZXNzZXMuZm9yRWFjaChpbmZvID0+IHtcclxuICAgIGlmIChpbmZvLnBpZCA9PT0gcGlkKSB7XHJcbiAgICAgIHJvb3RQcm9jZXNzSW5mbyA9IGluZm87XHJcbiAgICB9XHJcbiAgICBwaWRUb0NoaWxkcmVuLmFkZChpbmZvLnBhcmVudFBpZCwgaW5mbyk7XHJcbiAgfSk7XHJcbiAgY29uc3QgZGVzY2VuZGFudHMgPSByb290UHJvY2Vzc0luZm8gPT0gbnVsbCA/IFtdIDogW3Jvb3RQcm9jZXNzSW5mb107XHJcbiAgLy8gV2FsayB0aHJvdWdoIHRoZSBhcnJheSwgYWRkaW5nIHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBlbGVtZW50IHRvIHRoZSBlbmQuIFRoaXNcclxuICAvLyBicmVhZHRoLWZpcnN0IHRyYXZlcnNhbCBtZWFucyB0aGF0IHRoZSBlbGVtZW50cyB3aWxsIGJlIHNvcnRlZCBieSBkZXB0aC5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2NlbmRhbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBpbmZvID0gZGVzY2VuZGFudHNbaV07XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHBpZFRvQ2hpbGRyZW4uZ2V0KGluZm8ucGlkKTtcclxuICAgIGRlc2NlbmRhbnRzLnB1c2goLi4uQXJyYXkuZnJvbShjaGlsZHJlbikpO1xyXG4gIH1cclxuICByZXR1cm4gZGVzY2VuZGFudHM7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwc1RyZWUoKTogUHJvbWlzZTxBcnJheTxQcm9jZXNzSW5mbz4+IHtcclxuICBpZiAoaXNXaW5kb3dzUGxhdGZvcm0oKSkge1xyXG4gICAgcmV0dXJuIHBzVHJlZVdpbmRvd3MoKTtcclxuICB9XHJcbiAgY29uc3QgW2NvbW1hbmRzLCB3aXRoQXJnc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICBydW5Db21tYW5kKCdwcycsIFsnLUEnLCAnLW8nLCAncHBpZCxwaWQsY29tbSddKS50b1Byb21pc2UoKSxcclxuICAgIHJ1bkNvbW1hbmQoJ3BzJywgWyctQScsICctd3cnLCAnLW8nLCAncGlkLGFyZ3MnXSkudG9Qcm9taXNlKCksXHJcbiAgXSk7XHJcblxyXG4gIHJldHVybiBwYXJzZVBzT3V0cHV0KGNvbW1hbmRzLCB3aXRoQXJncyk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHBzVHJlZVdpbmRvd3MoKTogUHJvbWlzZTxBcnJheTxQcm9jZXNzSW5mbz4+IHtcclxuICBjb25zdCBzdGRvdXQgPSBhd2FpdCBydW5Db21tYW5kKCd3bWljLmV4ZScsIFtcclxuICAgICdQUk9DRVNTJyxcclxuICAgICdHRVQnLFxyXG4gICAgJ1BhcmVudFByb2Nlc3NJZCxQcm9jZXNzSWQsTmFtZScsXHJcbiAgXSkudG9Qcm9taXNlKCk7XHJcbiAgcmV0dXJuIHBhcnNlUHNPdXRwdXQoc3Rkb3V0KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHNPdXRwdXQoXHJcbiAgcHNPdXRwdXQ6IHN0cmluZyxcclxuICBhcmdzT3V0cHV0OiA/c3RyaW5nLFxyXG4pOiBBcnJheTxQcm9jZXNzSW5mbz4ge1xyXG4gIC8vIFJlbW92ZSB0aGUgZmlyc3QgaGVhZGVyIGxpbmUuXHJcbiAgY29uc3QgbGluZXMgPSBwc091dHB1dFxyXG4gICAgLnRyaW0oKVxyXG4gICAgLnNwbGl0KC9cXG58XFxyXFxuLylcclxuICAgIC5zbGljZSgxKTtcclxuXHJcbiAgbGV0IHdpdGhBcmdzID0gbmV3IE1hcCgpO1xyXG4gIGlmIChhcmdzT3V0cHV0ICE9IG51bGwpIHtcclxuICAgIHdpdGhBcmdzID0gbmV3IE1hcChcclxuICAgICAgYXJnc091dHB1dFxyXG4gICAgICAgIC50cmltKClcclxuICAgICAgICAuc3BsaXQoL1xcbnxcXHJcXG4vKVxyXG4gICAgICAgIC5zbGljZSgxKVxyXG4gICAgICAgIC5tYXAobGluZSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjb2x1bW5zID0gbGluZS50cmltKCkuc3BsaXQoL1xccysvKTtcclxuICAgICAgICAgIGNvbnN0IHBpZCA9IHBhcnNlSW50KGNvbHVtbnNbMF0sIDEwKTtcclxuICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSBjb2x1bW5zLnNsaWNlKDEpLmpvaW4oJyAnKTtcclxuICAgICAgICAgIHJldHVybiBbcGlkLCBjb21tYW5kXTtcclxuICAgICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGluZXMubWFwKGxpbmUgPT4ge1xyXG4gICAgY29uc3QgY29sdW1ucyA9IGxpbmUudHJpbSgpLnNwbGl0KC9cXHMrLyk7XHJcbiAgICBjb25zdCBbcGFyZW50UGlkLCBwaWRTdHJdID0gY29sdW1ucztcclxuICAgIGNvbnN0IHBpZCA9IHBhcnNlSW50KHBpZFN0ciwgMTApO1xyXG4gICAgY29uc3QgY29tbWFuZCA9IGNvbHVtbnMuc2xpY2UoMikuam9pbignICcpO1xyXG4gICAgY29uc3QgY29tbWFuZFdpdGhBcmdzID0gd2l0aEFyZ3MuZ2V0KHBpZCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY29tbWFuZCxcclxuICAgICAgcGFyZW50UGlkOiBwYXJzZUludChwYXJlbnRQaWQsIDEwKSxcclxuICAgICAgcGlkLFxyXG4gICAgICBjb21tYW5kV2l0aEFyZ3M6IGNvbW1hbmRXaXRoQXJncyA9PSBudWxsID8gY29tbWFuZCA6IGNvbW1hbmRXaXRoQXJncyxcclxuICAgIH07XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIFVzZSBgcHNgIHRvIGdldCBtZW1vcnkgdXNhZ2UgaW4ga2IgZm9yIGFuIGFycmF5IG9mIHByb2Nlc3MgaWQncyBhcyBhIG1hcC5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1lbW9yeVVzYWdlUGVyUGlkKFxyXG4gIHBpZHM6IEFycmF5PG51bWJlcj4sXHJcbik6IFByb21pc2U8TWFwPG51bWJlciwgbnVtYmVyPj4ge1xyXG4gIGNvbnN0IHVzYWdlID0gbmV3IE1hcCgpO1xyXG4gIGlmIChwaWRzLmxlbmd0aCA+PSAxKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGRvdXQgPSBhd2FpdCBydW5Db21tYW5kKCdwcycsIFtcclxuICAgICAgICAnLXAnLFxyXG4gICAgICAgIHBpZHMuam9pbignLCcpLFxyXG4gICAgICAgICctbycsXHJcbiAgICAgICAgJ3BpZD0nLFxyXG4gICAgICAgICctbycsXHJcbiAgICAgICAgJ3Jzcz0nLFxyXG4gICAgICBdKS50b1Byb21pc2UoKTtcclxuICAgICAgc3Rkb3V0LnNwbGl0KCdcXG4nKS5mb3JFYWNoKGxpbmUgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS50cmltKCkuc3BsaXQoL1xccysvKTtcclxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICBjb25zdCBbcGlkLCByc3NdID0gcGFydHMubWFwKHggPT4gcGFyc2VJbnQoeCwgMTApKTtcclxuICAgICAgICAgIHVzYWdlLnNldChwaWQsIHJzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAvLyBJZ25vcmUgZXJyb3JzLlxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdXNhZ2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgbm8tb3AgZXJyb3IgaGFuZGxlcnMgdG8gdGhlIHByb2Nlc3MncyBzdHJlYW1zIHNvIHRoYXQgTm9kZSBkb2Vzbid0IHRocm93IHRoZW0uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudFN0cmVhbXNGcm9tVGhyb3dpbmcoXHJcbiAgcHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXHJcbik6IElEaXNwb3NhYmxlIHtcclxuICByZXR1cm4gbmV3IFVuaXZlcnNhbERpc3Bvc2FibGUoZ2V0U3RyZWFtRXJyb3JFdmVudHMocHJvYykuc3Vic2NyaWJlKCkpO1xyXG59XHJcblxyXG4vKipcclxuICogTG9nIGVycm9ycyBmcm9tIGEgcHJvY2VzcydzIHN0cmVhbXMuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgcnhqcyRJU3Vic2NyaXB0aW9uYCBzbyB0aGF0IGl0XHJcbiAqIGNhbiBlYXNpbHkgYmUgdXNlZCB3aXRoIGBPYnNlcnZhYmxlLnVzaW5nKClgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvZ1N0cmVhbUVycm9ycyhcclxuICBwcm9jOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2VzcyxcclxuICBjb21tYW5kOiBzdHJpbmcsXHJcbiAgYXJnczogQXJyYXk8c3RyaW5nPixcclxuICBvcHRpb25zPzogT2JqZWN0LFxyXG4pOiBJRGlzcG9zYWJsZSAmIHJ4anMkSVN1YnNjcmlwdGlvbiB7XHJcbiAgcmV0dXJuIG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKFxyXG4gICAgZ2V0U3RyZWFtRXJyb3JFdmVudHMocHJvYylcclxuICAgICAgLmRvKChbZXJyLCBzdHJlYW1OYW1lXSkgPT4ge1xyXG4gICAgICAgIGxvZ2dlci5lcnJvcihcclxuICAgICAgICAgIGBzdHJlYW0gZXJyb3Igb24gc3RyZWFtICR7c3RyZWFtTmFtZX0gd2l0aCBjb21tYW5kOmAsXHJcbiAgICAgICAgICBjb21tYW5kLFxyXG4gICAgICAgICAgYXJncyxcclxuICAgICAgICAgIG9wdGlvbnMsXHJcbiAgICAgICAgICAnZXJyb3I6JyxcclxuICAgICAgICAgIGVycixcclxuICAgICAgICApO1xyXG4gICAgICB9KVxyXG4gICAgICAuc3Vic2NyaWJlKCksXHJcbiAgKTtcclxufVxyXG5cclxuLy9cclxuLy8gVHlwZXNcclxuLy9cclxuXHJcbi8vIEV4YWN0bHkgb25lIG9mIGV4aXRDb2RlIGFuZCBzaWduYWwgd2lsbCBiZSBub24tbnVsbC5cclxuLy8gS2lsbGluZyBhIHByb2Nlc3Mgd2lsbCByZXN1bHQgaW4gYSBudWxsIGV4aXRDb2RlIGJ1dCBhIG5vbi1udWxsIHNpZ25hbC5cclxuZXhwb3J0IHR5cGUgUHJvY2Vzc0V4aXRNZXNzYWdlID0ge1xyXG4gIGtpbmQ6ICdleGl0JyxcclxuICBleGl0Q29kZTogP251bWJlcixcclxuICBzaWduYWw6ID9zdHJpbmcsXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBQcm9jZXNzTWVzc2FnZSA9XHJcbiAgfCB7XHJcbiAgICAgIGtpbmQ6ICdzdGRvdXQnLFxyXG4gICAgICBkYXRhOiBzdHJpbmcsXHJcbiAgICB9XHJcbiAgfCB7XHJcbiAgICAgIGtpbmQ6ICdzdGRlcnInLFxyXG4gICAgICBkYXRhOiBzdHJpbmcsXHJcbiAgICB9XHJcbiAgfCBQcm9jZXNzRXhpdE1lc3NhZ2U7XHJcblxyXG4vLyBJbiBvbGRlciB2ZXJzaW9ucyBvZiBwcm9jZXNzLmpzLCBlcnJvcnMgd2VyZSBlbWl0dGVkIGFzIG1lc3NhZ2VzIGluc3RlYWQgb2YgZXJyb3JzLiBUaGlzIHR5cGVcclxuLy8gZXhpc3RzIHRvIHN1cHBvcnQgdGhlIHRyYW5zaXRpb24sIGJ1dCBubyBuZXcgdXNhZ2VzIHNob3VsZCBiZSBhZGRlZC5cclxuZXhwb3J0IHR5cGUgTGVnYWN5UHJvY2Vzc01lc3NhZ2UgPVxyXG4gIHwgUHJvY2Vzc01lc3NhZ2VcclxuICB8IHtraW5kOiAnZXJyb3InLCBlcnJvcjogT2JqZWN0fTtcclxuXHJcbmV4cG9ydCB0eXBlIFByb2Nlc3NJbmZvID0ge1xyXG4gIHBhcmVudFBpZDogbnVtYmVyLFxyXG4gIHBpZDogbnVtYmVyLFxyXG4gIGNvbW1hbmQ6IHN0cmluZyxcclxuICBjb21tYW5kV2l0aEFyZ3M6IHN0cmluZyxcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIExldmVsID0gJ2luZm8nIHwgJ2xvZycgfCAnd2FybmluZycgfCAnZXJyb3InIHwgJ2RlYnVnJyB8ICdzdWNjZXNzJztcclxuZXhwb3J0IHR5cGUgTWVzc2FnZSA9IHt0ZXh0OiBzdHJpbmcsIGxldmVsOiBMZXZlbH07XHJcblxyXG5leHBvcnQgdHlwZSBNZXNzYWdlRXZlbnQgPSB7XHJcbiAgdHlwZTogJ21lc3NhZ2UnLFxyXG4gIG1lc3NhZ2U6IE1lc3NhZ2UsXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBQcm9ncmVzc0V2ZW50ID0ge1xyXG4gIHR5cGU6ICdwcm9ncmVzcycsXHJcbiAgcHJvZ3Jlc3M6ID9udW1iZXIsXHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBSZXN1bHRFdmVudCA9IHtcclxuICB0eXBlOiAncmVzdWx0JyxcclxuICByZXN1bHQ6IG1peGVkLFxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgU3RhdHVzID0ge3R5cGU6IHN0cmluZywgb2JqZWN0OiBtaXhlZH07XHJcblxyXG5leHBvcnQgdHlwZSBTdGF0dXNFdmVudCA9IHtcclxuICB0eXBlOiAnc3RhdHVzJyxcclxuICBzdGF0dXM6IFN0YXR1cyxcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFRhc2tFdmVudCA9XHJcbiAgfCBNZXNzYWdlRXZlbnRcclxuICB8IFByb2dyZXNzRXZlbnRcclxuICB8IFJlc3VsdEV2ZW50XHJcbiAgfCBTdGF0dXNFdmVudDtcclxuXHJcbnR5cGUgQ3JlYXRlUHJvY2Vzc1N0cmVhbU9wdGlvbnMgPSAoXHJcbiAgfCBjaGlsZF9wcm9jZXNzJHNwYXduT3B0c1xyXG4gIHwgY2hpbGRfcHJvY2VzcyRmb3JrT3B0c1xyXG4pICYge1xyXG4gIGtpbGxUcmVlV2hlbkRvbmU/OiA/Ym9vbGVhbixcclxuICBraWxsVHJlZVNpZ25hbD86IHN0cmluZyxcclxuICB0aW1lb3V0PzogP251bWJlcixcclxuICBpbnB1dD86ID8oc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSxcclxuICBkb250TG9nSW5OdWNsaWRlPzogP2Jvb2xlYW4sXHJcbn07XHJcblxyXG50eXBlIEdldE91dHB1dFN0cmVhbU9wdGlvbnMgPSB7XHJcbiAgc3BsaXRCeUxpbmVzPzogP2Jvb2xlYW4sXHJcbiAgbWF4QnVmZmVyPzogP251bWJlcixcclxuICBleGl0RXJyb3JCdWZmZXJTaXplPzogP251bWJlcixcclxuICBpc0V4aXRFcnJvcj86ID8oZXZlbnQ6IFByb2Nlc3NFeGl0TWVzc2FnZSkgPT4gYm9vbGVhbixcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIE9ic2VydmVQcm9jZXNzT3B0aW9ucyA9IFNwYXduUHJvY2Vzc09wdGlvbnMgJlxyXG4gIEdldE91dHB1dFN0cmVhbU9wdGlvbnM7XHJcblxyXG5leHBvcnQgdHlwZSBTcGF3blByb2Nlc3NPcHRpb25zID0gY2hpbGRfcHJvY2VzcyRzcGF3bk9wdHMgJlxyXG4gIENyZWF0ZVByb2Nlc3NTdHJlYW1PcHRpb25zO1xyXG5leHBvcnQgdHlwZSBGb3JrUHJvY2Vzc09wdGlvbnMgPSBjaGlsZF9wcm9jZXNzJGZvcmtPcHRzICZcclxuICBDcmVhdGVQcm9jZXNzU3RyZWFtT3B0aW9ucztcclxuXHJcbmV4cG9ydCB0eXBlIFByb2Nlc3NFcnJvciA9IFByb2Nlc3NTeXN0ZW1FcnJvciB8IFByb2Nlc3NFeGl0RXJyb3I7XHJcblxyXG4vL1xyXG4vLyBFcnJvcnNcclxuLy9cclxuXHJcbi8qKlxyXG4gKiBBbiBlcnJvciB0aHJvd24gYnkgcHJvY2VzcyB1dGlscyB3aGVuIHRoZSBwcm9jZXNzIGV4aXRzIHdpdGggYW4gZXJyb3IgY29kZS4gVGhpcyB0eXBlIGhhcyBhbGwgdGhlXHJcbiAqIHByb3BlcnRpZXMgb2YgUHJvY2Vzc0V4aXRNZXNzYWdlIChleGNlcHQgXCJraW5kXCIpLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhlIGBzdGRlcnJgIHByb3BlcnR5IHdpbGwgb25seSBjb250YWluIHRoZSBjb21wbGV0ZSBzdGRlcnIgd2hlbiB0aHJvd24gYnkgdGhlXHJcbiAqIG91dHB1dC1hY2N1bXVsYXRpbmcgZnVuY3Rpb25zIChgcnVuQ29tbWFuZCgpYCwgYHJ1bkNvbW1hbmREZXRhaWxlZCgpYCkuIEZvciBvdGhlcnMsIGxpa2VcclxuICogYG9ic2VydmVQcm9jZXNzKClgLCBpdCB3aWxsIGJlIHRydW5jYXRlZC4gU2ltaWxhcmx5LCBgc3Rkb3V0YCB3aWxsIG9ubHkgYmUgcG9wdWxhdGVkIHdoZW4gdGhlXHJcbiAqIGVycm9yIGlzIHRocm93biBieSBvdXRwdXQtYWNjdW11bGF0aW5nIGZ1bmN0aW9ucy4gRm9yIG90aGVycywgaXQgd2lsbCBhbHdheXMgYmUgYG51bGxgLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByb2Nlc3NFeGl0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgZXhpdENvZGU6ID9udW1iZXI7XHJcbiAgc2lnbmFsOiA/c3RyaW5nO1xyXG4gIHN0ZGVycjogc3RyaW5nO1xyXG4gIHN0ZG91dDogP3N0cmluZztcclxuICBjb21tYW5kOiBzdHJpbmc7XHJcbiAgYXJnczogQXJyYXk8c3RyaW5nPjtcclxuICBwcm9jZXNzOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2VzcztcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBleGl0Q29kZTogP251bWJlcixcclxuICAgIHNpZ25hbDogP3N0cmluZyxcclxuICAgIHByb2M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzLFxyXG4gICAgc3RkZXJyOiBzdHJpbmcsXHJcbiAgICBzdGRvdXQ/OiBzdHJpbmcsXHJcbiAgKSB7XHJcbiAgICAvLyAkRmxvd0lzc3VlOiBUaGlzIGlzbid0IHR5cGVkIGluIHRoZSBGbG93IG5vZGUgdHlwZSBkZWZzXHJcbiAgICBjb25zdCB7c3Bhd25hcmdzfSA9IHByb2M7XHJcbiAgICBjb25zdCBhcmdzQW5kQ29tbWFuZCA9XHJcbiAgICAgIHNwYXduYXJnc1swXSA9PT0gcHJvY2Vzcy5leGVjUGF0aCA/IHNwYXduYXJncy5zbGljZSgxKSA6IHNwYXduYXJncztcclxuICAgIGNvbnN0IFtjb21tYW5kLCAuLi5hcmdzXSA9IGFyZ3NBbmRDb21tYW5kO1xyXG4gICAgc3VwZXIoXHJcbiAgICAgIGBcIiR7Y29tbWFuZH1cIiBmYWlsZWQgd2l0aCAke2V4aXRFdmVudFRvTWVzc2FnZSh7XHJcbiAgICAgICAgZXhpdENvZGUsXHJcbiAgICAgICAgc2lnbmFsLFxyXG4gICAgICB9KX1cXG5cXG4ke3N0ZGVycn1cXG5cXG4ke2FyZ3NBbmRDb21tYW5kLmpvaW4oJyAnKX1gLFxyXG4gICAgKTtcclxuICAgIHRoaXMubmFtZSA9ICdQcm9jZXNzRXhpdEVycm9yJztcclxuICAgIHRoaXMuZXhpdENvZGUgPSBleGl0Q29kZTtcclxuICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsO1xyXG4gICAgdGhpcy5zdGRlcnIgPSBzdGRlcnI7XHJcbiAgICB0aGlzLnN0ZG91dCA9IHN0ZG91dDtcclxuICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XHJcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xyXG4gICAgdGhpcy5wcm9jZXNzID0gcHJvYztcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzIHN5c3RlbSBlcnJvcnMgYXJlIGp1c3QgYXVnbWVudGVkIEVycm9yIG9iamVjdHMuIFdlIHdyYXAgdGhlIGVycm9ycyBhbmQgZXhwb3NlIHRoZSBwcm9jZXNzXHJcbiAqIHNpbmNlIG91ciB1dGlsaXRpZXMgdGhyb3cgdGhlIGVycm9ycyBiZWZvcmUgcmV0dXJuaW5nIHRoZSBwcm9jZXNzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFByb2Nlc3NTeXN0ZW1FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBlcnJubzogbnVtYmVyIHwgc3RyaW5nO1xyXG4gIGNvZGU6IHN0cmluZztcclxuICBwYXRoOiA/c3RyaW5nO1xyXG4gIHN5c2NhbGw6ID9zdHJpbmc7XHJcbiAgcHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3M7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGVycjogYW55LCBwcm9jOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcykge1xyXG4gICAgc3VwZXIoZXJyLm1lc3NhZ2UpO1xyXG4gICAgdGhpcy5uYW1lID0gJ1Byb2Nlc3NTeXN0ZW1FcnJvcic7XHJcbiAgICB0aGlzLmVycm5vID0gZXJyLmVycm5vO1xyXG4gICAgdGhpcy5jb2RlID0gZXJyLmNvZGU7XHJcbiAgICB0aGlzLnBhdGggPSBlcnIucGF0aDtcclxuICAgIHRoaXMuc3lzY2FsbCA9IGVyci5zeXNjYWxsO1xyXG4gICAgdGhpcy5wcm9jZXNzID0gcHJvYztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNYXhCdWZmZXJFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKHN0cmVhbU5hbWU6IHN0cmluZykge1xyXG4gICAgc3VwZXIoYCR7c3RyZWFtTmFtZX0gbWF4QnVmZmVyIGV4Y2VlZGVkYCk7XHJcbiAgICB0aGlzLm5hbWUgPSAnTWF4QnVmZmVyRXhjZWVkZWRFcnJvcic7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvY2Vzc1RpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3Rvcih0aW1lb3V0OiBudW1iZXIsIHByb2M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzKSB7XHJcbiAgICAvLyAkRmxvd0lzc3VlOiBUaGlzIGlzbid0IHR5cGVkIGluIHRoZSBGbG93IG5vZGUgdHlwZSBkZWZzXHJcbiAgICBjb25zdCB7c3Bhd25hcmdzfSA9IHByb2M7XHJcbiAgICBjb25zdCBjb21tYW5kTmFtZSA9XHJcbiAgICAgIHNwYXduYXJnc1swXSA9PT0gcHJvY2Vzcy5leGVjUGF0aCA/IHNwYXduYXJnc1sxXSA6IHNwYXduYXJnc1swXTtcclxuICAgIHN1cGVyKGBcIiR7Y29tbWFuZE5hbWV9XCIgdGltZWQgb3V0IGFmdGVyICR7dGltZW91dH1tc2ApO1xyXG4gICAgdGhpcy5uYW1lID0gJ1Byb2Nlc3NUaW1lb3V0RXJyb3InO1xyXG4gIH1cclxufVxyXG5cclxuLy9cclxuLy8gSW50ZXJuYWwgU3R1ZmZcclxuLy9cclxuLy8gUGF5IG5vIGF0dGVudGlvbiEgVGhpcyBpcyBqdXN0IHN0dWZmIHRoYXQncyB1c2VkIGludGVybmFsbHkgdG8gaW1wbGVtZW50IHRoZSBnb29kIHN0dWZmLlxyXG4vL1xyXG5cclxuLy8gTm9kZSBjcmFzaGVzIGlmIHdlIGFsbG93IGJ1ZmZlcnMgdGhhdCBhcmUgdG9vIGxhcmdlLlxyXG5jb25zdCBERUZBVUxUX01BWF9CVUZGRVIgPSAxMDAgKiAxMDI0ICogMTAyNDtcclxuXHJcbmNvbnN0IE1BWF9MT0dHRURfQ0FMTFMgPSAxMDA7XHJcbmNvbnN0IE5VTV9QUkVTRVJWRURfSElTVE9SWV9DQUxMUyA9IDUwO1xyXG5cclxuY29uc3Qgbm9vcERpc3Bvc2FibGUgPSB7ZGlzcG9zZTogKCkgPT4ge319O1xyXG5jb25zdCB3aGVuU2hlbGxFbnZpcm9ubWVudExvYWRlZCA9XHJcbiAgdHlwZW9mIGF0b20gIT09ICd1bmRlZmluZWQnICYmICFhdG9tLmluU3BlY01vZGUoKVxyXG4gICAgPyBhdG9tLndoZW5TaGVsbEVudmlyb25tZW50TG9hZGVkLmJpbmQoYXRvbSlcclxuICAgIDogY2IgPT4ge1xyXG4gICAgICAgIGNiKCk7XHJcbiAgICAgICAgcmV0dXJuIG5vb3BEaXNwb3NhYmxlO1xyXG4gICAgICB9O1xyXG5cclxuLyoqXHJcbiAqIExvZyBjdXN0b20gZXZlbnRzIHRvIGxvZzRqcyBzbyB0aGF0IHdlIGNhbiBlYXNpbHkgaG9vayBpbnRvIHByb2Nlc3MgZXZlbnRzXHJcbiAqIHVzaW5nIGEgY3VzdG9tIGxvZzRqcyBhcHBlbmRlciAoZS5nLiBmb3IgYW5hbHl0aWNzIHB1cnBvc2VzKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9jZXNzTG9nZ2luZ0V2ZW50IHtcclxuICBjb21tYW5kOiBzdHJpbmc7XHJcbiAgZHVyYXRpb246IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoY29tbWFuZDogc3RyaW5nLCBkdXJhdGlvbjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLmNvbW1hbmQgPSBjb21tYW5kO1xyXG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgLy8gbG9nNGpzIHVzZXMgdXRpbC5pbnNwZWN0IHRvIGNvbnZlcnQgbG9nIGFyZ3VtZW50cyB0byBzdHJpbmdzLlxyXG4gICAgLy8gTm90ZTogY29tcHV0ZWQgcHJvcGVydHkgbWV0aG9kcyBhcmVuJ3Qgc3VwcG9ydGVkIGJ5IEZsb3cgeWV0LlxyXG4gICAgKHRoaXM6IGFueSlbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSAoKSA9PiB7XHJcbiAgICAgIHJldHVybiBgJHt0aGlzLmR1cmF0aW9ufW1zOiAke3RoaXMuY29tbWFuZH1gO1xyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBsb2dnZWRDYWxscyA9IFtdO1xyXG5mdW5jdGlvbiBsb2dDYWxsKGR1cmF0aW9uOiBudW1iZXIsIGNvbW1hbmQ6IHN0cmluZywgYXJnczogQXJyYXk8c3RyaW5nPikge1xyXG4gIC8vIFRyaW0gdGhlIGhpc3Rvcnkgb25jZSBpbiBhIHdoaWxlLCB0byBhdm9pZCBkb2luZyBleHBlbnNpdmUgYXJyYXlcclxuICAvLyBtYW5pcHVsYXRpb24gYWxsIHRoZSB0aW1lIGFmdGVyIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaGlzdG9yeVxyXG4gIGlmIChsb2dnZWRDYWxscy5sZW5ndGggPiBNQVhfTE9HR0VEX0NBTExTKSB7XHJcbiAgICBsb2dnZWRDYWxscy5zcGxpY2UoMCwgbG9nZ2VkQ2FsbHMubGVuZ3RoIC0gTlVNX1BSRVNFUlZFRF9ISVNUT1JZX0NBTExTLCB7XHJcbiAgICAgIGNvbW1hbmQ6ICcuLi4gaGlzdG9yeSBzdHJpcHBlZCAuLi4nLFxyXG4gICAgICBkdXJhdGlvbjogMCxcclxuICAgICAgdGltZTogbmV3IERhdGUoKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZnVsbENvbW1hbmQgPSBzaGVsbFF1b3RlKFtjb21tYW5kLCAuLi5hcmdzXSk7XHJcbiAgbG9nZ2VkQ2FsbHMucHVzaCh7XHJcbiAgICBjb21tYW5kOiBmdWxsQ29tbWFuZCxcclxuICAgIGR1cmF0aW9uLFxyXG4gICAgdGltZTogbmV3IERhdGUoKSxcclxuICB9KTtcclxuICBsb2dnZXIuaW5mbyhuZXcgUHJvY2Vzc0xvZ2dpbmdFdmVudChmdWxsQ29tbWFuZCwgZHVyYXRpb24pKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEF0dGVtcHQgdG8gZ2V0IHRoZSBmdWxseSBxdWFsaWZpZWQgYmluYXJ5IG5hbWUgZnJvbSBhIHByb2Nlc3MgaWQuIFRoaXMgaXNcclxuICogc3VycHJpc2luZ2x5IHRyaWNreS4gJ3BzJyBvbmx5IHJlcG9ydHMgdGhlIHBhdGggYXMgaW52b2tlZCwgYW5kIGluIHNvbWUgY2FzZXNcclxuICogbm90IGV2ZW4gdGhhdC5cclxuICpcclxuICogT24gTGludXgsIHRoZSAvcHJvYyBmaWxlc3lzdGVtIGNhbiBiZSB1c2VkIHRvIGZpbmQgaXQuXHJcbiAqIG1hY09TIGRvZXNuJ3QgaGF2ZSAvcHJvYywgc28gd2UgcmVseSBvbiB0aGUgZmFjdCB0aGF0IHRoZSBwcm9jZXNzIGhvbGRzXHJcbiAqIGFuIG9wZW4gRkQgdG8gdGhlIGV4ZWN1dGFibGUuIFRoaXMgY2FuIGZhaWwgZm9yIHZhcmlvdXMgcmVhc29ucyAobW9zdGx5XHJcbiAqIG5vdCBoYXZpbmcgcGVybWlzc2lvbnMgdG8gZXhlY3V0ZSBsc29mIG9uIHRoZSBwaWQuKVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFic29sdXRlQmluYXJ5UGF0aEZvclBpZChcclxuICBwaWQ6IG51bWJlcixcclxuKTogUHJvbWlzZTw/c3RyaW5nPiB7XHJcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcclxuICAgIHJldHVybiBfZ2V0TGludXhCaW5hcnlQYXRoRm9yUGlkKHBpZCk7XHJcbiAgfVxyXG5cclxuICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicpIHtcclxuICAgIHJldHVybiBfZ2V0RGFyd2luQmluYXJ5UGF0aEZvclBpZChwaWQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIF9nZXRMaW51eEJpbmFyeVBhdGhGb3JQaWQocGlkOiBudW1iZXIpOiBQcm9taXNlPD9zdHJpbmc+IHtcclxuICBjb25zdCBleGVMaW5rID0gYC9wcm9jLyR7cGlkfS9leGVgO1xyXG4gIC8vIC9wcm9jL3h4eC9leGUgaXMgYSBzeW1saW5rIHRvIHRoZSByZWFsIGJpbmFyeSBpbiB0aGUgZmlsZSBzeXN0ZW0uXHJcbiAgcmV0dXJuIHJ1bkNvbW1hbmQoJy9iaW4vcmVhbHBhdGgnLCBbJy1xJywgJy1lJywgZXhlTGlua10pXHJcbiAgICAuY2F0Y2goXyA9PlxyXG4gICAgICBydW5Db21tYW5kKCcvYmluL3N1ZG8nLCBbXHJcbiAgICAgICAgJy1uJyxcclxuICAgICAgICAnLS0nLFxyXG4gICAgICAgICcvYmluL3JlYWxwYXRoJyxcclxuICAgICAgICAnLXEnLFxyXG4gICAgICAgICctZScsXHJcbiAgICAgICAgZXhlTGluayxcclxuICAgICAgXSksXHJcbiAgICApXHJcbiAgICAuY2F0Y2goXyA9PiBPYnNlcnZhYmxlLm9mKG51bGwpKVxyXG4gICAgLnRvUHJvbWlzZSgpO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBfZ2V0RGFyd2luQmluYXJ5UGF0aEZvclBpZChwaWQ6IG51bWJlcik6IFByb21pc2U8P3N0cmluZz4ge1xyXG4gIHJldHVybiBydW5Db21tYW5kKCcvdXNyL3NiaW4vbHNvZicsIFsnLXAnLCBgJHtwaWR9YF0pXHJcbiAgICAuY2F0Y2goXyA9PiB7XHJcbiAgICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKG51bGwpO1xyXG4gICAgfSlcclxuICAgIC5tYXAoXHJcbiAgICAgIHN0ZG91dCA9PlxyXG4gICAgICAgIHN0ZG91dCA9PSBudWxsXHJcbiAgICAgICAgICA/IG51bGxcclxuICAgICAgICAgIDogc3Rkb3V0XHJcbiAgICAgICAgICAgICAgLnNwbGl0KCdcXG4nKVxyXG4gICAgICAgICAgICAgIC5tYXAobGluZSA9PiBsaW5lLnRyaW0oKS5zcGxpdCgvXFxzKy8pKVxyXG4gICAgICAgICAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lWzNdID09PSAndHh0JylcclxuICAgICAgICAgICAgICAubWFwKGxpbmUgPT4gbGluZVs4XSlbMF0sXHJcbiAgICApXHJcbiAgICAudGFrZSgxKVxyXG4gICAgLnRvUHJvbWlzZSgpO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAxLiBJdCBjb250YWlucyBhIHByb2Nlc3MgdGhhdCdzIGNyZWF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIGZhY3Rvcnkgd2hlbiB5b3Ugc3Vic2NyaWJlLlxyXG4gKiAyLiBJdCBkb2Vzbid0IGNvbXBsZXRlIHVudGlsIHRoZSBwcm9jZXNzIGV4aXRzIChvciBlcnJvcnMpLlxyXG4gKiAzLiBUaGUgcHJvY2VzcyBpcyBraWxsZWQgd2hlbiB5b3UgdW5zdWJzY3JpYmUuXHJcbiAqXHJcbiAqIFRoaXMgbWVhbnMgdGhhdCBhIHNpbmdsZSBvYnNlcnZhYmxlIGluc3RhbmNlIGNhbiBiZSB1c2VkIHRvIHNwYXduIG11bHRpcGxlIHByb2Nlc3Nlcy4gSW5kZWVkLCBpZlxyXG4gKiB5b3Ugc3Vic2NyaWJlIG11bHRpcGxlIHRpbWVzLCBtdWx0aXBsZSBwcm9jZXNzZXMgKndpbGwqIGJlIHNwYXduZWQuXHJcbiAqXHJcbiAqIElNUE9SVEFOVDogVGhlIGV4aXQgZXZlbnQgZG9lcyBOT1QgbWVhbiB0aGF0IGFsbCBzdGRvdXQgYW5kIHN0ZGVyciBldmVudHMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUHJvY2Vzc1N0cmVhbShcclxuICB0eXBlOiAnc3Bhd24nIHwgJ2ZvcmsnID0gJ3NwYXduJyxcclxuICBjb21tYW5kT3JNb2R1bGVQYXRoOiBzdHJpbmcsXHJcbiAgYXJncz86IEFycmF5PHN0cmluZz4gPSBbXSxcclxuICBvcHRpb25zPzogQ3JlYXRlUHJvY2Vzc1N0cmVhbU9wdGlvbnMgPSB7fSxcclxuKTogT2JzZXJ2YWJsZTxjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcz4ge1xyXG4gIGNvbnN0IGlucHV0T3B0aW9uID0gb3B0aW9ucy5pbnB1dDtcclxuICBsZXQgaW5wdXQ7XHJcbiAgaWYgKGlucHV0T3B0aW9uICE9IG51bGwpIHtcclxuICAgIGlucHV0ID1cclxuICAgICAgdHlwZW9mIGlucHV0T3B0aW9uID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gT2JzZXJ2YWJsZS5vZihpbnB1dE9wdGlvbilcclxuICAgICAgICA6IGlucHV0T3B0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9ic2VydmFibGVGcm9tU3Vic2NyaWJlRnVuY3Rpb24od2hlblNoZWxsRW52aXJvbm1lbnRMb2FkZWQpXHJcbiAgICAudGFrZSgxKVxyXG4gICAgLnN3aXRjaE1hcCgoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBkb250TG9nSW5OdWNsaWRlLFxyXG4gICAgICAgIGtpbGxUcmVlV2hlbkRvbmUsXHJcbiAgICAgICAga2lsbFRyZWVTaWduYWwsXHJcbiAgICAgICAgdGltZW91dCxcclxuICAgICAgfSA9IG9wdGlvbnM7XHJcbiAgICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSBza2V0Y2h5LW51bGwtbnVtYmVyOm9mZlxyXG4gICAgICBjb25zdCBlbmZvcmNlVGltZW91dCA9IHRpbWVvdXRcclxuICAgICAgICA/IHggPT5cclxuICAgICAgICAgICAgeC50aW1lb3V0V2l0aChcclxuICAgICAgICAgICAgICB0aW1lb3V0LFxyXG4gICAgICAgICAgICAgIE9ic2VydmFibGUudGhyb3cobmV3IFByb2Nlc3NUaW1lb3V0RXJyb3IodGltZW91dCwgcHJvYykpLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgOiB4ID0+IHg7XHJcbiAgICAgIGNvbnN0IHByb2MgPSBjaGlsZF9wcm9jZXNzW3R5cGVdKFxyXG4gICAgICAgIG51Y2xpZGVVcmkuZXhwYW5kSG9tZURpcihjb21tYW5kT3JNb2R1bGVQYXRoKSxcclxuICAgICAgICBhcmdzLFxyXG4gICAgICAgIC8vICRGbG93Rml4TWU6IGNoaWxkX3Byb2Nlc3Mkc3Bhd25PcHRzIGFuZCBjaGlsZF9wcm9jZXNzJGZvcmtPcHRzIGhhdmUgaW5jb21wYXRpYmxlIHN0ZGlvIHR5cGVzLlxyXG4gICAgICAgIHsuLi5vcHRpb25zfSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIC8vIERvbid0IGxldCBOb2RlIHRocm93IHN0cmVhbSBlcnJvcnMgYW5kIGNyYXNoIHRoZSBwcm9jZXNzLiBOb3RlIHRoYXQgd2UgbmV2ZXIgZGlzcG9zZSBvZlxyXG4gICAgICAvLyB0aGlzIGJlY2F1c2Ugc3RyZWFtIGVycm9ycyBjYW4gc3RpbGwgb2NjdXIgYWZ0ZXIgdGhlIHVzZXIgdW5zdWJzY3JpYmVzIGZyb20gb3VyIHByb2Nlc3NcclxuICAgICAgLy8gb2JzZXJ2YWJsZS4gVGhhdCdzIG9rYXk7IHdoZW4gdGhlIHN0cmVhbXMgY2xvc2UsIHRoZSBsaXN0ZW5lcnMgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICBwcmV2ZW50U3RyZWFtc0Zyb21UaHJvd2luZyhwcm9jKTtcclxuXHJcbiAgICAgIC8vIElmIHdlIHdlcmUgdG8gY29ubmVjdCB0aGUgZXJyb3IgaGFuZGxlciBhcyBwYXJ0IG9mIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlLCB1bnN1YnNjcmliaW5nXHJcbiAgICAgIC8vIHdvdWxkIGNhdXNlIGl0IHRvIGJlIHJlbW92ZWQuIFRoYXQgd291bGQgbGVhdmUgbm8gYXR0YWNoZWQgZXJyb3IgaGFuZGxlciwgc28gbm9kZSB3b3VsZFxyXG4gICAgICAvLyB0aHJvdywgdHJpZ2dlcmluZyBBdG9tJ3MgdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXIuXHJcbiAgICAgIGNvbnN0IGVycm9ycyA9IE9ic2VydmFibGUuZnJvbUV2ZW50KHByb2MsICdlcnJvcicpXHJcbiAgICAgICAgLmZsYXRNYXAoT2JzZXJ2YWJsZS50aHJvdylcclxuICAgICAgICAucHVibGlzaCgpO1xyXG4gICAgICBlcnJvcnMuY29ubmVjdCgpO1xyXG5cclxuICAgICAgY29uc3QgZXhpdEV2ZW50cyA9IE9ic2VydmFibGUuZnJvbUV2ZW50KFxyXG4gICAgICAgIHByb2MsXHJcbiAgICAgICAgJ2V4aXQnLFxyXG4gICAgICAgIChleGl0Q29kZTogP251bWJlciwgc2lnbmFsOiA/c3RyaW5nKSA9PiAoe1xyXG4gICAgICAgICAga2luZDogJ2V4aXQnLFxyXG4gICAgICAgICAgZXhpdENvZGUsXHJcbiAgICAgICAgICBzaWduYWwsXHJcbiAgICAgICAgfSksXHJcbiAgICAgIClcclxuICAgICAgICAuZmlsdGVyKGlzUmVhbEV4aXQpXHJcbiAgICAgICAgLnRha2UoMSk7XHJcblxyXG4gICAgICBpZiAoZG9udExvZ0luTnVjbGlkZSAhPT0gdHJ1ZSAmJiBOVUNMSURFX0RPX05PVF9MT0cgIT09IHRydWUpIHtcclxuICAgICAgICAvLyBMb2cgdGhlIGNvbXBsZXRpb24gb2YgdGhlIHByb2Nlc3MuIE5vdGUgdGhhdCB3ZSBpbnRlbnRpb25hbGx5IGRvbid0IG1lcmdlIHRoaXMgd2l0aCB0aGVcclxuICAgICAgICAvLyByZXR1cm5lZCBvYnNlcnZhYmxlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byBjYW5jZWwgdGhlIHNpZGUtZWZmZWN0IHdoZW4gdGhlIHVzZXJcclxuICAgICAgICAvLyB1bnN1YnNjcmliZXMgb3Igd2hlbiB0aGUgcHJvY2VzcyBleGl0cyAoXCJjbG9zZVwiIGV2ZW50cyBjb21lIGFmdGVyIFwiZXhpdFwiIGV2ZW50cykuXHJcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcclxuICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudChwcm9jLCAnY2xvc2UnKVxyXG4gICAgICAgICAgLmRvKCgpID0+IHtcclxuICAgICAgICAgICAgbG9nQ2FsbChcclxuICAgICAgICAgICAgICBNYXRoLnJvdW5kKHBlcmZvcm1hbmNlTm93KCkgLSBub3cpLFxyXG4gICAgICAgICAgICAgIGNvbW1hbmRPck1vZHVsZVBhdGgsXHJcbiAgICAgICAgICAgICAgYXJncyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuc3Vic2NyaWJlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gZW5mb3JjZVRpbWVvdXQoXHJcbiAgICAgICAgT2JzZXJ2YWJsZS51c2luZyhcclxuICAgICAgICAgIC8vIExvZyBzdHJlYW0gZXJyb3JzLCBidXQgb25seSBmb3IgYXMgbG9uZyBhcyB5b3UncmUgc3Vic2NyaWJlZCB0byB0aGUgcHJvY2VzcyBvYnNlcnZhYmxlLlxyXG4gICAgICAgICAgKCkgPT4gbG9nU3RyZWFtRXJyb3JzKHByb2MsIGNvbW1hbmRPck1vZHVsZVBhdGgsIGFyZ3MsIG9wdGlvbnMpLFxyXG4gICAgICAgICAgKCkgPT5cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgICAgICAgICAgICAvLyBOb2RlIFtkZWxheXMgdGhlIGVtaXNzaW9uIG9mIHByb2Nlc3MgZXJyb3JzXVsxXSBieSBhIHRpY2sgaW4gb3JkZXIgdG8gZ2l2ZVxyXG4gICAgICAgICAgICAgIC8vIGNvbnN1bWVycyBhIGNoYW5jZSB0byBzdWJzY3JpYmUgdG8gdGhlIGVycm9yIGV2ZW50LiBUaGlzIG1lYW5zIHRoYXQgb3VyIG9ic2VydmFibGVcclxuICAgICAgICAgICAgICAvLyB3b3VsZCBub3JtYWxseSBlbWl0IHRoZSBwcm9jZXNzIGFuZCB0aGVuLCBhIHRpY2sgbGF0ZXIsIGVycm9yLiBIb3dldmVyLCBpdCdzIG1vcmVcclxuICAgICAgICAgICAgICAvLyBjb252ZW5pZW50IHRvIG5ldmVyIGVtaXQgdGhlIHByb2Nlc3MgaWYgdGhlcmUgd2FzIGFuIGVycm9yLiBBbHRob3VnaCBvYnNlcnZhYmxlc1xyXG4gICAgICAgICAgICAgIC8vIGRvbid0IHJlcXVpcmUgdGhlIGVycm9yIHRvIGJlIGRlbGF5ZWQgYXQgYWxsLCB0aGUgdW5kZXJseWluZyBldmVudCBlbWl0dGVyXHJcbiAgICAgICAgICAgICAgLy8gYWJzdHJhY3Rpb24gZG9lcywgc28gd2UnbGwganVzdCByb2xsIHdpdGggdGhhdCBhbmQgdXNlIGBwaWQgPT0gbnVsbGAgYXMgYSBzaWduYWxcclxuICAgICAgICAgICAgICAvLyB0aGF0IGFuIGVycm9yIGlzIGZvcnRoY29taW5nLlxyXG4gICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgLy8gWzFdOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92Ny4xMC4wL2xpYi9pbnRlcm5hbC9jaGlsZF9wcm9jZXNzLmpzI0wzMDFcclxuICAgICAgICAgICAgICBwcm9jLnBpZCA9PSBudWxsID8gT2JzZXJ2YWJsZS5lbXB0eSgpIDogT2JzZXJ2YWJsZS5vZihwcm9jKSxcclxuICAgICAgICAgICAgICBPYnNlcnZhYmxlLm5ldmVyKCksIC8vIERvbid0IGNvbXBsZXRlIHVudGlsIHdlIHNheSBzbyFcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICApXHJcbiAgICAgICAgICAubWVyZ2UoXHJcbiAgICAgICAgICAgIC8vIFdyaXRlIGFueSBpbnB1dCB0byBzdGRpbi4gVGhpcyBpcyBqdXN0IGZvciB0aGUgc2lkZS1lZmZlY3QuIFdlIG1lcmdlIGl0IGhlcmUgdG9cclxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgd3JpdGluZyB0byB0aGUgc3RkaW4gc3RyZWFtIGhhcHBlbnMgYWZ0ZXIgb3VyIGV2ZW50IGxpc3RlbmVycyBhcmUgYWRkZWQuXHJcbiAgICAgICAgICAgIGlucHV0ID09IG51bGxcclxuICAgICAgICAgICAgICA/IE9ic2VydmFibGUuZW1wdHkoKVxyXG4gICAgICAgICAgICAgIDogaW5wdXRcclxuICAgICAgICAgICAgICAgICAgLmRvKHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0OiBzdHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgcHJvYy5zdGRpbi53cml0ZShzdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgIHByb2Muc3RkaW4uZW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgLmlnbm9yZUVsZW1lbnRzKCksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICAudGFrZVVudGlsKGVycm9ycylcclxuICAgICAgICAgIC50YWtlVW50aWwoZXhpdEV2ZW50cylcclxuICAgICAgICAgIC5kbyh7XHJcbiAgICAgICAgICAgIGVycm9yOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgIH0pLFxyXG4gICAgICApXHJcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAvLyBTaW5jZSB0aGlzIHV0aWxpdHkgZXJyb3JzICpiZWZvcmUqIGVtaXR0aW5nIHRoZSBwcm9jZXNzLCBhZGQgdGhlIHByb2Nlc3MgdG8gdGhlIGVycm9yXHJcbiAgICAgICAgICAvLyBzbyB0aGF0IHVzZXJzIGNhbiBnZXQgd2hhdGV2ZXIgaW5mbyB0aGV5IG5lZWQgb2ZmIG9mIGl0LlxyXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5uYW1lID09PSAnRXJyb3InICYmICdlcnJubycgaW4gZXJyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBQcm9jZXNzU3lzdGVtRXJyb3IoZXJyLCBwcm9jKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGVycjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgIC8vICRGbG93Rml4TWUoPj0wLjY4LjApIEZsb3cgc3VwcHJlc3MgKFQyNzE4Nzg1NylcclxuICAgICAgICAgIGlmICghcHJvYy53YXNLaWxsZWQgJiYgIWZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgIGtpbGxQcm9jZXNzKHByb2MsIEJvb2xlYW4oa2lsbFRyZWVXaGVuRG9uZSksIGtpbGxUcmVlU2lnbmFsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1JlYWxFeGl0KGV2ZW50OiB7ZXhpdENvZGU6ID9udW1iZXIsIHNpZ25hbDogP3N0cmluZ30pOiBib29sZWFuIHtcclxuICAvLyBBbiBleGl0IHNpZ25hbCBmcm9tIFNJR1VTUjEgZG9lc24ndCBhY3R1YWxseSBleGl0IHRoZSBwcm9jZXNzLCBzbyBza2lwIHRoYXQuXHJcbiAgcmV0dXJuIGV2ZW50LnNpZ25hbCAhPT0gJ1NJR1VTUjEnO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBfa2lsbFByb2Nlc3MoXHJcbiAgcHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MgJiB7d2FzS2lsbGVkPzogYm9vbGVhbn0sXHJcbiAga2lsbFRyZWU6IGJvb2xlYW4sXHJcbiAga2lsbFRyZWVTaWduYWw6ID9zdHJpbmcsXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHByb2Mud2FzS2lsbGVkID0gdHJ1ZTtcclxuICBpZiAoIWtpbGxUcmVlKSB7XHJcbiAgICBpZiAoa2lsbFRyZWVTaWduYWwgIT0gbnVsbCAmJiBraWxsVHJlZVNpZ25hbCAhPT0gJycpIHtcclxuICAgICAgcHJvYy5raWxsKGtpbGxUcmVlU2lnbmFsKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb2Mua2lsbCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICBpZiAoL153aW4vLnRlc3QocHJvY2Vzcy5wbGF0Zm9ybSkpIHtcclxuICAgIGF3YWl0IGtpbGxXaW5kb3dzUHJvY2Vzc1RyZWUocHJvYy5waWQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBhd2FpdCBraWxsVW5peFByb2Nlc3NUcmVlKHByb2MpO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24ga2lsbFdpbmRvd3NQcm9jZXNzVHJlZShwaWQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjaGlsZF9wcm9jZXNzLmV4ZWMoYHRhc2traWxsIC9waWQgJHtwaWR9IC9UIC9GYCwgZXJyb3IgPT4ge1xyXG4gICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xyXG4gICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGtpbGxVbml4UHJvY2Vzc1RyZWUoXHJcbiAgcHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGNvbnN0IGRlc2NlbmRhbnRzID0gYXdhaXQgZ2V0RGVzY2VuZGFudHNPZlByb2Nlc3MocHJvYy5waWQpO1xyXG4gIC8vIEtpbGwgdGhlIHByb2Nlc3Nlcywgc3RhcnRpbmcgd2l0aCB0aG9zZSBvZiBncmVhdGVzdCBkZXB0aC5cclxuICBmb3IgKGNvbnN0IGluZm8gb2YgZGVzY2VuZGFudHMucmV2ZXJzZSgpKSB7XHJcbiAgICBraWxsUGlkKGluZm8ucGlkKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzRXhpdEVycm9yRGVmYXVsdChleGl0OiBQcm9jZXNzRXhpdE1lc3NhZ2UpOiBib29sZWFuIHtcclxuICByZXR1cm4gZXhpdC5leGl0Q29kZSAhPT0gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNXaW5kb3dzUGxhdGZvcm0oKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIC9ed2luLy50ZXN0KHByb2Nlc3MucGxhdGZvcm0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsaW1pdEJ1ZmZlclNpemUoXHJcbiAgc3RyZWFtOiBPYnNlcnZhYmxlPHN0cmluZz4sXHJcbiAgbWF4QnVmZmVyOiA/bnVtYmVyLFxyXG4gIHN0cmVhbU5hbWU6IHN0cmluZyxcclxuKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcclxuICBpZiAobWF4QnVmZmVyID09IG51bGwpIHtcclxuICAgIHJldHVybiBzdHJlYW07XHJcbiAgfVxyXG4gIHJldHVybiBPYnNlcnZhYmxlLmRlZmVyKCgpID0+IHtcclxuICAgIGxldCB0b3RhbFNpemUgPSAwO1xyXG4gICAgcmV0dXJuIHN0cmVhbS5kbyhkYXRhID0+IHtcclxuICAgICAgdG90YWxTaXplICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICBpZiAodG90YWxTaXplID4gbWF4QnVmZmVyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IE1heEJ1ZmZlckV4Y2VlZGVkRXJyb3Ioc3RyZWFtTmFtZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IGFuIG9ic2VydmFibGUgb2YgZXJyb3IgZXZlbnRzIGZvciBhIHByb2Nlc3MncyBzdHJlYW1zLiBOb3RlIHRoYXQgdGhlc2UgYXJlIHJlcHJlc2VudGVkIGFzXHJcbiAqIG5vcm1hbCBlbGVtZW50cywgbm90IG9ic2VydmFibGUgZXJyb3JzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3RyZWFtRXJyb3JFdmVudHMoXHJcbiAgcHJvYzogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXHJcbik6IE9ic2VydmFibGU8W0Vycm9yLCBzdHJpbmddPiB7XHJcbiAgY29uc3Qgc3RyZWFtcyA9IFtcclxuICAgIFsnc3RkaW4nLCBwcm9jLnN0ZGluXSxcclxuICAgIFsnc3Rkb3V0JywgcHJvYy5zdGRvdXRdLFxyXG4gICAgWydzdGRlcnInLCBwcm9jLnN0ZGVycl0sXHJcbiAgXTtcclxuICByZXR1cm4gT2JzZXJ2YWJsZS5tZXJnZShcclxuICAgIC4uLnN0cmVhbXMubWFwKFxyXG4gICAgICAoW25hbWUsIHN0cmVhbV0pID0+XHJcbiAgICAgICAgc3RyZWFtID09IG51bGxcclxuICAgICAgICAgID8gT2JzZXJ2YWJsZS5lbXB0eSgpXHJcbiAgICAgICAgICA6IE9ic2VydmFibGUuZnJvbUV2ZW50KHN0cmVhbSwgJ2Vycm9yJykubWFwKGVyciA9PiBbZXJyLCBuYW1lXSksXHJcbiAgICApLFxyXG4gICk7XHJcbn1cclxuIl19