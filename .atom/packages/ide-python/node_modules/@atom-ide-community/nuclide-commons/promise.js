"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sleep = sleep;
exports.nextTick = nextTick;
exports.triggerAfterWait = triggerAfterWait;
exports.timeoutPromise = timeoutPromise;
exports.createDeadline = createDeadline;
exports.timeoutAfterDeadline = timeoutAfterDeadline;
exports.retryLimit = retryLimit;
exports.serializeAsyncCall = serializeAsyncCall;
exports.asyncFind = asyncFind;
exports.denodeify = denodeify;
exports.asyncLimit = asyncLimit;
exports.asyncFilter = asyncFilter;
exports.asyncObjFilter = asyncObjFilter;
exports.asyncSome = asyncSome;
exports.isPromise = isPromise;
exports.lastly = lastly;
exports.delayTime = delayTime;
exports.PromiseWithState = exports.Deferred = exports.TimedOutError = exports.RequestSerializer = void 0;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Allows a caller to ensure that the results it receives from consecutive
 * promise resolutions are never outdated. Usage:
 *
 * var requestSerializer = new RequestSerializer();
 *
 * // in some later loop:
 *
 * // note that you do not await the async function here -- you must pass the
 * // promise it returns to `run`
 * var result = await requestSerializer.run(someAsyncFunction())
 *
 * if (result.status === 'success') {
 *   ....
 *   result.result
 * } else if (result.status === 'outdated') {
 *   ....
 * }
 *
 * The contract is that the status is 'success' if and only if this was the most
 * recently dispatched call of 'run'. For example, if you call run(promise1) and
 * then run(promise2), and promise2 resolves first, the second callsite would
 * receive a 'success' status. If promise1 later resolved, the first callsite
 * would receive an 'outdated' status.
 */
class RequestSerializer {
  constructor() {
    this._lastDispatchedOp = void 0;
    this._lastFinishedOp = void 0;
    this._latestPromise = void 0;
    this._waitResolve = void 0;
    this._lastDispatchedOp = 0;
    this._lastFinishedOp = 0;
    this._latestPromise = new Promise((resolve, reject) => {
      this._waitResolve = resolve;
    });
  }

  async run(promise) {
    const thisOp = this._lastDispatchedOp + 1;
    this._lastDispatchedOp = thisOp;
    this._latestPromise = promise;

    this._waitResolve();

    const result = await promise;

    if (this._lastFinishedOp < thisOp) {
      this._lastFinishedOp = thisOp;
      return {
        status: 'success',
        result
      };
    } else {
      return {
        status: 'outdated'
      };
    }
  }
  /**
   * Returns a Promise that resolves to the last result of `run`,
   * as soon as there are no more outstanding `run` calls.
   */


  async waitForLatestResult() {
    let lastPromise = null;
    let result = null;

    while (lastPromise !== this._latestPromise) {
      lastPromise = this._latestPromise; // Wait for the current last know promise to resolve, or a next run have started.
      // eslint-disable-next-line no-await-in-loop

      result = await new Promise((resolve, reject) => {
        this._waitResolve = resolve;

        this._latestPromise.then(resolve);
      });
    }

    return result;
  }

  isRunInProgress() {
    return this._lastDispatchedOp > this._lastFinishedOp;
  }

}
/*
 * Returns a promise that will resolve after `milliSeconds` milli seconds.
 * this can be used to pause execution asynchronously.
 * e.g. await sleep(1000), pauses the async flow execution for 1 second.
 */


exports.RequestSerializer = RequestSerializer;

function sleep(milliSeconds) {
  return new Promise(resolve => {
    setTimeout(resolve, milliSeconds);
  });
}

function nextTick() {
  return new Promise(resolve => {
    process.nextTick(resolve);
  });
}
/**
 * Executes a provided callback only if a promise takes longer than
 * `milliSeconds` milliseconds to resolve.
 *
 * @param `promise` the promise to wait on.
 * @param `milliSeconds` max amount of time that `promise` can take to resolve
 * before timeoutFn is fired.
 * @param `timeoutFn` the function to execute when a promise takes longer than
 * `milliSeconds` ms to resolve.
 * @param `cleanupFn` the cleanup function to execute after the promise resolves.
 */


async function triggerAfterWait(promise, milliSeconds, timeoutFn, cleanupFn) {
  const timeout = setTimeout(timeoutFn, milliSeconds);

  try {
    return await promise;
  } finally {
    clearTimeout(timeout);

    if (cleanupFn) {
      cleanupFn();
    }
  }
}
/**
 * Thrown by `timeoutPromise` if the timer fires before the promise resolves/rejects.
 */


class TimedOutError extends Error {
  constructor(milliseconds) {
    super(`Timed out after ${String(milliseconds)} ms`);
    this.timeout = void 0;
    this.timeout = milliseconds;
  }

}
/**
 * Returns a Promise that resolves to the same value as the given promise, or rejects with
 * `TimedOutError` if it takes longer than `milliseconds` milliseconds.
 */


exports.TimedOutError = TimedOutError;

function timeoutPromise(promise, milliseconds) {
  return new Promise((resolve, reject) => {
    let timeout = setTimeout(() => {
      timeout = null;
      reject(new TimedOutError(milliseconds)); // This gives useless error.stack results.
      // We could capture the stack pre-emptively at the start
      // of this method if we wanted useful ones.
    }, milliseconds);
    promise.then(value => {
      if (timeout != null) {
        clearTimeout(timeout);
      }

      resolve(value);
    }).catch(value => {
      if (timeout != null) {
        clearTimeout(timeout);
      }

      reject(value);
    });
  });
} // An DeadlineRequest parameter to an async method is a way of *requesting* that
// method to throw a TimedOutError if it doesn't complete in a certain time.
// It's just a request -- the async method will typically honor the request
// by passing the parameter on to ALL subsidiary async methods that it awaits,
// or by calling expirePromise to enforce a timeout, or similar.
//
// In cases where a method supports DeadlineRequest but you don't trust it, do
// `await timeoutAfterDeadline(deadline, untrusted.foo(deadline-1000))` so you
// ask it nicely but if it doesn't give its own more-specific deadline message
// within a 1000ms grace period then you force matters.
//
// Under the hood an DeadlineRequest is just a timestamp of the time by which
// the operation should complete. This makes it compositional (better than
// "delay" parameters) and safely remotable (better than "CancellationToken"
// parameters) so long as clocks are in sync. In all other respects it's less
// versatile than CancellationTokens.


function createDeadline(delay) {
  return Date.now() + delay;
}

function timeoutAfterDeadline(deadline, promise) {
  const delay = deadline - Date.now();
  return timeoutPromise(promise, delay < 0 ? 0 : delay);
}
/**
 * Call an async function repeatedly with a maximum number of trials limit,
 * until a valid result that's defined by a validation function.
 * A failed call can result from an async thrown exception, or invalid result.
 *
 * @param `retryFunction` the async logic that's wanted to be retried.
 * @param `validationFunction` the validation function that decides whether a response is valid.
 * @param `maximumTries` the number of times the `retryFunction` can fail to get a valid
 * response before the `retryLimit` is terminated reporting an error.
 * @param `retryIntervalMs` optional, the number of milliseconds to wait between trials, if wanted.
 *
 * If an exception is encountered on the last trial, the exception is thrown.
 * If no valid response is found, an exception is thrown.
 */


async function retryLimit(retryFunction, validationFunction, maximumTries, retryIntervalMs = 0) {
  let result = null;
  let tries = 0;
  let lastError = null;

  while (tries === 0 || tries < maximumTries) {
    try {
      // eslint-disable-next-line no-await-in-loop
      result = await retryFunction();
      lastError = null;

      if (validationFunction(result)) {
        return result;
      }
    } catch (error) {
      lastError = error;
      result = null;
    }

    if (++tries < maximumTries && retryIntervalMs !== 0) {
      // eslint-disable-next-line no-await-in-loop
      await sleep(retryIntervalMs);
    }
  }

  if (lastError != null) {
    throw lastError;
  } else if (tries === maximumTries) {
    throw new Error('No valid response found!');
  } else {
    return result;
  }
}
/**
 * Limits async function execution parallelism to only one at a time.
 * Hence, if a call is already running, it will wait for it to finish,
 * then start the next async execution, but if called again while not finished,
 * it will return the scheduled execution promise.
 *
 * Sample Usage:
 * ```
 * let i = 1;
 * const oneExecAtATime = oneParallelAsyncCall(() => {
 *   return next Promise((resolve, reject) => {
 *     setTimeout(200, () => resolve(i++));
 *   });
 * });
 *
 * const result1Promise = oneExecAtATime(); // Start an async, and resolve to 1 in 200 ms.
 * const result2Promise = oneExecAtATime(); // Schedule the next async, and resolve to 2 in 400 ms.
 * const result3Promise = oneExecAtATime(); // Reuse scheduled promise and resolve to 2 in 400 ms.
 * ```
 */


function serializeAsyncCall(asyncFun) {
  let scheduledCall = null;
  let pendingCall = null;

  const startAsyncCall = () => {
    const resultPromise = asyncFun();
    pendingCall = resultPromise.then(() => pendingCall = null, () => pendingCall = null);
    return resultPromise;
  };

  const callNext = () => {
    scheduledCall = null;
    return startAsyncCall();
  };

  const scheduleNextCall = () => {
    if (scheduledCall == null) {
      (0, _assert.default)(pendingCall, 'pendingCall must not be null!');
      scheduledCall = pendingCall.then(callNext, callNext);
    }

    return scheduledCall;
  };

  return () => {
    if (pendingCall == null) {
      return startAsyncCall();
    } else {
      return scheduleNextCall();
    }
  };
}
/**
 * Provides a promise along with methods to change its state. Our version of the non-standard
 * `Promise.defer()`.
 *
 * IMPORTANT: This should almost never be used!! Instead, use the Promise constructor. See
 *  <https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern>
 */


class Deferred {
  constructor() {
    this.promise = void 0;
    this.resolve = void 0;
    this.reject = void 0;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }

}
/**
 * Returns a value derived asynchronously from an element in the items array.
 * The test function is applied sequentially to each element in items until
 * one returns a Promise that resolves to a non-null value. When this happens,
 * the Promise returned by this method will resolve to that non-null value. If
 * no such Promise is produced, then the Promise returned by this function
 * will resolve to null.
 *
 * @param items Array of elements that will be passed to test, one at a time.
 * @param test Will be called with each item and must return either:
 *     (1) A "thenable" (i.e, a Promise or promise-like object) that resolves
 *         to a derived value (that will be returned) or null.
 *     (2) null.
 *     In both cases where null is returned, test will be applied to the next
 *     item in the array.
 * @param thisArg Receiver that will be used when test is called.
 * @return Promise that resolves to an asynchronously derived value or null.
 */


exports.Deferred = Deferred;

function asyncFind(items_, test, thisArg) {
  let items = items_;
  return new Promise((resolve, reject) => {
    // Create a local copy of items to defend against the caller modifying the
    // array before this Promise is resolved.
    items = items.slice();
    const numItems = items.length;

    const next = async function (index) {
      if (index === numItems) {
        resolve(null);
        return;
      }

      const item = items[index];
      const result = await test.call(thisArg, item);

      if (result != null) {
        resolve(result);
      } else {
        next(index + 1);
      }
    };

    next(0);
  });
}

function denodeify(f) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      }

      f.apply(this, args.concat([callback]));
    });
  };
}
/**
 * A Promise utility that runs a maximum of limit async operations at a time
 * iterating over an array and returning the result of executions.
 * e.g. to limit the number of file reads to 5,
 * replace the code:
 *    var fileContents = await Promise.all(filePaths.map(fsPromise.readFile))
 * with:
 *    var fileContents = await asyncLimit(filePaths, 5, fsPromise.readFile)
 *
 * This is particulrily useful to limit IO operations to a configurable maximum (to avoid
 * blocking), while enjoying the configured level of parallelism.
 *
 * @param array the array of items for iteration.
 * @param limit the configurable number of parallel async operations.
 * @param mappingFunction the async Promise function that could return a useful result.
 */


function asyncLimit(array, limit, mappingFunction) {
  const result = new Array(array.length);
  let parallelPromises = 0;
  let index = 0;
  let parallelLimit = Math.min(limit, array.length) || 1;
  return new Promise((resolve, reject) => {
    const runPromise = async () => {
      if (index === array.length) {
        if (parallelPromises === 0) {
          resolve(result);
        }

        return;
      }

      ++parallelPromises;
      const i = index++;

      try {
        result[i] = await mappingFunction(array[i]);
      } catch (e) {
        reject(e);
      }

      --parallelPromises;
      runPromise();
    };

    while (parallelLimit--) {
      runPromise();
    }
  });
}
/**
 * `filter` Promise utility that allows filtering an array with an async Promise function.
 * It's an alternative to `Array.prototype.filter` that accepts an async function.
 * You can optionally configure a limit to set the maximum number of async operations at a time.
 *
 * Previously, with the `Promise.all` primitive, we can't set the parallelism limit and we have to
 * `filter`, so, we replace the old `filter` code:
 *     var existingFilePaths = [];
 *     await Promise.all(filePaths.map(async (filePath) => {
 *       if (await fsPromise.exists(filePath)) {
 *         existingFilePaths.push(filePath);
 *       }
 *     }));
 * with limit 5 parallel filesystem operations at a time:
 *    var existingFilePaths = await asyncFilter(filePaths, fsPromise.exists, 5);
 *
 * @param array the array of items for `filter`ing.
 * @param filterFunction the async `filter` function that returns a Promise that resolves to a
 *   boolean.
 * @param limit the configurable number of parallel async operations.
 */


async function asyncFilter(array, filterFunction, limit) {
  const filteredList = []; // flowlint-next-line sketchy-null-number:off

  await asyncLimit(array, limit || array.length, async item => {
    if (await filterFunction(item)) {
      filteredList.push(item);
    }
  });
  return filteredList;
}

async function asyncObjFilter(obj, filterFunction, limit) {
  const keys = Object.keys(obj);
  const filteredObj = {}; // flowlint-next-line sketchy-null-number:off

  await asyncLimit(keys, limit || keys.length, async key => {
    const item = obj[key];

    if (await filterFunction(item, key)) {
      filteredObj[key] = item;
    }
  });
  return filteredObj;
}
/**
 * `some` Promise utility that allows `some` an array with an async Promise some function.
 * It's an alternative to `Array.prototype.some` that accepts an async some function.
 * You can optionally configure a limit to set the maximum number of async operations at a time.
 *
 * Previously, with the Promise.all primitive, we can't set the parallelism limit and we have to
 * `some`, so, we replace the old `some` code:
 *     var someFileExist = false;
 *     await Promise.all(filePaths.map(async (filePath) => {
 *       if (await fsPromise.exists(filePath)) {
 *         someFileExist = true;
 *       }
 *     }));
 * with limit 5 parallel filesystem operations at a time:
 *    var someFileExist = await asyncSome(filePaths, fsPromise.exists, 5);
 *
 * @param array the array of items for `some`ing.
 * @param someFunction the async `some` function that returns a Promise that resolves to a
 *   boolean.
 * @param limit the configurable number of parallel async operations.
 */


async function asyncSome(array, someFunction, limit) {
  let resolved = false; // flowlint-next-line sketchy-null-number:off

  await asyncLimit(array, limit || array.length, async item => {
    if (resolved) {
      // We don't need to call the someFunction anymore or wait any longer.
      return;
    }

    if (await someFunction(item)) {
      resolved = true;
    }
  });
  return resolved;
}
/**
 * Check if an object is Promise by testing if it has a `then` function property.
 */


function isPromise(object) {
  return Boolean(object) && typeof object === 'object' && typeof object.then === 'function';
}
/**
 * We can't name a function 'finally', so use lastly instead.
 * fn() will be executed (and completed) after the provided promise resolves/rejects.
 */


function lastly(promise, fn) {
  return promise.then(ret => {
    return Promise.resolve(fn()).then(() => ret);
  }, err => {
    return Promise.resolve(fn()).then(() => Promise.reject(err));
  });
}
/**
 * With a pure promise object, there's no way to tell synchronously
 * whether or not it has 'settled' (i.e. been fulfilled or rejected).
 * Here we provide a wrapper that provides that information.
 */


class PromiseWithState {
  constructor(promise) {
    this._promise = void 0;
    this._state = void 0;
    this._state = {
      kind: 'pending'
    };
    this._promise = promise.then(value => {
      this._state = {
        kind: 'fulfilled',
        value
      };
      return value;
    }, error => {
      this._state = {
        kind: 'rejected',
        error
      };
      throw error;
    });
  }

  getPromise() {
    return this._promise;
  }

  getState() {
    return this._state;
  }

}

exports.PromiseWithState = PromiseWithState;

function delayTime(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms);
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3Byb21pc2UuanMiXSwibmFtZXMiOlsiUmVxdWVzdFNlcmlhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIl9sYXN0RGlzcGF0Y2hlZE9wIiwiX2xhc3RGaW5pc2hlZE9wIiwiX2xhdGVzdFByb21pc2UiLCJfd2FpdFJlc29sdmUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJ1biIsInByb21pc2UiLCJ0aGlzT3AiLCJyZXN1bHQiLCJzdGF0dXMiLCJ3YWl0Rm9yTGF0ZXN0UmVzdWx0IiwibGFzdFByb21pc2UiLCJ0aGVuIiwiaXNSdW5JblByb2dyZXNzIiwic2xlZXAiLCJtaWxsaVNlY29uZHMiLCJzZXRUaW1lb3V0IiwibmV4dFRpY2siLCJwcm9jZXNzIiwidHJpZ2dlckFmdGVyV2FpdCIsInRpbWVvdXRGbiIsImNsZWFudXBGbiIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJUaW1lZE91dEVycm9yIiwiRXJyb3IiLCJtaWxsaXNlY29uZHMiLCJTdHJpbmciLCJ0aW1lb3V0UHJvbWlzZSIsInZhbHVlIiwiY2F0Y2giLCJjcmVhdGVEZWFkbGluZSIsImRlbGF5IiwiRGF0ZSIsIm5vdyIsInRpbWVvdXRBZnRlckRlYWRsaW5lIiwiZGVhZGxpbmUiLCJyZXRyeUxpbWl0IiwicmV0cnlGdW5jdGlvbiIsInZhbGlkYXRpb25GdW5jdGlvbiIsIm1heGltdW1UcmllcyIsInJldHJ5SW50ZXJ2YWxNcyIsInRyaWVzIiwibGFzdEVycm9yIiwiZXJyb3IiLCJzZXJpYWxpemVBc3luY0NhbGwiLCJhc3luY0Z1biIsInNjaGVkdWxlZENhbGwiLCJwZW5kaW5nQ2FsbCIsInN0YXJ0QXN5bmNDYWxsIiwicmVzdWx0UHJvbWlzZSIsImNhbGxOZXh0Iiwic2NoZWR1bGVOZXh0Q2FsbCIsIkRlZmVycmVkIiwiYXN5bmNGaW5kIiwiaXRlbXNfIiwidGVzdCIsInRoaXNBcmciLCJpdGVtcyIsInNsaWNlIiwibnVtSXRlbXMiLCJsZW5ndGgiLCJuZXh0IiwiaW5kZXgiLCJpdGVtIiwiY2FsbCIsImRlbm9kZWlmeSIsImYiLCJhcmdzIiwiY2FsbGJhY2siLCJhcHBseSIsImNvbmNhdCIsImFzeW5jTGltaXQiLCJhcnJheSIsImxpbWl0IiwibWFwcGluZ0Z1bmN0aW9uIiwiQXJyYXkiLCJwYXJhbGxlbFByb21pc2VzIiwicGFyYWxsZWxMaW1pdCIsIk1hdGgiLCJtaW4iLCJydW5Qcm9taXNlIiwiaSIsImUiLCJhc3luY0ZpbHRlciIsImZpbHRlckZ1bmN0aW9uIiwiZmlsdGVyZWRMaXN0IiwicHVzaCIsImFzeW5jT2JqRmlsdGVyIiwib2JqIiwia2V5cyIsIk9iamVjdCIsImZpbHRlcmVkT2JqIiwia2V5IiwiYXN5bmNTb21lIiwic29tZUZ1bmN0aW9uIiwicmVzb2x2ZWQiLCJpc1Byb21pc2UiLCJvYmplY3QiLCJCb29sZWFuIiwibGFzdGx5IiwiZm4iLCJyZXQiLCJlcnIiLCJQcm9taXNlV2l0aFN0YXRlIiwiX3Byb21pc2UiLCJfc3RhdGUiLCJraW5kIiwiZ2V0UHJvbWlzZSIsImdldFN0YXRlIiwiZGVsYXlUaW1lIiwibXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlBOzs7O0FBWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1BLGlCQUFOLENBQTJCO0FBTWhDQyxFQUFBQSxXQUFXLEdBQUc7QUFBQSxTQUxkQyxpQkFLYztBQUFBLFNBSmRDLGVBSWM7QUFBQSxTQUhkQyxjQUdjO0FBQUEsU0FGZEMsWUFFYztBQUNaLFNBQUtILGlCQUFMLEdBQXlCLENBQXpCO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QixD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QUFVLEdBQWU7QUFDdkIsV0FBTyxLQUFLSCxRQUFaO0FBQ0Q7O0FBRURJLEVBQUFBLFFBQVEsR0FBb0I7QUFDMUIsV0FBTyxLQUFLSCxNQUFaO0FBQ0Q7O0FBeEI4Qjs7OztBQTJCMUIsU0FBU0ksU0FBVCxDQUFtQkMsRUFBbkIsRUFBOEM7QUFDbkQsU0FBTyxJQUFJN0csT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q1ksSUFBQUEsVUFBVSxDQUFDYixPQUFELEVBQVU0RyxFQUFWLENBQVY7QUFDRCxHQUZNLENBQVA7QUFHRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnYXNzZXJ0JztcclxuXHJcbnR5cGUgUnVuUmV0dXJuPFQ+ID1cclxuICB8IHtcclxuICAgICAgc3RhdHVzOiAnc3VjY2VzcycsXHJcbiAgICAgIHJlc3VsdDogVCxcclxuICAgIH1cclxuICB8IHtcclxuICAgICAgc3RhdHVzOiAnb3V0ZGF0ZWQnLFxyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYSBjYWxsZXIgdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdHMgaXQgcmVjZWl2ZXMgZnJvbSBjb25zZWN1dGl2ZVxyXG4gKiBwcm9taXNlIHJlc29sdXRpb25zIGFyZSBuZXZlciBvdXRkYXRlZC4gVXNhZ2U6XHJcbiAqXHJcbiAqIHZhciByZXF1ZXN0U2VyaWFsaXplciA9IG5ldyBSZXF1ZXN0U2VyaWFsaXplcigpO1xyXG4gKlxyXG4gKiAvLyBpbiBzb21lIGxhdGVyIGxvb3A6XHJcbiAqXHJcbiAqIC8vIG5vdGUgdGhhdCB5b3UgZG8gbm90IGF3YWl0IHRoZSBhc3luYyBmdW5jdGlvbiBoZXJlIC0tIHlvdSBtdXN0IHBhc3MgdGhlXHJcbiAqIC8vIHByb21pc2UgaXQgcmV0dXJucyB0byBgcnVuYFxyXG4gKiB2YXIgcmVzdWx0ID0gYXdhaXQgcmVxdWVzdFNlcmlhbGl6ZXIucnVuKHNvbWVBc3luY0Z1bmN0aW9uKCkpXHJcbiAqXHJcbiAqIGlmIChyZXN1bHQuc3RhdHVzID09PSAnc3VjY2VzcycpIHtcclxuICogICAuLi4uXHJcbiAqICAgcmVzdWx0LnJlc3VsdFxyXG4gKiB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdvdXRkYXRlZCcpIHtcclxuICogICAuLi4uXHJcbiAqIH1cclxuICpcclxuICogVGhlIGNvbnRyYWN0IGlzIHRoYXQgdGhlIHN0YXR1cyBpcyAnc3VjY2VzcycgaWYgYW5kIG9ubHkgaWYgdGhpcyB3YXMgdGhlIG1vc3RcclxuICogcmVjZW50bHkgZGlzcGF0Y2hlZCBjYWxsIG9mICdydW4nLiBGb3IgZXhhbXBsZSwgaWYgeW91IGNhbGwgcnVuKHByb21pc2UxKSBhbmRcclxuICogdGhlbiBydW4ocHJvbWlzZTIpLCBhbmQgcHJvbWlzZTIgcmVzb2x2ZXMgZmlyc3QsIHRoZSBzZWNvbmQgY2FsbHNpdGUgd291bGRcclxuICogcmVjZWl2ZSBhICdzdWNjZXNzJyBzdGF0dXMuIElmIHByb21pc2UxIGxhdGVyIHJlc29sdmVkLCB0aGUgZmlyc3QgY2FsbHNpdGVcclxuICogd291bGQgcmVjZWl2ZSBhbiAnb3V0ZGF0ZWQnIHN0YXR1cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBSZXF1ZXN0U2VyaWFsaXplcjxUPiB7XHJcbiAgX2xhc3REaXNwYXRjaGVkT3A6IG51bWJlcjtcclxuICBfbGFzdEZpbmlzaGVkT3A6IG51bWJlcjtcclxuICBfbGF0ZXN0UHJvbWlzZTogUHJvbWlzZTxUPjtcclxuICBfd2FpdFJlc29sdmU6IEZ1bmN0aW9uO1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHRoaXMuX2xhc3REaXNwYXRjaGVkT3AgPSAwO1xyXG4gICAgdGhpcy5fbGFzdEZpbmlzaGVkT3AgPSAwO1xyXG4gICAgdGhpcy5fbGF0ZXN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5fd2FpdFJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBydW4ocHJvbWlzZTogUHJvbWlzZTxUPik6IFByb21pc2U8UnVuUmV0dXJuPFQ+PiB7XHJcbiAgICBjb25zdCB0aGlzT3AgPSB0aGlzLl9sYXN0RGlzcGF0Y2hlZE9wICsgMTtcclxuICAgIHRoaXMuX2xhc3REaXNwYXRjaGVkT3AgPSB0aGlzT3A7XHJcbiAgICB0aGlzLl9sYXRlc3RQcm9taXNlID0gcHJvbWlzZTtcclxuICAgIHRoaXMuX3dhaXRSZXNvbHZlKCk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xyXG4gICAgaWYgKHRoaXMuX2xhc3RGaW5pc2hlZE9wIDwgdGhpc09wKSB7XHJcbiAgICAgIHRoaXMuX2xhc3RGaW5pc2hlZE9wID0gdGhpc09wO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXR1czogJ3N1Y2Nlc3MnLFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiAnb3V0ZGF0ZWQnLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGFzdCByZXN1bHQgb2YgYHJ1bmAsXHJcbiAgICogYXMgc29vbiBhcyB0aGVyZSBhcmUgbm8gbW9yZSBvdXRzdGFuZGluZyBgcnVuYCBjYWxscy5cclxuICAgKi9cclxuICBhc3luYyB3YWl0Rm9yTGF0ZXN0UmVzdWx0KCk6IFByb21pc2U8VD4ge1xyXG4gICAgbGV0IGxhc3RQcm9taXNlID0gbnVsbDtcclxuICAgIGxldCByZXN1bHQ6IGFueSA9IG51bGw7XHJcbiAgICB3aGlsZSAobGFzdFByb21pc2UgIT09IHRoaXMuX2xhdGVzdFByb21pc2UpIHtcclxuICAgICAgbGFzdFByb21pc2UgPSB0aGlzLl9sYXRlc3RQcm9taXNlO1xyXG4gICAgICAvLyBXYWl0IGZvciB0aGUgY3VycmVudCBsYXN0IGtub3cgcHJvbWlzZSB0byByZXNvbHZlLCBvciBhIG5leHQgcnVuIGhhdmUgc3RhcnRlZC5cclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcclxuICAgICAgcmVzdWx0ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX3dhaXRSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB0aGlzLl9sYXRlc3RQcm9taXNlLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChyZXN1bHQ6IFQpO1xyXG4gIH1cclxuXHJcbiAgaXNSdW5JblByb2dyZXNzKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xhc3REaXNwYXRjaGVkT3AgPiB0aGlzLl9sYXN0RmluaXNoZWRPcDtcclxuICB9XHJcbn1cclxuXHJcbi8qXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFmdGVyIGBtaWxsaVNlY29uZHNgIG1pbGxpIHNlY29uZHMuXHJcbiAqIHRoaXMgY2FuIGJlIHVzZWQgdG8gcGF1c2UgZXhlY3V0aW9uIGFzeW5jaHJvbm91c2x5LlxyXG4gKiBlLmcuIGF3YWl0IHNsZWVwKDEwMDApLCBwYXVzZXMgdGhlIGFzeW5jIGZsb3cgZXhlY3V0aW9uIGZvciAxIHNlY29uZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzbGVlcChtaWxsaVNlY29uZHM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbWlsbGlTZWNvbmRzKTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG5leHRUaWNrKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgIHByb2Nlc3MubmV4dFRpY2socmVzb2x2ZSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGNhbGxiYWNrIG9ubHkgaWYgYSBwcm9taXNlIHRha2VzIGxvbmdlciB0aGFuXHJcbiAqIGBtaWxsaVNlY29uZHNgIG1pbGxpc2Vjb25kcyB0byByZXNvbHZlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYHByb21pc2VgIHRoZSBwcm9taXNlIHRvIHdhaXQgb24uXHJcbiAqIEBwYXJhbSBgbWlsbGlTZWNvbmRzYCBtYXggYW1vdW50IG9mIHRpbWUgdGhhdCBgcHJvbWlzZWAgY2FuIHRha2UgdG8gcmVzb2x2ZVxyXG4gKiBiZWZvcmUgdGltZW91dEZuIGlzIGZpcmVkLlxyXG4gKiBAcGFyYW0gYHRpbWVvdXRGbmAgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBhIHByb21pc2UgdGFrZXMgbG9uZ2VyIHRoYW5cclxuICogYG1pbGxpU2Vjb25kc2AgbXMgdG8gcmVzb2x2ZS5cclxuICogQHBhcmFtIGBjbGVhbnVwRm5gIHRoZSBjbGVhbnVwIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIHByb21pc2UgcmVzb2x2ZXMuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJpZ2dlckFmdGVyV2FpdDxUPihcclxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxyXG4gIG1pbGxpU2Vjb25kczogbnVtYmVyLFxyXG4gIHRpbWVvdXRGbjogKCkgPT4gdm9pZCxcclxuICBjbGVhbnVwRm4/OiAoKSA9PiB2b2lkLFxyXG4pOiBQcm9taXNlPFQ+IHtcclxuICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCh0aW1lb3V0Rm4sIG1pbGxpU2Vjb25kcyk7XHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xyXG4gIH0gZmluYWxseSB7XHJcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICBpZiAoY2xlYW51cEZuKSB7XHJcbiAgICAgIGNsZWFudXBGbigpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRocm93biBieSBgdGltZW91dFByb21pc2VgIGlmIHRoZSB0aW1lciBmaXJlcyBiZWZvcmUgdGhlIHByb21pc2UgcmVzb2x2ZXMvcmVqZWN0cy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBUaW1lZE91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIHRpbWVvdXQ6IG51bWJlcjtcclxuICBjb25zdHJ1Y3RvcihtaWxsaXNlY29uZHM6IG51bWJlcikge1xyXG4gICAgc3VwZXIoYFRpbWVkIG91dCBhZnRlciAke1N0cmluZyhtaWxsaXNlY29uZHMpfSBtc2ApO1xyXG4gICAgdGhpcy50aW1lb3V0ID0gbWlsbGlzZWNvbmRzO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIGdpdmVuIHByb21pc2UsIG9yIHJlamVjdHMgd2l0aFxyXG4gKiBgVGltZWRPdXRFcnJvcmAgaWYgaXQgdGFrZXMgbG9uZ2VyIHRoYW4gYG1pbGxpc2Vjb25kc2AgbWlsbGlzZWNvbmRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXRQcm9taXNlPFQ+KFxyXG4gIHByb21pc2U6IFByb21pc2U8VD4sXHJcbiAgbWlsbGlzZWNvbmRzOiBudW1iZXIsXHJcbik6IFByb21pc2U8VD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBsZXQgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgcmVqZWN0KG5ldyBUaW1lZE91dEVycm9yKG1pbGxpc2Vjb25kcykpO1xyXG4gICAgICAvLyBUaGlzIGdpdmVzIHVzZWxlc3MgZXJyb3Iuc3RhY2sgcmVzdWx0cy5cclxuICAgICAgLy8gV2UgY291bGQgY2FwdHVyZSB0aGUgc3RhY2sgcHJlLWVtcHRpdmVseSBhdCB0aGUgc3RhcnRcclxuICAgICAgLy8gb2YgdGhpcyBtZXRob2QgaWYgd2Ugd2FudGVkIHVzZWZ1bCBvbmVzLlxyXG4gICAgfSwgbWlsbGlzZWNvbmRzKTtcclxuICAgIHByb21pc2VcclxuICAgICAgLnRoZW4odmFsdWUgPT4ge1xyXG4gICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYXRjaCh2YWx1ZSA9PiB7XHJcbiAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWplY3QodmFsdWUpO1xyXG4gICAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuLy8gQW4gRGVhZGxpbmVSZXF1ZXN0IHBhcmFtZXRlciB0byBhbiBhc3luYyBtZXRob2QgaXMgYSB3YXkgb2YgKnJlcXVlc3RpbmcqIHRoYXRcclxuLy8gbWV0aG9kIHRvIHRocm93IGEgVGltZWRPdXRFcnJvciBpZiBpdCBkb2Vzbid0IGNvbXBsZXRlIGluIGEgY2VydGFpbiB0aW1lLlxyXG4vLyBJdCdzIGp1c3QgYSByZXF1ZXN0IC0tIHRoZSBhc3luYyBtZXRob2Qgd2lsbCB0eXBpY2FsbHkgaG9ub3IgdGhlIHJlcXVlc3RcclxuLy8gYnkgcGFzc2luZyB0aGUgcGFyYW1ldGVyIG9uIHRvIEFMTCBzdWJzaWRpYXJ5IGFzeW5jIG1ldGhvZHMgdGhhdCBpdCBhd2FpdHMsXHJcbi8vIG9yIGJ5IGNhbGxpbmcgZXhwaXJlUHJvbWlzZSB0byBlbmZvcmNlIGEgdGltZW91dCwgb3Igc2ltaWxhci5cclxuLy9cclxuLy8gSW4gY2FzZXMgd2hlcmUgYSBtZXRob2Qgc3VwcG9ydHMgRGVhZGxpbmVSZXF1ZXN0IGJ1dCB5b3UgZG9uJ3QgdHJ1c3QgaXQsIGRvXHJcbi8vIGBhd2FpdCB0aW1lb3V0QWZ0ZXJEZWFkbGluZShkZWFkbGluZSwgdW50cnVzdGVkLmZvbyhkZWFkbGluZS0xMDAwKSlgIHNvIHlvdVxyXG4vLyBhc2sgaXQgbmljZWx5IGJ1dCBpZiBpdCBkb2Vzbid0IGdpdmUgaXRzIG93biBtb3JlLXNwZWNpZmljIGRlYWRsaW5lIG1lc3NhZ2VcclxuLy8gd2l0aGluIGEgMTAwMG1zIGdyYWNlIHBlcmlvZCB0aGVuIHlvdSBmb3JjZSBtYXR0ZXJzLlxyXG4vL1xyXG4vLyBVbmRlciB0aGUgaG9vZCBhbiBEZWFkbGluZVJlcXVlc3QgaXMganVzdCBhIHRpbWVzdGFtcCBvZiB0aGUgdGltZSBieSB3aGljaFxyXG4vLyB0aGUgb3BlcmF0aW9uIHNob3VsZCBjb21wbGV0ZS4gVGhpcyBtYWtlcyBpdCBjb21wb3NpdGlvbmFsIChiZXR0ZXIgdGhhblxyXG4vLyBcImRlbGF5XCIgcGFyYW1ldGVycykgYW5kIHNhZmVseSByZW1vdGFibGUgKGJldHRlciB0aGFuIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIlxyXG4vLyBwYXJhbWV0ZXJzKSBzbyBsb25nIGFzIGNsb2NrcyBhcmUgaW4gc3luYy4gSW4gYWxsIG90aGVyIHJlc3BlY3RzIGl0J3MgbGVzc1xyXG4vLyB2ZXJzYXRpbGUgdGhhbiBDYW5jZWxsYXRpb25Ub2tlbnMuXHJcbmV4cG9ydCB0eXBlIERlYWRsaW5lUmVxdWVzdCA9IG51bWJlcjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWFkbGluZShkZWxheTogbnVtYmVyKTogRGVhZGxpbmVSZXF1ZXN0IHtcclxuICByZXR1cm4gRGF0ZS5ub3coKSArIGRlbGF5O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dEFmdGVyRGVhZGxpbmU8VD4oXHJcbiAgZGVhZGxpbmU6IERlYWRsaW5lUmVxdWVzdCxcclxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxyXG4pOiBQcm9taXNlPFQ+IHtcclxuICBjb25zdCBkZWxheSA9IGRlYWRsaW5lIC0gRGF0ZS5ub3coKTtcclxuICByZXR1cm4gdGltZW91dFByb21pc2UocHJvbWlzZSwgZGVsYXkgPCAwID8gMCA6IGRlbGF5KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgYW4gYXN5bmMgZnVuY3Rpb24gcmVwZWF0ZWRseSB3aXRoIGEgbWF4aW11bSBudW1iZXIgb2YgdHJpYWxzIGxpbWl0LFxyXG4gKiB1bnRpbCBhIHZhbGlkIHJlc3VsdCB0aGF0J3MgZGVmaW5lZCBieSBhIHZhbGlkYXRpb24gZnVuY3Rpb24uXHJcbiAqIEEgZmFpbGVkIGNhbGwgY2FuIHJlc3VsdCBmcm9tIGFuIGFzeW5jIHRocm93biBleGNlcHRpb24sIG9yIGludmFsaWQgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYHJldHJ5RnVuY3Rpb25gIHRoZSBhc3luYyBsb2dpYyB0aGF0J3Mgd2FudGVkIHRvIGJlIHJldHJpZWQuXHJcbiAqIEBwYXJhbSBgdmFsaWRhdGlvbkZ1bmN0aW9uYCB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiB0aGF0IGRlY2lkZXMgd2hldGhlciBhIHJlc3BvbnNlIGlzIHZhbGlkLlxyXG4gKiBAcGFyYW0gYG1heGltdW1Ucmllc2AgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgYHJldHJ5RnVuY3Rpb25gIGNhbiBmYWlsIHRvIGdldCBhIHZhbGlkXHJcbiAqIHJlc3BvbnNlIGJlZm9yZSB0aGUgYHJldHJ5TGltaXRgIGlzIHRlcm1pbmF0ZWQgcmVwb3J0aW5nIGFuIGVycm9yLlxyXG4gKiBAcGFyYW0gYHJldHJ5SW50ZXJ2YWxNc2Agb3B0aW9uYWwsIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmV0d2VlbiB0cmlhbHMsIGlmIHdhbnRlZC5cclxuICpcclxuICogSWYgYW4gZXhjZXB0aW9uIGlzIGVuY291bnRlcmVkIG9uIHRoZSBsYXN0IHRyaWFsLCB0aGUgZXhjZXB0aW9uIGlzIHRocm93bi5cclxuICogSWYgbm8gdmFsaWQgcmVzcG9uc2UgaXMgZm91bmQsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmV0cnlMaW1pdDxUPihcclxuICByZXRyeUZ1bmN0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxyXG4gIHZhbGlkYXRpb25GdW5jdGlvbjogKHJlc3VsdDogVCkgPT4gYm9vbGVhbixcclxuICBtYXhpbXVtVHJpZXM6IG51bWJlcixcclxuICByZXRyeUludGVydmFsTXM/OiBudW1iZXIgPSAwLFxyXG4pOiBQcm9taXNlPFQ+IHtcclxuICBsZXQgcmVzdWx0ID0gbnVsbDtcclxuICBsZXQgdHJpZXMgPSAwO1xyXG4gIGxldCBsYXN0RXJyb3IgPSBudWxsO1xyXG4gIHdoaWxlICh0cmllcyA9PT0gMCB8fCB0cmllcyA8IG1heGltdW1Ucmllcykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcclxuICAgICAgcmVzdWx0ID0gYXdhaXQgcmV0cnlGdW5jdGlvbigpO1xyXG4gICAgICBsYXN0RXJyb3IgPSBudWxsO1xyXG4gICAgICBpZiAodmFsaWRhdGlvbkZ1bmN0aW9uKHJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcclxuICAgICAgcmVzdWx0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoKyt0cmllcyA8IG1heGltdW1UcmllcyAmJiByZXRyeUludGVydmFsTXMgIT09IDApIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcclxuICAgICAgYXdhaXQgc2xlZXAocmV0cnlJbnRlcnZhbE1zKTtcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKGxhc3RFcnJvciAhPSBudWxsKSB7XHJcbiAgICB0aHJvdyBsYXN0RXJyb3I7XHJcbiAgfSBlbHNlIGlmICh0cmllcyA9PT0gbWF4aW11bVRyaWVzKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHJlc3BvbnNlIGZvdW5kIScpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gKChyZXN1bHQ6IGFueSk6IFQpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIExpbWl0cyBhc3luYyBmdW5jdGlvbiBleGVjdXRpb24gcGFyYWxsZWxpc20gdG8gb25seSBvbmUgYXQgYSB0aW1lLlxyXG4gKiBIZW5jZSwgaWYgYSBjYWxsIGlzIGFscmVhZHkgcnVubmluZywgaXQgd2lsbCB3YWl0IGZvciBpdCB0byBmaW5pc2gsXHJcbiAqIHRoZW4gc3RhcnQgdGhlIG5leHQgYXN5bmMgZXhlY3V0aW9uLCBidXQgaWYgY2FsbGVkIGFnYWluIHdoaWxlIG5vdCBmaW5pc2hlZCxcclxuICogaXQgd2lsbCByZXR1cm4gdGhlIHNjaGVkdWxlZCBleGVjdXRpb24gcHJvbWlzZS5cclxuICpcclxuICogU2FtcGxlIFVzYWdlOlxyXG4gKiBgYGBcclxuICogbGV0IGkgPSAxO1xyXG4gKiBjb25zdCBvbmVFeGVjQXRBVGltZSA9IG9uZVBhcmFsbGVsQXN5bmNDYWxsKCgpID0+IHtcclxuICogICByZXR1cm4gbmV4dCBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICogICAgIHNldFRpbWVvdXQoMjAwLCAoKSA9PiByZXNvbHZlKGkrKykpO1xyXG4gKiAgIH0pO1xyXG4gKiB9KTtcclxuICpcclxuICogY29uc3QgcmVzdWx0MVByb21pc2UgPSBvbmVFeGVjQXRBVGltZSgpOyAvLyBTdGFydCBhbiBhc3luYywgYW5kIHJlc29sdmUgdG8gMSBpbiAyMDAgbXMuXHJcbiAqIGNvbnN0IHJlc3VsdDJQcm9taXNlID0gb25lRXhlY0F0QVRpbWUoKTsgLy8gU2NoZWR1bGUgdGhlIG5leHQgYXN5bmMsIGFuZCByZXNvbHZlIHRvIDIgaW4gNDAwIG1zLlxyXG4gKiBjb25zdCByZXN1bHQzUHJvbWlzZSA9IG9uZUV4ZWNBdEFUaW1lKCk7IC8vIFJldXNlIHNjaGVkdWxlZCBwcm9taXNlIGFuZCByZXNvbHZlIHRvIDIgaW4gNDAwIG1zLlxyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVBc3luY0NhbGw8VD4oXHJcbiAgYXN5bmNGdW46ICgpID0+IFByb21pc2U8VD4sXHJcbik6ICgpID0+IFByb21pc2U8VD4ge1xyXG4gIGxldCBzY2hlZHVsZWRDYWxsID0gbnVsbDtcclxuICBsZXQgcGVuZGluZ0NhbGwgPSBudWxsO1xyXG4gIGNvbnN0IHN0YXJ0QXN5bmNDYWxsID0gKCkgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0UHJvbWlzZSA9IGFzeW5jRnVuKCk7XHJcbiAgICBwZW5kaW5nQ2FsbCA9IHJlc3VsdFByb21pc2UudGhlbihcclxuICAgICAgKCkgPT4gKHBlbmRpbmdDYWxsID0gbnVsbCksXHJcbiAgICAgICgpID0+IChwZW5kaW5nQ2FsbCA9IG51bGwpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiByZXN1bHRQcm9taXNlO1xyXG4gIH07XHJcbiAgY29uc3QgY2FsbE5leHQgPSAoKSA9PiB7XHJcbiAgICBzY2hlZHVsZWRDYWxsID0gbnVsbDtcclxuICAgIHJldHVybiBzdGFydEFzeW5jQ2FsbCgpO1xyXG4gIH07XHJcbiAgY29uc3Qgc2NoZWR1bGVOZXh0Q2FsbCA9ICgpID0+IHtcclxuICAgIGlmIChzY2hlZHVsZWRDYWxsID09IG51bGwpIHtcclxuICAgICAgaW52YXJpYW50KHBlbmRpbmdDYWxsLCAncGVuZGluZ0NhbGwgbXVzdCBub3QgYmUgbnVsbCEnKTtcclxuICAgICAgc2NoZWR1bGVkQ2FsbCA9IHBlbmRpbmdDYWxsLnRoZW4oY2FsbE5leHQsIGNhbGxOZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY2hlZHVsZWRDYWxsO1xyXG4gIH07XHJcbiAgcmV0dXJuICgpID0+IHtcclxuICAgIGlmIChwZW5kaW5nQ2FsbCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBzdGFydEFzeW5jQ2FsbCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHNjaGVkdWxlTmV4dENhbGwoKTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYSBwcm9taXNlIGFsb25nIHdpdGggbWV0aG9kcyB0byBjaGFuZ2UgaXRzIHN0YXRlLiBPdXIgdmVyc2lvbiBvZiB0aGUgbm9uLXN0YW5kYXJkXHJcbiAqIGBQcm9taXNlLmRlZmVyKClgLlxyXG4gKlxyXG4gKiBJTVBPUlRBTlQ6IFRoaXMgc2hvdWxkIGFsbW9zdCBuZXZlciBiZSB1c2VkISEgSW5zdGVhZCwgdXNlIHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yLiBTZWVcclxuICogIDxodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvUHJvbWlzZS1hbnRpLXBhdHRlcm5zI3RoZS1kZWZlcnJlZC1hbnRpLXBhdHRlcm4+XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQ8VD4ge1xyXG4gIHByb21pc2U6IFByb21pc2U8VD47XHJcbiAgcmVzb2x2ZTogKHZhbHVlOiBUKSA9PiB2b2lkO1xyXG4gIHJlamVjdDogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHZhbHVlIGRlcml2ZWQgYXN5bmNocm9ub3VzbHkgZnJvbSBhbiBlbGVtZW50IGluIHRoZSBpdGVtcyBhcnJheS5cclxuICogVGhlIHRlc3QgZnVuY3Rpb24gaXMgYXBwbGllZCBzZXF1ZW50aWFsbHkgdG8gZWFjaCBlbGVtZW50IGluIGl0ZW1zIHVudGlsXHJcbiAqIG9uZSByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbm9uLW51bGwgdmFsdWUuIFdoZW4gdGhpcyBoYXBwZW5zLFxyXG4gKiB0aGUgUHJvbWlzZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCB3aWxsIHJlc29sdmUgdG8gdGhhdCBub24tbnVsbCB2YWx1ZS4gSWZcclxuICogbm8gc3VjaCBQcm9taXNlIGlzIHByb2R1Y2VkLCB0aGVuIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb25cclxuICogd2lsbCByZXNvbHZlIHRvIG51bGwuXHJcbiAqXHJcbiAqIEBwYXJhbSBpdGVtcyBBcnJheSBvZiBlbGVtZW50cyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRlc3QsIG9uZSBhdCBhIHRpbWUuXHJcbiAqIEBwYXJhbSB0ZXN0IFdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCBpdGVtIGFuZCBtdXN0IHJldHVybiBlaXRoZXI6XHJcbiAqICAgICAoMSkgQSBcInRoZW5hYmxlXCIgKGkuZSwgYSBQcm9taXNlIG9yIHByb21pc2UtbGlrZSBvYmplY3QpIHRoYXQgcmVzb2x2ZXNcclxuICogICAgICAgICB0byBhIGRlcml2ZWQgdmFsdWUgKHRoYXQgd2lsbCBiZSByZXR1cm5lZCkgb3IgbnVsbC5cclxuICogICAgICgyKSBudWxsLlxyXG4gKiAgICAgSW4gYm90aCBjYXNlcyB3aGVyZSBudWxsIGlzIHJldHVybmVkLCB0ZXN0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgbmV4dFxyXG4gKiAgICAgaXRlbSBpbiB0aGUgYXJyYXkuXHJcbiAqIEBwYXJhbSB0aGlzQXJnIFJlY2VpdmVyIHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gdGVzdCBpcyBjYWxsZWQuXHJcbiAqIEByZXR1cm4gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFzeW5jaHJvbm91c2x5IGRlcml2ZWQgdmFsdWUgb3IgbnVsbC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhc3luY0ZpbmQ8VCwgVT4oXHJcbiAgaXRlbXNfOiBBcnJheTxUPixcclxuICB0ZXN0OiAodDogVCkgPT4gP1Byb21pc2U8P1U+LFxyXG4gIHRoaXNBcmc/OiBtaXhlZCxcclxuKTogUHJvbWlzZTw/VT4ge1xyXG4gIGxldCBpdGVtcyA9IGl0ZW1zXztcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgLy8gQ3JlYXRlIGEgbG9jYWwgY29weSBvZiBpdGVtcyB0byBkZWZlbmQgYWdhaW5zdCB0aGUgY2FsbGVyIG1vZGlmeWluZyB0aGVcclxuICAgIC8vIGFycmF5IGJlZm9yZSB0aGlzIFByb21pc2UgaXMgcmVzb2x2ZWQuXHJcbiAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKCk7XHJcbiAgICBjb25zdCBudW1JdGVtcyA9IGl0ZW1zLmxlbmd0aDtcclxuXHJcbiAgICBjb25zdCBuZXh0ID0gYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcclxuICAgICAgaWYgKGluZGV4ID09PSBudW1JdGVtcykge1xyXG4gICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBpdGVtID0gaXRlbXNbaW5kZXhdO1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0ZXN0LmNhbGwodGhpc0FyZywgaXRlbSk7XHJcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xyXG4gICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuZXh0KGluZGV4ICsgMSk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbmV4dCgwKTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlbm9kZWlmeShcclxuICBmOiAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gYW55LFxyXG4pOiAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gUHJvbWlzZTxhbnk+IHtcclxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogQXJyYXk8YW55Pikge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyb3IsIHJlc3VsdCkge1xyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KFtjYWxsYmFja10pKTtcclxuICAgIH0pO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIFByb21pc2UgdXRpbGl0eSB0aGF0IHJ1bnMgYSBtYXhpbXVtIG9mIGxpbWl0IGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lXHJcbiAqIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IGFuZCByZXR1cm5pbmcgdGhlIHJlc3VsdCBvZiBleGVjdXRpb25zLlxyXG4gKiBlLmcuIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgZmlsZSByZWFkcyB0byA1LFxyXG4gKiByZXBsYWNlIHRoZSBjb2RlOlxyXG4gKiAgICB2YXIgZmlsZUNvbnRlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoZmlsZVBhdGhzLm1hcChmc1Byb21pc2UucmVhZEZpbGUpKVxyXG4gKiB3aXRoOlxyXG4gKiAgICB2YXIgZmlsZUNvbnRlbnRzID0gYXdhaXQgYXN5bmNMaW1pdChmaWxlUGF0aHMsIDUsIGZzUHJvbWlzZS5yZWFkRmlsZSlcclxuICpcclxuICogVGhpcyBpcyBwYXJ0aWN1bHJpbHkgdXNlZnVsIHRvIGxpbWl0IElPIG9wZXJhdGlvbnMgdG8gYSBjb25maWd1cmFibGUgbWF4aW11bSAodG8gYXZvaWRcclxuICogYmxvY2tpbmcpLCB3aGlsZSBlbmpveWluZyB0aGUgY29uZmlndXJlZCBsZXZlbCBvZiBwYXJhbGxlbGlzbS5cclxuICpcclxuICogQHBhcmFtIGFycmF5IHRoZSBhcnJheSBvZiBpdGVtcyBmb3IgaXRlcmF0aW9uLlxyXG4gKiBAcGFyYW0gbGltaXQgdGhlIGNvbmZpZ3VyYWJsZSBudW1iZXIgb2YgcGFyYWxsZWwgYXN5bmMgb3BlcmF0aW9ucy5cclxuICogQHBhcmFtIG1hcHBpbmdGdW5jdGlvbiB0aGUgYXN5bmMgUHJvbWlzZSBmdW5jdGlvbiB0aGF0IGNvdWxkIHJldHVybiBhIHVzZWZ1bCByZXN1bHQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNMaW1pdDxULCBWPihcclxuICBhcnJheTogQXJyYXk8VD4sXHJcbiAgbGltaXQ6IG51bWJlcixcclxuICBtYXBwaW5nRnVuY3Rpb246IChpdGVtOiBUKSA9PiBQcm9taXNlPFY+LFxyXG4pOiBQcm9taXNlPEFycmF5PFY+PiB7XHJcbiAgY29uc3QgcmVzdWx0OiBBcnJheTxWPiA9IG5ldyBBcnJheShhcnJheS5sZW5ndGgpO1xyXG4gIGxldCBwYXJhbGxlbFByb21pc2VzID0gMDtcclxuICBsZXQgaW5kZXggPSAwO1xyXG5cclxuICBsZXQgcGFyYWxsZWxMaW1pdCA9IE1hdGgubWluKGxpbWl0LCBhcnJheS5sZW5ndGgpIHx8IDE7XHJcblxyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBydW5Qcm9taXNlID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAoaW5kZXggPT09IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwYXJhbGxlbFByb21pc2VzID09PSAwKSB7XHJcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICArK3BhcmFsbGVsUHJvbWlzZXM7XHJcbiAgICAgIGNvbnN0IGkgPSBpbmRleCsrO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IGF3YWl0IG1hcHBpbmdGdW5jdGlvbihhcnJheVtpXSk7XHJcbiAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgIH1cclxuICAgICAgLS1wYXJhbGxlbFByb21pc2VzO1xyXG4gICAgICBydW5Qcm9taXNlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHdoaWxlIChwYXJhbGxlbExpbWl0LS0pIHtcclxuICAgICAgcnVuUHJvbWlzZSgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogYGZpbHRlcmAgUHJvbWlzZSB1dGlsaXR5IHRoYXQgYWxsb3dzIGZpbHRlcmluZyBhbiBhcnJheSB3aXRoIGFuIGFzeW5jIFByb21pc2UgZnVuY3Rpb24uXHJcbiAqIEl0J3MgYW4gYWx0ZXJuYXRpdmUgdG8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIHRoYXQgYWNjZXB0cyBhbiBhc3luYyBmdW5jdGlvbi5cclxuICogWW91IGNhbiBvcHRpb25hbGx5IGNvbmZpZ3VyZSBhIGxpbWl0IHRvIHNldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXHJcbiAqXHJcbiAqIFByZXZpb3VzbHksIHdpdGggdGhlIGBQcm9taXNlLmFsbGAgcHJpbWl0aXZlLCB3ZSBjYW4ndCBzZXQgdGhlIHBhcmFsbGVsaXNtIGxpbWl0IGFuZCB3ZSBoYXZlIHRvXHJcbiAqIGBmaWx0ZXJgLCBzbywgd2UgcmVwbGFjZSB0aGUgb2xkIGBmaWx0ZXJgIGNvZGU6XHJcbiAqICAgICB2YXIgZXhpc3RpbmdGaWxlUGF0aHMgPSBbXTtcclxuICogICAgIGF3YWl0IFByb21pc2UuYWxsKGZpbGVQYXRocy5tYXAoYXN5bmMgKGZpbGVQYXRoKSA9PiB7XHJcbiAqICAgICAgIGlmIChhd2FpdCBmc1Byb21pc2UuZXhpc3RzKGZpbGVQYXRoKSkge1xyXG4gKiAgICAgICAgIGV4aXN0aW5nRmlsZVBhdGhzLnB1c2goZmlsZVBhdGgpO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICB9KSk7XHJcbiAqIHdpdGggbGltaXQgNSBwYXJhbGxlbCBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXQgYSB0aW1lOlxyXG4gKiAgICB2YXIgZXhpc3RpbmdGaWxlUGF0aHMgPSBhd2FpdCBhc3luY0ZpbHRlcihmaWxlUGF0aHMsIGZzUHJvbWlzZS5leGlzdHMsIDUpO1xyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgdGhlIGFycmF5IG9mIGl0ZW1zIGZvciBgZmlsdGVyYGluZy5cclxuICogQHBhcmFtIGZpbHRlckZ1bmN0aW9uIHRoZSBhc3luYyBgZmlsdGVyYCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYVxyXG4gKiAgIGJvb2xlYW4uXHJcbiAqIEBwYXJhbSBsaW1pdCB0aGUgY29uZmlndXJhYmxlIG51bWJlciBvZiBwYXJhbGxlbCBhc3luYyBvcGVyYXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jRmlsdGVyPFQ+KFxyXG4gIGFycmF5OiBBcnJheTxUPixcclxuICBmaWx0ZXJGdW5jdGlvbjogKGl0ZW06IFQpID0+IFByb21pc2U8Ym9vbGVhbj4sXHJcbiAgbGltaXQ/OiBudW1iZXIsXHJcbik6IFByb21pc2U8QXJyYXk8VD4+IHtcclxuICBjb25zdCBmaWx0ZXJlZExpc3QgPSBbXTtcclxuICAvLyBmbG93bGludC1uZXh0LWxpbmUgc2tldGNoeS1udWxsLW51bWJlcjpvZmZcclxuICBhd2FpdCBhc3luY0xpbWl0KGFycmF5LCBsaW1pdCB8fCBhcnJheS5sZW5ndGgsIGFzeW5jIChpdGVtOiBUKSA9PiB7XHJcbiAgICBpZiAoYXdhaXQgZmlsdGVyRnVuY3Rpb24oaXRlbSkpIHtcclxuICAgICAgZmlsdGVyZWRMaXN0LnB1c2goaXRlbSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgcmV0dXJuIGZpbHRlcmVkTGlzdDtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jT2JqRmlsdGVyPFQ+KFxyXG4gIG9iajoge1trZXk6IHN0cmluZ106IFR9LFxyXG4gIGZpbHRlckZ1bmN0aW9uOiAoaXRlbTogVCwga2V5OiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj4sXHJcbiAgbGltaXQ/OiBudW1iZXIsXHJcbik6IFByb21pc2U8e1trZXk6IHN0cmluZ106IFR9PiB7XHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XHJcbiAgY29uc3QgZmlsdGVyZWRPYmogPSB7fTtcclxuICAvLyBmbG93bGludC1uZXh0LWxpbmUgc2tldGNoeS1udWxsLW51bWJlcjpvZmZcclxuICBhd2FpdCBhc3luY0xpbWl0KGtleXMsIGxpbWl0IHx8IGtleXMubGVuZ3RoLCBhc3luYyAoa2V5OiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IGl0ZW0gPSBvYmpba2V5XTtcclxuICAgIGlmIChhd2FpdCBmaWx0ZXJGdW5jdGlvbihpdGVtLCBrZXkpKSB7XHJcbiAgICAgIGZpbHRlcmVkT2JqW2tleV0gPSBpdGVtO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIHJldHVybiBmaWx0ZXJlZE9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIGBzb21lYCBQcm9taXNlIHV0aWxpdHkgdGhhdCBhbGxvd3MgYHNvbWVgIGFuIGFycmF5IHdpdGggYW4gYXN5bmMgUHJvbWlzZSBzb21lIGZ1bmN0aW9uLlxyXG4gKiBJdCdzIGFuIGFsdGVybmF0aXZlIHRvIGBBcnJheS5wcm90b3R5cGUuc29tZWAgdGhhdCBhY2NlcHRzIGFuIGFzeW5jIHNvbWUgZnVuY3Rpb24uXHJcbiAqIFlvdSBjYW4gb3B0aW9uYWxseSBjb25maWd1cmUgYSBsaW1pdCB0byBzZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxyXG4gKlxyXG4gKiBQcmV2aW91c2x5LCB3aXRoIHRoZSBQcm9taXNlLmFsbCBwcmltaXRpdmUsIHdlIGNhbid0IHNldCB0aGUgcGFyYWxsZWxpc20gbGltaXQgYW5kIHdlIGhhdmUgdG9cclxuICogYHNvbWVgLCBzbywgd2UgcmVwbGFjZSB0aGUgb2xkIGBzb21lYCBjb2RlOlxyXG4gKiAgICAgdmFyIHNvbWVGaWxlRXhpc3QgPSBmYWxzZTtcclxuICogICAgIGF3YWl0IFByb21pc2UuYWxsKGZpbGVQYXRocy5tYXAoYXN5bmMgKGZpbGVQYXRoKSA9PiB7XHJcbiAqICAgICAgIGlmIChhd2FpdCBmc1Byb21pc2UuZXhpc3RzKGZpbGVQYXRoKSkge1xyXG4gKiAgICAgICAgIHNvbWVGaWxlRXhpc3QgPSB0cnVlO1xyXG4gKiAgICAgICB9XHJcbiAqICAgICB9KSk7XHJcbiAqIHdpdGggbGltaXQgNSBwYXJhbGxlbCBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXQgYSB0aW1lOlxyXG4gKiAgICB2YXIgc29tZUZpbGVFeGlzdCA9IGF3YWl0IGFzeW5jU29tZShmaWxlUGF0aHMsIGZzUHJvbWlzZS5leGlzdHMsIDUpO1xyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgdGhlIGFycmF5IG9mIGl0ZW1zIGZvciBgc29tZWBpbmcuXHJcbiAqIEBwYXJhbSBzb21lRnVuY3Rpb24gdGhlIGFzeW5jIGBzb21lYCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYVxyXG4gKiAgIGJvb2xlYW4uXHJcbiAqIEBwYXJhbSBsaW1pdCB0aGUgY29uZmlndXJhYmxlIG51bWJlciBvZiBwYXJhbGxlbCBhc3luYyBvcGVyYXRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jU29tZTxUPihcclxuICBhcnJheTogQXJyYXk8VD4sXHJcbiAgc29tZUZ1bmN0aW9uOiAoaXRlbTogVCkgPT4gUHJvbWlzZTxib29sZWFuPixcclxuICBsaW1pdD86IG51bWJlcixcclxuKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgbGV0IHJlc29sdmVkID0gZmFsc2U7XHJcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHNrZXRjaHktbnVsbC1udW1iZXI6b2ZmXHJcbiAgYXdhaXQgYXN5bmNMaW1pdChhcnJheSwgbGltaXQgfHwgYXJyYXkubGVuZ3RoLCBhc3luYyAoaXRlbTogVCkgPT4ge1xyXG4gICAgaWYgKHJlc29sdmVkKSB7XHJcbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY2FsbCB0aGUgc29tZUZ1bmN0aW9uIGFueW1vcmUgb3Igd2FpdCBhbnkgbG9uZ2VyLlxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoYXdhaXQgc29tZUZ1bmN0aW9uKGl0ZW0pKSB7XHJcbiAgICAgIHJlc29sdmVkID0gdHJ1ZTtcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gcmVzb2x2ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgUHJvbWlzZSBieSB0ZXN0aW5nIGlmIGl0IGhhcyBhIGB0aGVuYCBmdW5jdGlvbiBwcm9wZXJ0eS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2Uob2JqZWN0OiBhbnkpOiBib29sZWFuIHtcclxuICByZXR1cm4gKFxyXG4gICAgQm9vbGVhbihvYmplY3QpICYmXHJcbiAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxyXG4gICAgdHlwZW9mIG9iamVjdC50aGVuID09PSAnZnVuY3Rpb24nXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdlIGNhbid0IG5hbWUgYSBmdW5jdGlvbiAnZmluYWxseScsIHNvIHVzZSBsYXN0bHkgaW5zdGVhZC5cclxuICogZm4oKSB3aWxsIGJlIGV4ZWN1dGVkIChhbmQgY29tcGxldGVkKSBhZnRlciB0aGUgcHJvdmlkZWQgcHJvbWlzZSByZXNvbHZlcy9yZWplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxhc3RseTxUPihcclxuICBwcm9taXNlOiBQcm9taXNlPFQ+LFxyXG4gIGZuOiAoKSA9PiBQcm9taXNlPG1peGVkPiB8IG1peGVkLFxyXG4pOiBQcm9taXNlPFQ+IHtcclxuICByZXR1cm4gcHJvbWlzZS50aGVuKFxyXG4gICAgcmV0ID0+IHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmbigpKS50aGVuKCgpID0+IHJldCk7XHJcbiAgICB9LFxyXG4gICAgZXJyID0+IHtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmbigpKS50aGVuKCgpID0+IFByb21pc2UucmVqZWN0KGVycikpO1xyXG4gICAgfSxcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogV2l0aCBhIHB1cmUgcHJvbWlzZSBvYmplY3QsIHRoZXJlJ3Mgbm8gd2F5IHRvIHRlbGwgc3luY2hyb25vdXNseVxyXG4gKiB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgJ3NldHRsZWQnIChpLmUuIGJlZW4gZnVsZmlsbGVkIG9yIHJlamVjdGVkKS5cclxuICogSGVyZSB3ZSBwcm92aWRlIGEgd3JhcHBlciB0aGF0IHByb3ZpZGVzIHRoYXQgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQcm9taXNlU3RhdGU8VD4gPVxyXG4gIHwge2tpbmQ6ICdwZW5kaW5nJ31cclxuICB8IHtraW5kOiAnZnVsZmlsbGVkJywgdmFsdWU6IFR9XHJcbiAgfCB7a2luZDogJ3JlamVjdGVkJywgZXJyb3I6IGFueX07XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvbWlzZVdpdGhTdGF0ZTxUPiB7XHJcbiAgX3Byb21pc2U6IFByb21pc2U8VD47XHJcbiAgX3N0YXRlOiBQcm9taXNlU3RhdGU8VD47XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByb21pc2U6IFByb21pc2U8VD4pIHtcclxuICAgIHRoaXMuX3N0YXRlID0ge2tpbmQ6ICdwZW5kaW5nJ307XHJcbiAgICB0aGlzLl9wcm9taXNlID0gcHJvbWlzZS50aGVuKFxyXG4gICAgICB2YWx1ZSA9PiB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB7a2luZDogJ2Z1bGZpbGxlZCcsIHZhbHVlfTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgIH0sXHJcbiAgICAgIGVycm9yID0+IHtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IHtraW5kOiAncmVqZWN0ZWQnLCBlcnJvcn07XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZ2V0UHJvbWlzZSgpOiBQcm9taXNlPFQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgZ2V0U3RhdGUoKTogUHJvbWlzZVN0YXRlPFQ+IHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWxheVRpbWUobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcclxuICB9KTtcclxufVxyXG4iXX0=