"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/* global requestIdleCallback, cancelIdleCallback */

/**
 * `scheduleIdleCallback` is a wrapper around `requestIdleCallback` that:
 *   - Returns a disposable.
 *   - Manages checking `timeRemaining`.
 *
 * `timeRemaining` is how much time the system thinks is available for your
 * work. `50` is the maximum allowed value. By choosing `49` for
 * `afterRemainingTime`, you're saying: "only invoke the callback when there
 * are 49ms available for me to do work". It was can take multiple loops around
 * `requestIdleCallback` for so much time to become available.
 */
var _default = typeof requestIdleCallback !== 'undefined' ? // Using Browser API
// Is guaranteed to resolve after `timeout` milliseconds.
function scheduleIdleCallback(callback_, options = {}) {
  const afterRemainingTime = options.afterRemainingTime || 49; // flowlint-next-line sketchy-null-number:off

  const timeout = options.timeout || 500;
  let callback = callback_;
  let id;
  const startTime = Date.now();

  function fn(deadline) {
    if (deadline.timeRemaining() >= afterRemainingTime || Date.now() - startTime >= timeout) {
      (0, _assert.default)(callback != null);
      callback();
      id = callback = null;
    } else {
      id = requestIdleCallback(fn, {
        timeout: timeout - (Date.now() - startTime)
      });
    }
  }

  id = requestIdleCallback(fn, {
    timeout
  });
  return {
    dispose() {
      if (id != null) {
        cancelIdleCallback(id);
        id = callback = null;
      }
    }

  };
} : // Using Node API
function scheduleIdleCallback(callback, options) {
  const id = setImmediate(callback);
  return {
    dispose() {
      clearImmediate(id);
    }

  };
};

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3NjaGVkdWxlSWRsZUNhbGxiYWNrLmpzIl0sIm5hbWVzIjpbInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzY2hlZHVsZUlkbGVDYWxsYmFjayIsImNhbGxiYWNrXyIsIm9wdGlvbnMiLCJhZnRlclJlbWFpbmluZ1RpbWUiLCJ0aW1lb3V0IiwiY2FsbGJhY2siLCJpZCIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJmbiIsImRlYWRsaW5lIiwidGltZVJlbWFpbmluZyIsImRpc3Bvc2UiLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJzZXRJbW1lZGlhdGUiLCJjbGVhckltbWVkaWF0ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQTBCQTs7OztBQTFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7ZUFVZ0IsT0FBT0EsbUJBQVAsS0FBK0IsV0FBL0IsR0FDWjtBQUNBO0FBQ0EsU0FBU0Msb0JBQVQsQ0FDRUMsU0FERixFQUVFQyxPQUFrQixHQUFHLEVBRnZCLEVBR2U7QUFDYixRQUFNQyxrQkFBa0IsR0FBR0QsT0FBTyxDQUFDQyxrQkFBUixJQUE4QixFQUF6RCxDQURhLENBRWI7O0FBQ0EsUUFBTUMsT0FBTyxHQUFHRixPQUFPLENBQUNFLE9BQVIsSUFBbUIsR0FBbkM7QUFDQSxNQUFJQyxRQUFRLEdBQUdKLFNBQWY7QUFDQSxNQUFJSyxFQUFKO0FBQ0EsUUFBTUMsU0FBUyxHQUFHQyxJQUFJLENBQUNDLEdBQUwsRUFBbEI7O0FBQ0EsV0FBU0MsRUFBVCxDQUFZQyxRQUFaLEVBQXNCO0FBQ3BCLFFBQ0VBLFFBQVEsQ0FBQ0MsYUFBVCxNQUE0QlQsa0JBQTVCLElBQ0FLLElBQUksQ0FBQ0MsR0FBTCxLQUFhRixTQUFiLElBQTBCSCxPQUY1QixFQUdFO0FBQ0EsMkJBQVVDLFFBQVEsSUFBSSxJQUF0QjtBQUNBQSxNQUFBQSxRQUFRO0FBQ1JDLE1BQUFBLEVBQUUsR0FBR0QsUUFBUSxHQUFHLElBQWhCO0FBQ0QsS0FQRCxNQU9PO0FBQ0xDLE1BQUFBLEVBQUUsR0FBR1AsbUJBQW1CLENBQUNXLEVBQUQsRUFBSztBQUMzQk4sUUFBQUEsT0FBTyxFQUFFQSxPQUFPLElBQUlJLElBQUksQ0FBQ0MsR0FBTCxLQUFhRixTQUFqQjtBQURXLE9BQUwsQ0FBeEI7QUFHRDtBQUNGOztBQUNERCxFQUFBQSxFQUFFLEdBQUdQLG1CQUFtQixDQUFDVyxFQUFELEVBQUs7QUFBQ04sSUFBQUE7QUFBRCxHQUFMLENBQXhCO0FBQ0EsU0FBTztBQUNMUyxJQUFBQSxPQUFPLEdBQUc7QUFDUixVQUFJUCxFQUFFLElBQUksSUFBVixFQUFnQjtBQUNkUSxRQUFBQSxrQkFBa0IsQ0FBQ1IsRUFBRCxDQUFsQjtBQUNBQSxRQUFBQSxFQUFFLEdBQUdELFFBQVEsR0FBRyxJQUFoQjtBQUNEO0FBQ0Y7O0FBTkksR0FBUDtBQVFELENBcENXLEdBcUNaO0FBQ0EsU0FBU0wsb0JBQVQsQ0FDRUssUUFERixFQUVFSCxPQUZGLEVBR2U7QUFDYixRQUFNSSxFQUFFLEdBQUdTLFlBQVksQ0FBQ1YsUUFBRCxDQUF2QjtBQUNBLFNBQU87QUFDTFEsSUFBQUEsT0FBTyxHQUFHO0FBQ1JHLE1BQUFBLGNBQWMsQ0FBQ1YsRUFBRCxDQUFkO0FBQ0Q7O0FBSEksR0FBUDtBQUtELEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuLyogZ2xvYmFsIHJlcXVlc3RJZGxlQ2FsbGJhY2ssIGNhbmNlbElkbGVDYWxsYmFjayAqL1xyXG5cclxuLyoqXHJcbiAqIGBzY2hlZHVsZUlkbGVDYWxsYmFja2AgaXMgYSB3cmFwcGVyIGFyb3VuZCBgcmVxdWVzdElkbGVDYWxsYmFja2AgdGhhdDpcclxuICogICAtIFJldHVybnMgYSBkaXNwb3NhYmxlLlxyXG4gKiAgIC0gTWFuYWdlcyBjaGVja2luZyBgdGltZVJlbWFpbmluZ2AuXHJcbiAqXHJcbiAqIGB0aW1lUmVtYWluaW5nYCBpcyBob3cgbXVjaCB0aW1lIHRoZSBzeXN0ZW0gdGhpbmtzIGlzIGF2YWlsYWJsZSBmb3IgeW91clxyXG4gKiB3b3JrLiBgNTBgIGlzIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuIEJ5IGNob29zaW5nIGA0OWAgZm9yXHJcbiAqIGBhZnRlclJlbWFpbmluZ1RpbWVgLCB5b3UncmUgc2F5aW5nOiBcIm9ubHkgaW52b2tlIHRoZSBjYWxsYmFjayB3aGVuIHRoZXJlXHJcbiAqIGFyZSA0OW1zIGF2YWlsYWJsZSBmb3IgbWUgdG8gZG8gd29ya1wiLiBJdCB3YXMgY2FuIHRha2UgbXVsdGlwbGUgbG9vcHMgYXJvdW5kXHJcbiAqIGByZXF1ZXN0SWRsZUNhbGxiYWNrYCBmb3Igc28gbXVjaCB0aW1lIHRvIGJlY29tZSBhdmFpbGFibGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5cclxudHlwZSBDYWxsYmFja1QgPSAoKSA9PiB2b2lkO1xyXG50eXBlIE9wdGlvbnNUID0ge1xyXG4gIGFmdGVyUmVtYWluaW5nVGltZT86IDMwIHwgNDAgfCA0OSxcclxuICB0aW1lb3V0PzogbnVtYmVyLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAndW5kZWZpbmVkJ1xyXG4gID8gLy8gVXNpbmcgQnJvd3NlciBBUElcclxuICAgIC8vIElzIGd1YXJhbnRlZWQgdG8gcmVzb2x2ZSBhZnRlciBgdGltZW91dGAgbWlsbGlzZWNvbmRzLlxyXG4gICAgZnVuY3Rpb24gc2NoZWR1bGVJZGxlQ2FsbGJhY2soXHJcbiAgICAgIGNhbGxiYWNrXzogQ2FsbGJhY2tULFxyXG4gICAgICBvcHRpb25zPzogT3B0aW9uc1QgPSB7fSxcclxuICAgICk6IElEaXNwb3NhYmxlIHtcclxuICAgICAgY29uc3QgYWZ0ZXJSZW1haW5pbmdUaW1lID0gb3B0aW9ucy5hZnRlclJlbWFpbmluZ1RpbWUgfHwgNDk7XHJcbiAgICAgIC8vIGZsb3dsaW50LW5leHQtbGluZSBza2V0Y2h5LW51bGwtbnVtYmVyOm9mZlxyXG4gICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDUwMDtcclxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfO1xyXG4gICAgICBsZXQgaWQ7XHJcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgIGZ1bmN0aW9uIGZuKGRlYWRsaW5lKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZGVhZGxpbmUudGltZVJlbWFpbmluZygpID49IGFmdGVyUmVtYWluaW5nVGltZSB8fFxyXG4gICAgICAgICAgRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA+PSB0aW1lb3V0XHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBpbnZhcmlhbnQoY2FsbGJhY2sgIT0gbnVsbCk7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgaWQgPSBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlkID0gcmVxdWVzdElkbGVDYWxsYmFjayhmbiwge1xyXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0IC0gKERhdGUubm93KCkgLSBzdGFydFRpbWUpLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlkID0gcmVxdWVzdElkbGVDYWxsYmFjayhmbiwge3RpbWVvdXR9KTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrKGlkKTtcclxuICAgICAgICAgICAgaWQgPSBjYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICA6IC8vIFVzaW5nIE5vZGUgQVBJXHJcbiAgICBmdW5jdGlvbiBzY2hlZHVsZUlkbGVDYWxsYmFjayhcclxuICAgICAgY2FsbGJhY2s6IENhbGxiYWNrVCxcclxuICAgICAgb3B0aW9ucz86IE9wdGlvbnNULFxyXG4gICAgKTogSURpc3Bvc2FibGUge1xyXG4gICAgICBjb25zdCBpZCA9IHNldEltbWVkaWF0ZShjYWxsYmFjayk7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZGlzcG9zZSgpIHtcclxuICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGlkKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSk7XHJcbiJdfQ==