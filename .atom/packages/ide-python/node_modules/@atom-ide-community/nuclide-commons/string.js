"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stringifyError = stringifyError;
exports.maybeToString = maybeToString;
exports.relativeDate = relativeDate;
exports.countOccurrences = countOccurrences;
exports.shellParse = shellParse;
exports.shellParseWithGlobs = shellParseWithGlobs;
exports.shellQuote = shellQuote;
exports.removeCommonPrefix = removeCommonPrefix;
exports.removeCommonSuffix = removeCommonSuffix;
exports.shorten = shorten;
exports.splitOnce = splitOnce;
exports.indent = indent;
exports.pluralize = pluralize;
exports.capitalize = capitalize;
exports.getMatchRanges = getMatchRanges;
exports.escapeMarkdown = escapeMarkdown;
exports.ZERO_WIDTH_SPACE = exports.ELLIPSIS_CHAR = exports.URL_REGEX = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _shellQuote = require("./_shell-quote");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
function stringifyError(error) {
  return `name: ${error.name}, message: ${error.message}, stack: ${error.stack}.`;
} // As of Flow v0.28, Flow does not alllow implicit string coercion of null or undefined. Use this to
// make it explicit.


function maybeToString(str) {
  // We don't want to encourage the use of this function directly because it coerces anything to a
  // string. We get stricter typechecking by using maybeToString, so it should generally be
  // preferred.
  return String(str);
}
/**
 * Originally adapted from https://github.com/azer/relative-date.
 * We're including it because of https://github.com/npm/npm/issues/12012
 */


const SECOND = 1000;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const WEEK = 7 * DAY;
const YEAR = DAY * 365;
const MONTH = YEAR / 12;
const shortFormats = [[0.7 * MINUTE, 'now'], [1.5 * MINUTE, '1m'], [60 * MINUTE, 'm', MINUTE], [1.5 * HOUR, '1h'], [DAY, 'h', HOUR], [2 * DAY, '1d'], [7 * DAY, 'd', DAY], [1.5 * WEEK, '1w'], [MONTH, 'w', WEEK], [1.5 * MONTH, '1mo'], [YEAR, 'mo', MONTH], [1.5 * YEAR, '1y'], [Number.MAX_VALUE, 'y', YEAR]];
const longFormats = [[0.7 * MINUTE, 'just now'], [1.5 * MINUTE, 'a minute ago'], [60 * MINUTE, 'minutes ago', MINUTE], [1.5 * HOUR, 'an hour ago'], [DAY, 'hours ago', HOUR], [2 * DAY, 'yesterday'], [7 * DAY, 'days ago', DAY], [1.5 * WEEK, 'a week ago'], [MONTH, 'weeks ago', WEEK], [1.5 * MONTH, 'a month ago'], [YEAR, 'months ago', MONTH], [1.5 * YEAR, 'a year ago'], [Number.MAX_VALUE, 'years ago', YEAR]];
const longFormatsNumbers = [[0.7 * MINUTE, 'just now'], [1.5 * MINUTE, '1 minute ago'], [60 * MINUTE, 'minutes ago', MINUTE], [1.5 * HOUR, '1 hour ago'], [DAY, 'hours ago', HOUR], [2 * DAY, 'yesterday'], [7 * DAY, 'days ago', DAY], [1.5 * WEEK, '1 week ago'], [MONTH, 'weeks ago', WEEK], [1.5 * MONTH, '1 month ago'], [YEAR, 'months ago', MONTH], [1.5 * YEAR, '1 year ago'], [Number.MAX_VALUE, 'years ago', YEAR]];

function relativeDate(input_, reference_, useShortVariant = false, useNumbersOnly = false) {
  let input = input_;
  let reference = reference_;

  if (input instanceof Date) {
    input = input.getTime();
  } // flowlint-next-line sketchy-null-number:off


  if (!reference) {
    reference = new Date().getTime();
  }

  if (reference instanceof Date) {
    reference = reference.getTime();
  }

  const delta = reference - input;
  const formats = useShortVariant ? shortFormats : useNumbersOnly ? longFormatsNumbers : longFormats;

  for (const [limit, relativeFormat, remainder] of formats) {
    if (delta < limit) {
      if (typeof remainder === 'number') {
        return Math.round(delta / remainder) + (useShortVariant ? '' : ' ') + relativeFormat;
      } else {
        return relativeFormat;
      }
    }
  }

  throw new Error('This should never be reached.');
}
/**
 * Count the number of occurrences of `char` in `str`.
 * `char` must be a string of length 1.
 */


function countOccurrences(haystack, _char) {
  (0, _assert.default)(_char.length === 1, 'char must be a string of length 1');
  let count = 0;

  const code = _char.charCodeAt(0);

  for (let i = 0; i < haystack.length; i++) {
    if (haystack.charCodeAt(i) === code) {
      count++;
    }
  }

  return count;
}
/**
 * shell-quote's parse allows pipe operators and comments.
 * Generally users don't care about this, so throw if we encounter any operators.
 */


function shellParse(str, env) {
  const result = (0, _shellQuote.parse)(str, env);

  for (let i = 0; i < result.length; i++) {
    if (typeof result[i] !== 'string') {
      if (result[i].op != null) {
        throw new Error(`Unexpected operator "${result[i].op}" provided to shellParse`);
      } else {
        throw new Error(`Unexpected comment "${result[i].comment}" provided to shellParse`);
      }
    }
  }

  return result;
}
/**
 * shell-quote's parse allows pipe operators and comments and globs
 * We treat glob patterns as normal strings. For the other operators, we throw.
 */


function shellParseWithGlobs(str, env) {
  const result = (0, _shellQuote.parse)(str, env);

  for (let i = 0; i < result.length; i++) {
    if (typeof result[i] !== 'string') {
      if (result[i].op === 'glob') {
        result[i] = result[i].pattern;
      } else if (result[i].op != null) {
        throw new Error(`Unexpected operator "${result[i].op}" provided to shellParse`);
      } else {
        throw new Error(`Unexpected comment "${result[i].comment}" provided to shellParse`);
      }
    }
  }

  return result;
}
/**
 * Technically you can pass in { operator: string } here,
 * but we don't use that in most APIs.
 */


function shellQuote(args) {
  return (0, _shellQuote.quote)(args);
}

function removeCommonPrefix(a, b) {
  let i = 0;

  while (a[i] === b[i] && i < a.length && i < b.length) {
    i++;
  }

  return [a.substring(i), b.substring(i)];
}

function removeCommonSuffix(a, b) {
  let i = 0;

  while (a[a.length - 1 - i] === b[b.length - 1 - i] && i < a.length && i < b.length) {
    i++;
  }

  return [a.substring(0, a.length - i), b.substring(0, b.length - i)];
}

function shorten(str, maxLength, suffix) {
  return str.length < maxLength ? str : str.slice(0, maxLength) + (suffix || '');
}
/**
 * Like String.split, but only splits once.
 */


function splitOnce(str, separator) {
  const index = str.indexOf(separator);
  return index === -1 ? [str, null] : [str.slice(0, index), str.slice(index + separator.length)];
}
/**
 * Indents each line by the specified number of characters.
 */


function indent(str, level = 2, _char2 = ' ') {
  return str.replace(/^([^\n])/gm, _char2.repeat(level) + '$1');
}

function pluralize(noun, count) {
  return count === 1 ? noun : noun + 's';
}

function capitalize(str) {
  return str.length === 0 ? str : str.charAt(0).toUpperCase().concat(str.slice(1));
}

/**
 * Returns a list of ranges where needle occurs in haystack.
 * This will *not* return overlapping matches; i.e. the returned list will be disjoint.
 * This makes it easier to use for e.g. highlighting matches in a UI.
 */
function getMatchRanges(haystack, needle) {
  if (needle === '') {
    // Not really a valid use.
    return [];
  }

  const ranges = [];
  let matchIndex = 0;

  while ((matchIndex = haystack.indexOf(needle, matchIndex)) !== -1) {
    const prevRange = ranges[ranges.length - 1];

    if (prevRange != null && prevRange[1] === matchIndex) {
      prevRange[1] += needle.length;
    } else {
      ranges.push([matchIndex, matchIndex + needle.length]);
    }

    matchIndex += needle.length;
  }

  return ranges;
}

function escapeMarkdown(markdown) {
  // Which characters can be backslash-escaped?
  // markdown:   ! #    ()*+ -.        [\] _`{ }   https://daringfireball.net/projects/markdown/syntax#backslash
  // commonMark: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~  https://spec.commonmark.org/0.28/#backslash-escapes
  // We'll only backslash-escape the lowest common denominator.
  const slashEscaped = markdown.replace(/[#!()*+\-.[\\\]_`{}]/g, '\\$&'); // And HTML tags need to be &lt; &gt; escaped.

  return slashEscaped.replace(/</g, '&lt;').replace(/>/g, '&gt;');
} // Originally copied from:
// http://stackoverflow.com/questions/3809401/what-is-a-good-regular-expression-to-match-a-url
// But adopted to match `www.` urls as well as `https?` urls
// and `!` as acceptable url piece.
// Then optimized with https://www.npmjs.com/package/regexp-tree.
// Added a single matching group for use with String.split.
// eslint-disable-next-line max-len


const URL_REGEX = /(https?:\/\/(?:www\.)?[-\w@:%.+~#=]{2,256}\.[a-z]{2,6}\b[-\w@:%+.~#?&/=!]*|www\.[-\w@:%.+~#=]{2,256}\.[a-z]{2,6}\b[-\w@:%+.~#?&/=!]*)/;
exports.URL_REGEX = URL_REGEX;
const ELLIPSIS_CHAR = '\u2026';
exports.ELLIPSIS_CHAR = ELLIPSIS_CHAR;
const ZERO_WIDTH_SPACE = '\u200B';
exports.ZERO_WIDTH_SPACE = ZERO_WIDTH_SPACE;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3N0cmluZy5qcyJdLCJuYW1lcyI6WyJzdHJpbmdpZnlFcnJvciIsImVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJzdGFjayIsIm1heWJlVG9TdHJpbmciLCJzdHIiLCJTdHJpbmciLCJTRUNPTkQiLCJNSU5VVEUiLCJIT1VSIiwiREFZIiwiV0VFSyIsIllFQVIiLCJNT05USCIsInNob3J0Rm9ybWF0cyIsIk51bWJlciIsIk1BWF9WQUxVRSIsImxvbmdGb3JtYXRzIiwibG9uZ0Zvcm1hdHNOdW1iZXJzIiwicmVsYXRpdmVEYXRlIiwiaW5wdXRfIiwicmVmZXJlbmNlXyIsInVzZVNob3J0VmFyaWFudCIsInVzZU51bWJlcnNPbmx5IiwiaW5wdXQiLCJyZWZlcmVuY2UiLCJEYXRlIiwiZ2V0VGltZSIsImRlbHRhIiwiZm9ybWF0cyIsImxpbWl0IiwicmVsYXRpdmVGb3JtYXQiLCJyZW1haW5kZXIiLCJNYXRoIiwicm91bmQiLCJFcnJvciIsImNvdW50T2NjdXJyZW5jZXMiLCJoYXlzdGFjayIsImNoYXIiLCJsZW5ndGgiLCJjb3VudCIsImNvZGUiLCJjaGFyQ29kZUF0IiwiaSIsInNoZWxsUGFyc2UiLCJlbnYiLCJyZXN1bHQiLCJvcCIsImNvbW1lbnQiLCJzaGVsbFBhcnNlV2l0aEdsb2JzIiwicGF0dGVybiIsInNoZWxsUXVvdGUiLCJhcmdzIiwicmVtb3ZlQ29tbW9uUHJlZml4IiwiYSIsImIiLCJzdWJzdHJpbmciLCJyZW1vdmVDb21tb25TdWZmaXgiLCJzaG9ydGVuIiwibWF4TGVuZ3RoIiwic3VmZml4Iiwic2xpY2UiLCJzcGxpdE9uY2UiLCJzZXBhcmF0b3IiLCJpbmRleCIsImluZGV4T2YiLCJpbmRlbnQiLCJsZXZlbCIsInJlcGxhY2UiLCJyZXBlYXQiLCJwbHVyYWxpemUiLCJub3VuIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiY29uY2F0IiwiZ2V0TWF0Y2hSYW5nZXMiLCJuZWVkbGUiLCJyYW5nZXMiLCJtYXRjaEluZGV4IiwicHJldlJhbmdlIiwicHVzaCIsImVzY2FwZU1hcmtkb3duIiwibWFya2Rvd24iLCJzbGFzaEVzY2FwZWQiLCJVUkxfUkVHRVgiLCJFTExJUFNJU19DSEFSIiwiWkVST19XSURUSF9TUEFDRSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZQTs7QUFDQTs7OztBQWJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLTyxTQUFTQSxjQUFULENBQXdCQyxLQUF4QixFQUE4QztBQUNuRCxTQUFRLFNBQVFBLEtBQUssQ0FBQ0MsSUFBSyxjQUFhRCxLQUFLLENBQUNFLE9BQVEsWUFDcERGLEtBQUssQ0FBQ0csS0FDUCxHQUZEO0FBR0QsQyxDQUVEO0FBQ0E7OztBQUNPLFNBQVNDLGFBQVQsQ0FBdUJDLEdBQXZCLEVBQTZDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLE1BQU0sQ0FBQ0QsR0FBRCxDQUFiO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBTUUsTUFBTSxHQUFHLElBQWY7QUFDQSxNQUFNQyxNQUFNLEdBQUcsS0FBS0QsTUFBcEI7QUFDQSxNQUFNRSxJQUFJLEdBQUcsS0FBS0QsTUFBbEI7QUFDQSxNQUFNRSxHQUFHLEdBQUcsS0FBS0QsSUFBakI7QUFDQSxNQUFNRSxJQUFJLEdBQUcsSUFBSUQsR0FBakI7QUFDQSxNQUFNRSxJQUFJLEdBQUdGLEdBQUcsR0FBRyxHQUFuQjtBQUNBLE1BQU1HLEtBQUssR0FBR0QsSUFBSSxHQUFHLEVBQXJCO0FBRUEsTUFBTUUsWUFBWSxHQUFHLENBQ25CLENBQUMsTUFBTU4sTUFBUCxFQUFlLEtBQWYsQ0FEbUIsRUFFbkIsQ0FBQyxNQUFNQSxNQUFQLEVBQWUsSUFBZixDQUZtQixFQUduQixDQUFDLEtBQUtBLE1BQU4sRUFBYyxHQUFkLEVBQW1CQSxNQUFuQixDQUhtQixFQUluQixDQUFDLE1BQU1DLElBQVAsRUFB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LENBQUNBLE1BQU0sQ0FBQ3ZDLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBeEI7O0FBQ0EsUUFBSXlDLFNBQVMsSUFBSSxJQUFiLElBQXFCQSxTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCRCxVQUExQyxFQUFzRDtBQUNwREMsTUFBQUEsU0FBUyxDQUFDLENBQUQsQ0FBVCxJQUFnQkgsTUFBTSxDQUFDdEMsTUFBdkI7QUFDRCxLQUZELE1BRU87QUFDTHVDLE1BQUFBLE1BQU0sQ0FBQ0csSUFBUCxDQUFZLENBQUNGLFVBQUQsRUFBYUEsVUFBVSxHQUFHRixNQUFNLENBQUN0QyxNQUFqQyxDQUFaO0FBQ0Q7O0FBQ0R3QyxJQUFBQSxVQUFVLElBQUlGLE1BQU0sQ0FBQ3RDLE1BQXJCO0FBQ0Q7O0FBQ0QsU0FBT3VDLE1BQVA7QUFDRDs7QUFFTSxTQUFTSSxjQUFULENBQXdCQyxRQUF4QixFQUFrRDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU1DLFlBQVksR0FBR0QsUUFBUSxDQUFDZixPQUFULENBQWlCLHVCQUFqQixFQUEwQyxNQUExQyxDQUFyQixDQUx1RCxDQU12RDs7QUFDQSxTQUFPZ0IsWUFBWSxDQUFDaEIsT0FBYixDQUFxQixJQUFyQixFQUEyQixNQUEzQixFQUFtQ0EsT0FBbkMsQ0FBMkMsSUFBM0MsRUFBaUQsTUFBakQsQ0FBUDtBQUNELEMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sTUFBTWlCLFNBQVMsR0FBRyx1SUFBbEI7O0FBRUEsTUFBTUMsYUFBYSxHQUFHLFFBQXRCOztBQUNBLE1BQU1DLGdCQUFnQixHQUFHLFFBQXpCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcclxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XHJcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxyXG4gKlxyXG4gKiBAZmxvd1xyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQge3BhcnNlLCBxdW90ZX0gZnJvbSAnLi9fc2hlbGwtcXVvdGUnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yKGVycm9yOiBFcnJvcik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGBuYW1lOiAke2Vycm9yLm5hbWV9LCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9LCBzdGFjazogJHtcclxuICAgIGVycm9yLnN0YWNrXHJcbiAgfS5gO1xyXG59XHJcblxyXG4vLyBBcyBvZiBGbG93IHYwLjI4LCBGbG93IGRvZXMgbm90IGFsbGxvdyBpbXBsaWNpdCBzdHJpbmcgY29lcmNpb24gb2YgbnVsbCBvciB1bmRlZmluZWQuIFVzZSB0aGlzIHRvXHJcbi8vIG1ha2UgaXQgZXhwbGljaXQuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXliZVRvU3RyaW5nKHN0cjogP3N0cmluZyk6IHN0cmluZyB7XHJcbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBlbmNvdXJhZ2UgdGhlIHVzZSBvZiB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5IGJlY2F1c2UgaXQgY29lcmNlcyBhbnl0aGluZyB0byBhXHJcbiAgLy8gc3RyaW5nLiBXZSBnZXQgc3RyaWN0ZXIgdHlwZWNoZWNraW5nIGJ5IHVzaW5nIG1heWJlVG9TdHJpbmcsIHNvIGl0IHNob3VsZCBnZW5lcmFsbHkgYmVcclxuICAvLyBwcmVmZXJyZWQuXHJcbiAgcmV0dXJuIFN0cmluZyhzdHIpO1xyXG59XHJcblxyXG4vKipcclxuICogT3JpZ2luYWxseSBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2F6ZXIvcmVsYXRpdmUtZGF0ZS5cclxuICogV2UncmUgaW5jbHVkaW5nIGl0IGJlY2F1c2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ucG0vaXNzdWVzLzEyMDEyXHJcbiAqL1xyXG5jb25zdCBTRUNPTkQgPSAxMDAwO1xyXG5jb25zdCBNSU5VVEUgPSA2MCAqIFNFQ09ORDtcclxuY29uc3QgSE9VUiA9IDYwICogTUlOVVRFO1xyXG5jb25zdCBEQVkgPSAyNCAqIEhPVVI7XHJcbmNvbnN0IFdFRUsgPSA3ICogREFZO1xyXG5jb25zdCBZRUFSID0gREFZICogMzY1O1xyXG5jb25zdCBNT05USCA9IFlFQVIgLyAxMjtcclxuXHJcbmNvbnN0IHNob3J0Rm9ybWF0cyA9IFtcclxuICBbMC43ICogTUlOVVRFLCAnbm93J10sXHJcbiAgWzEuNSAqIE1JTlVURSwgJzFtJ10sXHJcbiAgWzYwICogTUlOVVRFLCAnbScsIE1JTlVURV0sXHJcbiAgWzEuNSAqIEhPVVIsICcxaCddLFxyXG4gIFtEQVksICdoJywgSE9VUl0sXHJcbiAgWzIgKiBEQVksICcxZCddLFxyXG4gIFs3ICogREFZLCAnZCcsIERBWV0sXHJcbiAgWzEuNSAqIFdFRUssICcxdyddLFxyXG4gIFtNT05USCwgJ3cnLCBXRUVLXSxcclxuICBbMS41ICogTU9OVEgsICcxbW8nXSxcclxuICBbWUVBUiwgJ21vJywgTU9OVEhdLFxyXG4gIFsxLjUgKiBZRUFSLCAnMXknXSxcclxuICBbTnVtYmVyLk1BWF9WQUxVRSwgJ3knLCBZRUFSXSxcclxuXTtcclxuXHJcbmNvbnN0IGxvbmdGb3JtYXRzID0gW1xyXG4gIFswLjcgKiBNSU5VVEUsICdqdXN0IG5vdyddLFxyXG4gIFsxLjUgKiBNSU5VVEUsICdhIG1pbnV0ZSBhZ28nXSxcclxuICBbNjAgKiBNSU5VVEUsICdtaW51dGVzIGFnbycsIE1JTlVURV0sXHJcbiAgWzEuNSAqIEhPVVIsICdhbiBob3VyIGFnbyddLFxyXG4gIFtEQVksICdob3VycyBhZ28nLCBIT1VSXSxcclxuICBbMiAqIERBWSwgJ3llc3RlcmRheSddLFxyXG4gIFs3ICogREFZLCAnZGF5cyBhZ28nLCBEQVldLFxyXG4gIFsxLjUgKiBXRUVLLCAnYSB3ZWVrIGFnbyddLFxyXG4gIFtNT05USCwgJ3dlZWtzIGFnbycsIFdFRUtdLFxyXG4gIFsxLjUgKiBNT05USCwgJ2EgbW9udGggYWdvJ10sXHJcbiAgW1lFQVIsICdtb250aHMgYWdvJywgTU9OVEhdLFxyXG4gIFsxLjUgKiBZRUFSLCAnYSB5ZWFyIGFnbyddLFxyXG4gIFtOdW1iZXIuTUFYX1ZBTFVFLCAneWVhcnMgYWdvJywgWUVBUl0sXHJcbl07XHJcblxyXG5jb25zdCBsb25nRm9ybWF0c051bWJlcnMgPSBbXHJcbiAgWzAuNyAqIE1JTlVURSwgJ2p1c3Qgbm93J10sXHJcbiAgWzEuNSAqIE1JTlVURSwgJzEgbWludXRlIGFnbyddLFxyXG4gIFs2MCAqIE1JTlVURSwgJ21pbnV0ZXMgYWdvJywgTUlOVVRFXSxcclxuICBbMS41ICogSE9VUiwgJzEgaG91ciBhZ28nXSxcclxuICBbREFZLCAnaG91cnMgYWdvJywgSE9VUl0sXHJcbiAgWzIgKiBEQVksICd5ZXN0ZXJkYXknXSxcclxuICBbNyAqIERBWSwgJ2RheXMgYWdvJywgREFZXSxcclxuICBbMS41ICogV0VFSywgJzEgd2VlayBhZ28nXSxcclxuICBbTU9OVEgsICd3ZWVrcyBhZ28nLCBXRUVLXSxcclxuICBbMS41ICogTU9OVEgsICcxIG1vbnRoIGFnbyddLFxyXG4gIFtZRUFSLCAnbW9udGhzIGFnbycsIE1PTlRIXSxcclxuICBbMS41ICogWUVBUiwgJzEgeWVhciBhZ28nXSxcclxuICBbTnVtYmVyLk1BWF9WQUxVRSwgJ3llYXJzIGFnbycsIFlFQVJdLFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbGF0aXZlRGF0ZShcclxuICBpbnB1dF86IG51bWJlciB8IERhdGUsXHJcbiAgcmVmZXJlbmNlXz86IG51bWJlciB8IERhdGUsXHJcbiAgdXNlU2hvcnRWYXJpYW50PzogYm9vbGVhbiA9IGZhbHNlLFxyXG4gIHVzZU51bWJlcnNPbmx5PzogYm9vbGVhbiA9IGZhbHNlLFxyXG4pOiBzdHJpbmcge1xyXG4gIGxldCBpbnB1dCA9IGlucHV0XztcclxuICBsZXQgcmVmZXJlbmNlID0gcmVmZXJlbmNlXztcclxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICBpbnB1dCA9IGlucHV0LmdldFRpbWUoKTtcclxuICB9XHJcbiAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHNrZXRjaHktbnVsbC1udW1iZXI6b2ZmXHJcbiAgaWYgKCFyZWZlcmVuY2UpIHtcclxuICAgIHJlZmVyZW5jZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gIH1cclxuICBpZiAocmVmZXJlbmNlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgcmVmZXJlbmNlID0gcmVmZXJlbmNlLmdldFRpbWUoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGRlbHRhID0gcmVmZXJlbmNlIC0gaW5wdXQ7XHJcbiAgY29uc3QgZm9ybWF0cyA9IHVzZVNob3J0VmFyaWFudFxyXG4gICAgPyBzaG9ydEZvcm1hdHNcclxuICAgIDogdXNlTnVtYmVyc09ubHlcclxuICAgICAgPyBsb25nRm9ybWF0c051bWJlcnNcclxuICAgICAgOiBsb25nRm9ybWF0cztcclxuICBmb3IgKGNvbnN0IFtsaW1pdCwgcmVsYXRpdmVGb3JtYXQsIHJlbWFpbmRlcl0gb2YgZm9ybWF0cykge1xyXG4gICAgaWYgKGRlbHRhIDwgbGltaXQpIHtcclxuICAgICAgaWYgKHR5cGVvZiByZW1haW5kZXIgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIE1hdGgucm91bmQoZGVsdGEgLyByZW1haW5kZXIpICtcclxuICAgICAgICAgICh1c2VTaG9ydFZhcmlhbnQgPyAnJyA6ICcgJykgK1xyXG4gICAgICAgICAgcmVsYXRpdmVGb3JtYXRcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZWxhdGl2ZUZvcm1hdDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBuZXZlciBiZSByZWFjaGVkLicpO1xyXG59XHJcblxyXG4vKipcclxuICogQ291bnQgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBvZiBgY2hhcmAgaW4gYHN0cmAuXHJcbiAqIGBjaGFyYCBtdXN0IGJlIGEgc3RyaW5nIG9mIGxlbmd0aCAxLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50T2NjdXJyZW5jZXMoaGF5c3RhY2s6IHN0cmluZywgY2hhcjogc3RyaW5nKSB7XHJcbiAgaW52YXJpYW50KGNoYXIubGVuZ3RoID09PSAxLCAnY2hhciBtdXN0IGJlIGEgc3RyaW5nIG9mIGxlbmd0aCAxJyk7XHJcblxyXG4gIGxldCBjb3VudCA9IDA7XHJcbiAgY29uc3QgY29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaGF5c3RhY2suY2hhckNvZGVBdChpKSA9PT0gY29kZSkge1xyXG4gICAgICBjb3VudCsrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY291bnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzaGVsbC1xdW90ZSdzIHBhcnNlIGFsbG93cyBwaXBlIG9wZXJhdG9ycyBhbmQgY29tbWVudHMuXHJcbiAqIEdlbmVyYWxseSB1c2VycyBkb24ndCBjYXJlIGFib3V0IHRoaXMsIHNvIHRocm93IGlmIHdlIGVuY291bnRlciBhbnkgb3BlcmF0b3JzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNoZWxsUGFyc2Uoc3RyOiBzdHJpbmcsIGVudj86IE9iamVjdCk6IEFycmF5PHN0cmluZz4ge1xyXG4gIGNvbnN0IHJlc3VsdCA9IHBhcnNlKHN0ciwgZW52KTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHR5cGVvZiByZXN1bHRbaV0gIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGlmIChyZXN1bHRbaV0ub3AgIT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBVbmV4cGVjdGVkIG9wZXJhdG9yIFwiJHtyZXN1bHRbaV0ub3B9XCIgcHJvdmlkZWQgdG8gc2hlbGxQYXJzZWAsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgVW5leHBlY3RlZCBjb21tZW50IFwiJHtyZXN1bHRbaV0uY29tbWVudH1cIiBwcm92aWRlZCB0byBzaGVsbFBhcnNlYCxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzaGVsbC1xdW90ZSdzIHBhcnNlIGFsbG93cyBwaXBlIG9wZXJhdG9ycyBhbmQgY29tbWVudHMgYW5kIGdsb2JzXHJcbiAqIFdlIHRyZWF0IGdsb2IgcGF0dGVybnMgYXMgbm9ybWFsIHN0cmluZ3MuIEZvciB0aGUgb3RoZXIgb3BlcmF0b3JzLCB3ZSB0aHJvdy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaGVsbFBhcnNlV2l0aEdsb2JzKHN0cjogc3RyaW5nLCBlbnY/OiBPYmplY3QpOiBBcnJheTxzdHJpbmc+IHtcclxuICBjb25zdCByZXN1bHQgPSBwYXJzZShzdHIsIGVudik7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICh0eXBlb2YgcmVzdWx0W2ldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICBpZiAocmVzdWx0W2ldLm9wID09PSAnZ2xvYicpIHtcclxuICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbaV0ucGF0dGVybjtcclxuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbaV0ub3AgIT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIGBVbmV4cGVjdGVkIG9wZXJhdG9yIFwiJHtyZXN1bHRbaV0ub3B9XCIgcHJvdmlkZWQgdG8gc2hlbGxQYXJzZWAsXHJcbiAgICAgICAgKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgVW5leHBlY3RlZCBjb21tZW50IFwiJHtyZXN1bHRbaV0uY29tbWVudH1cIiBwcm92aWRlZCB0byBzaGVsbFBhcnNlYCxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZWNobmljYWxseSB5b3UgY2FuIHBhc3MgaW4geyBvcGVyYXRvcjogc3RyaW5nIH0gaGVyZSxcclxuICogYnV0IHdlIGRvbid0IHVzZSB0aGF0IGluIG1vc3QgQVBJcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaGVsbFF1b3RlKGFyZ3M6IEFycmF5PHN0cmluZz4pOiBzdHJpbmcge1xyXG4gIHJldHVybiBxdW90ZShhcmdzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbW1vblByZWZpeChhOiBzdHJpbmcsIGI6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZ10ge1xyXG4gIGxldCBpID0gMDtcclxuICB3aGlsZSAoYVtpXSA9PT0gYltpXSAmJiBpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoKSB7XHJcbiAgICBpKys7XHJcbiAgfVxyXG4gIHJldHVybiBbYS5zdWJzdHJpbmcoaSksIGIuc3Vic3RyaW5nKGkpXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbW1vblN1ZmZpeChhOiBzdHJpbmcsIGI6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZ10ge1xyXG4gIGxldCBpID0gMDtcclxuICB3aGlsZSAoXHJcbiAgICBhW2EubGVuZ3RoIC0gMSAtIGldID09PSBiW2IubGVuZ3RoIC0gMSAtIGldICYmXHJcbiAgICBpIDwgYS5sZW5ndGggJiZcclxuICAgIGkgPCBiLmxlbmd0aFxyXG4gICkge1xyXG4gICAgaSsrO1xyXG4gIH1cclxuICByZXR1cm4gW2Euc3Vic3RyaW5nKDAsIGEubGVuZ3RoIC0gaSksIGIuc3Vic3RyaW5nKDAsIGIubGVuZ3RoIC0gaSldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2hvcnRlbihcclxuICBzdHI6IHN0cmluZyxcclxuICBtYXhMZW5ndGg6IG51bWJlcixcclxuICBzdWZmaXg/OiBzdHJpbmcsXHJcbik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIHN0ci5sZW5ndGggPCBtYXhMZW5ndGhcclxuICAgID8gc3RyXHJcbiAgICA6IHN0ci5zbGljZSgwLCBtYXhMZW5ndGgpICsgKHN1ZmZpeCB8fCAnJyk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaWtlIFN0cmluZy5zcGxpdCwgYnV0IG9ubHkgc3BsaXRzIG9uY2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRPbmNlKHN0cjogc3RyaW5nLCBzZXBhcmF0b3I6IHN0cmluZyk6IFtzdHJpbmcsID9zdHJpbmddIHtcclxuICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKHNlcGFyYXRvcik7XHJcbiAgcmV0dXJuIGluZGV4ID09PSAtMVxyXG4gICAgPyBbc3RyLCBudWxsXVxyXG4gICAgOiBbc3RyLnNsaWNlKDAsIGluZGV4KSwgc3RyLnNsaWNlKGluZGV4ICsgc2VwYXJhdG9yLmxlbmd0aCldO1xyXG59XHJcblxyXG4vKipcclxuICogSW5kZW50cyBlYWNoIGxpbmUgYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgY2hhcmFjdGVycy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmRlbnQoXHJcbiAgc3RyOiBzdHJpbmcsXHJcbiAgbGV2ZWw6IG51bWJlciA9IDIsXHJcbiAgY2hhcjogc3RyaW5nID0gJyAnLFxyXG4pOiBzdHJpbmcge1xyXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXihbXlxcbl0pL2dtLCBjaGFyLnJlcGVhdChsZXZlbCkgKyAnJDEnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBsdXJhbGl6ZShub3VuOiBzdHJpbmcsIGNvdW50OiBudW1iZXIpIHtcclxuICByZXR1cm4gY291bnQgPT09IDEgPyBub3VuIDogbm91biArICdzJztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIHJldHVybiBzdHIubGVuZ3RoID09PSAwXHJcbiAgICA/IHN0clxyXG4gICAgOiBzdHJcclxuICAgICAgICAuY2hhckF0KDApXHJcbiAgICAgICAgLnRvVXBwZXJDYXNlKClcclxuICAgICAgICAuY29uY2F0KHN0ci5zbGljZSgxKSk7XHJcbn1cclxuXHJcbnR5cGUgTWF0Y2hSYW5nZSA9IFsvKiBzdGFydCAqLyBudW1iZXIsIC8qIGVuZCAqLyBudW1iZXJdO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBsaXN0IG9mIHJhbmdlcyB3aGVyZSBuZWVkbGUgb2NjdXJzIGluIGhheXN0YWNrLlxyXG4gKiBUaGlzIHdpbGwgKm5vdCogcmV0dXJuIG92ZXJsYXBwaW5nIG1hdGNoZXM7IGkuZS4gdGhlIHJldHVybmVkIGxpc3Qgd2lsbCBiZSBkaXNqb2ludC5cclxuICogVGhpcyBtYWtlcyBpdCBlYXNpZXIgdG8gdXNlIGZvciBlLmcuIGhpZ2hsaWdodGluZyBtYXRjaGVzIGluIGEgVUkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF0Y2hSYW5nZXMoXHJcbiAgaGF5c3RhY2s6IHN0cmluZyxcclxuICBuZWVkbGU6IHN0cmluZyxcclxuKTogQXJyYXk8TWF0Y2hSYW5nZT4ge1xyXG4gIGlmIChuZWVkbGUgPT09ICcnKSB7XHJcbiAgICAvLyBOb3QgcmVhbGx5IGEgdmFsaWQgdXNlLlxyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgcmFuZ2VzID0gW107XHJcbiAgbGV0IG1hdGNoSW5kZXggPSAwO1xyXG4gIHdoaWxlICgobWF0Y2hJbmRleCA9IGhheXN0YWNrLmluZGV4T2YobmVlZGxlLCBtYXRjaEluZGV4KSkgIT09IC0xKSB7XHJcbiAgICBjb25zdCBwcmV2UmFuZ2UgPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdO1xyXG4gICAgaWYgKHByZXZSYW5nZSAhPSBudWxsICYmIHByZXZSYW5nZVsxXSA9PT0gbWF0Y2hJbmRleCkge1xyXG4gICAgICBwcmV2UmFuZ2VbMV0gKz0gbmVlZGxlLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJhbmdlcy5wdXNoKFttYXRjaEluZGV4LCBtYXRjaEluZGV4ICsgbmVlZGxlLmxlbmd0aF0pO1xyXG4gICAgfVxyXG4gICAgbWF0Y2hJbmRleCArPSBuZWVkbGUubGVuZ3RoO1xyXG4gIH1cclxuICByZXR1cm4gcmFuZ2VzO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlTWFya2Rvd24obWFya2Rvd246IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgLy8gV2hpY2ggY2hhcmFjdGVycyBjYW4gYmUgYmFja3NsYXNoLWVzY2FwZWQ/XHJcbiAgLy8gbWFya2Rvd246ICAgISAjICAgICgpKisgLS4gICAgICAgIFtcXF0gX2B7IH0gICBodHRwczovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXHJcbiAgLy8gY29tbW9uTWFyazogIVwiIyQlJicoKSorLC0uLzo7PD0+P0BbXFxdXl9ge3x9fiAgaHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMjgvI2JhY2tzbGFzaC1lc2NhcGVzXHJcbiAgLy8gV2UnbGwgb25seSBiYWNrc2xhc2gtZXNjYXBlIHRoZSBsb3dlc3QgY29tbW9uIGRlbm9taW5hdG9yLlxyXG4gIGNvbnN0IHNsYXNoRXNjYXBlZCA9IG1hcmtkb3duLnJlcGxhY2UoL1sjISgpKitcXC0uW1xcXFxcXF1fYHt9XS9nLCAnXFxcXCQmJyk7XHJcbiAgLy8gQW5kIEhUTUwgdGFncyBuZWVkIHRvIGJlICZsdDsgJmd0OyBlc2NhcGVkLlxyXG4gIHJldHVybiBzbGFzaEVzY2FwZWQucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcclxufVxyXG5cclxuLy8gT3JpZ2luYWxseSBjb3BpZWQgZnJvbTpcclxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zODA5NDAxL3doYXQtaXMtYS1nb29kLXJlZ3VsYXItZXhwcmVzc2lvbi10by1tYXRjaC1hLXVybFxyXG4vLyBCdXQgYWRvcHRlZCB0byBtYXRjaCBgd3d3LmAgdXJscyBhcyB3ZWxsIGFzIGBodHRwcz9gIHVybHNcclxuLy8gYW5kIGAhYCBhcyBhY2NlcHRhYmxlIHVybCBwaWVjZS5cclxuLy8gVGhlbiBvcHRpbWl6ZWQgd2l0aCBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9yZWdleHAtdHJlZS5cclxuLy8gQWRkZWQgYSBzaW5nbGUgbWF0Y2hpbmcgZ3JvdXAgZm9yIHVzZSB3aXRoIFN0cmluZy5zcGxpdC5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cclxuZXhwb3J0IGNvbnN0IFVSTF9SRUdFWCA9IC8oaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/Wy1cXHdAOiUuK34jPV17MiwyNTZ9XFwuW2Etel17Miw2fVxcYlstXFx3QDolKy5+Iz8mLz0hXSp8d3d3XFwuWy1cXHdAOiUuK34jPV17MiwyNTZ9XFwuW2Etel17Miw2fVxcYlstXFx3QDolKy5+Iz8mLz0hXSopLztcclxuXHJcbmV4cG9ydCBjb25zdCBFTExJUFNJU19DSEFSID0gJ1xcdTIwMjYnO1xyXG5leHBvcnQgY29uc3QgWkVST19XSURUSF9TUEFDRSA9ICdcXHUyMDBCJztcclxuIl19