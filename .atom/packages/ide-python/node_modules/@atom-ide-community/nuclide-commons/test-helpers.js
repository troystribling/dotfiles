"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expectAsyncFailure = expectAsyncFailure;
exports.clearRequireCache = clearRequireCache;
exports.uncachedRequire = uncachedRequire;
exports.spyOnGetterValue = spyOnGetterValue;
exports.arePropertiesEqual = arePropertiesEqual;
exports.expectObservableToStartWith = expectObservableToStartWith;
exports.generateFixture = generateFixture;
exports.writeCoverage = writeCoverage;

var _assert = _interopRequireDefault(require("assert"));

var _fs = _interopRequireDefault(require("fs"));

var _temp = _interopRequireDefault(require("temp"));

var _uuid = _interopRequireDefault(require("uuid"));

var _fsPromise = _interopRequireDefault(require("./fsPromise"));

var _nuclideUri = _interopRequireDefault(require("./nuclideUri"));

var _promise = require("./promise");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
(0, _assert.default)(typeof atom !== 'undefined' && atom.inSpecMode() || process.env.NODE_ENV === 'test', 'Test helpers should only be used in spec mode');
/**
 * Verifies that a Promise fails with an Error with specific expectations. When
 * running a test where a Promise is expected to fail, it is important to verify
 * that it failed in the expected way to avoid false positives in test results.
 *
 * This function should be used with `await` inside `waitsForPromise()`.
 *
 * @param promise will be awaited. It is expected to reject. If it does not
 *     reject, then this function will return a rejected Promise.
 * @param verify should confirm expectations about the Error produced by the
 *     rejection of `promise`. If these expectations are not met, then
 *     `verify()` must throw an exception.
 */

async function expectAsyncFailure(promise, verify) {
  try {
    await promise;
    return Promise.reject(new Error('Promise should have failed, but did not.'));
  } catch (e) {
    verify(e);
  }
}
/**
 * This is useful for mocking a module that the module under test requires.
 * After setting up the mocks, you must invalidate the require cache and then
 * re-require the module under test so that it picks up the mocked
 * dependencies.
 *
 * The require parameter is needed because require is bound differently in each
 * file, and we need to execute this in the caller's context.
 */


function clearRequireCache(require, module) {
  delete require.cache[require.resolve(module)];
}

function uncachedRequire(require, module) {
  clearRequireCache(require, module); // $FlowIgnore

  return require(module);
}
/**
 * Jasmine has trouble spying on properties supplied by getters, so to make it
 * work we have to get the value, delete the getter, and set the value as a
 * property.
 *
 * This makes two assumptions:
 * - The getter is idempotent (otherwise, callers in other tests might be
 *   surprised when the value here is returned)
 * - The getter returns a function (otherwise, it doesn't make sense to spy on
 *   it)
 */


function spyOnGetterValue(object, f) {
  const value = object[f];
  delete object[f];
  object[f] = value;
  return spyOn(object, f);
}
/**
 * Checks if the two objects have equal properties. This considers a property
 * set to undefined to be equivalent to a property that was not set at all.
 */


function arePropertiesEqual(obj1, obj2) {
  const allProps = new Set();

  function addAllProps(obj) {
    for (const prop of Object.keys(obj)) {
      allProps.add(prop);
    }
  }

  [obj1, obj2].forEach(addAllProps);

  for (const prop of allProps) {
    if (obj1[prop] !== obj2[prop]) {
      return false;
    }
  }

  return true;
}
/**
 * Warning: Callsites *must* await the resulting promise, or test failures may go unreported or
 * misattributed.
 */


async function expectObservableToStartWith(source, expected) {
  const actual = await source.take(expected.length).toArray().toPromise();
  expect(actual).toEqual(expected);
}
/**
 * Takes of Map of file/file-content pairs, and creates a temp dir that matches
 * the file structure of the Map. Example:
 *
 * generateFixture('myfixture', new Map([
 *   ['foo.js'],
 *   ['bar/baz.txt', 'some text'],
 * ]));
 *
 * Creates:
 *
 * /tmp/myfixture_1/foo.js (empty file)
 * /tmp/myfixture_1/bar/baz.txt (with 'some text')
 */


async function generateFixture(fixtureName, files) {
  _temp.default.track();

  const MAX_CONCURRENT_FILE_OPS = 100;
  const tempDir = await _fsPromise.default.tempdir(fixtureName);

  if (files == null) {
    return tempDir;
  } // Map -> Array with full paths


  const fileTuples = Array.from(files, tuple => {
    // It's our own array - it's ok to mutate it
    tuple[0] = _nuclideUri.default.join(tempDir, tuple[0]);
    return tuple;
  }); // Dedupe the dirs that we have to make.

  const dirsToMake = fileTuples.map(([filename]) => _nuclideUri.default.dirname(filename)).filter((dirname, i, arr) => arr.indexOf(dirname) === i);
  await (0, _promise.asyncLimit)(dirsToMake, MAX_CONCURRENT_FILE_OPS, dirname => _fsPromise.default.mkdirp(dirname));
  await (0, _promise.asyncLimit)(fileTuples, MAX_CONCURRENT_FILE_OPS, ([filename, contents]) => {
    // We can't use fsPromise/fs-plus because it does too much extra work.
    // They call `mkdirp` before `writeFile`. We know that the target dir
    // exists, so we can optimize by going straight to `fs`. When you're
    // making 10k files, this adds ~500ms.
    return new Promise((resolve, reject) => {
      _fs.default.writeFile(filename, contents || '', err => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  });
  return tempDir;
}

function writeCoverage() {
  const {
    COVERAGE_DIR
  } = process.env;

  if (COVERAGE_DIR != null) {
    const coverage = global.__coverage__;

    if (coverage != null) {
      _fs.default.writeFileSync(_nuclideUri.default.join(COVERAGE_DIR, _uuid.default.v4() + '.json'), JSON.stringify(coverage));
    }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3Rlc3QtaGVscGVycy5qcyJdLCJuYW1lcyI6WyJhdG9tIiwiaW5TcGVjTW9kZSIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImV4cGVjdEFzeW5jRmFpbHVyZSIsInByb21pc2UiLCJ2ZXJpZnkiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJlIiwiY2xlYXJSZXF1aXJlQ2FjaGUiLCJyZXF1aXJlIiwibW9kdWxlIiwiY2FjaGUiLCJyZXNvbHZlIiwidW5jYWNoZWRSZXF1aXJlIiwic3B5T25HZXR0ZXJWYWx1ZSIsIm9iamVjdCIsImYiLCJ2YWx1ZSIsInNweU9uIiwiYXJlUHJvcGVydGllc0VxdWFsIiwib2JqMSIsIm9iajIiLCJhbGxQcm9wcyIsIlNldCIsImFkZEFsbFByb3BzIiwib2JqIiwicHJvcCIsIk9iamVjdCIsImtleXMiLCJhZGQiLCJmb3JFYWNoIiwiZXhwZWN0T2JzZXJ2YWJsZVRvU3RhcnRXaXRoIiwic291cmNlIiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJ0YWtlIiwibGVuZ3RoIiwidG9BcnJheSIsInRvUHJvbWlzZSIsImV4cGVjdCIsInRvRXF1YWwiLCJnZW5lcmF0ZUZpeHR1cmUiLCJmaXh0dXJlTmFtZSIsImZpbGVzIiwidGVtcCIsInRyYWNrIiwiTUFYX0NPTkNVUlJFTlRfRklMRV9PUFMiLCJ0ZW1wRGlyIiwiZnNQcm9taXNlIiwidGVtcGRpciIsImZpbGVUdXBsZXMiLCJBcnJheSIsImZyb20iLCJ0dXBsZSIsIm51Y2xpZGVVcmkiLCJqb2luIiwiZGlyc1RvTWFrZSIsIm1hcCIsImZpbGVuYW1lIiwiZGlybmFtZSIsImZpbHRlciIsImkiLCJhcnIiLCJpbmRleE9mIiwibWtkaXJwIiwiY29udGVudHMiLCJmcyIsIndyaXRlRmlsZSIsImVyciIsIndyaXRlQ292ZXJhZ2UiLCJDT1ZFUkFHRV9ESVIiLCJjb3ZlcmFnZSIsImdsb2JhbCIsIl9fY292ZXJhZ2VfXyIsIndy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R0osQ0FBQyxDQUFDWSxRQUFELEVBQVdPLFFBQVgsQ0FBRCxLQUEwQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQU8sSUFBSTdELE9BQUosQ0FBWSxDQUFDUSxPQUFELEVBQVVQLE1BQVYsS0FBcUI7QUFDdEM2RCxrQkFBR0MsU0FBSCxDQUFhVCxRQUFiLEVBQXVCTyxRQUFRLElBQUksRUFBbkMsRUFBdUNHLEdBQUcsSUFBSTtBQUM1QyxZQUFJQSxHQUFKLEVBQVM7QUFDUC9ELFVBQUFBLE1BQU0sQ0FBQytELEdBQUQsQ0FBTjtBQUNELFNBRkQsTUFFTztBQUNMeEQsVUFBQUEsT0FBTztBQUNSO0FBQ0YsT0FORDtBQU9ELEtBUk0sQ0FBUDtBQVNELEdBakJHLENBQU47QUFvQkEsU0FBT21DLE9BQVA7QUFDRDs7QUFFTSxTQUFTc0IsYUFBVCxHQUErQjtBQUNwQyxRQUFNO0FBQUNDLElBQUFBO0FBQUQsTUFBaUJ4RSxPQUFPLENBQUNDLEdBQS9COztBQUNBLE1BQUl1RSxZQUFZLElBQUksSUFBcEIsRUFBMEI7QUFDeEIsVUFBTUMsUUFBUSxHQUFHQyxNQUFNLENBQUNDLFlBQXhCOztBQUNBLFFBQUlGLFFBQVEsSUFBSSxJQUFoQixFQUFzQjtBQUNwQkwsa0JBQUdRLGFBQUgsQ0FDRXBCLG9CQUFXQyxJQUFYLENBQWdCZSxZQUFoQixFQUE4QkssY0FBS0MsRUFBTCxLQUFZLE9BQTFDLENBREYsRUFFRUMsSUFBSSxDQUFDQyxTQUFMLENBQWVQLFFBQWYsQ0FGRjtBQUlEO0FBQ0Y7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTctcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXHJcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxyXG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cclxuICpcclxuICogQGZsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuXHJcbmltcG9ydCB0eXBlIHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5cclxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgdGVtcCBmcm9tICd0ZW1wJztcclxuaW1wb3J0IHV1aWQgZnJvbSAndXVpZCc7XHJcbmltcG9ydCBmc1Byb21pc2UgZnJvbSAnLi9mc1Byb21pc2UnO1xyXG5pbXBvcnQgbnVjbGlkZVVyaSBmcm9tICcuL251Y2xpZGVVcmknO1xyXG5pbXBvcnQge2FzeW5jTGltaXR9IGZyb20gJy4vcHJvbWlzZSc7XHJcblxyXG5pbnZhcmlhbnQoXHJcbiAgKHR5cGVvZiBhdG9tICE9PSAndW5kZWZpbmVkJyAmJiBhdG9tLmluU3BlY01vZGUoKSkgfHxcclxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcsXHJcbiAgJ1Rlc3QgaGVscGVycyBzaG91bGQgb25seSBiZSB1c2VkIGluIHNwZWMgbW9kZScsXHJcbik7XHJcblxyXG4vKipcclxuICogVmVyaWZpZXMgdGhhdCBhIFByb21pc2UgZmFpbHMgd2l0aCBhbiBFcnJvciB3aXRoIHNwZWNpZmljIGV4cGVjdGF0aW9ucy4gV2hlblxyXG4gKiBydW5uaW5nIGEgdGVzdCB3aGVyZSBhIFByb21pc2UgaXMgZXhwZWN0ZWQgdG8gZmFpbCwgaXQgaXMgaW1wb3J0YW50IHRvIHZlcmlmeVxyXG4gKiB0aGF0IGl0IGZhaWxlZCBpbiB0aGUgZXhwZWN0ZWQgd2F5IHRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyBpbiB0ZXN0IHJlc3VsdHMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgd2l0aCBgYXdhaXRgIGluc2lkZSBgd2FpdHNGb3JQcm9taXNlKClgLlxyXG4gKlxyXG4gKiBAcGFyYW0gcHJvbWlzZSB3aWxsIGJlIGF3YWl0ZWQuIEl0IGlzIGV4cGVjdGVkIHRvIHJlamVjdC4gSWYgaXQgZG9lcyBub3RcclxuICogICAgIHJlamVjdCwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgcmVqZWN0ZWQgUHJvbWlzZS5cclxuICogQHBhcmFtIHZlcmlmeSBzaG91bGQgY29uZmlybSBleHBlY3RhdGlvbnMgYWJvdXQgdGhlIEVycm9yIHByb2R1Y2VkIGJ5IHRoZVxyXG4gKiAgICAgcmVqZWN0aW9uIG9mIGBwcm9taXNlYC4gSWYgdGhlc2UgZXhwZWN0YXRpb25zIGFyZSBub3QgbWV0LCB0aGVuXHJcbiAqICAgICBgdmVyaWZ5KClgIG11c3QgdGhyb3cgYW4gZXhjZXB0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGVjdEFzeW5jRmFpbHVyZShcclxuICBwcm9taXNlOiBQcm9taXNlPGFueT4sXHJcbiAgdmVyaWZ5OiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkLFxyXG4pOiBQcm9taXNlPGFueT4ge1xyXG4gIHRyeSB7XHJcbiAgICBhd2FpdCBwcm9taXNlO1xyXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxyXG4gICAgICBuZXcgRXJyb3IoJ1Byb21pc2Ugc2hvdWxkIGhhdmUgZmFpbGVkLCBidXQgZGlkIG5vdC4nKSxcclxuICAgICk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgdmVyaWZ5KGUpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBtb2NraW5nIGEgbW9kdWxlIHRoYXQgdGhlIG1vZHVsZSB1bmRlciB0ZXN0IHJlcXVpcmVzLlxyXG4gKiBBZnRlciBzZXR0aW5nIHVwIHRoZSBtb2NrcywgeW91IG11c3QgaW52YWxpZGF0ZSB0aGUgcmVxdWlyZSBjYWNoZSBhbmQgdGhlblxyXG4gKiByZS1yZXF1aXJlIHRoZSBtb2R1bGUgdW5kZXIgdGVzdCBzbyB0aGF0IGl0IHBpY2tzIHVwIHRoZSBtb2NrZWRcclxuICogZGVwZW5kZW5jaWVzLlxyXG4gKlxyXG4gKiBUaGUgcmVxdWlyZSBwYXJhbWV0ZXIgaXMgbmVlZGVkIGJlY2F1c2UgcmVxdWlyZSBpcyBib3VuZCBkaWZmZXJlbnRseSBpbiBlYWNoXHJcbiAqIGZpbGUsIGFuZCB3ZSBuZWVkIHRvIGV4ZWN1dGUgdGhpcyBpbiB0aGUgY2FsbGVyJ3MgY29udGV4dC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGVhclJlcXVpcmVDYWNoZShyZXF1aXJlOiBPYmplY3QsIG1vZHVsZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgZGVsZXRlIHJlcXVpcmUuY2FjaGVbcmVxdWlyZS5yZXNvbHZlKG1vZHVsZSldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdW5jYWNoZWRSZXF1aXJlKHJlcXVpcmU6IE9iamVjdCwgbW9kdWxlOiBzdHJpbmcpOiBtaXhlZCB7XHJcbiAgY2xlYXJSZXF1aXJlQ2FjaGUocmVxdWlyZSwgbW9kdWxlKTtcclxuICAvLyAkRmxvd0lnbm9yZVxyXG4gIHJldHVybiByZXF1aXJlKG1vZHVsZSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBKYXNtaW5lIGhhcyB0cm91YmxlIHNweWluZyBvbiBwcm9wZXJ0aWVzIHN1cHBsaWVkIGJ5IGdldHRlcnMsIHNvIHRvIG1ha2UgaXRcclxuICogd29yayB3ZSBoYXZlIHRvIGdldCB0aGUgdmFsdWUsIGRlbGV0ZSB0aGUgZ2V0dGVyLCBhbmQgc2V0IHRoZSB2YWx1ZSBhcyBhXHJcbiAqIHByb3BlcnR5LlxyXG4gKlxyXG4gKiBUaGlzIG1ha2VzIHR3byBhc3N1bXB0aW9uczpcclxuICogLSBUaGUgZ2V0dGVyIGlzIGlkZW1wb3RlbnQgKG90aGVyd2lzZSwgY2FsbGVycyBpbiBvdGhlciB0ZXN0cyBtaWdodCBiZVxyXG4gKiAgIHN1cnByaXNlZCB3aGVuIHRoZSB2YWx1ZSBoZXJlIGlzIHJldHVybmVkKVxyXG4gKiAtIFRoZSBnZXR0ZXIgcmV0dXJucyBhIGZ1bmN0aW9uIChvdGhlcndpc2UsIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBzcHkgb25cclxuICogICBpdClcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcHlPbkdldHRlclZhbHVlKG9iamVjdDogT2JqZWN0LCBmOiBzdHJpbmcpOiBKYXNtaW5lU3B5IHtcclxuICBjb25zdCB2YWx1ZSA9IG9iamVjdFtmXTtcclxuICBkZWxldGUgb2JqZWN0W2ZdO1xyXG4gIG9iamVjdFtmXSA9IHZhbHVlO1xyXG4gIHJldHVybiBzcHlPbihvYmplY3QsIGYpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSB0d28gb2JqZWN0cyBoYXZlIGVxdWFsIHByb3BlcnRpZXMuIFRoaXMgY29uc2lkZXJzIGEgcHJvcGVydHlcclxuICogc2V0IHRvIHVuZGVmaW5lZCB0byBiZSBlcXVpdmFsZW50IHRvIGEgcHJvcGVydHkgdGhhdCB3YXMgbm90IHNldCBhdCBhbGwuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlUHJvcGVydGllc0VxdWFsKG9iajE6IE9iamVjdCwgb2JqMjogT2JqZWN0KTogYm9vbGVhbiB7XHJcbiAgY29uc3QgYWxsUHJvcHMgPSBuZXcgU2V0KCk7XHJcbiAgZnVuY3Rpb24gYWRkQWxsUHJvcHMob2JqKSB7XHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMob2JqKSkge1xyXG4gICAgICBhbGxQcm9wcy5hZGQocHJvcCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFtvYmoxLCBvYmoyXS5mb3JFYWNoKGFkZEFsbFByb3BzKTtcclxuICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcclxuICAgIGlmIChvYmoxW3Byb3BdICE9PSBvYmoyW3Byb3BdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXYXJuaW5nOiBDYWxsc2l0ZXMgKm11c3QqIGF3YWl0IHRoZSByZXN1bHRpbmcgcHJvbWlzZSwgb3IgdGVzdCBmYWlsdXJlcyBtYXkgZ28gdW5yZXBvcnRlZCBvclxyXG4gKiBtaXNhdHRyaWJ1dGVkLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4cGVjdE9ic2VydmFibGVUb1N0YXJ0V2l0aDxUPihcclxuICBzb3VyY2U6IE9ic2VydmFibGU8VD4sXHJcbiAgZXhwZWN0ZWQ6IEFycmF5PFQ+LFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBjb25zdCBhY3R1YWw6IEFycmF5PFQ+ID0gYXdhaXQgc291cmNlXHJcbiAgICAudGFrZShleHBlY3RlZC5sZW5ndGgpXHJcbiAgICAudG9BcnJheSgpXHJcbiAgICAudG9Qcm9taXNlKCk7XHJcbiAgZXhwZWN0KGFjdHVhbCkudG9FcXVhbChleHBlY3RlZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUYWtlcyBvZiBNYXAgb2YgZmlsZS9maWxlLWNvbnRlbnQgcGFpcnMsIGFuZCBjcmVhdGVzIGEgdGVtcCBkaXIgdGhhdCBtYXRjaGVzXHJcbiAqIHRoZSBmaWxlIHN0cnVjdHVyZSBvZiB0aGUgTWFwLiBFeGFtcGxlOlxyXG4gKlxyXG4gKiBnZW5lcmF0ZUZpeHR1cmUoJ215Zml4dHVyZScsIG5ldyBNYXAoW1xyXG4gKiAgIFsnZm9vLmpzJ10sXHJcbiAqICAgWydiYXIvYmF6LnR4dCcsICdzb21lIHRleHQnXSxcclxuICogXSkpO1xyXG4gKlxyXG4gKiBDcmVhdGVzOlxyXG4gKlxyXG4gKiAvdG1wL215Zml4dHVyZV8xL2Zvby5qcyAoZW1wdHkgZmlsZSlcclxuICogL3RtcC9teWZpeHR1cmVfMS9iYXIvYmF6LnR4dCAod2l0aCAnc29tZSB0ZXh0JylcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUZpeHR1cmUoXHJcbiAgZml4dHVyZU5hbWU6IHN0cmluZyxcclxuICBmaWxlczogP01hcDxzdHJpbmcsID9zdHJpbmc+LFxyXG4pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIHRlbXAudHJhY2soKTtcclxuXHJcbiAgY29uc3QgTUFYX0NPTkNVUlJFTlRfRklMRV9PUFMgPSAxMDA7XHJcbiAgY29uc3QgdGVtcERpciA9IGF3YWl0IGZzUHJvbWlzZS50ZW1wZGlyKGZpeHR1cmVOYW1lKTtcclxuXHJcbiAgaWYgKGZpbGVzID09IG51bGwpIHtcclxuICAgIHJldHVybiB0ZW1wRGlyO1xyXG4gIH1cclxuXHJcbiAgLy8gTWFwIC0+IEFycmF5IHdpdGggZnVsbCBwYXRoc1xyXG4gIGNvbnN0IGZpbGVUdXBsZXMgPSBBcnJheS5mcm9tKGZpbGVzLCB0dXBsZSA9PiB7XHJcbiAgICAvLyBJdCdzIG91ciBvd24gYXJyYXkgLSBpdCdzIG9rIHRvIG11dGF0ZSBpdFxyXG4gICAgdHVwbGVbMF0gPSBudWNsaWRlVXJpLmpvaW4odGVtcERpciwgdHVwbGVbMF0pO1xyXG4gICAgcmV0dXJuIHR1cGxlO1xyXG4gIH0pO1xyXG5cclxuICAvLyBEZWR1cGUgdGhlIGRpcnMgdGhhdCB3ZSBoYXZlIHRvIG1ha2UuXHJcbiAgY29uc3QgZGlyc1RvTWFrZSA9IGZpbGVUdXBsZXNcclxuICAgIC5tYXAoKFtmaWxlbmFtZV0pID0+IG51Y2xpZGVVcmkuZGlybmFtZShmaWxlbmFtZSkpXHJcbiAgICAuZmlsdGVyKChkaXJuYW1lLCBpLCBhcnIpID0+IGFyci5pbmRleE9mKGRpcm5hbWUpID09PSBpKTtcclxuXHJcbiAgYXdhaXQgYXN5bmNMaW1pdChkaXJzVG9NYWtlLCBNQVhfQ09OQ1VSUkVOVF9GSUxFX09QUywgZGlybmFtZSA9PlxyXG4gICAgZnNQcm9taXNlLm1rZGlycChkaXJuYW1lKSxcclxuICApO1xyXG5cclxuICBhd2FpdCBhc3luY0xpbWl0KFxyXG4gICAgZmlsZVR1cGxlcyxcclxuICAgIE1BWF9DT05DVVJSRU5UX0ZJTEVfT1BTLFxyXG4gICAgKFtmaWxlbmFtZSwgY29udGVudHNdKSA9PiB7XHJcbiAgICAgIC8vIFdlIGNhbid0IHVzZSBmc1Byb21pc2UvZnMtcGx1cyBiZWNhdXNlIGl0IGRvZXMgdG9vIG11Y2ggZXh0cmEgd29yay5cclxuICAgICAgLy8gVGhleSBjYWxsIGBta2RpcnBgIGJlZm9yZSBgd3JpdGVGaWxlYC4gV2Uga25vdyB0aGF0IHRoZSB0YXJnZXQgZGlyXHJcbiAgICAgIC8vIGV4aXN0cywgc28gd2UgY2FuIG9wdGltaXplIGJ5IGdvaW5nIHN0cmFpZ2h0IHRvIGBmc2AuIFdoZW4geW91J3JlXHJcbiAgICAgIC8vIG1ha2luZyAxMGsgZmlsZXMsIHRoaXMgYWRkcyB+NTAwbXMuXHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgZnMud3JpdGVGaWxlKGZpbGVuYW1lLCBjb250ZW50cyB8fCAnJywgZXJyID0+IHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuICApO1xyXG5cclxuICByZXR1cm4gdGVtcERpcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlQ292ZXJhZ2UoKTogdm9pZCB7XHJcbiAgY29uc3Qge0NPVkVSQUdFX0RJUn0gPSBwcm9jZXNzLmVudjtcclxuICBpZiAoQ09WRVJBR0VfRElSICE9IG51bGwpIHtcclxuICAgIGNvbnN0IGNvdmVyYWdlID0gZ2xvYmFsLl9fY292ZXJhZ2VfXztcclxuICAgIGlmIChjb3ZlcmFnZSAhPSBudWxsKSB7XHJcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoXHJcbiAgICAgICAgbnVjbGlkZVVyaS5qb2luKENPVkVSQUdFX0RJUiwgdXVpZC52NCgpICsgJy5qc29uJyksXHJcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoY292ZXJhZ2UpLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=