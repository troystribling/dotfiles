"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _os = _interopRequireDefault(require("os"));

var _nuclideUri = _interopRequireDefault(require("./nuclideUri"));

var _process = require("./process");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */

/**
 * Provides a cross-platform way to check whether a binary is available.
 *
 * We ran into problems with the npm `which` package (the nature of which I unfortunately don't
 * remember) so we can use this for now.
 */
function sanitizePathForWindows(path) {
  if (_nuclideUri.default.basename(path) === path) {
    // simple binary in $PATH like `flow`
    return path;
  } else {
    return `${_nuclideUri.default.dirname(path)}:${_nuclideUri.default.basename(path)}`;
  }
}

var which = async function which(path, options = {}) {
  const isWindows = process.platform === 'win32';
  const whichCommand = isWindows ? 'where' : 'which';
  const searchPath = isWindows ? sanitizePathForWindows(path) : path;

  try {
    const result = await (0, _process.runCommand)(whichCommand, [searchPath], options).toPromise();
    return result.split(_os.default.EOL)[0];
  } catch (e) {
    return null;
  }
};

exports.default = which;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1jb21tb25zL3doaWNoLmpzIl0sIm5hbWVzIjpbInNhbml0aXplUGF0aEZvcldpbmRvd3MiLCJwYXRoIiwibnVjbGlkZVVyaSIsImJhc2VuYW1lIiwiZGlybmFtZSIsIndoaWNoIiwib3B0aW9ucyIsImlzV2luZG93cyIsInByb2Nlc3MiLCJwbGF0Zm9ybSIsIndoaWNoQ29tbWFuZCIsInNlYXJjaFBhdGgiLCJyZXN1bHQiLCJ0b1Byb21pc2UiLCJzcGxpdCIsIm9zIiwiRU9MIiwiZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWNBOztBQUNBOztBQUNBOzs7O0FBaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsU0FBU0Esc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNEO0FBQ3BELE1BQUlDLG9CQUFXQyxRQUFYLENBQW9CRixJQUFwQixNQUE4QkEsSUFBbEMsRUFBd0M7QUFDdEM7QUFDQSxXQUFPQSxJQUFQO0FBQ0QsR0FIRCxNQUdPO0FBQ0wsV0FBUSxHQUFFQyxvQkFBV0UsT0FBWCxDQUFtQkgsSUFBbkIsQ0FBeUIsSUFBR0Msb0JBQVdDLFFBQVgsQ0FBb0JGLElBQXBCLENBQTBCLEVBQWhFO0FBQ0Q7QUFDRjs7SUFFOEJJLEssR0FBZixlQUFlQSxLQUFmLENBQ2RKLElBRGMsRUFFZEssT0FBK0IsR0FBRyxFQUZwQixFQUdJO0FBQ2xCLFFBQU1DLFNBQVMsR0FBR0MsT0FBTyxDQUFDQyxRQUFSLEtBQXFCLE9BQXZDO0FBQ0EsUUFBTUMsWUFBWSxHQUFHSCxTQUFTLEdBQUcsT0FBSCxHQUFhLE9BQTNDO0FBQ0EsUUFBTUksVUFBVSxHQUFHSixTQUFTLEdBQUdQLHNCQUFzQixDQUFDQyxJQUFELENBQXpCLEdBQWtDQSxJQUE5RDs7QUFDQSxNQUFJO0FBQ0YsVUFBTVcsTUFBTSxHQUFHLE1BQU0seUJBQ25CRixZQURtQixFQUVuQixDQUFDQyxVQUFELENBRm1CLEVBR25CTCxPQUhtQixFQUluQk8sU0FKbUIsRUFBckI7QUFLQSxXQUFPRCxNQUFNLENBQUNFLEtBQVAsQ0FBYUMsWUFBR0MsR0FBaEIsRUFBcUIsQ0FBckIsQ0FBUDtBQUNELEdBUEQsQ0FPRSxPQUFPQyxDQUFQLEVBQVU7QUFDVixXQUFPLElBQVA7QUFDRDtBQUNGLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93IHN0cmljdC1sb2NhbFxyXG4gKiBAZm9ybWF0XHJcbiAqL1xyXG5cclxuaW1wb3J0IHR5cGUge09ic2VydmVQcm9jZXNzT3B0aW9uc30gZnJvbSAnLi9wcm9jZXNzJztcclxuXHJcbmltcG9ydCBvcyBmcm9tICdvcyc7XHJcbmltcG9ydCBudWNsaWRlVXJpIGZyb20gJy4vbnVjbGlkZVVyaSc7XHJcbmltcG9ydCB7cnVuQ29tbWFuZH0gZnJvbSAnLi9wcm9jZXNzJztcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIGNyb3NzLXBsYXRmb3JtIHdheSB0byBjaGVjayB3aGV0aGVyIGEgYmluYXJ5IGlzIGF2YWlsYWJsZS5cclxuICpcclxuICogV2UgcmFuIGludG8gcHJvYmxlbXMgd2l0aCB0aGUgbnBtIGB3aGljaGAgcGFja2FnZSAodGhlIG5hdHVyZSBvZiB3aGljaCBJIHVuZm9ydHVuYXRlbHkgZG9uJ3RcclxuICogcmVtZW1iZXIpIHNvIHdlIGNhbiB1c2UgdGhpcyBmb3Igbm93LlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHNhbml0aXplUGF0aEZvcldpbmRvd3MocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpZiAobnVjbGlkZVVyaS5iYXNlbmFtZShwYXRoKSA9PT0gcGF0aCkge1xyXG4gICAgLy8gc2ltcGxlIGJpbmFyeSBpbiAkUEFUSCBsaWtlIGBmbG93YFxyXG4gICAgcmV0dXJuIHBhdGg7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBgJHtudWNsaWRlVXJpLmRpcm5hbWUocGF0aCl9OiR7bnVjbGlkZVVyaS5iYXNlbmFtZShwYXRoKX1gO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgKGFzeW5jIGZ1bmN0aW9uIHdoaWNoKFxyXG4gIHBhdGg6IHN0cmluZyxcclxuICBvcHRpb25zPzogT2JzZXJ2ZVByb2Nlc3NPcHRpb25zID0ge30sXHJcbik6IFByb21pc2U8P3N0cmluZz4ge1xyXG4gIGNvbnN0IGlzV2luZG93cyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XHJcbiAgY29uc3Qgd2hpY2hDb21tYW5kID0gaXNXaW5kb3dzID8gJ3doZXJlJyA6ICd3aGljaCc7XHJcbiAgY29uc3Qgc2VhcmNoUGF0aCA9IGlzV2luZG93cyA/IHNhbml0aXplUGF0aEZvcldpbmRvd3MocGF0aCkgOiBwYXRoO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBydW5Db21tYW5kKFxyXG4gICAgICB3aGljaENvbW1hbmQsXHJcbiAgICAgIFtzZWFyY2hQYXRoXSxcclxuICAgICAgb3B0aW9ucyxcclxuICAgICkudG9Qcm9taXNlKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0LnNwbGl0KG9zLkVPTClbMF07XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59KTtcclxuIl19