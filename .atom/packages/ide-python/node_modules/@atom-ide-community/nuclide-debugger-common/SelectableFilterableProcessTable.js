"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _debugAdapterService = require("./debug-adapter-service");

var _AtomInput = require("@atom-ide-community/nuclide-commons-ui/AtomInput");

var _Table = require("@atom-ide-community/nuclide-commons-ui/Table");

var _nuclideUri = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/nuclideUri"));

var _UniversalDisposable = _interopRequireDefault(require("@atom-ide-community/nuclide-commons/UniversalDisposable"));

var _rxjsCompatUmdMin = require("rxjs-compat/bundles/rxjs-compat.umd.min.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
const PROCESS_UPDATES_INTERVAL_MS = 2000;
const COLUMNS = [{
  title: 'Process Binary',
  key: 'process',
  width: 0.25
}, {
  title: 'PID',
  key: 'pid',
  width: 0.1
}, {
  title: 'Command',
  key: 'command',
  width: 0.65
}];

function getCompareFunction(sortedColumn, sortDescending) {
  switch (sortedColumn) {
    case 'process':
      return (target1, target2) => {
        const first = sortDescending ? target2.process : target1.process;
        const second = sortDescending ? target1.process : target2.process;
        return first.toLowerCase().localeCompare(second.toLowerCase());
      };

    case 'pid':
      const order = sortDescending ? -1 : 1;
      return (target1, target2) => order * (target1.pid - target2.pid);

    case 'command':
      return (target1, target2) => {
        const first = sortDescending ? target2.command : target1.command;
        const second = sortDescending ? target1.command : target2.command;
        return first.toLowerCase().localeCompare(second.toLowerCase());
      };

    default:
      break;
  }

  return () => 0;
}

function filterProcesses(processes, filterText) {
  // Show all results if invalid regex
  let filterRegex;

  try {
    filterRegex = new RegExp(filterText, 'i');
  } catch (e) {
    return processes;
  }

  return processes.filter(item => filterRegex.test(item.process) || filterRegex.test(item.pid.toString()) || filterRegex.test(item.command));
}

class SelectableFilterableProcessTable extends React.Component {
  constructor(props) {
    super(props);
    this._disposables = void 0;

    this._updateList = processes => {
      // On Linux, process names for which only a name is available
      // are denoted as [name] in the commandWithArgs field. These
      // names often do not play well with basename (in particular,
      // some of the contain literal slashes) so handle them as a special
      // case.
      const noargsRegex = /^\[(.*)\]$/;

      const commandName = (name, withArgs) => {
        const match = withArgs.match(noargsRegex);

        if (match != null) {
          return match[1];
        }

        return _nuclideUri.default.basename(name);
      };

      const processList = processes.map(process => {
        return {
          process: commandName(process.command, process.commandWithArgs),
          pid: process.pid,
          command: process.commandWithArgs
        };
      });
      this.setState({
        processList
      });
    };

    this._handleFilterTextChange = filterText => {
      // Check if we've filtered down to one option and select if so
      const filteredProcesses = filterProcesses(this.state.processList, filterText); // TODO: (wbinnssmith) T30771435 this setState depends on current state
      // and should use an updater function rather than an object
      // eslint-disable-next-line react/no-access-state-in-setstate

      let selectedProcess = this.state.selectedProcess;

      if (filteredProcesses.length === 1) {
        // Check if we've filtered down to one option and select if so
        selectedProcess = filteredProcesses[0];
      } else if (filteredProcesses.findIndex(processRow => selectedProcess != null && selectedProcess.pid === processRow.pid) === -1) {
        // If we filter out our current selection,
        //   set our current selection to null
        selectedProcess = null;
      }

      this.setState({
        filterText,
        selectedProcess
      });
    };

    this._handleSelectTableRow = (selectedProcess, selectedIndex) => {
      this.setState({
        selectedProcess
      });
    };

    this._handleSort = (sortedColumn, sortDescending) => {
      this.setState({
        sortedColumn,
        sortDescending
      });
    };

    this._disposables = new _UniversalDisposable.default();
    this.state = {
      processList: [],
      selectedProcess: null,
      sortDescending: false,
      sortedColumn: null,
      filterText: ''
    };
  }

  componentDidMount() {
    this._disposables.add(_rxjsCompatUmdMin.Observable.interval(PROCESS_UPDATES_INTERVAL_MS).startWith(0).flatMap(_ => (0, _debugAdapterService.getVSCodeDebuggerAdapterServiceByNuclideUri)(this.props.targetUri).getProcessTree()).subscribe(this._updateList));
  }

  componentWillUnmount() {
    this._disposables.dispose();
  }

  setState(newState) {
    const onSelect = this.props.onSelect != null ? this.props.onSelect : _ => {};
    let changedSelectedProcess = false;

    if (newState.selectedProcess != null) {
      if (this.state.selectedProcess != null) {
        changedSelectedProcess = newState.selectedProcess.pid !== this.state.selectedProcess.pid;
      } else {
        changedSelectedProcess = true;
      }
    } else if (typeof newState.selectedProcess === 'undefined') {
      // this is the case that setState was not called with a selectedProcess
      changedSelectedProcess = false;
    } else {
      changedSelectedProcess = this.state.selectedProcess != null;
    }

    super.setState(newState, () => {
      changedSelectedProcess && onSelect(newState.selectedProcess);
    });
  }

  render() {
    const {
      processList,
      sortedColumn,
      sortDescending,
      selectedProcess,
      filterText
    } = this.state;
    const sortFunction = getCompareFunction(sortedColumn, sortDescending);
    let selectedIndex = null;
    const rows = filterProcesses(processList, filterText).sort(sortFunction).map((process, index) => {
      const row = {
        data: process
      };

      if (selectedProcess != null && selectedProcess.pid === process.pid) {
        selectedIndex = index;
      }

      return row;
    });
    return /*#__PURE__*/React.createElement("div", {
      className: "block"
    }, /*#__PURE__*/React.createElement("p", null, "Attach to a running native process"), /*#__PURE__*/React.createElement(_AtomInput.AtomInput, {
      placeholderText: "Search...",
      value: this.state.filterText,
      onDidChange: this._handleFilterTextChange,
      size: "sm",
      autofocus: true
    }), /*#__PURE__*/React.createElement(_Table.Table, {
      columns: COLUMNS,
      fixedHeader: true,
      maxBodyHeight: "30em",
      rows: rows,
      sortable: true,
      onSort: this._handleSort,
      sortedColumn: this.state.sortedColumn,
      sortDescending: this.state.sortDescending,
      selectable: true,
      selectedIndex: selectedIndex,
      onSelect: this._handleSelectTableRow,
      collapsable: true
    }));
  }

}

exports.default = SelectableFilterableProcessTable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL251Y2xpZGUvbnVjbGlkZS1kZWJ1Z2dlci1jb21tb24vU2VsZWN0YWJsZUZpbHRlcmFibGVQcm9jZXNzVGFibGUuanMiXSwibmFtZXMiOlsiUFJPQ0VTU19VUERBVEVTX0lOVEVSVkFMX01TIiwiQ09MVU1OUyIsInRpdGxlIiwia2V5Iiwid2lkdGgiLCJnZXRDb21wYXJlRnVuY3Rpb24iLCJzb3J0ZWRDb2x1bW4iLCJzb3J0RGVzY2VuZGluZyIsInRhcmdldDEiLCJ0YXJnZXQyIiwiZmlyc3QiLCJwcm9jZXNzIiwic2Vjb25kIiwidG9Mb3dlckNhc2UiLCJsb2NhbGVDb21wYXJlIiwib3JkZXIiLCJwaWQiLCJjb21tYW5kIiwiZmlsdGVyUHJvY2Vzc2VzIiwicHJvY2Vzc2VzIiwiZmlsdGVyVGV4dCIsImZpbHRlclJlZ2V4IiwiUmVnRXhwIiwiZSIsImZpbHRlciIsIml0ZW0iLCJ0ZXN0IiwidG9TdHJpbmciLCJTZWxlY3RhYmxlRmlsdGVyYWJsZVByb2Nlc3NUYWJsZSIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIl9kaXNwb3NhYmxlcyIsIl91cGRhdGVMaXN0Iiwibm9hcmdzUmVnZXgiLCJjb21tYW5kTmFtZSIsIm5hbWUiLCJ3aXRoQXJncyIsIm1hdGNoIiwibnVjbGlkZVVyaSIsImJhc2VuYW1lIiwicHJvY2Vzc0xpc3QiLCJtYXAiLCJjb21tYW5kV2l0aEFyZ3MiLCJzZXRTdGF0ZSIsIl9oYW5kbGVGaWx0ZXJUZXh0Q2hhbmdlIiwiZmlsdGVyZWRQcm9jZXNzZXMiLCJzdGF0ZSIsInNlbGVjdGVkUHJvY2VzcyIsImxlbmd0aCIsImZpbmRJbmRleCIsInByb2Nlc3NSb3ciLCJfaGFuZGxlU2VsZWN0VGFibGVSb3ciLCJzZWxlY3RlZEluZGV4IiwiX2hhbmRsZVNvcnQiLCJVbml2ZXJzYWxEaXNwb3NhYmxlIiwiY29tcG9uZW50RGlkTW91bnQiLCJhZGQiLCJPYnNlcnZhYmxlIiwiaW50ZXJ2YWwiLCJzdGFydFdpdGgiLCJmbGF0TWFwIiwiXyIsInRhcmdldFVyaSIsImdldFByb2Nlc3NUcmVlIiwic3Vic2NyaWJlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJkaXNwb3NlIiwibmV3U3RhdGUiLCJvblNlbGVjdCIsImNoYW5nZWRTZWxlY3RlZFByb2Nlc3MiLCJyZW5kZXIiLCJzb3J0RnVuY3Rpb24iLCJyb3dzIiwic29ydCIsImluZGV4Iiwicm93IiwiZGF0YSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQWVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBY0EsTUFBTUEsMkJBQTJCLEdBQUcsSUFBcEM7QUFFQSxNQUFNQyxPQUF5QixHQUFHLENBQ2hDO0FBQ0VDLEVBQUFBLEtBQUssRUFBRSxnQkFEVDtBQUVFQyxFQUFBQSxHQUFHLEVBQUUsU0FGUDtBQUdFQyxFQUFBQSxLQUFLLEVBQUU7QUFIVCxDQURnQyxFQU1oQztBQUNFRixFQUFBQSxLQUFLLEVBQUUsS0FEVDtBQUVFQyxFQUFBQSxHQUFHLEVBQUUsS0FGUDtBQUdFQyxFQUFBQSxLQUFLLEVBQUU7QUFIVCxDQU5nQyxFQVdoQztBQUNFRixFQUFBQSxLQUFLLEVBQUUsU0FEVDtBQUVFQyxFQUFBQSxHQUFHLEVBQUUsU0FGUDtBQUdFQyxFQUFBQSxLQUFLLEVBQUU7QUFIVCxDQVhnQyxDQUFsQzs7QUF1Q0EsU0FBU0Msa0JBQVQsQ0FDRUMsWUFERixFQUVFQyxjQUZGLEVBRzRDO0FBQzFDLFVBQVFELFlBQVI7QUFDRSxTQUFLLFNBQUw7QUFDRSxhQUFPLENBQUNFLE9BQUQsRUFBc0JDLE9BQXRCLEtBQThDO0FBQ25ELGNBQU1DLEtBQUssR0FBR0gsY0FBYyxHQUFHRSxPQUFPLENBQUNFLE9BQVgsR0FBcUJILE9BQU8sQ0FBQ0csT0FBekQ7QUFDQSxjQUFNQyxNQUFNLEdBQUdMLGNBQWMsR0FBR0MsT0FBTyxDQUFDRyxP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LE1BQUEsV0FBVyxFQUFFLEtBQUswQix1QkFIcEI7QUFJRSxNQUFBLElBQUksRUFBQyxJQUpQO0FBS0UsTUFBQSxTQUFTLEVBQUU7QUFMYixNQUZGLGVBU0Usb0JBQUMsWUFBRDtBQUNFLE1BQUEsT0FBTyxFQUFFN0MsT0FEWDtBQUVFLE1BQUEsV0FBVyxFQUFFLElBRmY7QUFHRSxNQUFBLGFBQWEsRUFBQyxNQUhoQjtBQUlFLE1BQUEsSUFBSSxFQUFFeUUsSUFKUjtBQUtFLE1BQUEsUUFBUSxFQUFFLElBTFo7QUFNRSxNQUFBLE1BQU0sRUFBRSxLQUFLbkIsV0FOZjtBQU9FLE1BQUEsWUFBWSxFQUFFLEtBQUtQLEtBQUwsQ0FBVzFDLFlBUDNCO0FBUUUsTUFBQSxjQUFjLEVBQUUsS0FBSzBDLEtBQUwsQ0FBV3pDLGNBUjdCO0FBU0UsTUFBQSxVQUFVLEVBQUUsSUFUZDtBQVVFLE1BQUEsYUFBYSxFQUFFK0MsYUFWakI7QUFXRSxNQUFBLFFBQVEsRUFBRSxLQUFLRCxxQkFYakI7QUFZRSxNQUFBLFdBQVcsRUFBRTtBQVpmLE1BVEYsQ0FERjtBQTBCRDs7QUFqTEQiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBmbG93XHJcbiAqIEBmb3JtYXRcclxuICovXHJcblxyXG5pbXBvcnQgdHlwZSB7Q29sdW1ufSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy11aS9UYWJsZSc7XHJcbmltcG9ydCB0eXBlIHtOdWNsaWRlVXJpfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9udWNsaWRlVXJpJztcclxuaW1wb3J0IHR5cGUge1Byb2Nlc3NJbmZvfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9wcm9jZXNzJztcclxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW1wb3J0IHtnZXRWU0NvZGVEZWJ1Z2dlckFkYXB0ZXJTZXJ2aWNlQnlOdWNsaWRlVXJpfSBmcm9tICcuL2RlYnVnLWFkYXB0ZXItc2VydmljZSc7XHJcbmltcG9ydCB7QXRvbUlucHV0fSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy11aS9BdG9tSW5wdXQnO1xyXG5pbXBvcnQge1RhYmxlfSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy11aS9UYWJsZSc7XHJcbmltcG9ydCBudWNsaWRlVXJpIGZyb20gJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1jb21tb25zL251Y2xpZGVVcmknO1xyXG5pbXBvcnQgVW5pdmVyc2FsRGlzcG9zYWJsZSBmcm9tICdAYXRvbS1pZGUtY29tbXVuaXR5L251Y2xpZGUtY29tbW9ucy9Vbml2ZXJzYWxEaXNwb3NhYmxlJztcclxuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnO1xyXG5cclxuY29uc3QgUFJPQ0VTU19VUERBVEVTX0lOVEVSVkFMX01TID0gMjAwMDtcclxuXHJcbmNvbnN0IENPTFVNTlM6IEFycmF5PENvbHVtbjwqPj4gPSBbXHJcbiAge1xyXG4gICAgdGl0bGU6ICdQcm9jZXNzIEJpbmFyeScsXHJcbiAgICBrZXk6ICdwcm9jZXNzJyxcclxuICAgIHdpZHRoOiAwLjI1LFxyXG4gIH0sXHJcbiAge1xyXG4gICAgdGl0bGU6ICdQSUQnLFxyXG4gICAga2V5OiAncGlkJyxcclxuICAgIHdpZHRoOiAwLjEsXHJcbiAgfSxcclxuICB7XHJcbiAgICB0aXRsZTogJ0NvbW1hbmQnLFxyXG4gICAga2V5OiAnY29tbWFuZCcsXHJcbiAgICB3aWR0aDogMC42NSxcclxuICB9LFxyXG5dO1xyXG5cclxudHlwZSBDb2x1bW5OYW1lID0gJ3Byb2Nlc3MnIHwgJ3BpZCcgfCAnY29tbWFuZCc7XHJcblxyXG50eXBlIFByb2Nlc3NSb3cgPSB7XHJcbiAgcHJvY2Vzczogc3RyaW5nLFxyXG4gIHBpZDogbnVtYmVyLFxyXG4gIGNvbW1hbmQ6IHN0cmluZyxcclxufTtcclxuXHJcbnR5cGUgUHJvcHMgPSB7fFxyXG4gICt0YXJnZXRVcmk6IE51Y2xpZGVVcmksXHJcbiAgK29uU2VsZWN0PzogKHNlbGVjdGVkUHJvY2VzczogP1Byb2Nlc3NSb3cpID0+IG1peGVkLFxyXG58fTtcclxuXHJcbnR5cGUgU3RhdGUgPSB7XHJcbiAgcHJvY2Vzc0xpc3Q6IEFycmF5PFByb2Nlc3NSb3c+LFxyXG4gIHNlbGVjdGVkUHJvY2VzczogP1Byb2Nlc3NSb3csXHJcbiAgc29ydERlc2NlbmRpbmc6IGJvb2xlYW4sXHJcbiAgc29ydGVkQ29sdW1uOiA/Q29sdW1uTmFtZSxcclxuICBmaWx0ZXJUZXh0OiBzdHJpbmcsXHJcbn07XHJcblxyXG5mdW5jdGlvbiBnZXRDb21wYXJlRnVuY3Rpb24oXHJcbiAgc29ydGVkQ29sdW1uOiA/Q29sdW1uTmFtZSxcclxuICBzb3J0RGVzY2VuZGluZzogYm9vbGVhbixcclxuKTogKGE6IFByb2Nlc3NSb3csIGI6IFByb2Nlc3NSb3cpID0+IG51bWJlciB7XHJcbiAgc3dpdGNoIChzb3J0ZWRDb2x1bW4pIHtcclxuICAgIGNhc2UgJ3Byb2Nlc3MnOlxyXG4gICAgICByZXR1cm4gKHRhcmdldDE6IFByb2Nlc3NSb3csIHRhcmdldDI6IFByb2Nlc3NSb3cpID0+IHtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHNvcnREZXNjZW5kaW5nID8gdGFyZ2V0Mi5wcm9jZXNzIDogdGFyZ2V0MS5wcm9jZXNzO1xyXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHNvcnREZXNjZW5kaW5nID8gdGFyZ2V0MS5wcm9jZXNzIDogdGFyZ2V0Mi5wcm9jZXNzO1xyXG4gICAgICAgIHJldHVybiBmaXJzdC50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoc2Vjb25kLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICB9O1xyXG4gICAgY2FzZSAncGlkJzpcclxuICAgICAgY29uc3Qgb3JkZXIgPSBzb3J0RGVzY2VuZGluZyA/IC0xIDogMTtcclxuICAgICAgcmV0dXJuICh0YXJnZXQxOiBQcm9jZXNzUm93LCB0YXJnZXQyOiBQcm9jZXNzUm93KSA9PlxyXG4gICAgICAgIG9yZGVyICogKHRhcmdldDEucGlkIC0gdGFyZ2V0Mi5waWQpO1xyXG4gICAgY2FzZSAnY29tbWFuZCc6XHJcbiAgICAgIHJldHVybiAodGFyZ2V0MTogUHJvY2Vzc1JvdywgdGFyZ2V0MjogUHJvY2Vzc1JvdykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gc29ydERlc2NlbmRpbmcgPyB0YXJnZXQyLmNvbW1hbmQgOiB0YXJnZXQxLmNvbW1hbmQ7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kID0gc29ydERlc2NlbmRpbmcgPyB0YXJnZXQxLmNvbW1hbmQgOiB0YXJnZXQyLmNvbW1hbmQ7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0LnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzZWNvbmQudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgIH07XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgcmV0dXJuICgpID0+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlclByb2Nlc3Nlcyhwcm9jZXNzZXM6IEFycmF5PFByb2Nlc3NSb3c+LCBmaWx0ZXJUZXh0OiBzdHJpbmcpIHtcclxuICAvLyBTaG93IGFsbCByZXN1bHRzIGlmIGludmFsaWQgcmVnZXhcclxuICBsZXQgZmlsdGVyUmVnZXg7XHJcbiAgdHJ5IHtcclxuICAgIGZpbHRlclJlZ2V4ID0gbmV3IFJlZ0V4cChmaWx0ZXJUZXh0LCAnaScpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBwcm9jZXNzZXM7XHJcbiAgfVxyXG4gIHJldHVybiBwcm9jZXNzZXMuZmlsdGVyKFxyXG4gICAgaXRlbSA9PlxyXG4gICAgICBmaWx0ZXJSZWdleC50ZXN0KGl0ZW0ucHJvY2VzcykgfHxcclxuICAgICAgZmlsdGVyUmVnZXgudGVzdChpdGVtLnBpZC50b1N0cmluZygpKSB8fFxyXG4gICAgICBmaWx0ZXJSZWdleC50ZXN0KGl0ZW0uY29tbWFuZCksXHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0YWJsZUZpbHRlcmFibGVQcm9jZXNzVGFibGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8XHJcbiAgUHJvcHMsXHJcbiAgU3RhdGUsXHJcbj4ge1xyXG4gIF9kaXNwb3NhYmxlczogVW5pdmVyc2FsRGlzcG9zYWJsZTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XHJcbiAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IG5ldyBVbml2ZXJzYWxEaXNwb3NhYmxlKCk7XHJcbiAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICBwcm9jZXNzTGlzdDogW10sXHJcbiAgICAgIHNlbGVjdGVkUHJvY2VzczogbnVsbCxcclxuICAgICAgc29ydERlc2NlbmRpbmc6IGZhbHNlLFxyXG4gICAgICBzb3J0ZWRDb2x1bW46IG51bGwsXHJcbiAgICAgIGZpbHRlclRleHQ6ICcnLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbXBvbmVudERpZE1vdW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZXMuYWRkKFxyXG4gICAgICBPYnNlcnZhYmxlLmludGVydmFsKFBST0NFU1NfVVBEQVRFU19JTlRFUlZBTF9NUylcclxuICAgICAgICAuc3RhcnRXaXRoKDApXHJcbiAgICAgICAgLmZsYXRNYXAoXyA9PlxyXG4gICAgICAgICAgZ2V0VlNDb2RlRGVidWdnZXJBZGFwdGVyU2VydmljZUJ5TnVjbGlkZVVyaShcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy50YXJnZXRVcmksXHJcbiAgICAgICAgICApLmdldFByb2Nlc3NUcmVlKCksXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5zdWJzY3JpYmUodGhpcy5fdXBkYXRlTGlzdCksXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlcy5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICBfdXBkYXRlTGlzdCA9IChwcm9jZXNzZXM6IEFycmF5PFByb2Nlc3NJbmZvPik6IHZvaWQgPT4ge1xyXG4gICAgLy8gT24gTGludXgsIHByb2Nlc3MgbmFtZXMgZm9yIHdoaWNoIG9ubHkgYSBuYW1lIGlzIGF2YWlsYWJsZVxyXG4gICAgLy8gYXJlIGRlbm90ZWQgYXMgW25hbWVdIGluIHRoZSBjb21tYW5kV2l0aEFyZ3MgZmllbGQuIFRoZXNlXHJcbiAgICAvLyBuYW1lcyBvZnRlbiBkbyBub3QgcGxheSB3ZWxsIHdpdGggYmFzZW5hbWUgKGluIHBhcnRpY3VsYXIsXHJcbiAgICAvLyBzb21lIG9mIHRoZSBjb250YWluIGxpdGVyYWwgc2xhc2hlcykgc28gaGFuZGxlIHRoZW0gYXMgYSBzcGVjaWFsXHJcbiAgICAvLyBjYXNlLlxyXG4gICAgY29uc3Qgbm9hcmdzUmVnZXggPSAvXlxcWyguKilcXF0kLztcclxuICAgIGNvbnN0IGNvbW1hbmROYW1lID0gKG5hbWUsIHdpdGhBcmdzKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1hdGNoID0gd2l0aEFyZ3MubWF0Y2gobm9hcmdzUmVnZXgpO1xyXG4gICAgICBpZiAobWF0Y2ggIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbnVjbGlkZVVyaS5iYXNlbmFtZShuYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcHJvY2Vzc0xpc3QgPSBwcm9jZXNzZXMubWFwKHByb2Nlc3MgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb2Nlc3M6IGNvbW1hbmROYW1lKHByb2Nlc3MuY29tbWFuZCwgcHJvY2Vzcy5jb21tYW5kV2l0aEFyZ3MpLFxyXG4gICAgICAgIHBpZDogcHJvY2Vzcy5waWQsXHJcbiAgICAgICAgY29tbWFuZDogcHJvY2Vzcy5jb21tYW5kV2l0aEFyZ3MsXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnNldFN0YXRlKHtwcm9jZXNzTGlzdH0pO1xyXG4gIH07XHJcblxyXG4gIF9oYW5kbGVGaWx0ZXJUZXh0Q2hhbmdlID0gKGZpbHRlclRleHQ6IHN0cmluZyk6IHZvaWQgPT4ge1xyXG4gICAgLy8gQ2hlY2sgaWYgd2UndmUgZmlsdGVyZWQgZG93biB0byBvbmUgb3B0aW9uIGFuZCBzZWxlY3QgaWYgc29cclxuICAgIGNvbnN0IGZpbHRlcmVkUHJvY2Vzc2VzID0gZmlsdGVyUHJvY2Vzc2VzKFxyXG4gICAgICB0aGlzLnN0YXRlLnByb2Nlc3NMaXN0LFxyXG4gICAgICBmaWx0ZXJUZXh0LFxyXG4gICAgKTtcclxuICAgIC8vIFRPRE86ICh3YmlubnNzbWl0aCkgVDMwNzcxNDM1IHRoaXMgc2V0U3RhdGUgZGVwZW5kcyBvbiBjdXJyZW50IHN0YXRlXHJcbiAgICAvLyBhbmQgc2hvdWxkIHVzZSBhbiB1cGRhdGVyIGZ1bmN0aW9uIHJhdGhlciB0aGFuIGFuIG9iamVjdFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWFjY2Vzcy1zdGF0ZS1pbi1zZXRzdGF0ZVxyXG4gICAgbGV0IHNlbGVjdGVkUHJvY2VzcyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRQcm9jZXNzO1xyXG4gICAgaWYgKGZpbHRlcmVkUHJvY2Vzc2VzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAvLyBDaGVjayBpZiB3ZSd2ZSBmaWx0ZXJlZCBkb3duIHRvIG9uZSBvcHRpb24gYW5kIHNlbGVjdCBpZiBzb1xyXG4gICAgICBzZWxlY3RlZFByb2Nlc3MgPSBmaWx0ZXJlZFByb2Nlc3Nlc1swXTtcclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIGZpbHRlcmVkUHJvY2Vzc2VzLmZpbmRJbmRleChcclxuICAgICAgICBwcm9jZXNzUm93ID0+XHJcbiAgICAgICAgICBzZWxlY3RlZFByb2Nlc3MgIT0gbnVsbCAmJiBzZWxlY3RlZFByb2Nlc3MucGlkID09PSBwcm9jZXNzUm93LnBpZCxcclxuICAgICAgKSA9PT0gLTFcclxuICAgICkge1xyXG4gICAgICAvLyBJZiB3ZSBmaWx0ZXIgb3V0IG91ciBjdXJyZW50IHNlbGVjdGlvbixcclxuICAgICAgLy8gICBzZXQgb3VyIGN1cnJlbnQgc2VsZWN0aW9uIHRvIG51bGxcclxuICAgICAgc2VsZWN0ZWRQcm9jZXNzID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgZmlsdGVyVGV4dCxcclxuICAgICAgc2VsZWN0ZWRQcm9jZXNzLFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgc2V0U3RhdGUobmV3U3RhdGU6IE9iamVjdCk6IHZvaWQge1xyXG4gICAgY29uc3Qgb25TZWxlY3QgPVxyXG4gICAgICB0aGlzLnByb3BzLm9uU2VsZWN0ICE9IG51bGwgPyB0aGlzLnByb3BzLm9uU2VsZWN0IDogXyA9PiB7fTtcclxuXHJcbiAgICBsZXQgY2hhbmdlZFNlbGVjdGVkUHJvY2VzcyA9IGZhbHNlO1xyXG4gICAgaWYgKG5ld1N0YXRlLnNlbGVjdGVkUHJvY2VzcyAhPSBudWxsKSB7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGVkUHJvY2VzcyAhPSBudWxsKSB7XHJcbiAgICAgICAgY2hhbmdlZFNlbGVjdGVkUHJvY2VzcyA9XHJcbiAgICAgICAgICBuZXdTdGF0ZS5zZWxlY3RlZFByb2Nlc3MucGlkICE9PSB0aGlzLnN0YXRlLnNlbGVjdGVkUHJvY2Vzcy5waWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hhbmdlZFNlbGVjdGVkUHJvY2VzcyA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5ld1N0YXRlLnNlbGVjdGVkUHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gdGhpcyBpcyB0aGUgY2FzZSB0aGF0IHNldFN0YXRlIHdhcyBub3QgY2FsbGVkIHdpdGggYSBzZWxlY3RlZFByb2Nlc3NcclxuICAgICAgY2hhbmdlZFNlbGVjdGVkUHJvY2VzcyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hhbmdlZFNlbGVjdGVkUHJvY2VzcyA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRQcm9jZXNzICE9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgc3VwZXIuc2V0U3RhdGUobmV3U3RhdGUsICgpID0+IHtcclxuICAgICAgY2hhbmdlZFNlbGVjdGVkUHJvY2VzcyAmJiBvblNlbGVjdChuZXdTdGF0ZS5zZWxlY3RlZFByb2Nlc3MpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlU2VsZWN0VGFibGVSb3cgPSAoXHJcbiAgICBzZWxlY3RlZFByb2Nlc3M6IFByb2Nlc3NSb3csXHJcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIsXHJcbiAgKTogdm9pZCA9PiB7XHJcbiAgICB0aGlzLnNldFN0YXRlKHtzZWxlY3RlZFByb2Nlc3N9KTtcclxuICB9O1xyXG5cclxuICBfaGFuZGxlU29ydCA9IChzb3J0ZWRDb2x1bW46IENvbHVtbk5hbWUsIHNvcnREZXNjZW5kaW5nOiBib29sZWFuKTogdm9pZCA9PiB7XHJcbiAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgc29ydGVkQ29sdW1uLFxyXG4gICAgICBzb3J0RGVzY2VuZGluZyxcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHJlbmRlcigpOiBSZWFjdC5Ob2RlIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgcHJvY2Vzc0xpc3QsXHJcbiAgICAgIHNvcnRlZENvbHVtbixcclxuICAgICAgc29ydERlc2NlbmRpbmcsXHJcbiAgICAgIHNlbGVjdGVkUHJvY2VzcyxcclxuICAgICAgZmlsdGVyVGV4dCxcclxuICAgIH0gPSB0aGlzLnN0YXRlO1xyXG4gICAgY29uc3Qgc29ydEZ1bmN0aW9uID0gZ2V0Q29tcGFyZUZ1bmN0aW9uKHNvcnRlZENvbHVtbiwgc29ydERlc2NlbmRpbmcpO1xyXG4gICAgbGV0IHNlbGVjdGVkSW5kZXggPSBudWxsO1xyXG5cclxuICAgIGNvbnN0IHJvd3MgPSBmaWx0ZXJQcm9jZXNzZXMocHJvY2Vzc0xpc3QsIGZpbHRlclRleHQpXHJcbiAgICAgIC5zb3J0KHNvcnRGdW5jdGlvbilcclxuICAgICAgLm1hcCgocHJvY2VzcywgaW5kZXgpID0+IHtcclxuICAgICAgICBjb25zdCByb3cgPSB7XHJcbiAgICAgICAgICBkYXRhOiBwcm9jZXNzLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChzZWxlY3RlZFByb2Nlc3MgIT0gbnVsbCAmJiBzZWxlY3RlZFByb2Nlc3MucGlkID09PSBwcm9jZXNzLnBpZCkge1xyXG4gICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdztcclxuICAgICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJibG9ja1wiPlxyXG4gICAgICAgIDxwPkF0dGFjaCB0byBhIHJ1bm5pbmcgbmF0aXZlIHByb2Nlc3M8L3A+XHJcbiAgICAgICAgPEF0b21JbnB1dFxyXG4gICAgICAgICAgcGxhY2Vob2xkZXJUZXh0PVwiU2VhcmNoLi4uXCJcclxuICAgICAgICAgIHZhbHVlPXt0aGlzLnN0YXRlLmZpbHRlclRleHR9XHJcbiAgICAgICAgICBvbkRpZENoYW5nZT17dGhpcy5faGFuZGxlRmlsdGVyVGV4dENoYW5nZX1cclxuICAgICAgICAgIHNpemU9XCJzbVwiXHJcbiAgICAgICAgICBhdXRvZm9jdXM9e3RydWV9XHJcbiAgICAgICAgLz5cclxuICAgICAgICA8VGFibGVcclxuICAgICAgICAgIGNvbHVtbnM9e0NPTFVNTlN9XHJcbiAgICAgICAgICBmaXhlZEhlYWRlcj17dHJ1ZX1cclxuICAgICAgICAgIG1heEJvZHlIZWlnaHQ9XCIzMGVtXCJcclxuICAgICAgICAgIHJvd3M9e3Jvd3N9XHJcbiAgICAgICAgICBzb3J0YWJsZT17dHJ1ZX1cclxuICAgICAgICAgIG9uU29ydD17dGhpcy5faGFuZGxlU29ydH1cclxuICAgICAgICAgIHNvcnRlZENvbHVtbj17dGhpcy5zdGF0ZS5zb3J0ZWRDb2x1bW59XHJcbiAgICAgICAgICBzb3J0RGVzY2VuZGluZz17dGhpcy5zdGF0ZS5zb3J0RGVzY2VuZGluZ31cclxuICAgICAgICAgIHNlbGVjdGFibGU9e3RydWV9XHJcbiAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxyXG4gICAgICAgICAgb25TZWxlY3Q9e3RoaXMuX2hhbmRsZVNlbGVjdFRhYmxlUm93fVxyXG4gICAgICAgICAgY29sbGFwc2FibGU9e3RydWV9XHJcbiAgICAgICAgLz5cclxuICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXX0=