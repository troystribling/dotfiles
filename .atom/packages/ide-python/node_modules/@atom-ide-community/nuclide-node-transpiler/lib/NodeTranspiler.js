/**
 * Copyright (c) 2017-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @format
 */
'use strict';
/* eslint nuclide-internal/no-commonjs: 0 */

/* eslint-disable no-console */
//------------------------------------------------------------------------------
// NodeTranspiler is a wrapper around babel with:
//  * Nuclide specific configuration, that must be shared among several
//    independent transpile systems.
//  * Lazy-loading of expensive libs like babel.
//  * It can be configured via environment variables:
//     * COVERAGE_DIR enables the "istanbul" transform to track coverage
//     * NUCLIDE_TRANSPILE_ENV should be null | production | production-modules:
//        * inline sourcemaps are disabled in both production environments
//        * "modules/" paths are not rewritten with "production-modules"
//------------------------------------------------------------------------------

const assert = require('assert');

const crypto = require('crypto');

const fs = require('fs');

const isBuiltinModule = require('is-builtin-module');

const path = require('path');

const os = require('os');

const docblock = require('./docblock');

const NUCLIDE_ROOT = path.join(__dirname, '..', '..', '..');
const MODULE_ALIASES = {
  redux: 'redux/dist/redux.min.js',
  rxjs: 'rxjs-compat/bundles/rxjs-compat.umd.min.js'
};
const NON_LAZY_MODULES = new Set(['atom', 'electron', 'react', 'react-dom', 'rxjs-compat/bundles/rxjs-compat.umd.min.js']);
const BABEL_OPTIONS = {
  plugins: [[require.resolve('./inline-invariant-tr')], [require.resolve('babel-plugin-module-resolver'), {
    alias: MODULE_ALIASES,
    cwd: NUCLIDE_ROOT
  }], [require.resolve('babel-plugin-idx')], [require.resolve('babel-plugin-lodash'), {
    // The babel plugin looks for lodash relative to the CWD.
    // This must be the path to the root package.json.
    cwd: NUCLIDE_ROOT
  }], // Note: @babel/plugin-proposal-class-properties doesn't work for us.
  [require.resolve('babel-plugin-transform-class-properties')], [require.resolve('@babel/plugin-proposal-object-rest-spread'), {
    loose: true,
    useBuiltIns: true
  }], // babel-preset-react:
  [require.resolve('@babel/plugin-transform-react-jsx'), {
    useBuiltIns: true
  }], [require.resolve('@babel/plugin-transform-flow-strip-types')], [require.resolve('@babel/plugin-transform-react-display-name')], [require.resolve('babel-plugin-relay')], [require.resolve('@babel/plugin-transform-modules-commonjs'), {
    // Determines which imports to lazy-require.
    lazy(moduleName) {
      if (NON_LAZY_MODULES.has(moduleName)) {
        return false;
      }

      return !isBuiltinModule(moduleName);
    }

  }], // The modules-commonjs transform only inserts 'use strict' for files with an ES6 import/export.
  [require.resolve('@babel/plugin-transform-strict-mode')], // Experimental syntax:
  [require.resolve('@babel/plugin-proposal-nullish-coalescing-operator')], [require.resolve('@babel/plugin-proposal-optional-chaining')]]
};
const {
  COVERAGE_DIR,
  NUCLIDE_TRANSPILE_ENV
} = process.env;

if (COVERAGE_DIR) {
  BABEL_OPTIONS.plugins.push([require.resolve('babel-plugin-istanbul')]);
}

switch (NUCLIDE_TRANSPILE_ENV) {
  case 'production':
    addYarnWorkspacesCompat();
    break;

  case 'production-modules':
    break;

  default:
    // Inline source maps should not be used in production.
    // TODO: Create .map files in production builds.
    BABEL_OPTIONS.sourceMap = 'inline'; // While Yarn workspaces work fine in development mode,
    // it doesn't hurt to be closer to the final production state.

    addYarnWorkspacesCompat();
    break;
}
/**
 * Nuclide / atom-ide-ui use Yarn workspaces, which is fine for dev mode -
 * but not so much when they're installed via `apm install` (which calls `npm install`).
 * To avoid having to publish all the modules every time, we can instead
 * use the module resolver transform to rewrite them (except when publishing modules.)
 */


function addYarnWorkspacesCompat() {
  try {
    const rootPkgJson = JSON.parse(fs.readFileSync(path.join(NUCLIDE_ROOT, 'package.json')));

    if (Array.isArray(rootPkgJson.workspaces)) {
      const glob = require('glob');

      rootPkgJson.workspaces.forEach(workspace => {
        const folders = glob.sync(workspace, {
          cwd: NUCLIDE_ROOT
        });
        folders.forEach(folder => {
          if (fs.existsSync(path.join(folder, 'package.json'))) {
            const moduleName = path.basename(folder); // Needs to be a relative path to the root CWD above.

            MODULE_ALIASES[moduleName] = './' + folder;
          }
        });
      });
    }
  } catch (err) {
    // It's OK if something doesn't exist above.
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }
}

function getVersion(start) {
  let current = start;

  do {
    try {
      const filename = path.join(current, 'package.json');
      const src = fs.readFileSync(filename);
      const json = JSON.parse(src);
      return json.version;
    } catch (err) {
      current = path.join(current, '..');
    }
  } while (current !== path.join(current, '..'));
}

class NodeTranspiler {
  static shouldCompile(bufferOrString) {
    const src = bufferOrString.toString();
    const directives = docblock.parseAsObject(docblock.extract(src));
    return directives.hasOwnProperty('flow') || directives.hasOwnProperty('transpile');
  }

  constructor() {
    this._babelVersion = require('@babel/core/package.json').version;

    this._getBabel = () => require('@babel/core');

    this._babel = null;
    this._cacheDir = null;
    this._configDigest = null;
  }

  getConfigDigest() {
    if (!this._configDigest) {
      // Keep the digest consistent regardless of what directory we're in.
      const optsOnly = { ...BABEL_OPTIONS,
        plugins: null
      };
      const hash = crypto.createHash('sha1').update('@babel/core', 'utf8').update('\0', 'utf8').update(this._babelVersion, 'utf8').update('\0', 'utf8').update(JSON.stringify(optsOnly), 'utf8'); // The source of this file and that of our plugins is used as part of the
      // hash as a way to version our transforms. For external transforms their
      // package.json version is used.

      [__filename, require.resolve('./docblock')].concat(BABEL_OPTIONS.plugins).filter(Boolean).forEach(plugin => {
        const pluginFile = Array.isArray(plugin) ? plugin[0] : plugin;

        if (pluginFile.includes('node_modules')) {
          hash.update(getVersion(pluginFile));
        } else {
          hash.update(fs.readFileSync(pluginFile));
        }

        hash.update('\0', 'utf8');
      });
      this._configDigest = hash.digest('hex');
    }

    return this._configDigest;
  }

  getFileDigest(src, filename) {
    assert(typeof filename === 'string');
    const hash = crypto.createHash('sha1') // Buffers are fast, but strings work too.
    .update(src, Buffer.isBuffer(src) ? undefined : 'utf8').update('\0', 'utf8').update(filename, 'utf8');
    const fileDigest = hash.digest('hex');
    return fileDigest;
  }

  transform(src, filename) {
    assert(typeof filename === 'string');

    if (!this._babel) {
      this._babel = this._getBabel();
    }

    try {
      const input = Buffer.isBuffer(src) ? src.toString() : src;
      const opts = {
        filename,
        ...BABEL_OPTIONS
      };

      const output = this._babel.transform(input, opts).code;

      return output;
    } catch (err) {
      console.error(`Error transpiling "${filename}"`);
      throw err;
    }
  }

  transformWithCache(src, filename) {
    assert(typeof filename === 'string');

    const cacheFilename = this._getCacheFilename(src, filename);

    if (fs.existsSync(cacheFilename)) {
      const cached = fs.readFileSync(cacheFilename, 'utf8');
      return cached;
    }

    const output = this.transform(src, filename);

    this._cacheWriteSync(cacheFilename, output);

    return output;
  }

  _getCacheFilename(src, filename) {
    if (!this._cacheDir) {
      // Give the ability to put the cache directory somewhere discoverable,
      // so debuggers can find the sourcemaps there.
      this._cacheDir = process.env.NUCLIDE_TRANSPILER_CACHE_DIR;

      if (this._cacheDir == null) {
        this._cacheDir = path.join(os.tmpdir(), '@atom-ide-community/nuclide-node-transpiler');
      }

      const digest = this.getConfigDigest();
      this._cacheDir = path.join(this._cacheDir, digest);
    }

    const fileDigest = this.getFileDigest(src, filename);
    const cacheFilename = path.join(this._cacheDir, fileDigest + '.js');
    return cacheFilename;
  }

  _cacheWriteSync(cacheFilename, src) {
    // Write the file to a temp file first and then move it so the write to the
    // cache is atomic. Although Node is single-threaded, there could be
    // multiple Node processes running simultaneously that are using the cache.
    const mkdirp = require('mkdirp');

    const uuid = require('uuid');

    const basedir = path.dirname(cacheFilename);
    const tmpName = path.join(basedir, '.' + uuid.v4());

    try {
      mkdirp.sync(basedir);
    } catch (err) {
      console.error(`Cache mkdirp failed. ${err}`);
      return;
    }

    try {
      fs.writeFileSync(tmpName, src);
      fs.renameSync(tmpName, cacheFilename);
    } catch (err) {
      console.error(`Cache write failed. ${err}`);

      try {
        fs.unlinkSync(tmpName);
      } catch (err_) {}
    }
  }

}

module.exports = NodeTranspiler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL251Y2xpZGUvbnVjbGlkZS1ub2RlLXRyYW5zcGlsZXIvbGliL05vZGVUcmFuc3BpbGVyLmpzIl0sIm5hbWVzIjpbImFzc2VydCIsInJlcXVpcmUiLCJjcnlwdG8iLCJmcyIsImlzQnVpbHRpbk1vZHVsZSIsInBhdGgiLCJvcyIsImRvY2Jsb2NrIiwiTlVDTElERV9ST09UIiwiam9pbiIsIl9fZGlybmFtZSIsIk1PRFVMRV9BTElBU0VTIiwicmVkdXgiLCJyeGpzIiwiTk9OX0xBWllfTU9EVUxFUyIsIlNldCIsIkJBQkVMX09QVElPTlMiLCJwbHVnaW5zIiwicmVzb2x2ZSIsImFsaWFzIiwiY3dkIiwibG9vc2UiLCJ1c2VCdWlsdElucyIsImxhenkiLCJtb2R1bGVOYW1lIiwiaGFzIiwiQ09WRVJBR0VfRElSIiwiTlVDTElERV9UUkFOU1BJTEVfRU5WIiwicHJvY2VzcyIsImVudiIsInB1c2giLCJhZGRZYXJuV29ya3NwYWNlc0NvbXBhdCIsInNvdXJjZU1hcCIsInJvb3RQa2dKc29uIiwiSlNPTiIsInBhcnNlIiwicmVhZEZpbGVTeW5jIiwiQXJyYXkiLCJpc0FycmF5Iiwid29ya3NwYWNlcyIsImdsb2IiLCJmb3JFYWNoIiwid29ya3NwYWNlIiwiZm9sZGVycyIsInN5bmMiLCJmb2xkZXIiLCJleGlzdHNTeW5jIiwiYmFzZW5hbWUiLCJlcnIiLCJjb2RlIiwiZ2V0VmVyc2lvbiIsInN0YXJ0IiwiY3VycmVudCIsImZpbGVuYW1lIiwic3JjIiwianNvbiIsInZlcnNpb24iLCJOb2RlVHJhbnNwaWxlciIsInNob3VsZENvbXBpbGUiLCJidWZmZXJPclN0cmluZyIsInRvU3RyaW5nIiwiZGlyZWN0aXZlcyIsInBhcnNlQXNPYmplY3QiLCJleHRyYWN0IiwiaGFzT3duUHJvcGVydHkiLCJjb25zdHJ1Y3RvciIsIl9iYWJlbFZlcnNpb24iLCJfZ2V0QmFiZWwiLCJfYmFiZWwiLCJfY2FjaGVEaXIiLCJfY29uZmlnRGlnZXN0IiwiZ2V0Q29uZmlnRGlnZXN0Iiwib3B0c09ubHkiLCJoYXNoIiwiY3JlYXRlSGFzaCIsInVwZGF0ZSIsInN0cmluZ2lmeSIsIl9fZmlsZW5hbWUiLCJjb25jYXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwicGx1Z2luIiwicGx1Z2luRmlsZSIsImluY2x1ZGVzIiwiZGlnZXN0IiwiZ2V0RmlsZURpZ2VzdCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiZmlsZURpZ2VzdCIsInRyYW5zZm9ybSIsImlucHV0Iiwib3B0cyIsIm91dHB1dCIsImNvbnNvbGUiLCJlcnJvciIsInRyYW5zZm9ybVdpdGhDYWNoZSIsImNhY2hlRmlsZW5hbWUiLCJfZ2V0Q2FjaGVGaWxlbmFtZSIsImNhY2hlZCIsIl9jYWNoZVdyaXRlU3luYyIsIk5VQ0xJREVfVFJBTlNQSUxFUl9DQUNIRV9ESVIiLCJ0bXBkaXIiLCJta2RpcnAiLCJ1dWlkIiwiYmFzZWRpciIsImRpcm5hbWUiLCJ0bXBOYW1lIiwidjQiLCJ3cml0ZUZpbGVTeW5jIiwicmVuYW1lU3luYyIsInVubGlua1N5bmMiLCJlcnJfIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLE1BQU0sR0FBR0MsT0FBTyxDQUFDLFFBQUQsQ0FBdEI7O0FBQ0EsTUFBTUMsTUFBTSxHQUFHRCxPQUFPLENBQUMsUUFBRCxDQUF0Qjs7QUFDQSxNQUFNRSxFQUFFLEdBQUdGLE9BQU8sQ0FBQyxJQUFELENBQWxCOztBQUNBLE1BQU1HLGVBQWUsR0FBR0gsT0FBTyxDQUFDLG1CQUFELENBQS9COztBQUNBLE1BQU1JLElBQUksR0FBR0osT0FBTyxDQUFDLE1BQUQsQ0FBcEI7O0FBQ0EsTUFBTUssRUFBRSxHQUFHTCxPQUFPLENBQUMsSUFBRCxD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RUQsUUFBSTtBQUNGN0MsTUFBQUEsRUFBRSxDQUFDMEcsYUFBSCxDQUFpQkYsT0FBakIsRUFBMEJyRCxHQUExQjtBQUNBbkQsTUFBQUEsRUFBRSxDQUFDMkcsVUFBSCxDQUFjSCxPQUFkLEVBQXVCVixhQUF2QjtBQUNELEtBSEQsQ0FHRSxPQUFPakQsR0FBUCxFQUFZO0FBQ1o4QyxNQUFBQSxPQUFPLENBQUNDLEtBQVIsQ0FBZSx1QkFBc0IvQyxHQUFJLEVBQXpDOztBQUNBLFVBQUk7QUFDRjdDLFFBQUFBLEVBQUUsQ0FBQzRHLFVBQUgsQ0FBY0osT0FBZDtBQUNELE9BRkQsQ0FFRSxPQUFPSyxJQUFQLEVBQWEsQ0FBRTtBQUNsQjtBQUNGOztBQXhJa0I7O0FBMklyQkMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCekQsY0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxyXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcclxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXHJcbiAqXHJcbiAqIEBub2Zsb3dcclxuICogQGZvcm1hdFxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyogZXNsaW50IG51Y2xpZGUtaW50ZXJuYWwvbm8tY29tbW9uanM6IDAgKi9cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vIE5vZGVUcmFuc3BpbGVyIGlzIGEgd3JhcHBlciBhcm91bmQgYmFiZWwgd2l0aDpcclxuLy8gICogTnVjbGlkZSBzcGVjaWZpYyBjb25maWd1cmF0aW9uLCB0aGF0IG11c3QgYmUgc2hhcmVkIGFtb25nIHNldmVyYWxcclxuLy8gICAgaW5kZXBlbmRlbnQgdHJhbnNwaWxlIHN5c3RlbXMuXHJcbi8vICAqIExhenktbG9hZGluZyBvZiBleHBlbnNpdmUgbGlicyBsaWtlIGJhYmVsLlxyXG4vLyAgKiBJdCBjYW4gYmUgY29uZmlndXJlZCB2aWEgZW52aXJvbm1lbnQgdmFyaWFibGVzOlxyXG4vLyAgICAgKiBDT1ZFUkFHRV9ESVIgZW5hYmxlcyB0aGUgXCJpc3RhbmJ1bFwiIHRyYW5zZm9ybSB0byB0cmFjayBjb3ZlcmFnZVxyXG4vLyAgICAgKiBOVUNMSURFX1RSQU5TUElMRV9FTlYgc2hvdWxkIGJlIG51bGwgfCBwcm9kdWN0aW9uIHwgcHJvZHVjdGlvbi1tb2R1bGVzOlxyXG4vLyAgICAgICAgKiBpbmxpbmUgc291cmNlbWFwcyBhcmUgZGlzYWJsZWQgaW4gYm90aCBwcm9kdWN0aW9uIGVudmlyb25tZW50c1xyXG4vLyAgICAgICAgKiBcIm1vZHVsZXMvXCIgcGF0aHMgYXJlIG5vdCByZXdyaXR0ZW4gd2l0aCBcInByb2R1Y3Rpb24tbW9kdWxlc1wiXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcclxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XHJcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcclxuY29uc3QgaXNCdWlsdGluTW9kdWxlID0gcmVxdWlyZSgnaXMtYnVpbHRpbi1tb2R1bGUnKTtcclxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcclxuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xyXG5cclxuY29uc3QgZG9jYmxvY2sgPSByZXF1aXJlKCcuL2RvY2Jsb2NrJyk7XHJcblxyXG5jb25zdCBOVUNMSURFX1JPT1QgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nKTtcclxuXHJcbmNvbnN0IE1PRFVMRV9BTElBU0VTID0ge1xyXG4gIHJlZHV4OiAncmVkdXgvZGlzdC9yZWR1eC5taW4uanMnLFxyXG4gIHJ4anM6ICdyeGpzLWNvbXBhdC9idW5kbGVzL3J4anMtY29tcGF0LnVtZC5taW4uanMnLFxyXG59O1xyXG5cclxuY29uc3QgTk9OX0xBWllfTU9EVUxFUyA9IG5ldyBTZXQoW1xyXG4gICdhdG9tJyxcclxuICAnZWxlY3Ryb24nLFxyXG4gICdyZWFjdCcsXHJcbiAgJ3JlYWN0LWRvbScsXHJcbiAgJ3J4anMtY29tcGF0L2J1bmRsZXMvcnhqcy1jb21wYXQudW1kLm1pbi5qcycsXHJcbl0pO1xyXG5cclxuY29uc3QgQkFCRUxfT1BUSU9OUyA9IHtcclxuICBwbHVnaW5zOiBbXHJcbiAgICBbcmVxdWlyZS5yZXNvbHZlKCcuL2lubGluZS1pbnZhcmlhbnQtdHInKV0sXHJcbiAgICBbXHJcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnYmFiZWwtcGx1Z2luLW1vZHVsZS1yZXNvbHZlcicpLFxyXG4gICAgICB7XHJcbiAgICAgICAgYWxpYXM6IE1PRFVMRV9BTElBU0VTLFxyXG4gICAgICAgIGN3ZDogTlVDTElERV9ST09ULFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICAgIFtyZXF1aXJlLnJlc29sdmUoJ2JhYmVsLXBsdWdpbi1pZHgnKV0sXHJcbiAgICBbXHJcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnYmFiZWwtcGx1Z2luLWxvZGFzaCcpLFxyXG4gICAgICB7XHJcbiAgICAgICAgLy8gVGhlIGJhYmVsIHBsdWdpbiBsb29rcyBmb3IgbG9kYXNoIHJlbGF0aXZlIHRvIHRoZSBDV0QuXHJcbiAgICAgICAgLy8gVGhpcyBtdXN0IGJlIHRoZSBwYXRoIHRvIHRoZSByb290IHBhY2thZ2UuanNvbi5cclxuICAgICAgICBjd2Q6IE5VQ0xJREVfUk9PVCxcclxuICAgICAgfSxcclxuICAgIF0sXHJcblxyXG4gICAgLy8gTm90ZTogQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1jbGFzcy1wcm9wZXJ0aWVzIGRvZXNuJ3Qgd29yayBmb3IgdXMuXHJcbiAgICBbcmVxdWlyZS5yZXNvbHZlKCdiYWJlbC1wbHVnaW4tdHJhbnNmb3JtLWNsYXNzLXByb3BlcnRpZXMnKV0sXHJcbiAgICBbXHJcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1vYmplY3QtcmVzdC1zcHJlYWQnKSxcclxuICAgICAge1xyXG4gICAgICAgIGxvb3NlOiB0cnVlLFxyXG4gICAgICAgIHVzZUJ1aWx0SW5zOiB0cnVlLFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuXHJcbiAgICAvLyBiYWJlbC1wcmVzZXQtcmVhY3Q6XHJcbiAgICBbcmVxdWlyZS5yZXNvbHZlKCdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1yZWFjdC1qc3gnKSwge3VzZUJ1aWx0SW5zOiB0cnVlfV0sXHJcbiAgICBbcmVxdWlyZS5yZXNvbHZlKCdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1mbG93LXN0cmlwLXR5cGVzJyldLFxyXG4gICAgW3JlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tcmVhY3QtZGlzcGxheS1uYW1lJyldLFxyXG5cclxuICAgIFtyZXF1aXJlLnJlc29sdmUoJ2JhYmVsLXBsdWdpbi1yZWxheScpXSxcclxuXHJcbiAgICBbXHJcbiAgICAgIHJlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tbW9kdWxlcy1jb21tb25qcycpLFxyXG4gICAgICB7XHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lcyB3aGljaCBpbXBvcnRzIHRvIGxhenktcmVxdWlyZS5cclxuICAgICAgICBsYXp5KG1vZHVsZU5hbWUpIHtcclxuICAgICAgICAgIGlmIChOT05fTEFaWV9NT0RVTEVTLmhhcyhtb2R1bGVOYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gIWlzQnVpbHRpbk1vZHVsZShtb2R1bGVOYW1lKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICAgIC8vIFRoZSBtb2R1bGVzLWNvbW1vbmpzIHRyYW5zZm9ybSBvbmx5IGluc2VydHMgJ3VzZSBzdHJpY3QnIGZvciBmaWxlcyB3aXRoIGFuIEVTNiBpbXBvcnQvZXhwb3J0LlxyXG4gICAgW3JlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3RyaWN0LW1vZGUnKV0sXHJcblxyXG4gICAgLy8gRXhwZXJpbWVudGFsIHN5bnRheDpcclxuICAgIFtyZXF1aXJlLnJlc29sdmUoJ0BiYWJlbC9wbHVnaW4tcHJvcG9zYWwtbnVsbGlzaC1jb2FsZXNjaW5nLW9wZXJhdG9yJyldLFxyXG4gICAgW3JlcXVpcmUucmVzb2x2ZSgnQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1vcHRpb25hbC1jaGFpbmluZycpXSxcclxuICBdLFxyXG59O1xyXG5cclxuY29uc3Qge0NPVkVSQUdFX0RJUiwgTlVDTElERV9UUkFOU1BJTEVfRU5WfSA9IHByb2Nlc3MuZW52O1xyXG5pZiAoQ09WRVJBR0VfRElSKSB7XHJcbiAgQkFCRUxfT1BUSU9OUy5wbHVnaW5zLnB1c2goW3JlcXVpcmUucmVzb2x2ZSgnYmFiZWwtcGx1Z2luLWlzdGFuYnVsJyldKTtcclxufVxyXG5zd2l0Y2ggKE5VQ0xJREVfVFJBTlNQSUxFX0VOVikge1xyXG4gIGNhc2UgJ3Byb2R1Y3Rpb24nOlxyXG4gICAgYWRkWWFybldvcmtzcGFjZXNDb21wYXQoKTtcclxuICAgIGJyZWFrO1xyXG4gIGNhc2UgJ3Byb2R1Y3Rpb24tbW9kdWxlcyc6XHJcbiAgICBicmVhaztcclxuICBkZWZhdWx0OlxyXG4gICAgLy8gSW5saW5lIHNvdXJjZSBtYXBzIHNob3VsZCBub3QgYmUgdXNlZCBpbiBwcm9kdWN0aW9uLlxyXG4gICAgLy8gVE9ETzogQ3JlYXRlIC5tYXAgZmlsZXMgaW4gcHJvZHVjdGlvbiBidWlsZHMuXHJcbiAgICBCQUJFTF9PUFRJT05TLnNvdXJjZU1hcCA9ICdpbmxpbmUnO1xyXG4gICAgLy8gV2hpbGUgWWFybiB3b3Jrc3BhY2VzIHdvcmsgZmluZSBpbiBkZXZlbG9wbWVudCBtb2RlLFxyXG4gICAgLy8gaXQgZG9lc24ndCBodXJ0IHRvIGJlIGNsb3NlciB0byB0aGUgZmluYWwgcHJvZHVjdGlvbiBzdGF0ZS5cclxuICAgIGFkZFlhcm5Xb3Jrc3BhY2VzQ29tcGF0KCk7XHJcbiAgICBicmVhaztcclxufVxyXG5cclxuLyoqXHJcbiAqIE51Y2xpZGUgLyBhdG9tLWlkZS11aSB1c2UgWWFybiB3b3Jrc3BhY2VzLCB3aGljaCBpcyBmaW5lIGZvciBkZXYgbW9kZSAtXHJcbiAqIGJ1dCBub3Qgc28gbXVjaCB3aGVuIHRoZXkncmUgaW5zdGFsbGVkIHZpYSBgYXBtIGluc3RhbGxgICh3aGljaCBjYWxscyBgbnBtIGluc3RhbGxgKS5cclxuICogVG8gYXZvaWQgaGF2aW5nIHRvIHB1Ymxpc2ggYWxsIHRoZSBtb2R1bGVzIGV2ZXJ5IHRpbWUsIHdlIGNhbiBpbnN0ZWFkXHJcbiAqIHVzZSB0aGUgbW9kdWxlIHJlc29sdmVyIHRyYW5zZm9ybSB0byByZXdyaXRlIHRoZW0gKGV4Y2VwdCB3aGVuIHB1Ymxpc2hpbmcgbW9kdWxlcy4pXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRZYXJuV29ya3NwYWNlc0NvbXBhdCgpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgcm9vdFBrZ0pzb24gPSBKU09OLnBhcnNlKFxyXG4gICAgICBmcy5yZWFkRmlsZVN5bmMocGF0aC5qb2luKE5VQ0xJREVfUk9PVCwgJ3BhY2thZ2UuanNvbicpKSxcclxuICAgICk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyb290UGtnSnNvbi53b3Jrc3BhY2VzKSkge1xyXG4gICAgICBjb25zdCBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xyXG4gICAgICByb290UGtnSnNvbi53b3Jrc3BhY2VzLmZvckVhY2god29ya3NwYWNlID0+IHtcclxuICAgICAgICBjb25zdCBmb2xkZXJzID0gZ2xvYi5zeW5jKHdvcmtzcGFjZSwge2N3ZDogTlVDTElERV9ST09UfSk7XHJcbiAgICAgICAgZm9sZGVycy5mb3JFYWNoKGZvbGRlciA9PiB7XHJcbiAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4oZm9sZGVyLCAncGFja2FnZS5qc29uJykpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGZvbGRlcik7XHJcbiAgICAgICAgICAgIC8vIE5lZWRzIHRvIGJlIGEgcmVsYXRpdmUgcGF0aCB0byB0aGUgcm9vdCBDV0QgYWJvdmUuXHJcbiAgICAgICAgICAgIE1PRFVMRV9BTElBU0VTW21vZHVsZU5hbWVdID0gJy4vJyArIGZvbGRlcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAvLyBJdCdzIE9LIGlmIHNvbWV0aGluZyBkb2Vzbid0IGV4aXN0IGFib3ZlLlxyXG4gICAgaWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykge1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRWZXJzaW9uKHN0YXJ0KSB7XHJcbiAgbGV0IGN1cnJlbnQgPSBzdGFydDtcclxuICBkbyB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBmaWxlbmFtZSA9IHBhdGguam9pbihjdXJyZW50LCAncGFja2FnZS5qc29uJyk7XHJcbiAgICAgIGNvbnN0IHNyYyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSk7XHJcbiAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHNyYyk7XHJcbiAgICAgIHJldHVybiBqc29uLnZlcnNpb247XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY3VycmVudCA9IHBhdGguam9pbihjdXJyZW50LCAnLi4nKTtcclxuICAgIH1cclxuICB9IHdoaWxlIChjdXJyZW50ICE9PSBwYXRoLmpvaW4oY3VycmVudCwgJy4uJykpO1xyXG59XHJcblxyXG5jbGFzcyBOb2RlVHJhbnNwaWxlciB7XHJcbiAgc3RhdGljIHNob3VsZENvbXBpbGUoYnVmZmVyT3JTdHJpbmcpIHtcclxuICAgIGNvbnN0IHNyYyA9IGJ1ZmZlck9yU3RyaW5nLnRvU3RyaW5nKCk7XHJcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gZG9jYmxvY2sucGFyc2VBc09iamVjdChkb2NibG9jay5leHRyYWN0KHNyYykpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgZGlyZWN0aXZlcy5oYXNPd25Qcm9wZXJ0eSgnZmxvdycpIHx8XHJcbiAgICAgIGRpcmVjdGl2ZXMuaGFzT3duUHJvcGVydHkoJ3RyYW5zcGlsZScpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLl9iYWJlbFZlcnNpb24gPSByZXF1aXJlKCdAYmFiZWwvY29yZS9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG4gICAgdGhpcy5fZ2V0QmFiZWwgPSAoKSA9PiByZXF1aXJlKCdAYmFiZWwvY29yZScpO1xyXG4gICAgdGhpcy5fYmFiZWwgPSBudWxsO1xyXG4gICAgdGhpcy5fY2FjaGVEaXIgPSBudWxsO1xyXG4gICAgdGhpcy5fY29uZmlnRGlnZXN0ID0gbnVsbDtcclxuICB9XHJcblxyXG4gIGdldENvbmZpZ0RpZ2VzdCgpIHtcclxuICAgIGlmICghdGhpcy5fY29uZmlnRGlnZXN0KSB7XHJcbiAgICAgIC8vIEtlZXAgdGhlIGRpZ2VzdCBjb25zaXN0ZW50IHJlZ2FyZGxlc3Mgb2Ygd2hhdCBkaXJlY3Rvcnkgd2UncmUgaW4uXHJcbiAgICAgIGNvbnN0IG9wdHNPbmx5ID0gey4uLkJBQkVMX09QVElPTlMsIHBsdWdpbnM6IG51bGx9O1xyXG4gICAgICBjb25zdCBoYXNoID0gY3J5cHRvXHJcbiAgICAgICAgLmNyZWF0ZUhhc2goJ3NoYTEnKVxyXG4gICAgICAgIC51cGRhdGUoJ0BiYWJlbC9jb3JlJywgJ3V0ZjgnKVxyXG4gICAgICAgIC51cGRhdGUoJ1xcMCcsICd1dGY4JylcclxuICAgICAgICAudXBkYXRlKHRoaXMuX2JhYmVsVmVyc2lvbiwgJ3V0ZjgnKVxyXG4gICAgICAgIC51cGRhdGUoJ1xcMCcsICd1dGY4JylcclxuICAgICAgICAudXBkYXRlKEpTT04uc3RyaW5naWZ5KG9wdHNPbmx5KSwgJ3V0ZjgnKTtcclxuICAgICAgLy8gVGhlIHNvdXJjZSBvZiB0aGlzIGZpbGUgYW5kIHRoYXQgb2Ygb3VyIHBsdWdpbnMgaXMgdXNlZCBhcyBwYXJ0IG9mIHRoZVxyXG4gICAgICAvLyBoYXNoIGFzIGEgd2F5IHRvIHZlcnNpb24gb3VyIHRyYW5zZm9ybXMuIEZvciBleHRlcm5hbCB0cmFuc2Zvcm1zIHRoZWlyXHJcbiAgICAgIC8vIHBhY2thZ2UuanNvbiB2ZXJzaW9uIGlzIHVzZWQuXHJcbiAgICAgIFtfX2ZpbGVuYW1lLCByZXF1aXJlLnJlc29sdmUoJy4vZG9jYmxvY2snKV1cclxuICAgICAgICAuY29uY2F0KEJBQkVMX09QVElPTlMucGx1Z2lucylcclxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXHJcbiAgICAgICAgLmZvckVhY2gocGx1Z2luID0+IHtcclxuICAgICAgICAgIGNvbnN0IHBsdWdpbkZpbGUgPSBBcnJheS5pc0FycmF5KHBsdWdpbikgPyBwbHVnaW5bMF0gOiBwbHVnaW47XHJcbiAgICAgICAgICBpZiAocGx1Z2luRmlsZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJykpIHtcclxuICAgICAgICAgICAgaGFzaC51cGRhdGUoZ2V0VmVyc2lvbihwbHVnaW5GaWxlKSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoYXNoLnVwZGF0ZShmcy5yZWFkRmlsZVN5bmMocGx1Z2luRmlsZSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaGFzaC51cGRhdGUoJ1xcMCcsICd1dGY4Jyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZ0RpZ2VzdCA9IGhhc2guZGlnZXN0KCdoZXgnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9jb25maWdEaWdlc3Q7XHJcbiAgfVxyXG5cclxuICBnZXRGaWxlRGlnZXN0KHNyYywgZmlsZW5hbWUpIHtcclxuICAgIGFzc2VydCh0eXBlb2YgZmlsZW5hbWUgPT09ICdzdHJpbmcnKTtcclxuICAgIGNvbnN0IGhhc2ggPSBjcnlwdG9cclxuICAgICAgLmNyZWF0ZUhhc2goJ3NoYTEnKVxyXG4gICAgICAvLyBCdWZmZXJzIGFyZSBmYXN0LCBidXQgc3RyaW5ncyB3b3JrIHRvby5cclxuICAgICAgLnVwZGF0ZShzcmMsIEJ1ZmZlci5pc0J1ZmZlcihzcmMpID8gdW5kZWZpbmVkIDogJ3V0ZjgnKVxyXG4gICAgICAudXBkYXRlKCdcXDAnLCAndXRmOCcpXHJcbiAgICAgIC51cGRhdGUoZmlsZW5hbWUsICd1dGY4Jyk7XHJcbiAgICBjb25zdCBmaWxlRGlnZXN0ID0gaGFzaC5kaWdlc3QoJ2hleCcpO1xyXG4gICAgcmV0dXJuIGZpbGVEaWdlc3Q7XHJcbiAgfVxyXG5cclxuICB0cmFuc2Zvcm0oc3JjLCBmaWxlbmFtZSkge1xyXG4gICAgYXNzZXJ0KHR5cGVvZiBmaWxlbmFtZSA9PT0gJ3N0cmluZycpO1xyXG4gICAgaWYgKCF0aGlzLl9iYWJlbCkge1xyXG4gICAgICB0aGlzLl9iYWJlbCA9IHRoaXMuX2dldEJhYmVsKCk7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBpbnB1dCA9IEJ1ZmZlci5pc0J1ZmZlcihzcmMpID8gc3JjLnRvU3RyaW5nKCkgOiBzcmM7XHJcbiAgICAgIGNvbnN0IG9wdHMgPSB7ZmlsZW5hbWUsIC4uLkJBQkVMX09QVElPTlN9O1xyXG4gICAgICBjb25zdCBvdXRwdXQgPSB0aGlzLl9iYWJlbC50cmFuc2Zvcm0oaW5wdXQsIG9wdHMpLmNvZGU7XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdHJhbnNwaWxpbmcgXCIke2ZpbGVuYW1lfVwiYCk7XHJcbiAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRyYW5zZm9ybVdpdGhDYWNoZShzcmMsIGZpbGVuYW1lKSB7XHJcbiAgICBhc3NlcnQodHlwZW9mIGZpbGVuYW1lID09PSAnc3RyaW5nJyk7XHJcbiAgICBjb25zdCBjYWNoZUZpbGVuYW1lID0gdGhpcy5fZ2V0Q2FjaGVGaWxlbmFtZShzcmMsIGZpbGVuYW1lKTtcclxuXHJcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhjYWNoZUZpbGVuYW1lKSkge1xyXG4gICAgICBjb25zdCBjYWNoZWQgPSBmcy5yZWFkRmlsZVN5bmMoY2FjaGVGaWxlbmFtZSwgJ3V0ZjgnKTtcclxuICAgICAgcmV0dXJuIGNhY2hlZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvdXRwdXQgPSB0aGlzLnRyYW5zZm9ybShzcmMsIGZpbGVuYW1lKTtcclxuICAgIHRoaXMuX2NhY2hlV3JpdGVTeW5jKGNhY2hlRmlsZW5hbWUsIG91dHB1dCk7XHJcblxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxuICB9XHJcblxyXG4gIF9nZXRDYWNoZUZpbGVuYW1lKHNyYywgZmlsZW5hbWUpIHtcclxuICAgIGlmICghdGhpcy5fY2FjaGVEaXIpIHtcclxuICAgICAgLy8gR2l2ZSB0aGUgYWJpbGl0eSB0byBwdXQgdGhlIGNhY2hlIGRpcmVjdG9yeSBzb21ld2hlcmUgZGlzY292ZXJhYmxlLFxyXG4gICAgICAvLyBzbyBkZWJ1Z2dlcnMgY2FuIGZpbmQgdGhlIHNvdXJjZW1hcHMgdGhlcmUuXHJcbiAgICAgIHRoaXMuX2NhY2hlRGlyID0gcHJvY2Vzcy5lbnYuTlVDTElERV9UUkFOU1BJTEVSX0NBQ0hFX0RJUjtcclxuICAgICAgaWYgKHRoaXMuX2NhY2hlRGlyID09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9jYWNoZURpciA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgJ0BhdG9tLWlkZS1jb21tdW5pdHkvbnVjbGlkZS1ub2RlLXRyYW5zcGlsZXInKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgZGlnZXN0ID0gdGhpcy5nZXRDb25maWdEaWdlc3QoKTtcclxuICAgICAgdGhpcy5fY2FjaGVEaXIgPSBwYXRoLmpvaW4odGhpcy5fY2FjaGVEaXIsIGRpZ2VzdCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmaWxlRGlnZXN0ID0gdGhpcy5nZXRGaWxlRGlnZXN0KHNyYywgZmlsZW5hbWUpO1xyXG4gICAgY29uc3QgY2FjaGVGaWxlbmFtZSA9IHBhdGguam9pbih0aGlzLl9jYWNoZURpciwgZmlsZURpZ2VzdCArICcuanMnKTtcclxuICAgIHJldHVybiBjYWNoZUZpbGVuYW1lO1xyXG4gIH1cclxuXHJcbiAgX2NhY2hlV3JpdGVTeW5jKGNhY2hlRmlsZW5hbWUsIHNyYykge1xyXG4gICAgLy8gV3JpdGUgdGhlIGZpbGUgdG8gYSB0ZW1wIGZpbGUgZmlyc3QgYW5kIHRoZW4gbW92ZSBpdCBzbyB0aGUgd3JpdGUgdG8gdGhlXHJcbiAgICAvLyBjYWNoZSBpcyBhdG9taWMuIEFsdGhvdWdoIE5vZGUgaXMgc2luZ2xlLXRocmVhZGVkLCB0aGVyZSBjb3VsZCBiZVxyXG4gICAgLy8gbXVsdGlwbGUgTm9kZSBwcm9jZXNzZXMgcnVubmluZyBzaW11bHRhbmVvdXNseSB0aGF0IGFyZSB1c2luZyB0aGUgY2FjaGUuXHJcblxyXG4gICAgY29uc3QgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XHJcbiAgICBjb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xyXG5cclxuICAgIGNvbnN0IGJhc2VkaXIgPSBwYXRoLmRpcm5hbWUoY2FjaGVGaWxlbmFtZSk7XHJcbiAgICBjb25zdCB0bXBOYW1lID0gcGF0aC5qb2luKGJhc2VkaXIsICcuJyArIHV1aWQudjQoKSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgbWtkaXJwLnN5bmMoYmFzZWRpcik7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgQ2FjaGUgbWtkaXJwIGZhaWxlZC4gJHtlcnJ9YCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKHRtcE5hbWUsIHNyYyk7XHJcbiAgICAgIGZzLnJlbmFtZVN5bmModG1wTmFtZSwgY2FjaGVGaWxlbmFtZSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgQ2FjaGUgd3JpdGUgZmFpbGVkLiAke2Vycn1gKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBmcy51bmxpbmtTeW5jKHRtcE5hbWUpO1xyXG4gICAgICB9IGNhdGNoIChlcnJfKSB7fVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlVHJhbnNwaWxlcjtcclxuIl19