import { TextEditor, TextBuffer, Range, Point } from "atom";
/**
 * Finds the word at the position. You can either provide a word regex yourself,
 * or have Atom use the word regex in force at the scopes at that position,
 * in which case it uses the optional includeNonWordCharacters, default true.
 * (I know that's a weird default but it follows Atom's convention...)
 */
export declare function wordAtPosition(editor: TextEditor, position: Point, wordRegex?: RegExp | {
    includeNonWordCharacters: boolean;
}): {
    wordMatch: Array<string>;
    range: Range;
} | null;
/**
 * Gets the trimmed range from a given range, i.e. moves the start and end points
 * to the first and last non-whitespace characters (or specified regex)
 * within the range respectively.
 *
 * @param editor       the editor containing the range
 * @param rangeToTrim  the range to trim
 * @param stopRegex    stop trimming when the first match is found for this regex,
 *   defaults to first non-whitespace character
 * @return Range  the trimmed range
 */
export declare function trimRange(editor: TextEditor, rangeToTrim: Range, stopRegex?: RegExp): Range;
/**
 * Gets the word being right-clicked on in a MouseEvent. A good use case for
 * this is performing an action on a word from a context menu.
 *
 * @param editor  the editor containing the word where the MouseEvent occurred
 *   from
 * @param event   the MouseEvent containing the screen position of the click
 */
export declare function getWordFromMouseEvent(editor: TextEditor, event: MouseEvent): string | null;
/**
 * Attempts to get a word from the last selection or cursor. A good use case for
 * this is performing an action on an 'active' word after a command is triggered
 * via a keybinding.
 *
 * @param editor  the editor containing the 'active' word when the keybinding is
 *   triggered
 */
export declare function getWordFromCursorOrSelection(editor: TextEditor): string | null;
export declare function wordAtPositionFromBuffer(buffer: TextBuffer, position: Point, wordRegex: RegExp): {
    wordMatch: Array<string>;
    range: Range;
} | null;
export declare function matchRegexEndingAt(buffer: TextBuffer, endPosition: Point, regex: RegExp): string | null;
export declare function isPositionInRange(position: Point, range: Range | Array<Range>): boolean;
