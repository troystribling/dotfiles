"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPositionInRange = exports.matchRegexEndingAt = exports.wordAtPositionFromBuffer = exports.getWordFromCursorOrSelection = exports.getWordFromMouseEvent = exports.trimRange = exports.wordAtPosition = void 0;
const atom_1 = require("atom");
const assert_1 = __importDefault(require("assert"));
/**
 * Finds the word at the position. You can either provide a word regex yourself,
 * or have Atom use the word regex in force at the scopes at that position,
 * in which case it uses the optional includeNonWordCharacters, default true.
 * (I know that's a weird default but it follows Atom's convention...)
 */
function wordAtPosition(editor, position, wordRegex) {
    let wordRegex_;
    if (wordRegex instanceof RegExp) {
        wordRegex_ = wordRegex;
    }
    else {
        // What is the word regex associated with the position? We'd like to use
        // Cursor.wordRegExp, except that function gets the regex associated
        // with the editor's current cursor while we want the regex associated with
        // the specific position. So we re-implement it ourselves...
        // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5032
        const nonWordChars = editor.getNonWordCharacters(position);
        const escaped = nonWordChars.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        // We copied this escaping regex from Cursor.wordRegexp, rather than
        // using the library function 'escapeStringRegExp'. That's because the
        // library function doesn't escape the hyphen character and so is
        // unsuitable for use inside a range.
        let r = `^[\t ]*$|[^\\s${escaped}]+`;
        if (wordRegex == null || wordRegex.includeNonWordCharacters) {
            r += `|[${escaped}]+`;
        }
        wordRegex_ = new RegExp(r, "g");
    }
    return wordAtPositionFromBuffer(editor.getBuffer(), position, wordRegex_);
}
exports.wordAtPosition = wordAtPosition;
/**
 * Gets the trimmed range from a given range, i.e. moves the start and end points
 * to the first and last non-whitespace characters (or specified regex)
 * within the range respectively.
 *
 * @param editor       the editor containing the range
 * @param rangeToTrim  the range to trim
 * @param stopRegex    stop trimming when the first match is found for this regex,
 *   defaults to first non-whitespace character
 * @return Range  the trimmed range
 */
function trimRange(editor, rangeToTrim, stopRegex = /\S/) {
    const buffer = editor.getBuffer();
    let { start, end } = rangeToTrim;
    buffer.scanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {
        start = range.start;
        stop();
    });
    buffer.backwardsScanInRange(stopRegex, rangeToTrim, ({ range, stop }) => {
        end = range.end;
        stop();
    });
    return new atom_1.Range(start, end);
}
exports.trimRange = trimRange;
function getSingleWordAtPosition(editor, position) {
    const match = wordAtPosition(editor, position);
    // We should only receive a single identifier from a single point.
    if (match == null || match.wordMatch.length !== 1) {
        return null;
    }
    return match.wordMatch[0];
}
/**
 * Gets the word being right-clicked on in a MouseEvent. A good use case for
 * this is performing an action on a word from a context menu.
 *
 * @param editor  the editor containing the word where the MouseEvent occurred
 *   from
 * @param event   the MouseEvent containing the screen position of the click
 */
function getWordFromMouseEvent(editor, event) {
    // We can't immediately get the identifier right-clicked on from
    // the MouseEvent. Using its target element content would work in
    // some cases but wouldn't work if there was additional content
    // in the same element, such as in a comment.
    // @ts-ignore: https://github.com/atom/atom/blob/aa3c34bedb361e09a5068dce9620b460a20ca3fb/src/text-editor.js#L5075
    const component = editor.getElement().component;
    assert_1.default(component);
    // This solution doesn't feel ideal but it is the way hyperclick does it.
    const point = component.screenPositionForMouseEvent(event);
    return getSingleWordAtPosition(editor, point);
}
exports.getWordFromMouseEvent = getWordFromMouseEvent;
/**
 * Attempts to get a word from the last selection or cursor. A good use case for
 * this is performing an action on an 'active' word after a command is triggered
 * via a keybinding.
 *
 * @param editor  the editor containing the 'active' word when the keybinding is
 *   triggered
 */
function getWordFromCursorOrSelection(editor) {
    const selection = editor.getSelectedText();
    if (selection && selection.length > 0) {
        return selection;
    }
    // There was no selection so we can go ahead and try the cursor position.
    const point = editor.getCursorScreenPosition();
    return getSingleWordAtPosition(editor, point);
}
exports.getWordFromCursorOrSelection = getWordFromCursorOrSelection;
function wordAtPositionFromBuffer(buffer, position, wordRegex) {
    const { row, column } = position;
    const rowRange = buffer.rangeForRow(row);
    let matchData;
    // Extract the expression from the row text.
    buffer.scanInRange(wordRegex, rowRange, (data) => {
        const { range } = data;
        if (range.start.isLessThanOrEqual(position) && range.end.isGreaterThan(position)) {
            matchData = data;
        }
        // Stop the scan if the scanner has passed our position.
        if (range.end.column > column) {
            data.stop();
        }
    });
    // @ts-ignore (it is assigned above)
    if (matchData) {
        return {
            wordMatch: matchData.match,
            range: matchData.range,
        };
    }
    else {
        return null;
    }
}
exports.wordAtPositionFromBuffer = wordAtPositionFromBuffer;
// Matches a regex on the text of the line ending at endPosition.
// regex should end with a '$'.
// Useful for autocomplete.
function matchRegexEndingAt(buffer, endPosition, regex) {
    const line = buffer.getTextInRange([[endPosition.row, 0], endPosition]);
    const match = regex.exec(line);
    return match == null ? null : match[0];
}
exports.matchRegexEndingAt = matchRegexEndingAt;
function isPositionInRange(position, range) {
    return Array.isArray(range) ? range.some((r) => r.containsPoint(position)) : range.containsPoint(position);
}
exports.isPositionInRange = isPositionInRange;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMtY29tbW9ucy1hdG9tL3JhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLCtCQUFnRjtBQUNoRixvREFBOEI7QUFFOUI7Ozs7O0dBS0c7QUFDSCxTQUFnQixjQUFjLENBQzVCLE1BQWtCLEVBQ2xCLFFBQWUsRUFDZixTQUEwRDtJQUUxRCxJQUFJLFVBQVUsQ0FBQTtJQUNkLElBQUksU0FBUyxZQUFZLE1BQU0sRUFBRTtRQUMvQixVQUFVLEdBQUcsU0FBUyxDQUFBO0tBQ3ZCO1NBQU07UUFDTCx3RUFBd0U7UUFDeEUsb0VBQW9FO1FBQ3BFLDJFQUEyRTtRQUMzRSw0REFBNEQ7UUFDNUQsa0hBQWtIO1FBQ2xILE1BQU0sWUFBWSxHQUFXLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUNsRSxNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLHVCQUF1QixFQUFFLE1BQU0sQ0FBQyxDQUFBO1FBQ3JFLG9FQUFvRTtRQUNwRSxzRUFBc0U7UUFDdEUsaUVBQWlFO1FBQ2pFLHFDQUFxQztRQUNyQyxJQUFJLENBQUMsR0FBRyxpQkFBaUIsT0FBTyxJQUFJLENBQUE7UUFDcEMsSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLFNBQVMsQ0FBQyx3QkFBd0IsRUFBRTtZQUMzRCxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksQ0FBQTtTQUN0QjtRQUNELFVBQVUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUE7S0FDaEM7SUFDRCxPQUFPLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUE7QUFDM0UsQ0FBQztBQTNCRCx3Q0EyQkM7QUFFRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLE1BQWtCLEVBQUUsV0FBa0IsRUFBRSxZQUFv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QUFhLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDNUcsQ0FBQztBQUZELDhDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGV4dEVkaXRvciwgVGV4dEVkaXRvckNvbXBvbmVudCwgVGV4dEJ1ZmZlciwgUmFuZ2UsIFBvaW50IH0gZnJvbSBcImF0b21cIlxuaW1wb3J0IGludmFyaWFudCBmcm9tIFwiYXNzZXJ0XCJcblxuLyoqXG4gKiBGaW5kcyB0aGUgd29yZCBhdCB0aGUgcG9zaXRpb24uIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSB3b3JkIHJlZ2V4IHlvdXJzZWxmLFxuICogb3IgaGF2ZSBBdG9tIHVzZSB0aGUgd29yZCByZWdleCBpbiBmb3JjZSBhdCB0aGUgc2NvcGVzIGF0IHRoYXQgcG9zaXRpb24sXG4gKiBpbiB3aGljaCBjYXNlIGl0IHVzZXMgdGhlIG9wdGlvbmFsIGluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVycywgZGVmYXVsdCB0cnVlLlxuICogKEkga25vdyB0aGF0J3MgYSB3ZWlyZCBkZWZhdWx0IGJ1dCBpdCBmb2xsb3dzIEF0b20ncyBjb252ZW50aW9uLi4uKVxuICovXG5leHBvcnQgZnVuY3Rpb24gd29yZEF0UG9zaXRpb24oXG4gIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgcG9zaXRpb246IFBvaW50LFxuICB3b3JkUmVnZXg/OiBSZWdFeHAgfCB7IGluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVyczogYm9vbGVhbiB9XG4pOiB7IHdvcmRNYXRjaDogQXJyYXk8c3RyaW5nPjsgcmFuZ2U6IFJhbmdlIH0gfCBudWxsIHtcbiAgbGV0IHdvcmRSZWdleF9cbiAgaWYgKHdvcmRSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHdvcmRSZWdleF8gPSB3b3JkUmVnZXhcbiAgfSBlbHNlIHtcbiAgICAvLyBXaGF0IGlzIHRoZSB3b3JkIHJlZ2V4IGFzc29jaWF0ZWQgd2l0aCB0aGUgcG9zaXRpb24/IFdlJ2QgbGlrZSB0byB1c2VcbiAgICAvLyBDdXJzb3Iud29yZFJlZ0V4cCwgZXhjZXB0IHRoYXQgZnVuY3Rpb24gZ2V0cyB0aGUgcmVnZXggYXNzb2NpYXRlZFxuICAgIC8vIHdpdGggdGhlIGVkaXRvcidzIGN1cnJlbnQgY3Vyc29yIHdoaWxlIHdlIHdhbnQgdGhlIHJlZ2V4IGFzc29jaWF0ZWQgd2l0aFxuICAgIC8vIHRoZSBzcGVjaWZpYyBwb3NpdGlvbi4gU28gd2UgcmUtaW1wbGVtZW50IGl0IG91cnNlbHZlcy4uLlxuICAgIC8vIEB0cy1pZ25vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2F0b20vYmxvYi9hYTNjMzRiZWRiMzYxZTA5YTUwNjhkY2U5NjIwYjQ2MGEyMGNhM2ZiL3NyYy90ZXh0LWVkaXRvci5qcyNMNTAzMlxuICAgIGNvbnN0IG5vbldvcmRDaGFyczogc3RyaW5nID0gZWRpdG9yLmdldE5vbldvcmRDaGFyYWN0ZXJzKHBvc2l0aW9uKVxuICAgIGNvbnN0IGVzY2FwZWQgPSBub25Xb3JkQ2hhcnMucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIilcbiAgICAvLyBXZSBjb3BpZWQgdGhpcyBlc2NhcGluZyByZWdleCBmcm9tIEN1cnNvci53b3JkUmVnZXhwLCByYXRoZXIgdGhhblxuICAgIC8vIHVzaW5nIHRoZSBsaWJyYXJ5IGZ1bmN0aW9uICdlc2NhcGVTdHJpbmdSZWdFeHAnLiBUaGF0J3MgYmVjYXVzZSB0aGVcbiAgICAvLyBsaWJyYXJ5IGZ1bmN0aW9uIGRvZXNuJ3QgZXNjYXBlIHRoZSBoeXBoZW4gY2hhcmFjdGVyIGFuZCBzbyBpc1xuICAgIC8vIHVuc3VpdGFibGUgZm9yIHVzZSBpbnNpZGUgYSByYW5nZS5cbiAgICBsZXQgciA9IGBeW1xcdCBdKiR8W15cXFxccyR7ZXNjYXBlZH1dK2BcbiAgICBpZiAod29yZFJlZ2V4ID09IG51bGwgfHwgd29yZFJlZ2V4LmluY2x1ZGVOb25Xb3JkQ2hhcmFjdGVycykge1xuICAgICAgciArPSBgfFske2VzY2FwZWR9XStgXG4gICAgfVxuICAgIHdvcmRSZWdleF8gPSBuZXcgUmVnRXhwKHIsIFwiZ1wiKVxuICB9XG4gIHJldHVybiB3b3JkQXRQb3NpdGlvbkZyb21CdWZmZXIoZWRpdG9yLmdldEJ1ZmZlcigpLCBwb3NpdGlvbiwgd29yZFJlZ2V4Xylcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0cmltbWVkIHJhbmdlIGZyb20gYSBnaXZlbiByYW5nZSwgaS5lLiBtb3ZlcyB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAqIHRvIHRoZSBmaXJzdCBhbmQgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChvciBzcGVjaWZpZWQgcmVnZXgpXG4gKiB3aXRoaW4gdGhlIHJhbmdlIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yICAgICAgIHRoZSBlZGl0b3IgY29udGFpbmluZyB0aGUgcmFuZ2VcbiAqIEBwYXJhbSByYW5nZVRvVHJpbSAgdGhlIHJhbmdlIHRvIHRyaW1cbiAqIEBwYXJhbSBzdG9wUmVnZXggICAgc3RvcCB0cmltbWluZyB3aGVuIHRoZSBmaXJzdCBtYXRjaCBpcyBmb3VuZCBmb3IgdGhpcyByZWdleCxcbiAqICAgZGVmYXVsdHMgdG8gZmlyc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIFJhbmdlICB0aGUgdHJpbW1lZCByYW5nZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJhbmdlKGVkaXRvcjogVGV4dEVkaXRvciwgcmFuZ2VUb1RyaW06IFJhbmdlLCBzdG9wUmVnZXg6IFJlZ0V4cCA9IC9cXFMvKTogUmFuZ2Uge1xuICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKClcbiAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2VUb1RyaW1cbiAgYnVmZmVyLnNjYW5JblJhbmdlKHN0b3BSZWdleCwgcmFuZ2VUb1RyaW0sICh7IHJhbmdlLCBzdG9wIH0pID0+IHtcbiAgICBzdGFydCA9IHJhbmdlLnN0YXJ0XG4gICAgc3RvcCgpXG4gIH0pXG4gIGJ1ZmZlci5iYWNrd2FyZHNTY2FuSW5SYW5nZShzdG9wUmVnZXgsIHJhbmdlVG9UcmltLCAoeyByYW5nZSwgc3RvcCB9KSA9PiB7XG4gICAgZW5kID0gcmFuZ2UuZW5kXG4gICAgc3RvcCgpXG4gIH0pXG4gIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gZ2V0U2luZ2xlV29yZEF0UG9zaXRpb24oZWRpdG9yOiBUZXh0RWRpdG9yLCBwb3NpdGlvbjogUG9pbnQpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbWF0Y2ggPSB3b3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvc2l0aW9uKVxuICAvLyBXZSBzaG91bGQgb25seSByZWNlaXZlIGEgc2luZ2xlIGlkZW50aWZpZXIgZnJvbSBhIHNpbmdsZSBwb2ludC5cbiAgaWYgKG1hdGNoID09IG51bGwgfHwgbWF0Y2gud29yZE1hdGNoLmxlbmd0aCAhPT0gMSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gbWF0Y2gud29yZE1hdGNoWzBdXG59XG5cbi8qKlxuICogR2V0cyB0aGUgd29yZCBiZWluZyByaWdodC1jbGlja2VkIG9uIGluIGEgTW91c2VFdmVudC4gQSBnb29kIHVzZSBjYXNlIGZvclxuICogdGhpcyBpcyBwZXJmb3JtaW5nIGFuIGFjdGlvbiBvbiBhIHdvcmQgZnJvbSBhIGNvbnRleHQgbWVudS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yICB0aGUgZWRpdG9yIGNvbnRhaW5pbmcgdGhlIHdvcmQgd2hlcmUgdGhlIE1vdXNlRXZlbnQgb2NjdXJyZWRcbiAqICAgZnJvbVxuICogQHBhcmFtIGV2ZW50ICAgdGhlIE1vdXNlRXZlbnQgY29udGFpbmluZyB0aGUgc2NyZWVuIHBvc2l0aW9uIG9mIHRoZSBjbGlja1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29yZEZyb21Nb3VzZUV2ZW50KGVkaXRvcjogVGV4dEVkaXRvciwgZXZlbnQ6IE1vdXNlRXZlbnQpOiBzdHJpbmcgfCBudWxsIHtcbiAgLy8gV2UgY2FuJ3QgaW1tZWRpYXRlbHkgZ2V0IHRoZSBpZGVudGlmaWVyIHJpZ2h0LWNsaWNrZWQgb24gZnJvbVxuICAvLyB0aGUgTW91c2VFdmVudC4gVXNpbmcgaXRzIHRhcmdldCBlbGVtZW50IGNvbnRlbnQgd291bGQgd29yayBpblxuICAvLyBzb21lIGNhc2VzIGJ1dCB3b3VsZG4ndCB3b3JrIGlmIHRoZXJlIHdhcyBhZGRpdGlvbmFsIGNvbnRlbnRcbiAgLy8gaW4gdGhlIHNhbWUgZWxlbWVudCwgc3VjaCBhcyBpbiBhIGNvbW1lbnQuXG4gIC8vIEB0cy1pZ25vcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hdG9tL2F0b20vYmxvYi9hYTNjMzRiZWRiMzYxZTA5YTUwNjhkY2U5NjIwYjQ2MGEyMGNhM2ZiL3NyYy90ZXh0LWVkaXRvci5qcyNMNTA3NVxuICBjb25zdCBjb21wb25lbnQ6IFRleHRFZGl0b3JDb21wb25lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudCgpLmNvbXBvbmVudFxuICBpbnZhcmlhbnQoY29tcG9uZW50KVxuICAvLyBUaGlzIHNvbHV0aW9uIGRvZXNuJ3QgZmVlbCBpZGVhbCBidXQgaXQgaXMgdGhlIHdheSBoeXBlcmNsaWNrIGRvZXMgaXQuXG4gIGNvbnN0IHBvaW50ID0gY29tcG9uZW50LnNjcmVlblBvc2l0aW9uRm9yTW91c2VFdmVudChldmVudClcbiAgcmV0dXJuIGdldFNpbmdsZVdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpXG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IGEgd29yZCBmcm9tIHRoZSBsYXN0IHNlbGVjdGlvbiBvciBjdXJzb3IuIEEgZ29vZCB1c2UgY2FzZSBmb3JcbiAqIHRoaXMgaXMgcGVyZm9ybWluZyBhbiBhY3Rpb24gb24gYW4gJ2FjdGl2ZScgd29yZCBhZnRlciBhIGNvbW1hbmQgaXMgdHJpZ2dlcmVkXG4gKiB2aWEgYSBrZXliaW5kaW5nLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgIHRoZSBlZGl0b3IgY29udGFpbmluZyB0aGUgJ2FjdGl2ZScgd29yZCB3aGVuIHRoZSBrZXliaW5kaW5nIGlzXG4gKiAgIHRyaWdnZXJlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V29yZEZyb21DdXJzb3JPclNlbGVjdGlvbihlZGl0b3I6IFRleHRFZGl0b3IpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGVkVGV4dCgpXG4gIGlmIChzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uXG4gIH1cblxuICAvLyBUaGVyZSB3YXMgbm8gc2VsZWN0aW9uIHNvIHdlIGNhbiBnbyBhaGVhZCBhbmQgdHJ5IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4gIGNvbnN0IHBvaW50ID0gZWRpdG9yLmdldEN1cnNvclNjcmVlblBvc2l0aW9uKClcbiAgcmV0dXJuIGdldFNpbmdsZVdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3b3JkQXRQb3NpdGlvbkZyb21CdWZmZXIoXG4gIGJ1ZmZlcjogVGV4dEJ1ZmZlcixcbiAgcG9zaXRpb246IFBvaW50LFxuICB3b3JkUmVnZXg6IFJlZ0V4cFxuKTogeyB3b3JkTWF0Y2g6IEFycmF5PHN0cmluZz47IHJhbmdlOiBSYW5nZSB9IHwgbnVsbCB7XG4gIGNvbnN0IHsgcm93LCBjb2x1bW4gfSA9IHBvc2l0aW9uXG4gIGNvbnN0IHJvd1JhbmdlID0gYnVmZmVyLnJhbmdlRm9yUm93KHJvdylcbiAgbGV0IG1hdGNoRGF0YTogeyBtYXRjaDogQXJyYXk8c3RyaW5nPjsgcmFuZ2U6IFJhbmdlIH0gfCBudWxsXG4gIC8vIEV4dHJhY3QgdGhlIGV4cHJlc3Npb24gZnJvbSB0aGUgcm93IHRleHQuXG4gIGJ1ZmZlci5zY2FuSW5SYW5nZSh3b3JkUmVnZXgsIHJvd1JhbmdlLCAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHsgcmFuZ2UgfSA9IGRhdGFcbiAgICBpZiAocmFuZ2Uuc3RhcnQuaXNMZXNzVGhhbk9yRXF1YWwocG9zaXRpb24pICYmIHJhbmdlLmVuZC5pc0dyZWF0ZXJUaGFuKHBvc2l0aW9uKSkge1xuICAgICAgbWF0Y2hEYXRhID0gZGF0YVxuICAgIH1cbiAgICAvLyBTdG9wIHRoZSBzY2FuIGlmIHRoZSBzY2FubmVyIGhhcyBwYXNzZWQgb3VyIHBvc2l0aW9uLlxuICAgIGlmIChyYW5nZS5lbmQuY29sdW1uID4gY29sdW1uKSB7XG4gICAgICBkYXRhLnN0b3AoKVxuICAgIH1cbiAgfSlcbiAgLy8gQHRzLWlnbm9yZSAoaXQgaXMgYXNzaWduZWQgYWJvdmUpXG4gIGlmIChtYXRjaERhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd29yZE1hdGNoOiBtYXRjaERhdGEubWF0Y2gsXG4gICAgICByYW5nZTogbWF0Y2hEYXRhLnJhbmdlLFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIE1hdGNoZXMgYSByZWdleCBvbiB0aGUgdGV4dCBvZiB0aGUgbGluZSBlbmRpbmcgYXQgZW5kUG9zaXRpb24uXG4vLyByZWdleCBzaG91bGQgZW5kIHdpdGggYSAnJCcuXG4vLyBVc2VmdWwgZm9yIGF1dG9jb21wbGV0ZS5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJlZ2V4RW5kaW5nQXQoYnVmZmVyOiBUZXh0QnVmZmVyLCBlbmRQb3NpdGlvbjogUG9pbnQsIHJlZ2V4OiBSZWdFeHApOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgbGluZSA9IGJ1ZmZlci5nZXRUZXh0SW5SYW5nZShbW2VuZFBvc2l0aW9uLnJvdywgMF0sIGVuZFBvc2l0aW9uXSlcbiAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKGxpbmUpXG4gIHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoWzBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Bvc2l0aW9uSW5SYW5nZShwb3NpdGlvbjogUG9pbnQsIHJhbmdlOiBSYW5nZSB8IEFycmF5PFJhbmdlPik6IGJvb2xlYW4ge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShyYW5nZSkgPyByYW5nZS5zb21lKChyKSA9PiByLmNvbnRhaW5zUG9pbnQocG9zaXRpb24pKSA6IHJhbmdlLmNvbnRhaW5zUG9pbnQocG9zaXRpb24pXG59XG4iXX0=