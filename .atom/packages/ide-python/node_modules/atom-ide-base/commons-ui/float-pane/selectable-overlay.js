"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeOverlaySelectable = makeOverlaySelectable;
exports.overlayFocusFix = overlayFocusFix;
exports.focusEditor = focusEditor;
exports.blurEditor = blurEditor;
exports.makeOverLayCopyable = makeOverLayCopyable;
exports.copyListener = copyListener;

/** makes the text selectable and copyable
 *
 * Note: you can directly add `user-select: text` (and `pointer-events: all`) in CSS for better performance
 */
function makeOverlaySelectable(editor, overlayElement, focusFix = true) {
  // allow the browser to handle selecting
  overlayElement.setAttribute("tabindex", "-1"); // make it selectable

  if (!overlayElement.style.userSelect || overlayElement.style.userSelect === "none") {
    overlayElement.style.userSelect = "text";
  }

  if (focusFix) {
    // fix overlay focus issue
    overlayFocusFix(editor, overlayElement);
  } // add copy keybindings


  overlayElement.classList.add("native-key-bindings");
}
/**
 * - focus on the datatip once the text is selected (cursor gets disabled temporarily)
 * - remove focus once mouse leaves
 */


function overlayFocusFix(editor, element) {
  const editorComponent = atom.views.getView(editor).getComponent();
  element.addEventListener("mousedown", () => {
    blurEditor(editorComponent);
    element.addEventListener("mouseleave", () => {
      focusEditor(editorComponent);
    });
  });
}

function focusEditor(editorComponent) {
  // @ts-ignore internal api
  editorComponent === null || editorComponent === void 0 ? void 0 : editorComponent.didFocus();
}

function blurEditor(editorComponent) {
  // @ts-ignore internal api
  editorComponent === null || editorComponent === void 0 ? void 0 : editorComponent.didBlurHiddenInput({
    relatedTarget: null
  });
}
/*
██████  ███████ ██████  ██████  ███████  ██████  █████  ████████ ███████ ██████
██   ██ ██      ██   ██ ██   ██ ██      ██      ██   ██    ██    ██      ██   ██
██   ██ █████   ██████  ██████  █████   ██      ███████    ██    █████   ██   ██
██   ██ ██      ██      ██   ██ ██      ██      ██   ██    ██    ██      ██   ██
██████  ███████ ██      ██   ██ ███████  ██████ ██   ██    ██    ███████ ██████
*/

/** @deprecated use `makeOverlaySelectable` instead.
 *
 * Makes the overlay component copyable
 * - you should call `makeOverlaySelectable` before this
 * - If your element already has mouseenter and mouseleav listeners, directly use `copyListener`
 */


function makeOverLayCopyable(element) {
  element.addEventListener("mouseenter", () => {
    element.addEventListener("keydown", copyListener);
  });
  element.addEventListener("mouseleave", () => {
    element.removeEventListener("keydown", copyListener);
  });
}
/** @deprecated use `makeOverlaySelectable` instead.
 *
 * A manual copy listener
 * Usage. Add the listener to your mouse enter and mouseleave listeners
   ```ts
   element.addEventListener("mouseenter", () => {element.addEventListener("keydown", copyListener)}`
   element.addEventListener("mouseleave", () => {element.removeEventListener("keydown", copyListener)}`
   ```
*/


async function copyListener(event) {
  event.preventDefault();

  if (event.ctrlKey && event.key === "c") {
    var _document$getSelectio, _document$getSelectio2;

    const text = (_document$getSelectio = (_document$getSelectio2 = document.getSelection()) === null || _document$getSelectio2 === void 0 ? void 0 : _document$getSelectio2.toString()) !== null && _document$getSelectio !== void 0 ? _document$getSelectio : "";
    await navigator.clipboard.writeText(text);
  }
} // TODO we should not need to manually listen for copy paste
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy1jb21tb25zLXVpL2Zsb2F0LXBhbmUvc2VsZWN0YWJsZS1vdmVybGF5LnRzIl0sIm5hbWVzIjpbIm1ha2VPdmVybGF5U2VsZWN0YWJsZSIsImVkaXRvciIsIm92ZXJsYXlFbGVtZW50IiwiZm9jdXNGaXgiLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsInVzZXJTZWxlY3QiLCJvdmVybGF5Rm9jdXNGaXgiLCJjbGFzc0xpc3QiLCJhZGQiLCJlbGVtZW50IiwiZWRpdG9yQ29tcG9uZW50IiwiYXRvbSIsInZpZXdzIiwiZ2V0VmlldyIsImdldENvbXBvbmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJibHVyRWRpdG9yIiwiZm9jdXNFZGl0b3IiLCJkaWRGb2N1cyIsImRpZEJsdXJIaWRkZW5JbnB1dCIsInJlbGF0ZWRUYXJnZXQiLCJtYWtlT3ZlckxheUNvcHlhYmxlIiwiY29weUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJjdHJsS2V5Iiwia2V5IiwidGV4dCIsImRvY3VtZW50IiwiZ2V0U2VsZWN0aW9uIiwidG9TdHJpbmciLCJuYXZpZ2F0b3IiLCJjbGlwYm9hcmQiLCJ3cml0ZVRleHQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBU0EscUJBQVQsQ0FBK0JDLE1BQS9CLEVBQW1EQyxjQUFuRCxFQUFnRkMsUUFBUSxHQUFHLElBQTNGLEVBQWlHO0FBQ3RHO0FBQ0FELEVBQUFBLGNBQWMsQ0FBQ0UsWUFBZixDQUE0QixVQUE1QixFQUF3QyxJQUF4QyxFQUZzRyxDQUl0Rzs7QUFDQSxNQUFJLENBQUNGLGNBQWMsQ0FBQ0csS0FBZixDQUFxQkMsVUFBdEIsSUFBb0NKLGNBQWMsQ0FBQ0csS0FBZixDQUFxQkMsVUFBckIsS0FBb0MsTUFBNUUsRUFBb0Y7QUFDbEZKLElBQUFBLGNBQWMsQ0FBQ0csS0FBZixDQUFxQkMsVUFBckIsR0FBa0MsTUFBbEM7QUFDRDs7QUFFRCxNQUFJSCxRQUFKLEVBQWM7QUFDWjtBQUNBSSxJQUFBQSxlQUFlLENBQUNOLE1BQUQsRUFBU0MsY0FBVCxDQUFmO0FBQ0QsR0FacUcsQ0FjdEc7OztBQUNBQSxFQUFBQSxjQUFjLENBQUNNLFNBQWYsQ0FBeUJDLEdBQXpCLENBQTZCLHFCQUE3QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNPLFNBQVNGLGVBQVQsQ0FBeUJOLE1BQXpCLEVBQTZDUyxPQUE3QyxFQUFtRTtBQUN4RSxRQUFNQyxlQUFlLEdBQUdDLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxPQUFYLENBQW1CYixNQUFuQixFQUEyQmMsWUFBM0IsRUFBeEI7QUFDQUwsRUFBQUEsT0FBTyxDQUFDTSxnQkFBUixDQUF5QixXQUF6QixFQUFzQyxNQUFNO0FBQzFDQyxJQUFBQSxVQUFVLENBQUNOLGVBQUQsQ0FBVjtBQUNBRCxJQUFBQSxPQUFPLENBQUNNLGdCQUFSLENBQXlCLFlBQXpCLEVBQXVDLE1BQU07QUFDM0NFLE1BQUFBLFdBQVcsQ0FBQ1AsZUFBRCxDQUFYO0FBQ0QsS0FGRDtBQUdELEdBTEQ7QUFNRDs7QUFFTSxTQUFTTyxXQUFULENBQXFCUCxlQUFyQixFQUEyRDtBQUNoRTtBQUNBQSxFQUFBQSxlQUFlLFNBQWYsSUFBQUEsZUFBZSxXQUFmLFlBQUFBLGVBQWUsQ0FBRVEsUUFBakI7QUFDRDs7QUFFTSxTQUFTRixVQUFULENBQW9CTixlQUFwQixFQUEwRDtBQUMvRDtBQUNBQSxFQUFBQSxlQUFlLFNBQWYsSUFBQUEsZUFBZSxXQUFmLFlBQUFBLGVBQWUsQ0FBRVMsa0JBQWpCLENBQW9DO0FBQ2xDQyxJQUFBQSxhQUFhLEVBQUU7QUFEbUIsR0FBcEM7QUFHRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU0MsbUJBQVQsQ0FBNkJaLE9BQTdCLEVBQW1EO0FBQ3hEQSxFQUFBQSxPQUFPLENBQUNNLGdCQUFSLENBQXlCLFlBQXpCLEVBQXVDLE1BQU07QUFDM0NOLElBQUFBLE9BQU8sQ0FBQ00sZ0JBQVIsQ0FBeUIsU0FBekIsRUFBb0NPLFlBQXBDO0FBQ0QsR0FGRDtBQUlBYixFQUFBQSxPQUFPLENBQUNNLGdCQUFSLENBQXlCLFlBQXpCLEVBQXVDLE1BQU07QUFDM0NOLElBQUFBLE9BQU8sQ0FBQ2MsbUJBQVIsQ0FBNEIsU0FBNUIsRUFBdUNELFlBQXZDO0FBQ0QsR0FGRDtBQUdEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxlQUFlQSxZQUFmLENBQTRCRSxLQUE1QixFQUFrRDtBQUN2REEsRUFBQUEsS0FBSyxDQUFDQyxjQUFOOztBQUNBLE1BQUlELEtBQUssQ0FBQ0UsT0FBTixJQUFpQkYsS0FBSyxDQUFDRyxHQUFOLEtBQWMsR0FBbkMsRUFBd0M7QUFBQTs7QUFDdEMsVUFBTUMsSUFBSSxzREFBR0MsUUFBUSxDQUFDQyxZQUFULEVBQUgsMkRBQUcsdUJBQXlCQyxRQUF6QixFQUFILHlFQUEwQyxFQUFwRDtBQUNBLFVBQU1DLFNBQVMsQ0FBQ0MsU0FBVixDQUFvQkMsU0FBcEIsQ0FBOEJOLElBQTlCLENBQU47QUFDRDtBQUNGLEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVGV4dEVkaXRvciwgVGV4dEVkaXRvckNvbXBvbmVudCB9IGZyb20gXCJhdG9tXCJcblxuLyoqIG1ha2VzIHRoZSB0ZXh0IHNlbGVjdGFibGUgYW5kIGNvcHlhYmxlXG4gKlxuICogTm90ZTogeW91IGNhbiBkaXJlY3RseSBhZGQgYHVzZXItc2VsZWN0OiB0ZXh0YCAoYW5kIGBwb2ludGVyLWV2ZW50czogYWxsYCkgaW4gQ1NTIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPdmVybGF5U2VsZWN0YWJsZShlZGl0b3I6IFRleHRFZGl0b3IsIG92ZXJsYXlFbGVtZW50OiBIVE1MRWxlbWVudCwgZm9jdXNGaXggPSB0cnVlKSB7XG4gIC8vIGFsbG93IHRoZSBicm93c2VyIHRvIGhhbmRsZSBzZWxlY3RpbmdcbiAgb3ZlcmxheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKVxuXG4gIC8vIG1ha2UgaXQgc2VsZWN0YWJsZVxuICBpZiAoIW92ZXJsYXlFbGVtZW50LnN0eWxlLnVzZXJTZWxlY3QgfHwgb3ZlcmxheUVsZW1lbnQuc3R5bGUudXNlclNlbGVjdCA9PT0gXCJub25lXCIpIHtcbiAgICBvdmVybGF5RWxlbWVudC5zdHlsZS51c2VyU2VsZWN0ID0gXCJ0ZXh0XCJcbiAgfVxuXG4gIGlmIChmb2N1c0ZpeCkge1xuICAgIC8vIGZpeCBvdmVybGF5IGZvY3VzIGlzc3VlXG4gICAgb3ZlcmxheUZvY3VzRml4KGVkaXRvciwgb3ZlcmxheUVsZW1lbnQpXG4gIH1cblxuICAvLyBhZGQgY29weSBrZXliaW5kaW5nc1xuICBvdmVybGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibmF0aXZlLWtleS1iaW5kaW5nc1wiKVxufVxuXG4vKipcbiAqIC0gZm9jdXMgb24gdGhlIGRhdGF0aXAgb25jZSB0aGUgdGV4dCBpcyBzZWxlY3RlZCAoY3Vyc29yIGdldHMgZGlzYWJsZWQgdGVtcG9yYXJpbHkpXG4gKiAtIHJlbW92ZSBmb2N1cyBvbmNlIG1vdXNlIGxlYXZlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3ZlcmxheUZvY3VzRml4KGVkaXRvcjogVGV4dEVkaXRvciwgZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgY29uc3QgZWRpdG9yQ29tcG9uZW50ID0gYXRvbS52aWV3cy5nZXRWaWV3KGVkaXRvcikuZ2V0Q29tcG9uZW50KClcbiAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsICgpID0+IHtcbiAgICBibHVyRWRpdG9yKGVkaXRvckNvbXBvbmVudClcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIGZvY3VzRWRpdG9yKGVkaXRvckNvbXBvbmVudClcbiAgICB9KVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9jdXNFZGl0b3IoZWRpdG9yQ29tcG9uZW50OiBUZXh0RWRpdG9yQ29tcG9uZW50KSB7XG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgYXBpXG4gIGVkaXRvckNvbXBvbmVudD8uZGlkRm9jdXMoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmx1ckVkaXRvcihlZGl0b3JDb21wb25lbnQ6IFRleHRFZGl0b3JDb21wb25lbnQpIHtcbiAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBhcGlcbiAgZWRpdG9yQ29tcG9uZW50Py5kaWRCbHVySGlkZGVuSW5wdXQoe1xuICAgIHJlbGF0ZWRUYXJnZXQ6IG51bGwsXG4gIH0pXG59XG5cbi8qXG7ilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiCAg4paI4paI4paI4paI4paI4paI4paI4paIIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojilojilojilojilojilohcbuKWiOKWiCAgIOKWiOKWiCDilojiloggICAgICDilojiloggICDilojilogg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiCAgICAgIOKWiOKWiCAgIOKWiOKWiCAgICDilojiloggICAg4paI4paIICAgICAg4paI4paIICAg4paI4paIXG7ilojiloggICDilojilogg4paI4paI4paI4paI4paIICAg4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiCAgIOKWiOKWiCAgICAgIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCAgICDilojiloggICAg4paI4paI4paI4paI4paIICAg4paI4paIICAg4paI4paIXG7ilojiloggICDilojilogg4paI4paIICAgICAg4paI4paIICAgICAg4paI4paIICAg4paI4paIIOKWiOKWiCAgICAgIOKWiOKWiCAgICAgIOKWiOKWiCAgIOKWiOKWiCAgICDilojiloggICAg4paI4paIICAgICAg4paI4paIICAg4paI4paIXG7ilojilojilojilojilojiloggIOKWiOKWiOKWiOKWiOKWiOKWiOKWiCDilojiloggICAgICDilojiloggICDilojilogg4paI4paI4paI4paI4paI4paI4paIICDilojilojilojilojilojilogg4paI4paIICAg4paI4paIICAgIOKWiOKWiCAgICDilojilojilojilojilojilojilogg4paI4paI4paI4paI4paI4paIXG4qL1xuXG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBtYWtlT3ZlcmxheVNlbGVjdGFibGVgIGluc3RlYWQuXG4gKlxuICogTWFrZXMgdGhlIG92ZXJsYXkgY29tcG9uZW50IGNvcHlhYmxlXG4gKiAtIHlvdSBzaG91bGQgY2FsbCBgbWFrZU92ZXJsYXlTZWxlY3RhYmxlYCBiZWZvcmUgdGhpc1xuICogLSBJZiB5b3VyIGVsZW1lbnQgYWxyZWFkeSBoYXMgbW91c2VlbnRlciBhbmQgbW91c2VsZWF2IGxpc3RlbmVycywgZGlyZWN0bHkgdXNlIGBjb3B5TGlzdGVuZXJgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT3ZlckxheUNvcHlhYmxlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4ge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY29weUxpc3RlbmVyKVxuICB9KVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgY29weUxpc3RlbmVyKVxuICB9KVxufVxuXG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBtYWtlT3ZlcmxheVNlbGVjdGFibGVgIGluc3RlYWQuXG4gKlxuICogQSBtYW51YWwgY29weSBsaXN0ZW5lclxuICogVXNhZ2UuIEFkZCB0aGUgbGlzdGVuZXIgdG8geW91ciBtb3VzZSBlbnRlciBhbmQgbW91c2VsZWF2ZSBsaXN0ZW5lcnNcbiAgIGBgYHRzXG4gICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNvcHlMaXN0ZW5lcil9YFxuICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCAoKSA9PiB7ZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjb3B5TGlzdGVuZXIpfWBcbiAgIGBgYFxuKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb3B5TGlzdGVuZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkgPT09IFwiY1wiKSB7XG4gICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpPy50b1N0cmluZygpID8/IFwiXCJcbiAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KVxuICB9XG59IC8vIFRPRE8gd2Ugc2hvdWxkIG5vdCBuZWVkIHRvIG1hbnVhbGx5IGxpc3RlbiBmb3IgY29weSBwYXN0ZVxuIl19