"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scrollIntoView = scrollIntoView;
exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;
exports.isOverflowHidden = isOverflowHidden;

/* globals getComputedStyle */

/**
 * Use these functions instead of `Element::scrollIntoView()` and
 * `Element::scrollIntoViewIfNeeded()`!
 *
 * We've had a recurring issue in Nuclide (e.g. T20028138) where the UI would shift, leaving part of
 * the workspace element offscreen and a blank area in the window. This was caused by called to the
 * native `scrollIntoView()` and `scrollIntoViewIfNeeded()` which, according to the spec, has two
 * potentially surprising behaviors:
 *
 * 1. [It scrolls every scrollable ancestor (not just the closest)][1], where
 * 2. "scrollable" is [explicitly defined][2] to include elements with `overflow: hidden`
 *
 * This is surprising because `overflow: hidden` is typically used to make elements *not
 * scrollable*.
 *
 * Once the `overflow: hidden` element is scrolled, the user has no way to return it to its original
 * position (as it has no scrollbars).
 *
 * Note that this API doesn't support smooth scrolling. If that becomes necessary, we'll need to
 * come up with a better fix.
 *
 * It's tempting to assume that using `scrollIntoViewIfNeeded()` would fix this issue, however, if
 * the window is small enough so that no amount of scrolling the desired scrollable element would
 * ever reveal the element you're trying to, the browser will keep scrolling ancestors.
 *
 * [1]: https://drafts.csswg.org/cssom-view/#element-scrolling-members
 * [2]: https://drafts.csswg.org/cssom-view/#scrolling-box
 */
function scrollIntoView(el, alignToTop) {
  const scrollTops = getScrollTops(el);
  el.scrollIntoView(alignToTop);
  restoreOverflowHiddenScrollTops(scrollTops);
}

function scrollIntoViewIfNeeded(el, center = true) {
  var _scrollIntoViewIfNeed, _scrollIntoViewIfNeed2, _ref;

  const scrollTops = getScrollTops(el) // eslint-disable-next-line no-unused-expressions
  ;
  (_scrollIntoViewIfNeed = (_scrollIntoViewIfNeed2 = (_ref = el).scrollIntoViewIfNeeded) === null || _scrollIntoViewIfNeed2 === void 0 ? void 0 : _scrollIntoViewIfNeed2.call(_ref, center)) !== null && _scrollIntoViewIfNeed !== void 0 ? _scrollIntoViewIfNeed : el.scrollIntoView(center);
  restoreOverflowHiddenScrollTops(scrollTops);
}

function getScrollTops(el_) {
  let el = el_;
  const scrollTops = new Map();

  while (el !== null) {
    scrollTops.set(el, el.scrollTop);
    el = el.parentElement;
  }

  return scrollTops;
}

function restoreOverflowHiddenScrollTops(scrollTops) {
  scrollTops.forEach((scrollTop, el) => {
    if (el.scrollTop !== scrollTop && isOverflowHidden(el)) {
      el.scrollTop = scrollTop;
    }
  });
}

function isOverflowHidden(el) {
  const overflowStyle = el === null || el === void 0 ? void 0 : el.style.overflow;
  const overflow = overflowStyle !== null && overflowStyle !== void 0 ? overflowStyle : getComputedStyle(el).overflow;
  return overflow === "hidden";
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy1jb21tb25zLXVpL3Njcm9sbEludG9WaWV3LnRzIl0sIm5hbWVzIjpbInNjcm9sbEludG9WaWV3IiwiZWwiLCJhbGlnblRvVG9wIiwic2Nyb2xsVG9wcyIsImdldFNjcm9sbFRvcHMiLCJyZXN0b3JlT3ZlcmZsb3dIaWRkZW5TY3JvbGxUb3BzIiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsImNlbnRlciIsImVsXyIsIk1hcCIsInNldCIsInNjcm9sbFRvcCIsInBhcmVudEVsZW1lbnQiLCJmb3JFYWNoIiwiaXNPdmVyZmxvd0hpZGRlbiIsIm92ZXJmbG93U3R5bGUiLCJzdHlsZSIsIm92ZXJmbG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFTyxTQUFTQSxjQUFULENBQXdCQyxFQUF4QixFQUFxQ0MsVUFBckMsRUFBaUU7QUFDdEUsUUFBTUMsVUFBVSxHQUFHQyxhQUFhLENBQUNILEVBQUQsQ0FBaEM7QUFDQUEsRUFBQUEsRUFBRSxDQUFDRCxjQUFILENBQWtCRSxVQUFsQjtBQUNBRyxFQUFBQSwrQkFBK0IsQ0FBQ0YsVUFBRCxDQUEvQjtBQUNEOztBQUlNLFNBQVNHLHNCQUFULENBQWdDTCxFQUFoQyxFQUE2Q00sTUFBZSxHQUFHLElBQS9ELEVBQTJFO0FBQUE7O0FBQ2hGLFFBQU1KLFVBQVUsR0FBR0MsYUFBYSxDQUFDSCxFQUFELENBQWhDLENBQ0E7QUFEQTtBQUVDLDZEQUFDQSxFQUFELEVBQXdCSyxzQkFBeEIsNkZBQWlEQyxNQUFqRCwwRUFBNEROLEVBQUUsQ0FBQ0QsY0FBSCxDQUFrQk8sTUFBbEIsQ0FBNUQ7QUFDREYsRUFBQUEsK0JBQStCLENBQUNGLFVBQUQsQ0FBL0I7QUFDRDs7QUFFRCxTQUFTQyxhQUFULENBQXVCSSxHQUF2QixFQUEyRDtBQUN6RCxNQUFJUCxFQUFrQixHQUFHTyxHQUF6QjtBQUNBLFFBQU1MLFVBQVUsR0FBRyxJQUFJTSxHQUFKLEVBQW5COztBQUNBLFNBQU9SLEVBQUUsS0FBSyxJQUFkLEVBQW9CO0FBQ2xCRSxJQUFBQSxVQUFVLENBQUNPLEdBQVgsQ0FBZVQsRUFBZixFQUFtQkEsRUFBRSxDQUFDVSxTQUF0QjtBQUNBVixJQUFBQSxFQUFFLEdBQUdBLEVBQUUsQ0FBQ1csYUFBUjtBQUNEOztBQUNELFNBQU9ULFVBQVA7QUFDRDs7QUFFRCxTQUFTRSwrQkFBVCxDQUF5Q0YsVUFBekMsRUFBaUY7QUFDL0VBLEVBQUFBLFVBQVUsQ0FBQ1UsT0FBWCxDQUFtQixDQUFDRixTQUFELEVBQVlWLEVBQVosS0FBbUI7QUFDcEMsUUFBSUEsRUFBRSxDQUFDVSxTQUFILEtBQWlCQSxTQUFqQixJQUE4QkcsZ0JBQWdCLENBQUNiLEVBQUQsQ0FBbEQsRUFBd0Q7QUFDdERBLE1BQUFBLEVBQUUsQ0FBQ1UsU0FBSCxHQUFlQSxTQUFmO0FBQ0Q7QUFDRixHQUpEO0FBS0Q7O0FBRU0sU0FBU0csZ0JBQVQsQ0FBMEJiLEVBQTFCLEVBQTJFO0FBQ2hGLFFBQU1jLGFBQWEsR0FBSWQsRUFBSixhQUFJQSxFQUFKLHVCQUFJQSxFQUFELENBQXFCZSxLQUFyQixDQUEyQkMsUUFBakQ7QUFDQSxRQUFNQSxRQUFRLEdBQUdGLGFBQUgsYUFBR0EsYUFBSCxjQUFHQSxhQUFILEdBQW9CRyxnQkFBZ0IsQ0FBQ2pCLEVBQUQsQ0FBaEIsQ0FBcUJnQixRQUF2RDtBQUNBLFNBQU9BLFFBQVEsS0FBSyxRQUFwQjtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBnZXRDb21wdXRlZFN0eWxlICovXG5cbi8qKlxuICogVXNlIHRoZXNlIGZ1bmN0aW9ucyBpbnN0ZWFkIG9mIGBFbGVtZW50OjpzY3JvbGxJbnRvVmlldygpYCBhbmRcbiAqIGBFbGVtZW50OjpzY3JvbGxJbnRvVmlld0lmTmVlZGVkKClgIVxuICpcbiAqIFdlJ3ZlIGhhZCBhIHJlY3VycmluZyBpc3N1ZSBpbiBOdWNsaWRlIChlLmcuIFQyMDAyODEzOCkgd2hlcmUgdGhlIFVJIHdvdWxkIHNoaWZ0LCBsZWF2aW5nIHBhcnQgb2ZcbiAqIHRoZSB3b3Jrc3BhY2UgZWxlbWVudCBvZmZzY3JlZW4gYW5kIGEgYmxhbmsgYXJlYSBpbiB0aGUgd2luZG93LiBUaGlzIHdhcyBjYXVzZWQgYnkgY2FsbGVkIHRvIHRoZVxuICogbmF0aXZlIGBzY3JvbGxJbnRvVmlldygpYCBhbmQgYHNjcm9sbEludG9WaWV3SWZOZWVkZWQoKWAgd2hpY2gsIGFjY29yZGluZyB0byB0aGUgc3BlYywgaGFzIHR3b1xuICogcG90ZW50aWFsbHkgc3VycHJpc2luZyBiZWhhdmlvcnM6XG4gKlxuICogMS4gW0l0IHNjcm9sbHMgZXZlcnkgc2Nyb2xsYWJsZSBhbmNlc3RvciAobm90IGp1c3QgdGhlIGNsb3Nlc3QpXVsxXSwgd2hlcmVcbiAqIDIuIFwic2Nyb2xsYWJsZVwiIGlzIFtleHBsaWNpdGx5IGRlZmluZWRdWzJdIHRvIGluY2x1ZGUgZWxlbWVudHMgd2l0aCBgb3ZlcmZsb3c6IGhpZGRlbmBcbiAqXG4gKiBUaGlzIGlzIHN1cnByaXNpbmcgYmVjYXVzZSBgb3ZlcmZsb3c6IGhpZGRlbmAgaXMgdHlwaWNhbGx5IHVzZWQgdG8gbWFrZSBlbGVtZW50cyAqbm90XG4gKiBzY3JvbGxhYmxlKi5cbiAqXG4gKiBPbmNlIHRoZSBgb3ZlcmZsb3c6IGhpZGRlbmAgZWxlbWVudCBpcyBzY3JvbGxlZCwgdGhlIHVzZXIgaGFzIG5vIHdheSB0byByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsXG4gKiBwb3NpdGlvbiAoYXMgaXQgaGFzIG5vIHNjcm9sbGJhcnMpLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIEFQSSBkb2Vzbid0IHN1cHBvcnQgc21vb3RoIHNjcm9sbGluZy4gSWYgdGhhdCBiZWNvbWVzIG5lY2Vzc2FyeSwgd2UnbGwgbmVlZCB0b1xuICogY29tZSB1cCB3aXRoIGEgYmV0dGVyIGZpeC5cbiAqXG4gKiBJdCdzIHRlbXB0aW5nIHRvIGFzc3VtZSB0aGF0IHVzaW5nIGBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKClgIHdvdWxkIGZpeCB0aGlzIGlzc3VlLCBob3dldmVyLCBpZlxuICogdGhlIHdpbmRvdyBpcyBzbWFsbCBlbm91Z2ggc28gdGhhdCBubyBhbW91bnQgb2Ygc2Nyb2xsaW5nIHRoZSBkZXNpcmVkIHNjcm9sbGFibGUgZWxlbWVudCB3b3VsZFxuICogZXZlciByZXZlYWwgdGhlIGVsZW1lbnQgeW91J3JlIHRyeWluZyB0bywgdGhlIGJyb3dzZXIgd2lsbCBrZWVwIHNjcm9sbGluZyBhbmNlc3RvcnMuXG4gKlxuICogWzFdOiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20tdmlldy8jZWxlbWVudC1zY3JvbGxpbmctbWVtYmVyc1xuICogWzJdOiBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20tdmlldy8jc2Nyb2xsaW5nLWJveFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbDogRWxlbWVudCwgYWxpZ25Ub1RvcD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgY29uc3Qgc2Nyb2xsVG9wcyA9IGdldFNjcm9sbFRvcHMoZWwpXG4gIGVsLnNjcm9sbEludG9WaWV3KGFsaWduVG9Ub3ApXG4gIHJlc3RvcmVPdmVyZmxvd0hpZGRlblNjcm9sbFRvcHMoc2Nyb2xsVG9wcylcbn1cblxuZXhwb3J0IHR5cGUgRWxlbWVudEV4dGVuZGVkID0gRWxlbWVudCAmIHsgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZD86IChzaG91bGRDZW50ZXI6IGJvb2xlYW4pID0+IHZvaWQgfVxuXG5leHBvcnQgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlbDogRWxlbWVudCwgY2VudGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICBjb25zdCBzY3JvbGxUb3BzID0gZ2V0U2Nyb2xsVG9wcyhlbClcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICA7KGVsIGFzIEVsZW1lbnRFeHRlbmRlZCkuc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZD8uKGNlbnRlcikgPz8gZWwuc2Nyb2xsSW50b1ZpZXcoY2VudGVyKVxuICByZXN0b3JlT3ZlcmZsb3dIaWRkZW5TY3JvbGxUb3BzKHNjcm9sbFRvcHMpXG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFRvcHMoZWxfOiBFbGVtZW50KTogTWFwPEVsZW1lbnQsIG51bWJlcj4ge1xuICBsZXQgZWw6IEVsZW1lbnQgfCBudWxsID0gZWxfXG4gIGNvbnN0IHNjcm9sbFRvcHMgPSBuZXcgTWFwPEVsZW1lbnQsIG51bWJlcj4oKVxuICB3aGlsZSAoZWwgIT09IG51bGwpIHtcbiAgICBzY3JvbGxUb3BzLnNldChlbCwgZWwuc2Nyb2xsVG9wKVxuICAgIGVsID0gZWwucGFyZW50RWxlbWVudFxuICB9XG4gIHJldHVybiBzY3JvbGxUb3BzXG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVPdmVyZmxvd0hpZGRlblNjcm9sbFRvcHMoc2Nyb2xsVG9wczogTWFwPEVsZW1lbnQsIG51bWJlcj4pOiB2b2lkIHtcbiAgc2Nyb2xsVG9wcy5mb3JFYWNoKChzY3JvbGxUb3AsIGVsKSA9PiB7XG4gICAgaWYgKGVsLnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wICYmIGlzT3ZlcmZsb3dIaWRkZW4oZWwpKSB7XG4gICAgICBlbC5zY3JvbGxUb3AgPSBzY3JvbGxUb3BcbiAgICB9XG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc092ZXJmbG93SGlkZGVuKGVsOiBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQgfCBFbGVtZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IG92ZXJmbG93U3R5bGUgPSAoZWwgYXMgSFRNTEVsZW1lbnQpPy5zdHlsZS5vdmVyZmxvd1xuICBjb25zdCBvdmVyZmxvdyA9IG92ZXJmbG93U3R5bGUgPz8gZ2V0Q29tcHV0ZWRTdHlsZShlbCkub3ZlcmZsb3dcbiAgcmV0dXJuIG92ZXJmbG93ID09PSBcImhpZGRlblwiXG59XG4iXX0=