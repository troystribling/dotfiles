"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts workspace/applyEdit commands to editors.
class ApplyEditAdapter {
    // Public: Attach to a {LanguageClientConnection} to receive edit events.
    static attach(connection) {
        connection.onApplyEdit((m) => ApplyEditAdapter.onApplyEdit(m));
    }
    /**
     * Tries to apply edits and reverts if anything goes wrong.
     * Returns the checkpoint, so the caller can revert changes if needed.
     */
    static applyEdits(buffer, edits) {
        const checkpoint = buffer.createCheckpoint();
        try {
            // Sort edits in reverse order to prevent edit conflicts.
            edits.sort((edit1, edit2) => -edit1.oldRange.compare(edit2.oldRange));
            edits.reduce((previous, current) => {
                ApplyEditAdapter.validateEdit(buffer, current, previous);
                buffer.setTextInRange(current.oldRange, current.newText);
                return current;
            }, null);
            buffer.groupChangesSinceCheckpoint(checkpoint);
            return checkpoint;
        }
        catch (err) {
            buffer.revertToCheckpoint(checkpoint);
            throw err;
        }
    }
    static onApplyEdit(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let changes = params.edit.changes || {};
            if (params.edit.documentChanges) {
                changes = {};
                params.edit.documentChanges.forEach((change) => {
                    if (change && change.textDocument) {
                        changes[change.textDocument.uri] = change.edits;
                    }
                });
            }
            const uris = Object.keys(changes);
            // Keep checkpoints from all successful buffer edits
            const checkpoints = [];
            const promises = uris.map((uri) => __awaiter(this, void 0, void 0, function* () {
                const path = convert_1.default.uriToPath(uri);
                const editor = yield atom.workspace.open(path, {
                    searchAllPanes: true,
                    // Open new editors in the background.
                    activatePane: false,
                    activateItem: false,
                });
                const buffer = editor.getBuffer();
                // Get an existing editor for the file, or open a new one if it doesn't exist.
                const edits = convert_1.default.convertLsTextEdits(changes[uri]);
                const checkpoint = ApplyEditAdapter.applyEdits(buffer, edits);
                checkpoints.push({ buffer, checkpoint });
            }));
            // Apply all edits or fail and revert everything
            const applied = yield Promise.all(promises)
                .then(() => true)
                .catch((err) => {
                atom.notifications.addError('workspace/applyEdits failed', {
                    description: 'Failed to apply edits.',
                    detail: err.message,
                });
                checkpoints.forEach(({ buffer, checkpoint }) => {
                    buffer.revertToCheckpoint(checkpoint);
                });
                return false;
            });
            return { applied };
        });
    }
    // Private: Do some basic sanity checking on the edit ranges.
    static validateEdit(buffer, edit, prevEdit) {
        const path = buffer.getPath() || '';
        if (prevEdit && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
            throw Error(`Found overlapping edit ranges in ${path}`);
        }
        const startRow = edit.oldRange.start.row;
        const startCol = edit.oldRange.start.column;
        const lineLength = buffer.lineLengthForRow(startRow);
        if (lineLength == null || startCol > lineLength) {
            throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
        }
    }
}
exports.default = ApplyEditAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBV2pDLDBEQUEwRDtBQUMxRDtJQUNFLHlFQUF5RTtJQUNsRSxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQW9DO1FBQ3ZELFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7O09BR0c7SUFDSSxNQUFNLENBQUMsVUFBVSxDQUN0QixNQUFrQixFQUNsQixLQUF5QjtRQUV6QixNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUM3QyxJQUFJLENBQUM7WUFDSCx5REFBeUQ7WUFDekQsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDdEUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsRUFBRTtnQkFDakMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7Z0JBQ3pELE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3pELE1BQU0sQ0FBQyxPQUFPLENBQUM7WUFDakIsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ1QsTUFBTSxDQUFDLDJCQUEyQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQy9DLE1BQU0sQ0FBQyxVQUFV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UUFBaUM7UUFFakMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUNwQyxFQUFFLENBQUMsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2RSxNQUFNLEtBQUssQ0FBQyxvQ0FBb0MsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUMxRCxDQUFDO1FBQ0QsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3pDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUM1QyxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckQsRUFBRSxDQUFDLENBQUMsVUFBVSxJQUFJLElBQUksSUFBSSxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUNoRCxNQUFNLEtBQUssQ0FBQyx3QkFBd0IsSUFBSSxJQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDOUUsQ0FBQztJQUNILENBQUM7Q0FDRjtBQXBHRCxtQ0FvR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcbmltcG9ydCB7XHJcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIEFwcGx5V29ya3NwYWNlRWRpdFBhcmFtcyxcclxuICBBcHBseVdvcmtzcGFjZUVkaXRSZXNwb25zZSxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCB7XHJcbiAgVGV4dEJ1ZmZlcixcclxuICBUZXh0RWRpdG9yLFxyXG59IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgd29ya3NwYWNlL2FwcGx5RWRpdCBjb21tYW5kcyB0byBlZGl0b3JzLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBseUVkaXRBZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IEF0dGFjaCB0byBhIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHJlY2VpdmUgZWRpdCBldmVudHMuXHJcbiAgcHVibGljIHN0YXRpYyBhdHRhY2goY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uKSB7XHJcbiAgICBjb25uZWN0aW9uLm9uQXBwbHlFZGl0KChtKSA9PiBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KG0pKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWVzIHRvIGFwcGx5IGVkaXRzIGFuZCByZXZlcnRzIGlmIGFueXRoaW5nIGdvZXMgd3JvbmcuXHJcbiAgICogUmV0dXJucyB0aGUgY2hlY2twb2ludCwgc28gdGhlIGNhbGxlciBjYW4gcmV2ZXJ0IGNoYW5nZXMgaWYgbmVlZGVkLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgYXBwbHlFZGl0cyhcclxuICAgIGJ1ZmZlcjogVGV4dEJ1ZmZlcixcclxuICAgIGVkaXRzOiBhdG9tSWRlLlRleHRFZGl0W10sXHJcbiAgKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBidWZmZXIuY3JlYXRlQ2hlY2twb2ludCgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gU29ydCBlZGl0cyBpbiByZXZlcnNlIG9yZGVyIHRvIHByZXZlbnQgZWRpdCBjb25mbGljdHMuXHJcbiAgICAgIGVkaXRzLnNvcnQoKGVkaXQxLCBlZGl0MikgPT4gLWVkaXQxLm9sZFJhbmdlLmNvbXBhcmUoZWRpdDIub2xkUmFuZ2UpKTtcclxuICAgICAgZWRpdHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xyXG4gICAgICAgIEFwcGx5RWRpdEFkYXB0ZXIudmFsaWRhdGVFZGl0KGJ1ZmZlciwgY3VycmVudCwgcHJldmlvdXMpO1xyXG4gICAgICAgIGJ1ZmZlci5zZXRUZXh0SW5SYW5nZShjdXJyZW50Lm9sZFJhbmdlLCBjdXJyZW50Lm5ld1RleHQpO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgICB9LCBudWxsKTtcclxuICAgICAgYnVmZmVyLmdyb3VwQ2hhbmdlc1NpbmNlQ2hlY2twb2ludChjaGVja3BvaW50KTtcclxuICAgICAgcmV0dXJuIGNoZWNrcG9pbnQ7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgYnVmZmVyLnJldmVydFRvQ2hlY2twb2ludChjaGVja3BvaW50KTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBvbkFwcGx5RWRpdChwYXJhbXM6IEFwcGx5V29ya3NwYWNlRWRpdFBhcmFtcyk6IFByb21pc2U8QXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2U+IHtcclxuXHJcbiAgICBsZXQgY2hhbmdlcyA9IHBhcmFtcy5lZGl0LmNoYW5nZXMgfHwge307XHJcblxyXG4gICAgaWYgKHBhcmFtcy5lZGl0LmRvY3VtZW50Q2hhbmdlcykge1xyXG4gICAgICBjaGFuZ2VzID0ge307XHJcbiAgICAgIHBhcmFtcy5lZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcclxuICAgICAgICBpZiAoY2hhbmdlICYmIGNoYW5nZS50ZXh0RG9jdW1lbnQpIHtcclxuICAgICAgICAgIGNoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gY2hhbmdlLmVkaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXJpcyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpO1xyXG5cclxuICAgIC8vIEtlZXAgY2hlY2twb2ludHMgZnJvbSBhbGwgc3VjY2Vzc2Z1bCBidWZmZXIgZWRpdHNcclxuICAgIGNvbnN0IGNoZWNrcG9pbnRzOiBBcnJheTx7IGJ1ZmZlcjogVGV4dEJ1ZmZlciwgY2hlY2twb2ludDogbnVtYmVyIH0+ID0gW107XHJcblxyXG4gICAgY29uc3QgcHJvbWlzZXMgPSB1cmlzLm1hcChhc3luYyAodXJpKSA9PiB7XHJcbiAgICAgIGNvbnN0IHBhdGggPSBDb252ZXJ0LnVyaVRvUGF0aCh1cmkpO1xyXG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBhdG9tLndvcmtzcGFjZS5vcGVuKFxyXG4gICAgICAgIHBhdGgsIHtcclxuICAgICAgICAgIHNlYXJjaEFsbFBhbmVzOiB0cnVlLFxyXG4gICAgICAgICAgLy8gT3BlbiBuZXcgZWRpdG9ycyBpbiB0aGUgYmFja2dyb3VuZC5cclxuICAgICAgICAgIGFjdGl2YXRlUGFuZTogZmFsc2UsXHJcbiAgICAgICAgICBhY3RpdmF0ZUl0ZW06IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICkgYXMgVGV4dEVkaXRvcjtcclxuICAgICAgY29uc3QgYnVmZmVyID0gZWRpdG9yLmdldEJ1ZmZlcigpO1xyXG4gICAgICAvLyBHZXQgYW4gZXhpc3RpbmcgZWRpdG9yIGZvciB0aGUgZmlsZSwgb3Igb3BlbiBhIG5ldyBvbmUgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICAgICAgY29uc3QgZWRpdHMgPSBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhjaGFuZ2VzW3VyaV0pO1xyXG4gICAgICBjb25zdCBjaGVja3BvaW50ID0gQXBwbHlFZGl0QWRhcHRlci5hcHBseUVkaXRzKGJ1ZmZlciwgZWRpdHMpO1xyXG4gICAgICBjaGVja3BvaW50cy5wdXNoKHtidWZmZXIsIGNoZWNrcG9pbnR9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFwcGx5IGFsbCBlZGl0cyBvciBmYWlsIGFuZCByZXZlcnQgZXZlcnl0aGluZ1xyXG4gICAgY29uc3QgYXBwbGllZCA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxyXG4gICAgICAudGhlbigoKSA9PiB0cnVlKVxyXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcignd29ya3NwYWNlL2FwcGx5RWRpdHMgZmFpbGVkJywge1xyXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdGYWlsZWQgdG8gYXBwbHkgZWRpdHMuJyxcclxuICAgICAgICAgIGRldGFpbDogZXJyLm1lc3NhZ2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY2hlY2twb2ludHMuZm9yRWFjaCgoe2J1ZmZlciwgY2hlY2twb2ludH0pID0+IHtcclxuICAgICAgICAgIGJ1ZmZlci5yZXZlcnRUb0NoZWNrcG9pbnQoY2hlY2twb2ludCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge2FwcGxpZWR9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHJpdmF0ZTogRG8gc29tZSBiYXNpYyBzYW5pdHkgY2hlY2tpbmcgb24gdGhlIGVkaXQgcmFuZ2VzLlxyXG4gIHByaXZhdGUgc3RhdGljIHZhbGlkYXRlRWRpdChcclxuICAgIGJ1ZmZlcjogVGV4dEJ1ZmZlcixcclxuICAgIGVkaXQ6IGF0b21JZGUuVGV4dEVkaXQsXHJcbiAgICBwcmV2RWRpdDogYXRvbUlkZS5UZXh0RWRpdCB8IG51bGwsXHJcbiAgKTogdm9pZCB7XHJcbiAgICBjb25zdCBwYXRoID0gYnVmZmVyLmdldFBhdGgoKSB8fCAnJztcclxuICAgIGlmIChwcmV2RWRpdCAmJiBlZGl0Lm9sZFJhbmdlLmVuZC5jb21wYXJlKHByZXZFZGl0Lm9sZFJhbmdlLnN0YXJ0KSA+IDApIHtcclxuICAgICAgdGhyb3cgRXJyb3IoYEZvdW5kIG92ZXJsYXBwaW5nIGVkaXQgcmFuZ2VzIGluICR7cGF0aH1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHN0YXJ0Um93ID0gZWRpdC5vbGRSYW5nZS5zdGFydC5yb3c7XHJcbiAgICBjb25zdCBzdGFydENvbCA9IGVkaXQub2xkUmFuZ2Uuc3RhcnQuY29sdW1uO1xyXG4gICAgY29uc3QgbGluZUxlbmd0aCA9IGJ1ZmZlci5saW5lTGVuZ3RoRm9yUm93KHN0YXJ0Um93KTtcclxuICAgIGlmIChsaW5lTGVuZ3RoID09IG51bGwgfHwgc3RhcnRDb2wgPiBsaW5lTGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGBPdXQgb2YgcmFuZ2UgZWRpdCBvbiAke3BhdGh9OiR7c3RhcnRSb3cgKyAxfToke3N0YXJ0Q29sICsgMX1gKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19