Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts workspace/applyEdit commands to editors.
let ApplyEditAdapter = class ApplyEditAdapter {
  // Public: Attach to a {LanguageClientConnection} to receive edit events.
  static attach(connection) {
    connection.onApplyEdit(m => ApplyEditAdapter.onApplyEdit(m));
  }

  static onApplyEdit(params) {
    return _asyncToGenerator(function* () {
      // TODO(protocol v3.0): Handle versioned documentChanges
      const { changes } = params.edit;
      const uris = Object.keys(changes);
      const paths = uris.map(_convert2.default.uriToPath);
      const editors = yield Promise.all(paths.map(function (path) {
        return atom.workspace.open(path, {
          searchAllPanes: true,
          // Open new editors in the background.
          activatePane: false,
          activateItem: false
        });
      }));

      const checkpoints = [];
      try {
        for (let i = 0; i < editors.length; i++) {
          const editor = editors[i];
          const uri = uris[i];
          // Get an existing editor for the file, or open a new one if it doesn't exist.
          const edits = _convert2.default.convertLsTextEdits(changes[uri]);
          // Sort edits in reverse order to prevent edit conflicts.
          edits.sort(function (edit1, edit2) {
            return -edit1.oldRange.compare(edit2.oldRange);
          });
          const buffer = editor.getBuffer();
          const checkpoint = buffer.createCheckpoint();
          checkpoints.push({ buffer, checkpoint });
          let prevEdit = null;
          for (const edit of edits) {
            ApplyEditAdapter.validateEdit(buffer, edit, prevEdit);
            buffer.setTextInRange(edit.oldRange, edit.newText);
            prevEdit = edit;
          }
          buffer.groupChangesSinceCheckpoint(checkpoint);
        }
        return { applied: true };
      } catch (e) {
        atom.notifications.addError('workspace/applyEdits failed', {
          description: 'Failed to apply edits.',
          detail: e.message
        });
        checkpoints.forEach(function ({ buffer, checkpoint }) {
          buffer.revertToCheckpoint(checkpoint);
        });
        return { applied: false };
      }
    })();
  }

  // Private: Do some basic sanity checking on the edit ranges.
  static validateEdit(buffer, edit, prevEdit) {
    const path = buffer.getPath() || '';
    if (prevEdit != null && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
      throw Error(`Found overlapping edit ranges in ${path}`);
    }
    const startRow = edit.oldRange.start.row;
    const startCol = edit.oldRange.start.column;
    const lineLength = buffer.lineLengthForRow(startRow);
    if (lineLength == null || startCol > lineLength) {
      throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
    }
  }
};
exports.default = ApplyEditAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9hcHBseS1lZGl0LWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiQXBwbHlFZGl0QWRhcHRlciIsImF0dGFjaCIsImNvbm5lY3Rpb24iLCJvbkFwcGx5RWRpdCIsIm0iLCJwYXJhbXMiLCJjaGFuZ2VzIiwiZWRpdCIsInVyaXMiLCJPYmplY3QiLCJrZXlzIiwicGF0aHMiLCJtYXAiLCJ1cmlUb1BhdGgiLCJlZGl0b3JzIiwiUHJvbWlzZSIsImFsbCIsImF0b20iLCJ3b3Jrc3BhY2UiLCJvcGVuIiwicGF0aCIsInNlYXJjaEFsbFBhbmVzIiwiYWN0aXZhdGVQYW5lIiwiYWN0aXZhdGVJdGVtIiwiY2hlY2twb2ludHMiLCJpIiwibGVuZ3RoIiwiZWRpdG9yIiwidXJpIiwiZWRpdHMiLCJjb252ZXJ0THNUZXh0RWRpdHMiLCJzb3J0IiwiZWRpdDEiLCJlZGl0MiIsIm9sZFJhbmdlIiwiY29tcGFyZSIsImJ1ZmZlciIsImdldEJ1ZmZlciIsImNoZWNrcG9pbnQiLCJjcmVhdGVDaGVja3BvaW50IiwicHVzaCIsInByZXZFZGl0IiwidmFsaWRhdGVFZGl0Iiwic2V0VGV4dEluUmFuZ2UiLCJuZXdUZXh0IiwiZ3JvdXBDaGFuZ2VzU2luY2VDaGVja3BvaW50IiwiYXBwbGllZCIsImUiLCJub3RpZmljYXRpb25zIiwiYWRkRXJyb3IiLCJkZXNjcmlwdGlvbiIsImRldGFpbCIsIm1lc3NhZ2UiLCJmb3JFYWNoIiwicmV2ZXJ0VG9DaGVja3BvaW50IiwiZ2V0UGF0aCIsImVuZCIsInN0YXJ0IiwiRXJyb3IiLCJzdGFydFJvdyIsInJvdyIsInN0YXJ0Q29sIiwiY29sdW1uIiwibGluZUxlbmd0aCIsImxpbmVMZW5ndGhGb3JSb3ciXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBS0E7Ozs7Ozs7O0FBRUE7SUFDcUJBLGdCLEdBQU4sTUFBTUEsZ0JBQU4sQ0FBdUI7QUFDcEM7QUFDQSxTQUFPQyxNQUFQLENBQWNDLFVBQWQsRUFBb0Q7QUFD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Q0QsVUFBTXVDLFdBQVdwRCxLQUFLMkIsUUFBTCxDQUFjdUIsS0FBZCxDQUFvQkcsR0FBckM7QUFDQSxVQUFNQyxXQUFXdEQsS0FBSzJCLFFBQUwsQ0FBY3VCLEtBQWQsQ0FBb0JLLE1BQXJDO0FBQ0EsVUFBTUMsYUFBYTNCLE9BQU80QixnQkFBUCxDQUF3QkwsUUFBeEIsQ0FBbkI7QUFDQSxRQUFJSSxjQUFjLElBQWQsSUFBc0JGLFdBQVdFLFVBQXJDLEVBQWlEO0FBQy9DLFlBQU1MLE1BQU8sd0JBQXVCdEMsSUFBSyxJQUFHdUMsV0FBVyxDQUFFLElBQUdFLFdBQVcsQ0FBRSxFQUFuRSxDQUFOO0FBQ0Q7QUFDRjtBQW5FbUMsQztrQkFBakI3RCxnQiIsImZpbGUiOiJhcHBseS1lZGl0LWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgdHlwZSBBcHBseVdvcmtzcGFjZUVkaXRQYXJhbXMsXHJcbiAgdHlwZSBBcHBseVdvcmtzcGFjZUVkaXRSZXNwb25zZSxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgd29ya3NwYWNlL2FwcGx5RWRpdCBjb21tYW5kcyB0byBlZGl0b3JzLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBseUVkaXRBZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IEF0dGFjaCB0byBhIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHJlY2VpdmUgZWRpdCBldmVudHMuXHJcbiAgc3RhdGljIGF0dGFjaChjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24pIHtcclxuICAgIGNvbm5lY3Rpb24ub25BcHBseUVkaXQobSA9PiBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KG0pKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBvbkFwcGx5RWRpdChwYXJhbXM6IEFwcGx5V29ya3NwYWNlRWRpdFBhcmFtcyk6IFByb21pc2U8QXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2U+IHtcclxuICAgIC8vIFRPRE8ocHJvdG9jb2wgdjMuMCk6IEhhbmRsZSB2ZXJzaW9uZWQgZG9jdW1lbnRDaGFuZ2VzXHJcbiAgICBjb25zdCB7Y2hhbmdlc30gPSBwYXJhbXMuZWRpdDtcclxuICAgIGNvbnN0IHVyaXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VzKTtcclxuICAgIGNvbnN0IHBhdGhzID0gdXJpcy5tYXAoQ29udmVydC51cmlUb1BhdGgpO1xyXG4gICAgY29uc3QgZWRpdG9ycyA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICBwYXRocy5tYXAocGF0aCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGF0b20ud29ya3NwYWNlLm9wZW4ocGF0aCwge1xyXG4gICAgICAgICAgc2VhcmNoQWxsUGFuZXM6IHRydWUsXHJcbiAgICAgICAgICAvLyBPcGVuIG5ldyBlZGl0b3JzIGluIHRoZSBiYWNrZ3JvdW5kLlxyXG4gICAgICAgICAgYWN0aXZhdGVQYW5lOiBmYWxzZSxcclxuICAgICAgICAgIGFjdGl2YXRlSXRlbTogZmFsc2UsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjaGVja3BvaW50cyA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZWRpdG9yID0gZWRpdG9yc1tpXTtcclxuICAgICAgICBjb25zdCB1cmkgPSB1cmlzW2ldO1xyXG4gICAgICAgIC8vIEdldCBhbiBleGlzdGluZyBlZGl0b3IgZm9yIHRoZSBmaWxlLCBvciBvcGVuIGEgbmV3IG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICAgIGNvbnN0IGVkaXRzID0gQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoY2hhbmdlc1t1cmldKTtcclxuICAgICAgICAvLyBTb3J0IGVkaXRzIGluIHJldmVyc2Ugb3JkZXIgdG8gcHJldmVudCBlZGl0IGNvbmZsaWN0cy5cclxuICAgICAgICBlZGl0cy5zb3J0KChlZGl0MSwgZWRpdDIpID0+IC1lZGl0MS5vbGRSYW5nZS5jb21wYXJlKGVkaXQyLm9sZFJhbmdlKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gZWRpdG9yLmdldEJ1ZmZlcigpO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBidWZmZXIuY3JlYXRlQ2hlY2twb2ludCgpO1xyXG4gICAgICAgIGNoZWNrcG9pbnRzLnB1c2goe2J1ZmZlciwgY2hlY2twb2ludH0pO1xyXG4gICAgICAgIGxldCBwcmV2RWRpdCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChjb25zdCBlZGl0IG9mIGVkaXRzKSB7XHJcbiAgICAgICAgICBBcHBseUVkaXRBZGFwdGVyLnZhbGlkYXRlRWRpdChidWZmZXIsIGVkaXQsIHByZXZFZGl0KTtcclxuICAgICAgICAgIGJ1ZmZlci5zZXRUZXh0SW5SYW5nZShlZGl0Lm9sZFJhbmdlLCBlZGl0Lm5ld1RleHQpO1xyXG4gICAgICAgICAgcHJldkVkaXQgPSBlZGl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIuZ3JvdXBDaGFuZ2VzU2luY2VDaGVja3BvaW50KGNoZWNrcG9pbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7YXBwbGllZDogdHJ1ZX07XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcignd29ya3NwYWNlL2FwcGx5RWRpdHMgZmFpbGVkJywge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRmFpbGVkIHRvIGFwcGx5IGVkaXRzLicsXHJcbiAgICAgICAgZGV0YWlsOiBlLm1lc3NhZ2UsXHJcbiAgICAgIH0pO1xyXG4gICAgICBjaGVja3BvaW50cy5mb3JFYWNoKCh7YnVmZmVyLCBjaGVja3BvaW50fSkgPT4ge1xyXG4gICAgICAgIGJ1ZmZlci5yZXZlcnRUb0NoZWNrcG9pbnQoY2hlY2twb2ludCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4ge2FwcGxpZWQ6IGZhbHNlfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByaXZhdGU6IERvIHNvbWUgYmFzaWMgc2FuaXR5IGNoZWNraW5nIG9uIHRoZSBlZGl0IHJhbmdlcy5cclxuICBzdGF0aWMgdmFsaWRhdGVFZGl0KGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyLCBlZGl0OiBhdG9tSWRlJFRleHRFZGl0LCBwcmV2RWRpdDogP2F0b21JZGUkVGV4dEVkaXQpOiB2b2lkIHtcclxuICAgIGNvbnN0IHBhdGggPSBidWZmZXIuZ2V0UGF0aCgpIHx8ICcnO1xyXG4gICAgaWYgKHByZXZFZGl0ICE9IG51bGwgJiYgZWRpdC5vbGRSYW5nZS5lbmQuY29tcGFyZShwcmV2RWRpdC5vbGRSYW5nZS5zdGFydCkgPiAwKSB7XHJcbiAgICAgIHRocm93IEVycm9yKGBGb3VuZCBvdmVybGFwcGluZyBlZGl0IHJhbmdlcyBpbiAke3BhdGh9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdGFydFJvdyA9IGVkaXQub2xkUmFuZ2Uuc3RhcnQucm93O1xyXG4gICAgY29uc3Qgc3RhcnRDb2wgPSBlZGl0Lm9sZFJhbmdlLnN0YXJ0LmNvbHVtbjtcclxuICAgIGNvbnN0IGxpbmVMZW5ndGggPSBidWZmZXIubGluZUxlbmd0aEZvclJvdyhzdGFydFJvdyk7XHJcbiAgICBpZiAobGluZUxlbmd0aCA9PSBudWxsIHx8IHN0YXJ0Q29sID4gbGluZUxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihgT3V0IG9mIHJhbmdlIGVkaXQgb24gJHtwYXRofToke3N0YXJ0Um93ICsgMX06JHtzdGFydENvbCArIDF9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==