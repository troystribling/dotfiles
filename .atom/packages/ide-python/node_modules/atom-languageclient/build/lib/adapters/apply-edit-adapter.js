"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts workspace/applyEdit commands to editors.
class ApplyEditAdapter {
    // Public: Attach to a {LanguageClientConnection} to receive edit events.
    static attach(connection) {
        connection.onApplyEdit((m) => ApplyEditAdapter.onApplyEdit(m));
    }
    /**
     * Tries to apply edits and reverts if anything goes wrong.
     * Returns the checkpoint, so the caller can revert changes if needed.
     */
    static applyEdits(buffer, edits) {
        const checkpoint = buffer.createCheckpoint();
        try {
            // Sort edits in reverse order to prevent edit conflicts.
            edits.sort((edit1, edit2) => -edit1.oldRange.compare(edit2.oldRange));
            edits.reduce((previous, current) => {
                ApplyEditAdapter.validateEdit(buffer, current, previous);
                buffer.setTextInRange(current.oldRange, current.newText);
                return current;
            }, null);
            buffer.groupChangesSinceCheckpoint(checkpoint);
            return checkpoint;
        }
        catch (err) {
            buffer.revertToCheckpoint(checkpoint);
            throw err;
        }
    }
    static onApplyEdit(params) {
        return __awaiter(this, void 0, void 0, function* () {
            let changes = params.edit.changes || {};
            if (params.edit.documentChanges) {
                changes = {};
                params.edit.documentChanges.forEach((change) => {
                    if (change && change.textDocument) {
                        changes[change.textDocument.uri] = change.edits;
                    }
                });
            }
            const uris = Object.keys(changes);
            // Keep checkpoints from all successful buffer edits
            const checkpoints = [];
            const promises = uris.map((uri) => __awaiter(this, void 0, void 0, function* () {
                const path = convert_1.default.uriToPath(uri);
                const editor = yield atom.workspace.open(path, {
                    searchAllPanes: true,
                    // Open new editors in the background.
                    activatePane: false,
                    activateItem: false,
                });
                const buffer = editor.getBuffer();
                // Get an existing editor for the file, or open a new one if it doesn't exist.
                const edits = convert_1.default.convertLsTextEdits(changes[uri]);
                const checkpoint = ApplyEditAdapter.applyEdits(buffer, edits);
                checkpoints.push({ buffer, checkpoint });
            }));
            // Apply all edits or fail and revert everything
            const applied = yield Promise.all(promises)
                .then(() => true)
                .catch((err) => {
                atom.notifications.addError('workspace/applyEdits failed', {
                    description: 'Failed to apply edits.',
                    detail: err.message,
                });
                checkpoints.forEach(({ buffer, checkpoint }) => {
                    buffer.revertToCheckpoint(checkpoint);
                });
                return false;
            });
            return { applied };
        });
    }
    // Private: Do some basic sanity checking on the edit ranges.
    static validateEdit(buffer, edit, prevEdit) {
        const path = buffer.getPath() || '';
        if (prevEdit && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
            throw Error(`Found overlapping edit ranges in ${path}`);
        }
        const startRow = edit.oldRange.start.row;
        const startCol = edit.oldRange.start.column;
        const lineLength = buffer.lineLengthForRow(startRow);
        if (lineLength == null || startCol > lineLength) {
            throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
        }
    }
}
exports.default = ApplyEditAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBV2pDLDBEQUEwRDtBQUMxRCxNQUFxQixnQkFBZ0I7SUFDbkMseUVBQXlFO0lBQ2xFLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBb0M7UUFDdkQsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxVQUFVLENBQ3RCLE1BQWtCLEVBQ2xCLEtBQXlCO1FBRXpCLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQzdDLElBQUk7WUFDRix5REFBeUQ7WUFDekQsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDdEUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQWlDLEVBQUUsT0FBTyxFQUFFLEVBQUU7Z0JBQzFELGdCQUFnQixDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUN6RCxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUN6RCxPQUFPLE9BQU8sQ0FBQztZQUNqQixDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDVCxNQUFNLENBQUMsMkJBQTJCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDL0MsT0FBTyxVQUFV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QUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdEUsTUFBTSxLQUFLLENBQUMsb0NBQW9DLElBQUksRUFBRSxDQUFDLENBQUM7U0FDekQ7UUFDRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDekMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1FBQzVDLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyRCxJQUFJLFVBQVUsSUFBSSxJQUFJLElBQUksUUFBUSxHQUFHLFVBQVUsRUFBRTtZQUMvQyxNQUFNLEtBQUssQ0FBQyx3QkFBd0IsSUFBSSxJQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDN0U7SUFDSCxDQUFDO0NBQ0Y7QUFwR0QsbUNBb0dDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBBcHBseVdvcmtzcGFjZUVkaXRQYXJhbXMsXHJcbiAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2UsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQge1xyXG4gIFRleHRCdWZmZXIsXHJcbiAgVGV4dEVkaXRvcixcclxufSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHdvcmtzcGFjZS9hcHBseUVkaXQgY29tbWFuZHMgdG8gZWRpdG9ycy5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwbHlFZGl0QWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBBdHRhY2ggdG8gYSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byByZWNlaXZlIGVkaXQgZXZlbnRzLlxyXG4gIHB1YmxpYyBzdGF0aWMgYXR0YWNoKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbikge1xyXG4gICAgY29ubmVjdGlvbi5vbkFwcGx5RWRpdCgobSkgPT4gQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdChtKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmllcyB0byBhcHBseSBlZGl0cyBhbmQgcmV2ZXJ0cyBpZiBhbnl0aGluZyBnb2VzIHdyb25nLlxyXG4gICAqIFJldHVybnMgdGhlIGNoZWNrcG9pbnQsIHNvIHRoZSBjYWxsZXIgY2FuIHJldmVydCBjaGFuZ2VzIGlmIG5lZWRlZC5cclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIGFwcGx5RWRpdHMoXHJcbiAgICBidWZmZXI6IFRleHRCdWZmZXIsXHJcbiAgICBlZGl0czogYXRvbUlkZS5UZXh0RWRpdFtdLFxyXG4gICk6IG51bWJlciB7XHJcbiAgICBjb25zdCBjaGVja3BvaW50ID0gYnVmZmVyLmNyZWF0ZUNoZWNrcG9pbnQoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNvcnQgZWRpdHMgaW4gcmV2ZXJzZSBvcmRlciB0byBwcmV2ZW50IGVkaXQgY29uZmxpY3RzLlxyXG4gICAgICBlZGl0cy5zb3J0KChlZGl0MSwgZWRpdDIpID0+IC1lZGl0MS5vbGRSYW5nZS5jb21wYXJlKGVkaXQyLm9sZFJhbmdlKSk7XHJcbiAgICAgIGVkaXRzLnJlZHVjZSgocHJldmlvdXM6IGF0b21JZGUuVGV4dEVkaXQgfCBudWxsLCBjdXJyZW50KSA9PiB7XHJcbiAgICAgICAgQXBwbHlFZGl0QWRhcHRlci52YWxpZGF0ZUVkaXQoYnVmZmVyLCBjdXJyZW50LCBwcmV2aW91cyk7XHJcbiAgICAgICAgYnVmZmVyLnNldFRleHRJblJhbmdlKGN1cnJlbnQub2xkUmFuZ2UsIGN1cnJlbnQubmV3VGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgIH0sIG51bGwpO1xyXG4gICAgICBidWZmZXIuZ3JvdXBDaGFuZ2VzU2luY2VDaGVja3BvaW50KGNoZWNrcG9pbnQpO1xyXG4gICAgICByZXR1cm4gY2hlY2twb2ludDtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBidWZmZXIucmV2ZXJ0VG9DaGVja3BvaW50KGNoZWNrcG9pbnQpO1xyXG4gICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIG9uQXBwbHlFZGl0KHBhcmFtczogQXBwbHlXb3Jrc3BhY2VFZGl0UGFyYW1zKTogUHJvbWlzZTxBcHBseVdvcmtzcGFjZUVkaXRSZXNwb25zZT4ge1xyXG5cclxuICAgIGxldCBjaGFuZ2VzID0gcGFyYW1zLmVkaXQuY2hhbmdlcyB8fCB7fTtcclxuXHJcbiAgICBpZiAocGFyYW1zLmVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XHJcbiAgICAgIGNoYW5nZXMgPSB7fTtcclxuICAgICAgcGFyYW1zLmVkaXQuZG9jdW1lbnRDaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xyXG4gICAgICAgIGlmIChjaGFuZ2UgJiYgY2hhbmdlLnRleHREb2N1bWVudCkge1xyXG4gICAgICAgICAgY2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSBjaGFuZ2UuZWRpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1cmlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XHJcblxyXG4gICAgLy8gS2VlcCBjaGVja3BvaW50cyBmcm9tIGFsbCBzdWNjZXNzZnVsIGJ1ZmZlciBlZGl0c1xyXG4gICAgY29uc3QgY2hlY2twb2ludHM6IEFycmF5PHsgYnVmZmVyOiBUZXh0QnVmZmVyLCBjaGVja3BvaW50OiBudW1iZXIgfT4gPSBbXTtcclxuXHJcbiAgICBjb25zdCBwcm9taXNlcyA9IHVyaXMubWFwKGFzeW5jICh1cmkpID0+IHtcclxuICAgICAgY29uc3QgcGF0aCA9IENvbnZlcnQudXJpVG9QYXRoKHVyaSk7XHJcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oXHJcbiAgICAgICAgcGF0aCwge1xyXG4gICAgICAgICAgc2VhcmNoQWxsUGFuZXM6IHRydWUsXHJcbiAgICAgICAgICAvLyBPcGVuIG5ldyBlZGl0b3JzIGluIHRoZSBiYWNrZ3JvdW5kLlxyXG4gICAgICAgICAgYWN0aXZhdGVQYW5lOiBmYWxzZSxcclxuICAgICAgICAgIGFjdGl2YXRlSXRlbTogZmFsc2UsXHJcbiAgICAgICAgfSxcclxuICAgICAgKSBhcyBUZXh0RWRpdG9yO1xyXG4gICAgICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKCk7XHJcbiAgICAgIC8vIEdldCBhbiBleGlzdGluZyBlZGl0b3IgZm9yIHRoZSBmaWxlLCBvciBvcGVuIGEgbmV3IG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gICAgICBjb25zdCBlZGl0cyA9IENvbnZlcnQuY29udmVydExzVGV4dEVkaXRzKGNoYW5nZXNbdXJpXSk7XHJcbiAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBBcHBseUVkaXRBZGFwdGVyLmFwcGx5RWRpdHMoYnVmZmVyLCBlZGl0cyk7XHJcbiAgICAgIGNoZWNrcG9pbnRzLnB1c2goe2J1ZmZlciwgY2hlY2twb2ludH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXBwbHkgYWxsIGVkaXRzIG9yIGZhaWwgYW5kIHJldmVydCBldmVyeXRoaW5nXHJcbiAgICBjb25zdCBhcHBsaWVkID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXHJcbiAgICAgIC50aGVuKCgpID0+IHRydWUpXHJcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZEVycm9yKCd3b3Jrc3BhY2UvYXBwbHlFZGl0cyBmYWlsZWQnLCB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhaWxlZCB0byBhcHBseSBlZGl0cy4nLFxyXG4gICAgICAgICAgZGV0YWlsOiBlcnIubWVzc2FnZSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjaGVja3BvaW50cy5mb3JFYWNoKCh7YnVmZmVyLCBjaGVja3BvaW50fSkgPT4ge1xyXG4gICAgICAgICAgYnVmZmVyLnJldmVydFRvQ2hlY2twb2ludChjaGVja3BvaW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7YXBwbGllZH07XHJcbiAgfVxyXG5cclxuICAvLyBQcml2YXRlOiBEbyBzb21lIGJhc2ljIHNhbml0eSBjaGVja2luZyBvbiB0aGUgZWRpdCByYW5nZXMuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgdmFsaWRhdGVFZGl0KFxyXG4gICAgYnVmZmVyOiBUZXh0QnVmZmVyLFxyXG4gICAgZWRpdDogYXRvbUlkZS5UZXh0RWRpdCxcclxuICAgIHByZXZFZGl0OiBhdG9tSWRlLlRleHRFZGl0IHwgbnVsbCxcclxuICApOiB2b2lkIHtcclxuICAgIGNvbnN0IHBhdGggPSBidWZmZXIuZ2V0UGF0aCgpIHx8ICcnO1xyXG4gICAgaWYgKHByZXZFZGl0ICYmIGVkaXQub2xkUmFuZ2UuZW5kLmNvbXBhcmUocHJldkVkaXQub2xkUmFuZ2Uuc3RhcnQpID4gMCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihgRm91bmQgb3ZlcmxhcHBpbmcgZWRpdCByYW5nZXMgaW4gJHtwYXRofWApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnRSb3cgPSBlZGl0Lm9sZFJhbmdlLnN0YXJ0LnJvdztcclxuICAgIGNvbnN0IHN0YXJ0Q29sID0gZWRpdC5vbGRSYW5nZS5zdGFydC5jb2x1bW47XHJcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gYnVmZmVyLmxpbmVMZW5ndGhGb3JSb3coc3RhcnRSb3cpO1xyXG4gICAgaWYgKGxpbmVMZW5ndGggPT0gbnVsbCB8fCBzdGFydENvbCA+IGxpbmVMZW5ndGgpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoYE91dCBvZiByYW5nZSBlZGl0IG9uICR7cGF0aH06JHtzdGFydFJvdyArIDF9OiR7c3RhcnRDb2wgKyAxfWApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=