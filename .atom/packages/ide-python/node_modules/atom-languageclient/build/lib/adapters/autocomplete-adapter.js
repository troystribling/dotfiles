"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.grammarScopeToAutoCompleteSelector = void 0;
const convert_1 = require("../convert");
const Utils = require("../utils");
const zadeh_1 = require("zadeh");
const languageclient_1 = require("../languageclient");
const apply_edit_adapter_1 = require("./apply-edit-adapter");
const atom_1 = require("atom");
class PossiblyResolvedCompletionItem {
    constructor(completionItem, isResolved) {
        this.completionItem = completionItem;
        this.isResolved = isResolved;
    }
}
/** Public: Adapts the language server protocol "textDocument/completion" to the Atom AutoComplete+ package. */
class AutocompleteAdapter {
    constructor() {
        this._suggestionCache = new WeakMap();
        this._cancellationTokens = new WeakMap();
    }
    static canAdapt(serverCapabilities) {
        return serverCapabilities.completionProvider != null;
    }
    static canResolve(serverCapabilities) {
        return (serverCapabilities.completionProvider != null && serverCapabilities.completionProvider.resolveProvider === true);
    }
    /**
     * Public: Obtain suggestion list for AutoComplete+ by querying the language server using the `textDocument/completion` request.
     *
     * @param server An {ActiveServer} pointing to the language server to query.
     * @param request The {atom$AutocompleteRequest} to satisfy.
     * @param onDidConvertCompletionItem An optional function that takes a {CompletionItem}, an
     *   {atom$AutocompleteSuggestion} and a {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @param shouldReplace The behavior of suggestion acceptance (see {ShouldReplace}).
     * @returns A {Promise} of an {Array} of {atom$AutocompleteSuggestion}s containing the AutoComplete+ suggestions to display.
     */
    getSuggestions(server, request, onDidConvertCompletionItem, minimumWordLength, shouldReplace = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const triggerChars = server.capabilities.completionProvider != null
                ? server.capabilities.completionProvider.triggerCharacters || []
                : [];
            // triggerOnly is true if we have just typed in a trigger character, and is false if we
            // have typed additional characters following a trigger character.
            const [triggerChar, triggerOnly] = AutocompleteAdapter.getTriggerCharacter(request, triggerChars);
            if (!this.shouldTrigger(request, triggerChar, minimumWordLength || 0)) {
                return [];
            }
            // Get the suggestions either from the cache or by calling the language server
            const suggestions = yield this.getOrBuildSuggestions(server, request, triggerChar, triggerOnly, shouldReplace, onDidConvertCompletionItem);
            // We must update the replacement prefix as characters are added and removed
            const cache = this._suggestionCache.get(server);
            const replacementPrefix = request.editor.getTextInBufferRange([
                [cache.triggerPoint.row, cache.triggerPoint.column + cache.triggerChar.length],
                request.bufferPosition,
            ]);
            for (const suggestion of suggestions) {
                if (suggestion.customReplacmentPrefix) {
                    // having this property means a custom range was provided
                    const len = replacementPrefix.length;
                    const preReplacementPrefix = suggestion.customReplacmentPrefix +
                        replacementPrefix.substring(len + cache.originalBufferPoint.column - request.bufferPosition.column, len);
                    // we cannot replace text after the cursor with the current autocomplete-plus API
                    // so we will simply ignore it for now
                    suggestion.replacementPrefix = preReplacementPrefix;
                }
                else {
                    suggestion.replacementPrefix = replacementPrefix;
                }
            }
            const filtered = !(request.prefix === "" || (triggerChar !== "" && triggerOnly));
            if (filtered) {
                // filter the suggestions who have `filterText` property
                const validSuggestions = suggestions.filter((sgs) => typeof sgs.filterText === "string");
                // TODO use `ObjectArrayFilterer.setCandidate` in `_suggestionCache` to avoid creating `ObjectArrayFilterer` every time from scratch
                const objFilterer = new zadeh_1.ObjectArrayFilterer(validSuggestions, "filterText");
                // zadeh returns an array of the selected `Suggestions`
                return objFilterer.filter(request.prefix);
            }
            else {
                return suggestions;
            }
        });
    }
    shouldTrigger(request, triggerChar, minWordLength) {
        return (request.activatedManually || triggerChar !== "" || minWordLength <= 0 || request.prefix.length >= minWordLength);
    }
    getOrBuildSuggestions(server, request, triggerChar, triggerOnly, shouldReplace, onDidConvertCompletionItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = this._suggestionCache.get(server);
            const triggerColumn = triggerChar !== "" && triggerOnly
                ? request.bufferPosition.column - triggerChar.length
                : request.bufferPosition.column - request.prefix.length - triggerChar.length;
            const triggerPoint = new atom_1.Point(request.bufferPosition.row, triggerColumn);
            // Do we have complete cached suggestions that are still valid for this request?
            if (cache &&
                !cache.isIncomplete &&
                cache.triggerChar === triggerChar &&
                cache.triggerPoint.isEqual(triggerPoint) &&
                cache.originalBufferPoint.isLessThanOrEqual(request.bufferPosition)) {
                return Array.from(cache.suggestionMap.keys());
            }
            // Our cached suggestions can't be used so obtain new ones from the language server
            const completions = yield Utils.doWithCancellationToken(server.connection, this._cancellationTokens, (cancellationToken) => server.connection.completion(AutocompleteAdapter.createCompletionParams(request, triggerChar, triggerOnly), cancellationToken));
            // spec guarantees all edits are on the same line, so we only need to check the columns
            const triggerColumns = [triggerPoint.column, request.bufferPosition.column];
            // Setup the cache for subsequent filtered results
            const isComplete = completions === null || Array.isArray(completions) || completions.isIncomplete === false;
            const suggestionMap = this.completionItemsToSuggestions(completions, request, triggerColumns, shouldReplace, onDidConvertCompletionItem);
            this._suggestionCache.set(server, {
                isIncomplete: !isComplete,
                triggerChar,
                triggerPoint,
                originalBufferPoint: request.bufferPosition,
                suggestionMap,
            });
            return Array.from(suggestionMap.keys());
        });
    }
    /**
     * Public: Obtain a complete version of a suggestion with additional information the language server can provide by
     * way of the `completionItem/resolve` request.
     *
     * @param server An {ActiveServer} pointing to the language server to query.
     * @param suggestion An {atom$AutocompleteSuggestion} suggestion that should be resolved.
     * @param request An {Object} with the AutoComplete+ request to satisfy.
     * @param onDidConvertCompletionItem An optional function that takes a {CompletionItem}, an
     *   {atom$AutocompleteSuggestion} and a {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @returns A {Promise} of an {atom$AutocompleteSuggestion} with the resolved AutoComplete+ suggestion.
     */
    completeSuggestion(server, suggestion, request, onDidConvertCompletionItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const cache = this._suggestionCache.get(server);
            if (cache) {
                const possiblyResolvedCompletionItem = cache.suggestionMap.get(suggestion);
                if (possiblyResolvedCompletionItem != null && possiblyResolvedCompletionItem.isResolved === false) {
                    const resolvedCompletionItem = yield server.connection.completionItemResolve(possiblyResolvedCompletionItem.completionItem);
                    if (resolvedCompletionItem != null) {
                        AutocompleteAdapter.resolveSuggestion(resolvedCompletionItem, suggestion, request, onDidConvertCompletionItem);
                        possiblyResolvedCompletionItem.isResolved = true;
                    }
                }
            }
            return suggestion;
        });
    }
    static resolveSuggestion(resolvedCompletionItem, suggestion, request, onDidConvertCompletionItem) {
        // only the `documentation` and `detail` properties may change when resolving
        AutocompleteAdapter.applyDetailsToSuggestion(resolvedCompletionItem, suggestion);
        if (onDidConvertCompletionItem != null) {
            onDidConvertCompletionItem(resolvedCompletionItem, suggestion, request);
        }
    }
    /**
     * Public: Get the trigger character that caused the autocomplete (if any). This is required because AutoComplete-plus
     * does not have trigger characters. Although the terminology is 'character' we treat them as variable length strings
     * as this will almost certainly change in the future to support '->' etc.
     *
     * @param request An {Array} of {atom$AutocompleteSuggestion}s to locate the prefix, editor, bufferPosition etc.
     * @param triggerChars The {Array} of {string}s that can be trigger characters.
     * @returns A [{string}, boolean] where the string is the matching trigger character or an empty string if one was not
     *   matched, and the boolean is true if the trigger character is in request.prefix, and false if it is in the word
     *   before request.prefix. The boolean return value has no meaning if the string return value is an empty string.
     */
    static getTriggerCharacter(request, triggerChars) {
        // AutoComplete-Plus considers text after a symbol to be a new trigger. So we should look backward
        // from the current cursor position to see if one is there and thus simulate it.
        const buffer = request.editor.getBuffer();
        const cursor = request.bufferPosition;
        const prefixStartColumn = cursor.column - request.prefix.length;
        for (const triggerChar of triggerChars) {
            if (request.prefix.endsWith(triggerChar)) {
                return [triggerChar, true];
            }
            if (prefixStartColumn >= triggerChar.length) {
                // Far enough along a line to fit the trigger char
                const start = new atom_1.Point(cursor.row, prefixStartColumn - triggerChar.length);
                const possibleTrigger = buffer.getTextInRange([start, [cursor.row, prefixStartColumn]]);
                if (possibleTrigger === triggerChar) {
                    // The text before our trigger is a trigger char!
                    return [triggerChar, false];
                }
            }
        }
        // There was no explicit trigger char
        return ["", false];
    }
    /**
     * Public: Create TextDocumentPositionParams to be sent to the language server based on the editor and position from
     * the AutoCompleteRequest.
     *
     * @param request The {atom$AutocompleteRequest} to obtain the editor from.
     * @param triggerPoint The {atom$Point} where the trigger started.
     * @returns A {string} containing the prefix including the trigger character.
     */
    static getPrefixWithTrigger(request, triggerPoint) {
        return request.editor.getBuffer().getTextInRange([[triggerPoint.row, triggerPoint.column], request.bufferPosition]);
    }
    /**
     * Public: Create {CompletionParams} to be sent to the language server based on the editor and position from the
     * Autocomplete request etc.
     *
     * @param request The {atom$AutocompleteRequest} containing the request details.
     * @param triggerCharacter The {string} containing the trigger character (empty if none).
     * @param triggerOnly A {boolean} representing whether this completion is triggered right after a trigger character.
     * @returns A {CompletionParams} with the keys:
     *
     *   - `textDocument` the language server protocol textDocument identification.
     *   - `position` the position within the text document to display completion request for.
     *   - `context` containing the trigger character and kind.
     */
    static createCompletionParams(request, triggerCharacter, triggerOnly) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(request.editor),
            position: convert_1.default.pointToPosition(request.bufferPosition),
            context: AutocompleteAdapter.createCompletionContext(triggerCharacter, triggerOnly),
        };
    }
    /**
     * Public: Create {CompletionContext} to be sent to the language server based on the trigger character.
     *
     * @param triggerCharacter The {string} containing the trigger character or '' if none.
     * @param triggerOnly A {boolean} representing whether this completion is triggered right after a trigger character.
     * @returns An {CompletionContext} that specifies the triggerKind and the triggerCharacter if there is one.
     */
    static createCompletionContext(triggerCharacter, triggerOnly) {
        if (triggerCharacter === "") {
            return { triggerKind: languageclient_1.CompletionTriggerKind.Invoked };
        }
        else {
            return triggerOnly
                ? { triggerKind: languageclient_1.CompletionTriggerKind.TriggerCharacter, triggerCharacter }
                : { triggerKind: languageclient_1.CompletionTriggerKind.TriggerForIncompleteCompletions, triggerCharacter };
        }
    }
    /**
     * Public: Convert a language server protocol CompletionItem array or CompletionList to an array of ordered
     * AutoComplete+ suggestions.
     *
     * @param completionItems An {Array} of {CompletionItem} objects or a {CompletionList} containing completion items to
     *   be converted.
     * @param request The {atom$AutocompleteRequest} to satisfy.
     * @param shouldReplace The behavior of suggestion acceptance (see {ShouldReplace}).
     * @param onDidConvertCompletionItem A function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion} and a
     *   {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @returns A {Map} of AutoComplete+ suggestions ordered by the CompletionItems sortText.
     */
    completionItemsToSuggestions(completionItems, request, triggerColumns, shouldReplace, onDidConvertCompletionItem) {
        const completionsArray = Array.isArray(completionItems)
            ? completionItems
            : (completionItems && completionItems.items) || [];
        return new Map(completionsArray
            .sort((a, b) => (a.sortText || a.label).localeCompare(b.sortText || b.label))
            .map((s) => [
            AutocompleteAdapter.completionItemToSuggestion(s, {}, request, triggerColumns, shouldReplace, onDidConvertCompletionItem),
            new PossiblyResolvedCompletionItem(s, false),
        ]));
    }
    /**
     * Public: Convert a language server protocol CompletionItem to an AutoComplete+ suggestion.
     *
     * @param item An {CompletionItem} containing a completion item to be converted.
     * @param suggestion A {atom$AutocompleteSuggestion} to have the conversion applied to.
     * @param request The {atom$AutocompleteRequest} to satisfy.
     * @param shouldReplace The behavior of suggestion acceptance (see {ShouldReplace}).
     * @param onDidConvertCompletionItem A function that takes a {CompletionItem}, an {atom$AutocompleteSuggestion} and a
     *   {atom$AutocompleteRequest} allowing you to adjust converted items.
     * @returns The {atom$AutocompleteSuggestion} passed in as suggestion with the conversion applied.
     */
    static completionItemToSuggestion(item, suggestion, request, triggerColumns, shouldReplace, onDidConvertCompletionItem) {
        AutocompleteAdapter.applyCompletionItemToSuggestion(item, suggestion);
        AutocompleteAdapter.applyTextEditToSuggestion(item.textEdit, request.editor, triggerColumns, request.bufferPosition, suggestion, shouldReplace);
        AutocompleteAdapter.applySnippetToSuggestion(item, suggestion);
        if (onDidConvertCompletionItem != null) {
            onDidConvertCompletionItem(item, suggestion, request);
        }
        return suggestion;
    }
    /**
     * Public: Convert the primary parts of a language server protocol CompletionItem to an AutoComplete+ suggestion.
     *
     * @param item An {CompletionItem} containing the completion items to be merged into.
     * @param suggestion The {Suggestion} to merge the conversion into.
     * @returns The {Suggestion} with details added from the {CompletionItem}.
     */
    static applyCompletionItemToSuggestion(item, suggestion) {
        suggestion.text = item.insertText || item.label;
        suggestion.filterText = item.filterText || item.label;
        suggestion.displayText = item.label;
        suggestion.type = AutocompleteAdapter.completionKindToSuggestionType(item.kind);
        AutocompleteAdapter.applyDetailsToSuggestion(item, suggestion);
        suggestion.completionItem = item;
    }
    static applyDetailsToSuggestion(item, suggestion) {
        suggestion.rightLabel = item.detail;
        // Older format, can't know what it is so assign to both and hope for best
        if (typeof item.documentation === "string") {
            suggestion.descriptionMarkdown = item.documentation;
            suggestion.description = item.documentation;
        }
        if (item.documentation != null && typeof item.documentation === "object") {
            // Newer format specifies the kind of documentation, assign appropriately
            if (item.documentation.kind === "markdown") {
                suggestion.descriptionMarkdown = item.documentation.value;
            }
            else {
                suggestion.description = item.documentation.value;
            }
        }
    }
    /**
     * Public: Applies the textEdit part of a language server protocol CompletionItem to an AutoComplete+ Suggestion via
     * the replacementPrefix and text properties.
     *
     * @param textEdit A {TextEdit} from a CompletionItem to apply.
     * @param editor An Atom {TextEditor} used to obtain the necessary text replacement.
     * @param suggestion An {atom$AutocompleteSuggestion} to set the replacementPrefix and text properties of.
     * @param shouldReplace The behavior of suggestion acceptance (see {ShouldReplace}).
     */
    static applyTextEditToSuggestion(textEdit, editor, triggerColumns, originalBufferPosition, suggestion, shouldReplace) {
        if (!textEdit) {
            return;
        }
        let range;
        if ("range" in textEdit) {
            range = textEdit.range;
        }
        else if (shouldReplace) {
            range = textEdit.replace;
        }
        else {
            range = textEdit.insert;
        }
        if (range.start.character !== triggerColumns[0]) {
            const atomRange = convert_1.default.lsRangeToAtomRange(range);
            suggestion.customReplacmentPrefix = editor.getTextInBufferRange([atomRange.start, originalBufferPosition]);
        }
        suggestion.text = textEdit.newText;
    }
    /**
     * Handle additional text edits after a suggestion insert, e.g. `additionalTextEdits`.
     *
     * `additionalTextEdits` are An optional array of additional text edits that are applied when selecting this
     * completion. Edits must not overlap (including the same insert position) with the main edit nor with themselves.
     *
     * Additional text edits should be used to change text unrelated to the current cursor position (for example adding an
     * import statement at the top of the file if the completion item will insert an unqualified type).
     */
    static applyAdditionalTextEdits(event) {
        var _a;
        const suggestion = event.suggestion;
        const additionalEdits = (_a = suggestion.completionItem) === null || _a === void 0 ? void 0 : _a.additionalTextEdits;
        const buffer = event.editor.getBuffer();
        apply_edit_adapter_1.default.applyEdits(buffer, convert_1.default.convertLsTextEdits(additionalEdits));
        buffer.groupLastChanges();
    }
    /**
     * Public: Adds a snippet to the suggestion if the CompletionItem contains snippet-formatted text
     *
     * @param item An {CompletionItem} containing the completion items to be merged into.
     * @param suggestion The {atom$AutocompleteSuggestion} to merge the conversion into.
     */
    static applySnippetToSuggestion(item, suggestion) {
        if (item.insertTextFormat === languageclient_1.InsertTextFormat.Snippet) {
            suggestion.snippet = item.textEdit != null ? item.textEdit.newText : item.insertText || item.label;
        }
    }
    /**
     * Public: Obtain the textual suggestion type required by AutoComplete+ that most closely maps to the numeric
     * completion kind supplies by the language server.
     *
     * @param kind A {Number} that represents the suggestion kind to be converted.
     * @returns A {String} containing the AutoComplete+ suggestion type equivalent to the given completion kind.
     */
    static completionKindToSuggestionType(kind) {
        switch (kind) {
            case languageclient_1.CompletionItemKind.Constant:
                return "constant";
            case languageclient_1.CompletionItemKind.Method:
                return "method";
            case languageclient_1.CompletionItemKind.Function:
            case languageclient_1.CompletionItemKind.Constructor:
                return "function";
            case languageclient_1.CompletionItemKind.Field:
            case languageclient_1.CompletionItemKind.Property:
                return "property";
            case languageclient_1.CompletionItemKind.Variable:
                return "variable";
            case languageclient_1.CompletionItemKind.Class:
                return "class";
            case languageclient_1.CompletionItemKind.Struct:
            case languageclient_1.CompletionItemKind.TypeParameter:
                return "type";
            case languageclient_1.CompletionItemKind.Operator:
                return "selector";
            case languageclient_1.CompletionItemKind.Interface:
                return "mixin";
            case languageclient_1.CompletionItemKind.Module:
                return "module";
            case languageclient_1.CompletionItemKind.Unit:
                return "builtin";
            case languageclient_1.CompletionItemKind.Enum:
            case languageclient_1.CompletionItemKind.EnumMember:
                return "enum";
            case languageclient_1.CompletionItemKind.Keyword:
                return "keyword";
            case languageclient_1.CompletionItemKind.Snippet:
                return "snippet";
            case languageclient_1.CompletionItemKind.File:
            case languageclient_1.CompletionItemKind.Folder:
                return "import";
            case languageclient_1.CompletionItemKind.Reference:
                return "require";
            default:
                return "value";
        }
    }
}
exports.default = AutocompleteAdapter;
/**
 * Normalizes the given grammar scope for autoComplete package so it always starts with `.` Based on
 * https://github.com/atom/autocomplete-plus/wiki/Autocomplete-Providers
 *
 * @param grammarScope Such as 'source.python' or '.source.python'
 * @returns The normalized grammarScope such as `.source.python`
 */
function grammarScopeToAutoCompleteSelector(grammarScope) {
    return grammarScope.includes(".") && grammarScope[0] !== "." ? `.${grammarScope}` : grammarScope;
}
exports.grammarScopeToAutoCompleteSelector = grammarScopeToAutoCompleteSelector;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvYXV0b2NvbXBsZXRlLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsd0NBQWdDO0FBQ2hDLGtDQUFpQztBQUdqQyxpQ0FBMkM7QUFDM0Msc0RBYTBCO0FBQzFCLDZEQUFtRDtBQUNuRCwrQkFBd0M7QUFtQ3hDLE1BQU0sOEJBQThCO0lBQ2xDLFlBQW1CLGNBQThCLEVBQVMsVUFBbUI7UUFBMUQsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBQVMsZUFBVSxHQUFWLFVBQVUsQ0FBUztJQUFHLENBQUM7Q0FDbEY7QUFFRCwrR0FBK0c7QUFDL0csTUFBcUIsbUJBQW1CO0lBQXhDO1FBV1UscUJBQWdCLEdBQWdELElBQUksT0FBTyxFQUFFLENBQUE7UUFDN0Usd0JBQW1CLEdBQStELElBQUksT0FBTyxFQUFFLENBQUE7SUEwZnpHLENBQUM7SUFyZ0JRLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE9BQU8sa0JBQWtCLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFBO0lBQ3RELENBQUM7SUFFTSxNQUFNLENBQUMsVUFBVSxDQUFDLGtCQUFzQztRQUM3RCxPQUFPLENBQ0wsa0JBQWtCLENBQUMsa0JBQWtCLElBQUksSUFBSSxJQUFJLGtCQUFrQixDQUFDLGtCQUFrQixDQUFDLGVBQWUsS0FBSyxJQUFJLENBQ2hILENBQUE7SUFDSCxDQUFDO0lBS0Q7Ozs7Ozs7OztPQVNHO0lBQ1UsY0FBYyxDQUN6QixNQUFvQixFQUNwQixPQUFxQyxFQUNyQywwQkFBbUQsRUFDbkQsaUJBQTBCLEVBQzFCLGdCQUErQixLQUFLOztZQUVwQyxNQUFNLFlBQVksR0FDaEIsTUFBTSxDQUFDLFlBQVksQ0FBQyxrQkFBa0IsSUFBSSxJQUFJO2dCQUM1QyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FB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QUFTLENBQUE7WUFDbEIsS0FBSyxtQ0FBa0IsQ0FBQyxPQUFPO2dCQUM3QixPQUFPLFNBQVMsQ0FBQTtZQUNsQixLQUFLLG1DQUFrQixDQUFDLElBQUksQ0FBQztZQUM3QixLQUFLLG1DQUFrQixDQUFDLE1BQU07Z0JBQzVCLE9BQU8sUUFBUSxDQUFBO1lBQ2pCLEtBQUssbUNBQWtCLENBQUMsU0FBUztnQkFDL0IsT0FBTyxTQUFTLENBQUE7WUFDbEI7Z0JBQ0UsT0FBTyxPQUFPLENBQUE7U0FDakI7SUFDSCxDQUFDO0NBQ0Y7QUF0Z0JELHNDQXNnQkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixrQ0FBa0MsQ0FBQyxZQUFvQjtJQUNyRSxPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFBO0FBQ2xHLENBQUM7QUFGRCxnRkFFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb252ZXJ0IGZyb20gXCIuLi9jb252ZXJ0XCJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuLi91dGlsc1wiXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gXCJ2c2NvZGUtanNvbnJwY1wiXG5pbXBvcnQgeyBBY3RpdmVTZXJ2ZXIgfSBmcm9tIFwiLi4vc2VydmVyLW1hbmFnZXJcIlxuaW1wb3J0IHsgT2JqZWN0QXJyYXlGaWx0ZXJlciB9IGZyb20gXCJ6YWRlaFwiXG5pbXBvcnQge1xuICBDb21wbGV0aW9uQ29udGV4dCxcbiAgQ29tcGxldGlvbkl0ZW0sXG4gIENvbXBsZXRpb25JdGVtS2luZCxcbiAgQ29tcGxldGlvbkxpc3QsXG4gIENvbXBsZXRpb25QYXJhbXMsXG4gIENvbXBsZXRpb25UcmlnZ2VyS2luZCxcbiAgSW5zZXJ0VGV4dEZvcm1hdCxcbiAgSW5zZXJ0UmVwbGFjZUVkaXQsXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgUmFuZ2UsXG4gIFNlcnZlckNhcGFiaWxpdGllcyxcbiAgVGV4dEVkaXQsXG59IGZyb20gXCIuLi9sYW5ndWFnZWNsaWVudFwiXG5pbXBvcnQgQXBwbHlFZGl0QWRhcHRlciBmcm9tIFwiLi9hcHBseS1lZGl0LWFkYXB0ZXJcIlxuaW1wb3J0IHsgUG9pbnQsIFRleHRFZGl0b3IgfSBmcm9tIFwiYXRvbVwiXG5pbXBvcnQgKiBhcyBhYyBmcm9tIFwiYXRvbS9hdXRvY29tcGxldGUtcGx1c1wiXG5pbXBvcnQgeyBTdWdnZXN0aW9uLCBUZXh0U3VnZ2VzdGlvbiwgU25pcHBldFN1Z2dlc3Rpb24sIFN1Z2dlc3Rpb25CYXNlIH0gZnJvbSBcIi4uL3R5cGVzL2F1dG9jb21wbGV0ZS1leHRlbmRlZFwiXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgYmVoYXZpb3Igb2Ygc3VnZ2VzdGlvbiBhY2NlcHRhbmNlLiBBc3N1bWUgeW91IGhhdmUgXCJjb25zfG9sZVwiIGluIHRoZSBlZGl0b3IgKCBgfGAgaXMgdGhlIGN1cnNvciBwb3NpdGlvbilcbiAqIGFuZCB0aGUgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb24gaXMgYGNvbnN0YC5cbiAqXG4gKiAtIElmIGBmYWxzZWAgLT4gdGhlIGVkaXRzIGFyZSBpbnNlcnRlZCA6IGNvbnN0fG9sZVxuICogLSBJZiBgdHJ1ZWBgIC0+IHRoZSBlZGl0cyBhcmUgcmVwbGFjZWQ6IGNvbnN0fFxuICovXG50eXBlIFNob3VsZFJlcGxhY2UgPSBib29sZWFuXG5cbi8qKlxuICogSG9sZHMgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zIGdlbmVyYXRlZCBmcm9tIHRoZSBDb21wbGV0aW9uSXRlbVtdIGxpc3Qgc2VudCBieSB0aGUgc2VydmVyLCBhcyB3ZWxsIGFzIG1ldGFkYXRhIGFib3V0XG4gKiB0aGUgY29udGV4dCBpdCB3YXMgY29sbGVjdGVkIGluXG4gKi9cbmludGVyZmFjZSBTdWdnZXN0aW9uQ2FjaGVFbnRyeSB7XG4gIC8qKiBJZiBgdHJ1ZWAsIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kIGEgbGlzdCBvZiBzdWdnZXN0aW9ucyB0byByZXBsYWNlIHRoaXMgb25lICovXG4gIGlzSW5jb21wbGV0ZTogYm9vbGVhblxuICAvKiogVGhlIHBvaW50IGxlZnQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgb3JpZ2luYWwgcHJlZml4IHNlbnQgdG8gdGhlIHNlcnZlciAqL1xuICB0cmlnZ2VyUG9pbnQ6IFBvaW50XG4gIC8qKiBUaGUgcG9pbnQgcmlnaHQgb2YgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSBvcmlnaW5hbCBwcmVmaXggc2VudCB0byB0aGUgc2VydmVyICovXG4gIG9yaWdpbmFsQnVmZmVyUG9pbnQ6IFBvaW50XG4gIC8qKiBUaGUgdHJpZ2dlciBzdHJpbmcgdGhhdCBjYXVzZWQgdGhlIGF1dG9jb21wbGV0ZSAoaWYgYW55KSAqL1xuICB0cmlnZ2VyQ2hhcjogc3RyaW5nXG4gIHN1Z2dlc3Rpb25NYXA6IE1hcDxTdWdnZXN0aW9uLCBQb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW0+XG59XG5cbnR5cGUgQ29tcGxldGlvbkl0ZW1BZGp1c3RlciA9IChcbiAgaXRlbTogQ29tcGxldGlvbkl0ZW0sXG4gIHN1Z2dlc3Rpb246IGFjLkFueVN1Z2dlc3Rpb24sXG4gIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnRcbikgPT4gdm9pZFxuXG5jbGFzcyBQb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW0ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgY29tcGxldGlvbkl0ZW06IENvbXBsZXRpb25JdGVtLCBwdWJsaWMgaXNSZXNvbHZlZDogYm9vbGVhbikge31cbn1cblxuLyoqIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvY29tcGxldGlvblwiIHRvIHRoZSBBdG9tIEF1dG9Db21wbGV0ZSsgcGFja2FnZS4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dG9jb21wbGV0ZUFkYXB0ZXIge1xuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5jb21wbGV0aW9uUHJvdmlkZXIgIT0gbnVsbFxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBjYW5SZXNvbHZlKHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5jb21wbGV0aW9uUHJvdmlkZXIgIT0gbnVsbCAmJiBzZXJ2ZXJDYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyLnJlc29sdmVQcm92aWRlciA9PT0gdHJ1ZVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3N1Z2dlc3Rpb25DYWNoZTogV2Vha01hcDxBY3RpdmVTZXJ2ZXIsIFN1Z2dlc3Rpb25DYWNoZUVudHJ5PiA9IG5ldyBXZWFrTWFwKClcbiAgcHJpdmF0ZSBfY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+ID0gbmV3IFdlYWtNYXAoKVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IE9idGFpbiBzdWdnZXN0aW9uIGxpc3QgZm9yIEF1dG9Db21wbGV0ZSsgYnkgcXVlcnlpbmcgdGhlIGxhbmd1YWdlIHNlcnZlciB1c2luZyB0aGUgYHRleHREb2N1bWVudC9jb21wbGV0aW9uYCByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmVyIEFuIHtBY3RpdmVTZXJ2ZXJ9IHBvaW50aW5nIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSByZXF1ZXN0IFRoZSB7YXRvbSRBdXRvY29tcGxldGVSZXF1ZXN0fSB0byBzYXRpc2Z5LlxuICAgKiBAcGFyYW0gb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtDb21wbGV0aW9uSXRlbX0sIGFuXG4gICAqICAge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gYW5kIGEge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBjb252ZXJ0ZWQgaXRlbXMuXG4gICAqIEBwYXJhbSBzaG91bGRSZXBsYWNlIFRoZSBiZWhhdmlvciBvZiBzdWdnZXN0aW9uIGFjY2VwdGFuY2UgKHNlZSB7U2hvdWxkUmVwbGFjZX0pLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHthdG9tJEF1dG9jb21wbGV0ZVN1Z2dlc3Rpb259cyBjb250YWluaW5nIHRoZSBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb25zIHRvIGRpc3BsYXkuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0U3VnZ2VzdGlvbnMoXG4gICAgc2VydmVyOiBBY3RpdmVTZXJ2ZXIsXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXIsXG4gICAgbWluaW11bVdvcmRMZW5ndGg/OiBudW1iZXIsXG4gICAgc2hvdWxkUmVwbGFjZTogU2hvdWxkUmVwbGFjZSA9IGZhbHNlXG4gICk6IFByb21pc2U8YWMuQW55U3VnZ2VzdGlvbltdPiB7XG4gICAgY29uc3QgdHJpZ2dlckNoYXJzID1cbiAgICAgIHNlcnZlci5jYXBhYmlsaXRpZXMuY29tcGxldGlvblByb3ZpZGVyICE9IG51bGxcbiAgICAgICAgPyBzZXJ2ZXIuY2FwYWJpbGl0aWVzLmNvbXBsZXRpb25Qcm92aWRlci50cmlnZ2VyQ2hhcmFjdGVycyB8fCBbXVxuICAgICAgICA6IFtdXG5cbiAgICAvLyB0cmlnZ2VyT25seSBpcyB0cnVlIGlmIHdlIGhhdmUganVzdCB0eXBlZCBpbiBhIHRyaWdnZXIgY2hhcmFjdGVyLCBhbmQgaXMgZmFsc2UgaWYgd2VcbiAgICAvLyBoYXZlIHR5cGVkIGFkZGl0aW9uYWwgY2hhcmFjdGVycyBmb2xsb3dpbmcgYSB0cmlnZ2VyIGNoYXJhY3Rlci5cbiAgICBjb25zdCBbdHJpZ2dlckNoYXIsIHRyaWdnZXJPbmx5XSA9IEF1dG9jb21wbGV0ZUFkYXB0ZXIuZ2V0VHJpZ2dlckNoYXJhY3RlcihyZXF1ZXN0LCB0cmlnZ2VyQ2hhcnMpXG5cbiAgICBpZiAoIXRoaXMuc2hvdWxkVHJpZ2dlcihyZXF1ZXN0LCB0cmlnZ2VyQ2hhciwgbWluaW11bVdvcmRMZW5ndGggfHwgMCkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgc3VnZ2VzdGlvbnMgZWl0aGVyIGZyb20gdGhlIGNhY2hlIG9yIGJ5IGNhbGxpbmcgdGhlIGxhbmd1YWdlIHNlcnZlclxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gYXdhaXQgdGhpcy5nZXRPckJ1aWxkU3VnZ2VzdGlvbnMoXG4gICAgICBzZXJ2ZXIsXG4gICAgICByZXF1ZXN0LFxuICAgICAgdHJpZ2dlckNoYXIsXG4gICAgICB0cmlnZ2VyT25seSxcbiAgICAgIHNob3VsZFJlcGxhY2UsXG4gICAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbVxuICAgIClcblxuICAgIC8vIFdlIG11c3QgdXBkYXRlIHRoZSByZXBsYWNlbWVudCBwcmVmaXggYXMgY2hhcmFjdGVycyBhcmUgYWRkZWQgYW5kIHJlbW92ZWRcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3N1Z2dlc3Rpb25DYWNoZS5nZXQoc2VydmVyKSFcbiAgICBjb25zdCByZXBsYWNlbWVudFByZWZpeCA9IHJlcXVlc3QuZWRpdG9yLmdldFRleHRJbkJ1ZmZlclJhbmdlKFtcbiAgICAgIFtjYWNoZS50cmlnZ2VyUG9pbnQucm93LCBjYWNoZS50cmlnZ2VyUG9pbnQuY29sdW1uICsgY2FjaGUudHJpZ2dlckNoYXIubGVuZ3RoXSxcbiAgICAgIHJlcXVlc3QuYnVmZmVyUG9zaXRpb24sXG4gICAgXSlcbiAgICBmb3IgKGNvbnN0IHN1Z2dlc3Rpb24gb2Ygc3VnZ2VzdGlvbnMpIHtcbiAgICAgIGlmIChzdWdnZXN0aW9uLmN1c3RvbVJlcGxhY21lbnRQcmVmaXgpIHtcbiAgICAgICAgLy8gaGF2aW5nIHRoaXMgcHJvcGVydHkgbWVhbnMgYSBjdXN0b20gcmFuZ2Ugd2FzIHByb3ZpZGVkXG4gICAgICAgIGNvbnN0IGxlbiA9IHJlcGxhY2VtZW50UHJlZml4Lmxlbmd0aFxuICAgICAgICBjb25zdCBwcmVSZXBsYWNlbWVudFByZWZpeCA9XG4gICAgICAgICAgc3VnZ2VzdGlvbi5jdXN0b21SZXBsYWNtZW50UHJlZml4ICtcbiAgICAgICAgICByZXBsYWNlbWVudFByZWZpeC5zdWJzdHJpbmcobGVuICsgY2FjaGUub3JpZ2luYWxCdWZmZXJQb2ludC5jb2x1bW4gLSByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uLmNvbHVtbiwgbGVuKVxuICAgICAgICAvLyB3ZSBjYW5ub3QgcmVwbGFjZSB0ZXh0IGFmdGVyIHRoZSBjdXJzb3Igd2l0aCB0aGUgY3VycmVudCBhdXRvY29tcGxldGUtcGx1cyBBUElcbiAgICAgICAgLy8gc28gd2Ugd2lsbCBzaW1wbHkgaWdub3JlIGl0IGZvciBub3dcbiAgICAgICAgc3VnZ2VzdGlvbi5yZXBsYWNlbWVudFByZWZpeCA9IHByZVJlcGxhY2VtZW50UHJlZml4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWdnZXN0aW9uLnJlcGxhY2VtZW50UHJlZml4ID0gcmVwbGFjZW1lbnRQcmVmaXhcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZCA9ICEocmVxdWVzdC5wcmVmaXggPT09IFwiXCIgfHwgKHRyaWdnZXJDaGFyICE9PSBcIlwiICYmIHRyaWdnZXJPbmx5KSlcbiAgICBpZiAoZmlsdGVyZWQpIHtcbiAgICAgIC8vIGZpbHRlciB0aGUgc3VnZ2VzdGlvbnMgd2hvIGhhdmUgYGZpbHRlclRleHRgIHByb3BlcnR5XG4gICAgICBjb25zdCB2YWxpZFN1Z2dlc3Rpb25zID0gc3VnZ2VzdGlvbnMuZmlsdGVyKChzZ3MpID0+IHR5cGVvZiBzZ3MuZmlsdGVyVGV4dCA9PT0gXCJzdHJpbmdcIikgYXMgU3VnZ2VzdGlvbltdICZcbiAgICAgICAgeyBmaWx0ZXJUZXh0OiBzdHJpbmcgfVtdXG4gICAgICAvLyBUT0RPIHVzZSBgT2JqZWN0QXJyYXlGaWx0ZXJlci5zZXRDYW5kaWRhdGVgIGluIGBfc3VnZ2VzdGlvbkNhY2hlYCB0byBhdm9pZCBjcmVhdGluZyBgT2JqZWN0QXJyYXlGaWx0ZXJlcmAgZXZlcnkgdGltZSBmcm9tIHNjcmF0Y2hcbiAgICAgIGNvbnN0IG9iakZpbHRlcmVyID0gbmV3IE9iamVjdEFycmF5RmlsdGVyZXIodmFsaWRTdWdnZXN0aW9ucywgXCJmaWx0ZXJUZXh0XCIpXG4gICAgICAvLyB6YWRlaCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBzZWxlY3RlZCBgU3VnZ2VzdGlvbnNgXG4gICAgICByZXR1cm4gb2JqRmlsdGVyZXIuZmlsdGVyKHJlcXVlc3QucHJlZml4KSBhcyBhbnkgYXMgU3VnZ2VzdGlvbltdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWdnZXN0aW9uc1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkVHJpZ2dlcihyZXF1ZXN0OiBhYy5TdWdnZXN0aW9uc1JlcXVlc3RlZEV2ZW50LCB0cmlnZ2VyQ2hhcjogc3RyaW5nLCBtaW5Xb3JkTGVuZ3RoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgcmVxdWVzdC5hY3RpdmF0ZWRNYW51YWxseSB8fCB0cmlnZ2VyQ2hhciAhPT0gXCJcIiB8fCBtaW5Xb3JkTGVuZ3RoIDw9IDAgfHwgcmVxdWVzdC5wcmVmaXgubGVuZ3RoID49IG1pbldvcmRMZW5ndGhcbiAgICApXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldE9yQnVpbGRTdWdnZXN0aW9ucyhcbiAgICBzZXJ2ZXI6IEFjdGl2ZVNlcnZlcixcbiAgICByZXF1ZXN0OiBhYy5TdWdnZXN0aW9uc1JlcXVlc3RlZEV2ZW50LFxuICAgIHRyaWdnZXJDaGFyOiBzdHJpbmcsXG4gICAgdHJpZ2dlck9ubHk6IGJvb2xlYW4sXG4gICAgc2hvdWxkUmVwbGFjZTogU2hvdWxkUmVwbGFjZSxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXJcbiAgKTogUHJvbWlzZTxTdWdnZXN0aW9uW10+IHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3N1Z2dlc3Rpb25DYWNoZS5nZXQoc2VydmVyKVxuXG4gICAgY29uc3QgdHJpZ2dlckNvbHVtbiA9XG4gICAgICB0cmlnZ2VyQ2hhciAhPT0gXCJcIiAmJiB0cmlnZ2VyT25seVxuICAgICAgICA/IHJlcXVlc3QuYnVmZmVyUG9zaXRpb24uY29sdW1uIC0gdHJpZ2dlckNoYXIubGVuZ3RoXG4gICAgICAgIDogcmVxdWVzdC5idWZmZXJQb3NpdGlvbi5jb2x1bW4gLSByZXF1ZXN0LnByZWZpeC5sZW5ndGggLSB0cmlnZ2VyQ2hhci5sZW5ndGhcbiAgICBjb25zdCB0cmlnZ2VyUG9pbnQgPSBuZXcgUG9pbnQocmVxdWVzdC5idWZmZXJQb3NpdGlvbi5yb3csIHRyaWdnZXJDb2x1bW4pXG5cbiAgICAvLyBEbyB3ZSBoYXZlIGNvbXBsZXRlIGNhY2hlZCBzdWdnZXN0aW9ucyB0aGF0IGFyZSBzdGlsbCB2YWxpZCBmb3IgdGhpcyByZXF1ZXN0P1xuICAgIGlmIChcbiAgICAgIGNhY2hlICYmXG4gICAgICAhY2FjaGUuaXNJbmNvbXBsZXRlICYmXG4gICAgICBjYWNoZS50cmlnZ2VyQ2hhciA9PT0gdHJpZ2dlckNoYXIgJiZcbiAgICAgIGNhY2hlLnRyaWdnZXJQb2ludC5pc0VxdWFsKHRyaWdnZXJQb2ludCkgJiZcbiAgICAgIGNhY2hlLm9yaWdpbmFsQnVmZmVyUG9pbnQuaXNMZXNzVGhhbk9yRXF1YWwocmVxdWVzdC5idWZmZXJQb3NpdGlvbilcbiAgICApIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGNhY2hlLnN1Z2dlc3Rpb25NYXAua2V5cygpKVxuICAgIH1cblxuICAgIC8vIE91ciBjYWNoZWQgc3VnZ2VzdGlvbnMgY2FuJ3QgYmUgdXNlZCBzbyBvYnRhaW4gbmV3IG9uZXMgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gICAgY29uc3QgY29tcGxldGlvbnMgPSBhd2FpdCBVdGlscy5kb1dpdGhDYW5jZWxsYXRpb25Ub2tlbihcbiAgICAgIHNlcnZlci5jb25uZWN0aW9uLFxuICAgICAgdGhpcy5fY2FuY2VsbGF0aW9uVG9rZW5zLFxuICAgICAgKGNhbmNlbGxhdGlvblRva2VuKSA9PlxuICAgICAgICBzZXJ2ZXIuY29ubmVjdGlvbi5jb21wbGV0aW9uKFxuICAgICAgICAgIEF1dG9jb21wbGV0ZUFkYXB0ZXIuY3JlYXRlQ29tcGxldGlvblBhcmFtcyhyZXF1ZXN0LCB0cmlnZ2VyQ2hhciwgdHJpZ2dlck9ubHkpLFxuICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuXG4gICAgICAgIClcbiAgICApXG5cbiAgICAvLyBzcGVjIGd1YXJhbnRlZXMgYWxsIGVkaXRzIGFyZSBvbiB0aGUgc2FtZSBsaW5lLCBzbyB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgdGhlIGNvbHVtbnNcbiAgICBjb25zdCB0cmlnZ2VyQ29sdW1uczogW251bWJlciwgbnVtYmVyXSA9IFt0cmlnZ2VyUG9pbnQuY29sdW1uLCByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uLmNvbHVtbl1cblxuICAgIC8vIFNldHVwIHRoZSBjYWNoZSBmb3Igc3Vic2VxdWVudCBmaWx0ZXJlZCByZXN1bHRzXG4gICAgY29uc3QgaXNDb21wbGV0ZSA9IGNvbXBsZXRpb25zID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoY29tcGxldGlvbnMpIHx8IGNvbXBsZXRpb25zLmlzSW5jb21wbGV0ZSA9PT0gZmFsc2VcbiAgICBjb25zdCBzdWdnZXN0aW9uTWFwID0gdGhpcy5jb21wbGV0aW9uSXRlbXNUb1N1Z2dlc3Rpb25zKFxuICAgICAgY29tcGxldGlvbnMsXG4gICAgICByZXF1ZXN0LFxuICAgICAgdHJpZ2dlckNvbHVtbnMsXG4gICAgICBzaG91bGRSZXBsYWNlLFxuICAgICAgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW1cbiAgICApXG4gICAgdGhpcy5fc3VnZ2VzdGlvbkNhY2hlLnNldChzZXJ2ZXIsIHtcbiAgICAgIGlzSW5jb21wbGV0ZTogIWlzQ29tcGxldGUsXG4gICAgICB0cmlnZ2VyQ2hhcixcbiAgICAgIHRyaWdnZXJQb2ludCxcbiAgICAgIG9yaWdpbmFsQnVmZmVyUG9pbnQ6IHJlcXVlc3QuYnVmZmVyUG9zaXRpb24sXG4gICAgICBzdWdnZXN0aW9uTWFwLFxuICAgIH0pXG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShzdWdnZXN0aW9uTWFwLmtleXMoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IE9idGFpbiBhIGNvbXBsZXRlIHZlcnNpb24gb2YgYSBzdWdnZXN0aW9uIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGNhbiBwcm92aWRlIGJ5XG4gICAqIHdheSBvZiB0aGUgYGNvbXBsZXRpb25JdGVtL3Jlc29sdmVgIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2ZXIgQW4ge0FjdGl2ZVNlcnZlcn0gcG9pbnRpbmcgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0byBxdWVyeS5cbiAgICogQHBhcmFtIHN1Z2dlc3Rpb24gQW4ge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gc3VnZ2VzdGlvbiB0aGF0IHNob3VsZCBiZSByZXNvbHZlZC5cbiAgICogQHBhcmFtIHJlcXVlc3QgQW4ge09iamVjdH0gd2l0aCB0aGUgQXV0b0NvbXBsZXRlKyByZXF1ZXN0IHRvIHNhdGlzZnkuXG4gICAqIEBwYXJhbSBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEge0NvbXBsZXRpb25JdGVtfSwgYW5cbiAgICogICB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBhbmQgYSB7YXRvbSRBdXRvY29tcGxldGVSZXF1ZXN0fSBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGNvbnZlcnRlZCBpdGVtcy5cbiAgICogQHJldHVybnMgQSB7UHJvbWlzZX0gb2YgYW4ge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gd2l0aCB0aGUgcmVzb2x2ZWQgQXV0b0NvbXBsZXRlKyBzdWdnZXN0aW9uLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNvbXBsZXRlU3VnZ2VzdGlvbihcbiAgICBzZXJ2ZXI6IEFjdGl2ZVNlcnZlcixcbiAgICBzdWdnZXN0aW9uOiBhYy5BbnlTdWdnZXN0aW9uLFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0/OiBDb21wbGV0aW9uSXRlbUFkanVzdGVyXG4gICk6IFByb21pc2U8YWMuQW55U3VnZ2VzdGlvbj4ge1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fc3VnZ2VzdGlvbkNhY2hlLmdldChzZXJ2ZXIpXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjb25zdCBwb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW0gPSBjYWNoZS5zdWdnZXN0aW9uTWFwLmdldChzdWdnZXN0aW9uKVxuICAgICAgaWYgKHBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbSAhPSBudWxsICYmIHBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbS5pc1Jlc29sdmVkID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlZENvbXBsZXRpb25JdGVtID0gYXdhaXQgc2VydmVyLmNvbm5lY3Rpb24uY29tcGxldGlvbkl0ZW1SZXNvbHZlKFxuICAgICAgICAgIHBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbS5jb21wbGV0aW9uSXRlbVxuICAgICAgICApXG4gICAgICAgIGlmIChyZXNvbHZlZENvbXBsZXRpb25JdGVtICE9IG51bGwpIHtcbiAgICAgICAgICBBdXRvY29tcGxldGVBZGFwdGVyLnJlc29sdmVTdWdnZXN0aW9uKHJlc29sdmVkQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb24sIHJlcXVlc3QsIG9uRGlkQ29udmVydENvbXBsZXRpb25JdGVtKVxuICAgICAgICAgIHBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbS5pc1Jlc29sdmVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWdnZXN0aW9uXG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHJlc29sdmVTdWdnZXN0aW9uKFxuICAgIHJlc29sdmVkQ29tcGxldGlvbkl0ZW06IENvbXBsZXRpb25JdGVtLFxuICAgIHN1Z2dlc3Rpb246IGFjLkFueVN1Z2dlc3Rpb24sXG4gICAgcmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXJcbiAgKTogdm9pZCB7XG4gICAgLy8gb25seSB0aGUgYGRvY3VtZW50YXRpb25gIGFuZCBgZGV0YWlsYCBwcm9wZXJ0aWVzIG1heSBjaGFuZ2Ugd2hlbiByZXNvbHZpbmdcbiAgICBBdXRvY29tcGxldGVBZGFwdGVyLmFwcGx5RGV0YWlsc1RvU3VnZ2VzdGlvbihyZXNvbHZlZENvbXBsZXRpb25JdGVtLCBzdWdnZXN0aW9uKVxuICAgIGlmIChvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSAhPSBudWxsKSB7XG4gICAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbShyZXNvbHZlZENvbXBsZXRpb25JdGVtLCBzdWdnZXN0aW9uIGFzIGFjLkFueVN1Z2dlc3Rpb24sIHJlcXVlc3QpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogR2V0IHRoZSB0cmlnZ2VyIGNoYXJhY3RlciB0aGF0IGNhdXNlZCB0aGUgYXV0b2NvbXBsZXRlIChpZiBhbnkpLiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgQXV0b0NvbXBsZXRlLXBsdXNcbiAgICogZG9lcyBub3QgaGF2ZSB0cmlnZ2VyIGNoYXJhY3RlcnMuIEFsdGhvdWdoIHRoZSB0ZXJtaW5vbG9neSBpcyAnY2hhcmFjdGVyJyB3ZSB0cmVhdCB0aGVtIGFzIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmdzXG4gICAqIGFzIHRoaXMgd2lsbCBhbG1vc3QgY2VydGFpbmx5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHRvIHN1cHBvcnQgJy0+JyBldGMuXG4gICAqXG4gICAqIEBwYXJhbSByZXF1ZXN0IEFuIHtBcnJheX0gb2Yge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn1zIHRvIGxvY2F0ZSB0aGUgcHJlZml4LCBlZGl0b3IsIGJ1ZmZlclBvc2l0aW9uIGV0Yy5cbiAgICogQHBhcmFtIHRyaWdnZXJDaGFycyBUaGUge0FycmF5fSBvZiB7c3RyaW5nfXMgdGhhdCBjYW4gYmUgdHJpZ2dlciBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBIFt7c3RyaW5nfSwgYm9vbGVhbl0gd2hlcmUgdGhlIHN0cmluZyBpcyB0aGUgbWF0Y2hpbmcgdHJpZ2dlciBjaGFyYWN0ZXIgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG9uZSB3YXMgbm90XG4gICAqICAgbWF0Y2hlZCwgYW5kIHRoZSBib29sZWFuIGlzIHRydWUgaWYgdGhlIHRyaWdnZXIgY2hhcmFjdGVyIGlzIGluIHJlcXVlc3QucHJlZml4LCBhbmQgZmFsc2UgaWYgaXQgaXMgaW4gdGhlIHdvcmRcbiAgICogICBiZWZvcmUgcmVxdWVzdC5wcmVmaXguIFRoZSBib29sZWFuIHJldHVybiB2YWx1ZSBoYXMgbm8gbWVhbmluZyBpZiB0aGUgc3RyaW5nIHJldHVybiB2YWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldFRyaWdnZXJDaGFyYWN0ZXIocmVxdWVzdDogYWMuU3VnZ2VzdGlvbnNSZXF1ZXN0ZWRFdmVudCwgdHJpZ2dlckNoYXJzOiBzdHJpbmdbXSk6IFtzdHJpbmcsIGJvb2xlYW5dIHtcbiAgICAvLyBBdXRvQ29tcGxldGUtUGx1cyBjb25zaWRlcnMgdGV4dCBhZnRlciBhIHN5bWJvbCB0byBiZSBhIG5ldyB0cmlnZ2VyLiBTbyB3ZSBzaG91bGQgbG9vayBiYWNrd2FyZFxuICAgIC8vIGZyb20gdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIHRvIHNlZSBpZiBvbmUgaXMgdGhlcmUgYW5kIHRodXMgc2ltdWxhdGUgaXQuXG4gICAgY29uc3QgYnVmZmVyID0gcmVxdWVzdC5lZGl0b3IuZ2V0QnVmZmVyKClcbiAgICBjb25zdCBjdXJzb3IgPSByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uXG4gICAgY29uc3QgcHJlZml4U3RhcnRDb2x1bW4gPSBjdXJzb3IuY29sdW1uIC0gcmVxdWVzdC5wcmVmaXgubGVuZ3RoXG4gICAgZm9yIChjb25zdCB0cmlnZ2VyQ2hhciBvZiB0cmlnZ2VyQ2hhcnMpIHtcbiAgICAgIGlmIChyZXF1ZXN0LnByZWZpeC5lbmRzV2l0aCh0cmlnZ2VyQ2hhcikpIHtcbiAgICAgICAgcmV0dXJuIFt0cmlnZ2VyQ2hhciwgdHJ1ZV1cbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhTdGFydENvbHVtbiA+PSB0cmlnZ2VyQ2hhci5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmFyIGVub3VnaCBhbG9uZyBhIGxpbmUgdG8gZml0IHRoZSB0cmlnZ2VyIGNoYXJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgUG9pbnQoY3Vyc29yLnJvdywgcHJlZml4U3RhcnRDb2x1bW4gLSB0cmlnZ2VyQ2hhci5sZW5ndGgpXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlVHJpZ2dlciA9IGJ1ZmZlci5nZXRUZXh0SW5SYW5nZShbc3RhcnQsIFtjdXJzb3Iucm93LCBwcmVmaXhTdGFydENvbHVtbl1dKVxuICAgICAgICBpZiAocG9zc2libGVUcmlnZ2VyID09PSB0cmlnZ2VyQ2hhcikge1xuICAgICAgICAgIC8vIFRoZSB0ZXh0IGJlZm9yZSBvdXIgdHJpZ2dlciBpcyBhIHRyaWdnZXIgY2hhciFcbiAgICAgICAgICByZXR1cm4gW3RyaWdnZXJDaGFyLCBmYWxzZV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXJlIHdhcyBubyBleHBsaWNpdCB0cmlnZ2VyIGNoYXJcbiAgICByZXR1cm4gW1wiXCIsIGZhbHNlXVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ3JlYXRlIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciBiYXNlZCBvbiB0aGUgZWRpdG9yIGFuZCBwb3NpdGlvbiBmcm9tXG4gICAqIHRoZSBBdXRvQ29tcGxldGVSZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gdG8gb2J0YWluIHRoZSBlZGl0b3IgZnJvbS5cbiAgICogQHBhcmFtIHRyaWdnZXJQb2ludCBUaGUge2F0b20kUG9pbnR9IHdoZXJlIHRoZSB0cmlnZ2VyIHN0YXJ0ZWQuXG4gICAqIEByZXR1cm5zIEEge3N0cmluZ30gY29udGFpbmluZyB0aGUgcHJlZml4IGluY2x1ZGluZyB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldFByZWZpeFdpdGhUcmlnZ2VyKHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsIHRyaWdnZXJQb2ludDogUG9pbnQpOiBzdHJpbmcge1xuICAgIHJldHVybiByZXF1ZXN0LmVkaXRvci5nZXRCdWZmZXIoKS5nZXRUZXh0SW5SYW5nZShbW3RyaWdnZXJQb2ludC5yb3csIHRyaWdnZXJQb2ludC5jb2x1bW5dLCByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENyZWF0ZSB7Q29tcGxldGlvblBhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGJhc2VkIG9uIHRoZSBlZGl0b3IgYW5kIHBvc2l0aW9uIGZyb20gdGhlXG4gICAqIEF1dG9jb21wbGV0ZSByZXF1ZXN0IGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3QgZGV0YWlscy5cbiAgICogQHBhcmFtIHRyaWdnZXJDaGFyYWN0ZXIgVGhlIHtzdHJpbmd9IGNvbnRhaW5pbmcgdGhlIHRyaWdnZXIgY2hhcmFjdGVyIChlbXB0eSBpZiBub25lKS5cbiAgICogQHBhcmFtIHRyaWdnZXJPbmx5IEEge2Jvb2xlYW59IHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgY29tcGxldGlvbiBpcyB0cmlnZ2VyZWQgcmlnaHQgYWZ0ZXIgYSB0cmlnZ2VyIGNoYXJhY3Rlci5cbiAgICogQHJldHVybnMgQSB7Q29tcGxldGlvblBhcmFtc30gd2l0aCB0aGUga2V5czpcbiAgICpcbiAgICogICAtIGB0ZXh0RG9jdW1lbnRgIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgdGV4dERvY3VtZW50IGlkZW50aWZpY2F0aW9uLlxuICAgKiAgIC0gYHBvc2l0aW9uYCB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSB0ZXh0IGRvY3VtZW50IHRvIGRpc3BsYXkgY29tcGxldGlvbiByZXF1ZXN0IGZvci5cbiAgICogICAtIGBjb250ZXh0YCBjb250YWluaW5nIHRoZSB0cmlnZ2VyIGNoYXJhY3RlciBhbmQga2luZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ29tcGxldGlvblBhcmFtcyhcbiAgICByZXF1ZXN0OiBhYy5TdWdnZXN0aW9uc1JlcXVlc3RlZEV2ZW50LFxuICAgIHRyaWdnZXJDaGFyYWN0ZXI6IHN0cmluZyxcbiAgICB0cmlnZ2VyT25seTogYm9vbGVhblxuICApOiBDb21wbGV0aW9uUGFyYW1zIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihyZXF1ZXN0LmVkaXRvciksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocmVxdWVzdC5idWZmZXJQb3NpdGlvbiksXG4gICAgICBjb250ZXh0OiBBdXRvY29tcGxldGVBZGFwdGVyLmNyZWF0ZUNvbXBsZXRpb25Db250ZXh0KHRyaWdnZXJDaGFyYWN0ZXIsIHRyaWdnZXJPbmx5KSxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDcmVhdGUge0NvbXBsZXRpb25Db250ZXh0fSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYmFzZWQgb24gdGhlIHRyaWdnZXIgY2hhcmFjdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHJpZ2dlckNoYXJhY3RlciBUaGUge3N0cmluZ30gY29udGFpbmluZyB0aGUgdHJpZ2dlciBjaGFyYWN0ZXIgb3IgJycgaWYgbm9uZS5cbiAgICogQHBhcmFtIHRyaWdnZXJPbmx5IEEge2Jvb2xlYW59IHJlcHJlc2VudGluZyB3aGV0aGVyIHRoaXMgY29tcGxldGlvbiBpcyB0cmlnZ2VyZWQgcmlnaHQgYWZ0ZXIgYSB0cmlnZ2VyIGNoYXJhY3Rlci5cbiAgICogQHJldHVybnMgQW4ge0NvbXBsZXRpb25Db250ZXh0fSB0aGF0IHNwZWNpZmllcyB0aGUgdHJpZ2dlcktpbmQgYW5kIHRoZSB0cmlnZ2VyQ2hhcmFjdGVyIGlmIHRoZXJlIGlzIG9uZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlQ29tcGxldGlvbkNvbnRleHQodHJpZ2dlckNoYXJhY3Rlcjogc3RyaW5nLCB0cmlnZ2VyT25seTogYm9vbGVhbik6IENvbXBsZXRpb25Db250ZXh0IHtcbiAgICBpZiAodHJpZ2dlckNoYXJhY3RlciA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIHsgdHJpZ2dlcktpbmQ6IENvbXBsZXRpb25UcmlnZ2VyS2luZC5JbnZva2VkIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyaWdnZXJPbmx5XG4gICAgICAgID8geyB0cmlnZ2VyS2luZDogQ29tcGxldGlvblRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIsIHRyaWdnZXJDaGFyYWN0ZXIgfVxuICAgICAgICA6IHsgdHJpZ2dlcktpbmQ6IENvbXBsZXRpb25UcmlnZ2VyS2luZC5UcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zLCB0cmlnZ2VyQ2hhcmFjdGVyIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDb252ZXJ0IGEgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIENvbXBsZXRpb25JdGVtIGFycmF5IG9yIENvbXBsZXRpb25MaXN0IHRvIGFuIGFycmF5IG9mIG9yZGVyZWRcbiAgICogQXV0b0NvbXBsZXRlKyBzdWdnZXN0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIGNvbXBsZXRpb25JdGVtcyBBbiB7QXJyYXl9IG9mIHtDb21wbGV0aW9uSXRlbX0gb2JqZWN0cyBvciBhIHtDb21wbGV0aW9uTGlzdH0gY29udGFpbmluZyBjb21wbGV0aW9uIGl0ZW1zIHRvXG4gICAqICAgYmUgY29udmVydGVkLlxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gdG8gc2F0aXNmeS5cbiAgICogQHBhcmFtIHNob3VsZFJlcGxhY2UgVGhlIGJlaGF2aW9yIG9mIHN1Z2dlc3Rpb24gYWNjZXB0YW5jZSAoc2VlIHtTaG91bGRSZXBsYWNlfSkuXG4gICAqIEBwYXJhbSBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBhbmQgYVxuICAgKiAgIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxuICAgKiBAcmV0dXJucyBBIHtNYXB9IG9mIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbnMgb3JkZXJlZCBieSB0aGUgQ29tcGxldGlvbkl0ZW1zIHNvcnRUZXh0LlxuICAgKi9cbiAgcHVibGljIGNvbXBsZXRpb25JdGVtc1RvU3VnZ2VzdGlvbnMoXG4gICAgY29tcGxldGlvbkl0ZW1zOiBDb21wbGV0aW9uSXRlbVtdIHwgQ29tcGxldGlvbkxpc3QgfCBudWxsLFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlckNvbHVtbnM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgc2hvdWxkUmVwbGFjZTogU2hvdWxkUmVwbGFjZSxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXJcbiAgKTogTWFwPFN1Z2dlc3Rpb24sIFBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbT4ge1xuICAgIGNvbnN0IGNvbXBsZXRpb25zQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvbXBsZXRpb25JdGVtcylcbiAgICAgID8gY29tcGxldGlvbkl0ZW1zXG4gICAgICA6IChjb21wbGV0aW9uSXRlbXMgJiYgY29tcGxldGlvbkl0ZW1zLml0ZW1zKSB8fCBbXVxuICAgIHJldHVybiBuZXcgTWFwKFxuICAgICAgY29tcGxldGlvbnNBcnJheVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gKGEuc29ydFRleHQgfHwgYS5sYWJlbCkubG9jYWxlQ29tcGFyZShiLnNvcnRUZXh0IHx8IGIubGFiZWwpKVxuICAgICAgICAubWFwPFtTdWdnZXN0aW9uLCBQb3NzaWJseVJlc29sdmVkQ29tcGxldGlvbkl0ZW1dPigocykgPT4gW1xuICAgICAgICAgIEF1dG9jb21wbGV0ZUFkYXB0ZXIuY29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAge30gYXMgU3VnZ2VzdGlvbixcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB0cmlnZ2VyQ29sdW1ucyxcbiAgICAgICAgICAgIHNob3VsZFJlcGxhY2UsXG4gICAgICAgICAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbVxuICAgICAgICAgICksXG4gICAgICAgICAgbmV3IFBvc3NpYmx5UmVzb2x2ZWRDb21wbGV0aW9uSXRlbShzLCBmYWxzZSksXG4gICAgICAgIF0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogQ29udmVydCBhIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBDb21wbGV0aW9uSXRlbSB0byBhbiBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtIEFuIHtDb21wbGV0aW9uSXRlbX0gY29udGFpbmluZyBhIGNvbXBsZXRpb24gaXRlbSB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSBzdWdnZXN0aW9uIEEge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gdG8gaGF2ZSB0aGUgY29udmVyc2lvbiBhcHBsaWVkIHRvLlxuICAgKiBAcGFyYW0gcmVxdWVzdCBUaGUge2F0b20kQXV0b2NvbXBsZXRlUmVxdWVzdH0gdG8gc2F0aXNmeS5cbiAgICogQHBhcmFtIHNob3VsZFJlcGxhY2UgVGhlIGJlaGF2aW9yIG9mIHN1Z2dlc3Rpb24gYWNjZXB0YW5jZSAoc2VlIHtTaG91bGRSZXBsYWNlfSkuXG4gICAqIEBwYXJhbSBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbSBBIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7Q29tcGxldGlvbkl0ZW19LCBhbiB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSBhbmQgYVxuICAgKiAgIHthdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3R9IGFsbG93aW5nIHlvdSB0byBhZGp1c3QgY29udmVydGVkIGl0ZW1zLlxuICAgKiBAcmV0dXJucyBUaGUge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gcGFzc2VkIGluIGFzIHN1Z2dlc3Rpb24gd2l0aCB0aGUgY29udmVyc2lvbiBhcHBsaWVkLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjb21wbGV0aW9uSXRlbVRvU3VnZ2VzdGlvbihcbiAgICBpdGVtOiBDb21wbGV0aW9uSXRlbSxcbiAgICBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uLFxuICAgIHJlcXVlc3Q6IGFjLlN1Z2dlc3Rpb25zUmVxdWVzdGVkRXZlbnQsXG4gICAgdHJpZ2dlckNvbHVtbnM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgc2hvdWxkUmVwbGFjZTogU2hvdWxkUmVwbGFjZSxcbiAgICBvbkRpZENvbnZlcnRDb21wbGV0aW9uSXRlbT86IENvbXBsZXRpb25JdGVtQWRqdXN0ZXJcbiAgKTogU3VnZ2VzdGlvbiB7XG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseUNvbXBsZXRpb25JdGVtVG9TdWdnZXN0aW9uKGl0ZW0sIHN1Z2dlc3Rpb24gYXMgVGV4dFN1Z2dlc3Rpb24pXG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseVRleHRFZGl0VG9TdWdnZXN0aW9uKFxuICAgICAgaXRlbS50ZXh0RWRpdCxcbiAgICAgIHJlcXVlc3QuZWRpdG9yLFxuICAgICAgdHJpZ2dlckNvbHVtbnMsXG4gICAgICByZXF1ZXN0LmJ1ZmZlclBvc2l0aW9uLFxuICAgICAgc3VnZ2VzdGlvbiBhcyBUZXh0U3VnZ2VzdGlvbixcbiAgICAgIHNob3VsZFJlcGxhY2VcbiAgICApXG4gICAgQXV0b2NvbXBsZXRlQWRhcHRlci5hcHBseVNuaXBwZXRUb1N1Z2dlc3Rpb24oaXRlbSwgc3VnZ2VzdGlvbiBhcyBTbmlwcGV0U3VnZ2VzdGlvbilcbiAgICBpZiAob25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0gIT0gbnVsbCkge1xuICAgICAgb25EaWRDb252ZXJ0Q29tcGxldGlvbkl0ZW0oaXRlbSwgc3VnZ2VzdGlvbiBhcyBhYy5BbnlTdWdnZXN0aW9uLCByZXF1ZXN0KVxuICAgIH1cblxuICAgIHJldHVybiBzdWdnZXN0aW9uXG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDb252ZXJ0IHRoZSBwcmltYXJ5IHBhcnRzIG9mIGEgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIENvbXBsZXRpb25JdGVtIHRvIGFuIEF1dG9Db21wbGV0ZSsgc3VnZ2VzdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGl0ZW0gQW4ge0NvbXBsZXRpb25JdGVtfSBjb250YWluaW5nIHRoZSBjb21wbGV0aW9uIGl0ZW1zIHRvIGJlIG1lcmdlZCBpbnRvLlxuICAgKiBAcGFyYW0gc3VnZ2VzdGlvbiBUaGUge1N1Z2dlc3Rpb259IHRvIG1lcmdlIHRoZSBjb252ZXJzaW9uIGludG8uXG4gICAqIEByZXR1cm5zIFRoZSB7U3VnZ2VzdGlvbn0gd2l0aCBkZXRhaWxzIGFkZGVkIGZyb20gdGhlIHtDb21wbGV0aW9uSXRlbX0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcGx5Q29tcGxldGlvbkl0ZW1Ub1N1Z2dlc3Rpb24oaXRlbTogQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb246IFRleHRTdWdnZXN0aW9uKTogdm9pZCB7XG4gICAgc3VnZ2VzdGlvbi50ZXh0ID0gaXRlbS5pbnNlcnRUZXh0IHx8IGl0ZW0ubGFiZWxcbiAgICBzdWdnZXN0aW9uLmZpbHRlclRleHQgPSBpdGVtLmZpbHRlclRleHQgfHwgaXRlbS5sYWJlbFxuICAgIHN1Z2dlc3Rpb24uZGlzcGxheVRleHQgPSBpdGVtLmxhYmVsXG4gICAgc3VnZ2VzdGlvbi50eXBlID0gQXV0b2NvbXBsZXRlQWRhcHRlci5jb21wbGV0aW9uS2luZFRvU3VnZ2VzdGlvblR5cGUoaXRlbS5raW5kKVxuICAgIEF1dG9jb21wbGV0ZUFkYXB0ZXIuYXBwbHlEZXRhaWxzVG9TdWdnZXN0aW9uKGl0ZW0sIHN1Z2dlc3Rpb24pXG4gICAgc3VnZ2VzdGlvbi5jb21wbGV0aW9uSXRlbSA9IGl0ZW1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgYXBwbHlEZXRhaWxzVG9TdWdnZXN0aW9uKGl0ZW06IENvbXBsZXRpb25JdGVtLCBzdWdnZXN0aW9uOiBTdWdnZXN0aW9uKTogdm9pZCB7XG4gICAgc3VnZ2VzdGlvbi5yaWdodExhYmVsID0gaXRlbS5kZXRhaWxcblxuICAgIC8vIE9sZGVyIGZvcm1hdCwgY2FuJ3Qga25vdyB3aGF0IGl0IGlzIHNvIGFzc2lnbiB0byBib3RoIGFuZCBob3BlIGZvciBiZXN0XG4gICAgaWYgKHR5cGVvZiBpdGVtLmRvY3VtZW50YXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN1Z2dlc3Rpb24uZGVzY3JpcHRpb25NYXJrZG93biA9IGl0ZW0uZG9jdW1lbnRhdGlvblxuICAgICAgc3VnZ2VzdGlvbi5kZXNjcmlwdGlvbiA9IGl0ZW0uZG9jdW1lbnRhdGlvblxuICAgIH1cblxuICAgIGlmIChpdGVtLmRvY3VtZW50YXRpb24gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS5kb2N1bWVudGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAvLyBOZXdlciBmb3JtYXQgc3BlY2lmaWVzIHRoZSBraW5kIG9mIGRvY3VtZW50YXRpb24sIGFzc2lnbiBhcHByb3ByaWF0ZWx5XG4gICAgICBpZiAoaXRlbS5kb2N1bWVudGF0aW9uLmtpbmQgPT09IFwibWFya2Rvd25cIikge1xuICAgICAgICBzdWdnZXN0aW9uLmRlc2NyaXB0aW9uTWFya2Rvd24gPSBpdGVtLmRvY3VtZW50YXRpb24udmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Z2dlc3Rpb24uZGVzY3JpcHRpb24gPSBpdGVtLmRvY3VtZW50YXRpb24udmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBBcHBsaWVzIHRoZSB0ZXh0RWRpdCBwYXJ0IG9mIGEgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIENvbXBsZXRpb25JdGVtIHRvIGFuIEF1dG9Db21wbGV0ZSsgU3VnZ2VzdGlvbiB2aWFcbiAgICogdGhlIHJlcGxhY2VtZW50UHJlZml4IGFuZCB0ZXh0IHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0RWRpdCBBIHtUZXh0RWRpdH0gZnJvbSBhIENvbXBsZXRpb25JdGVtIHRvIGFwcGx5LlxuICAgKiBAcGFyYW0gZWRpdG9yIEFuIEF0b20ge1RleHRFZGl0b3J9IHVzZWQgdG8gb2J0YWluIHRoZSBuZWNlc3NhcnkgdGV4dCByZXBsYWNlbWVudC5cbiAgICogQHBhcmFtIHN1Z2dlc3Rpb24gQW4ge2F0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbn0gdG8gc2V0IHRoZSByZXBsYWNlbWVudFByZWZpeCBhbmQgdGV4dCBwcm9wZXJ0aWVzIG9mLlxuICAgKiBAcGFyYW0gc2hvdWxkUmVwbGFjZSBUaGUgYmVoYXZpb3Igb2Ygc3VnZ2VzdGlvbiBhY2NlcHRhbmNlIChzZWUge1Nob3VsZFJlcGxhY2V9KS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXBwbHlUZXh0RWRpdFRvU3VnZ2VzdGlvbihcbiAgICB0ZXh0RWRpdDogVGV4dEVkaXQgfCBJbnNlcnRSZXBsYWNlRWRpdCB8IHVuZGVmaW5lZCxcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgdHJpZ2dlckNvbHVtbnM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgb3JpZ2luYWxCdWZmZXJQb3NpdGlvbjogUG9pbnQsXG4gICAgc3VnZ2VzdGlvbjogVGV4dFN1Z2dlc3Rpb24sXG4gICAgc2hvdWxkUmVwbGFjZTogU2hvdWxkUmVwbGFjZVxuICApOiB2b2lkIHtcbiAgICBpZiAoIXRleHRFZGl0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbGV0IHJhbmdlOiBSYW5nZVxuICAgIGlmIChcInJhbmdlXCIgaW4gdGV4dEVkaXQpIHtcbiAgICAgIHJhbmdlID0gdGV4dEVkaXQucmFuZ2VcbiAgICB9IGVsc2UgaWYgKHNob3VsZFJlcGxhY2UpIHtcbiAgICAgIHJhbmdlID0gdGV4dEVkaXQucmVwbGFjZVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IHRleHRFZGl0Lmluc2VydFxuICAgIH1cblxuICAgIGlmIChyYW5nZS5zdGFydC5jaGFyYWN0ZXIgIT09IHRyaWdnZXJDb2x1bW5zWzBdKSB7XG4gICAgICBjb25zdCBhdG9tUmFuZ2UgPSBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShyYW5nZSlcbiAgICAgIHN1Z2dlc3Rpb24uY3VzdG9tUmVwbGFjbWVudFByZWZpeCA9IGVkaXRvci5nZXRUZXh0SW5CdWZmZXJSYW5nZShbYXRvbVJhbmdlLnN0YXJ0LCBvcmlnaW5hbEJ1ZmZlclBvc2l0aW9uXSlcbiAgICB9XG4gICAgc3VnZ2VzdGlvbi50ZXh0ID0gdGV4dEVkaXQubmV3VGV4dFxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhZGRpdGlvbmFsIHRleHQgZWRpdHMgYWZ0ZXIgYSBzdWdnZXN0aW9uIGluc2VydCwgZS5nLiBgYWRkaXRpb25hbFRleHRFZGl0c2AuXG4gICAqXG4gICAqIGBhZGRpdGlvbmFsVGV4dEVkaXRzYCBhcmUgQW4gb3B0aW9uYWwgYXJyYXkgb2YgYWRkaXRpb25hbCB0ZXh0IGVkaXRzIHRoYXQgYXJlIGFwcGxpZWQgd2hlbiBzZWxlY3RpbmcgdGhpc1xuICAgKiBjb21wbGV0aW9uLiBFZGl0cyBtdXN0IG5vdCBvdmVybGFwIChpbmNsdWRpbmcgdGhlIHNhbWUgaW5zZXJ0IHBvc2l0aW9uKSB3aXRoIHRoZSBtYWluIGVkaXQgbm9yIHdpdGggdGhlbXNlbHZlcy5cbiAgICpcbiAgICogQWRkaXRpb25hbCB0ZXh0IGVkaXRzIHNob3VsZCBiZSB1c2VkIHRvIGNoYW5nZSB0ZXh0IHVucmVsYXRlZCB0byB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gKGZvciBleGFtcGxlIGFkZGluZyBhblxuICAgKiBpbXBvcnQgc3RhdGVtZW50IGF0IHRoZSB0b3Agb2YgdGhlIGZpbGUgaWYgdGhlIGNvbXBsZXRpb24gaXRlbSB3aWxsIGluc2VydCBhbiB1bnF1YWxpZmllZCB0eXBlKS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXBwbHlBZGRpdGlvbmFsVGV4dEVkaXRzKGV2ZW50OiBhYy5TdWdnZXN0aW9uSW5zZXJ0ZWRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBldmVudC5zdWdnZXN0aW9uIGFzIFN1Z2dlc3Rpb25CYXNlXG4gICAgY29uc3QgYWRkaXRpb25hbEVkaXRzID0gc3VnZ2VzdGlvbi5jb21wbGV0aW9uSXRlbT8uYWRkaXRpb25hbFRleHRFZGl0c1xuICAgIGNvbnN0IGJ1ZmZlciA9IGV2ZW50LmVkaXRvci5nZXRCdWZmZXIoKVxuXG4gICAgQXBwbHlFZGl0QWRhcHRlci5hcHBseUVkaXRzKGJ1ZmZlciwgQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoYWRkaXRpb25hbEVkaXRzKSlcbiAgICBidWZmZXIuZ3JvdXBMYXN0Q2hhbmdlcygpXG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBBZGRzIGEgc25pcHBldCB0byB0aGUgc3VnZ2VzdGlvbiBpZiB0aGUgQ29tcGxldGlvbkl0ZW0gY29udGFpbnMgc25pcHBldC1mb3JtYXR0ZWQgdGV4dFxuICAgKlxuICAgKiBAcGFyYW0gaXRlbSBBbiB7Q29tcGxldGlvbkl0ZW19IGNvbnRhaW5pbmcgdGhlIGNvbXBsZXRpb24gaXRlbXMgdG8gYmUgbWVyZ2VkIGludG8uXG4gICAqIEBwYXJhbSBzdWdnZXN0aW9uIFRoZSB7YXRvbSRBdXRvY29tcGxldGVTdWdnZXN0aW9ufSB0byBtZXJnZSB0aGUgY29udmVyc2lvbiBpbnRvLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhcHBseVNuaXBwZXRUb1N1Z2dlc3Rpb24oaXRlbTogQ29tcGxldGlvbkl0ZW0sIHN1Z2dlc3Rpb246IFNuaXBwZXRTdWdnZXN0aW9uKTogdm9pZCB7XG4gICAgaWYgKGl0ZW0uaW5zZXJ0VGV4dEZvcm1hdCA9PT0gSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0KSB7XG4gICAgICBzdWdnZXN0aW9uLnNuaXBwZXQgPSBpdGVtLnRleHRFZGl0ICE9IG51bGwgPyBpdGVtLnRleHRFZGl0Lm5ld1RleHQgOiBpdGVtLmluc2VydFRleHQgfHwgaXRlbS5sYWJlbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IE9idGFpbiB0aGUgdGV4dHVhbCBzdWdnZXN0aW9uIHR5cGUgcmVxdWlyZWQgYnkgQXV0b0NvbXBsZXRlKyB0aGF0IG1vc3QgY2xvc2VseSBtYXBzIHRvIHRoZSBudW1lcmljXG4gICAqIGNvbXBsZXRpb24ga2luZCBzdXBwbGllcyBieSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAgKlxuICAgKiBAcGFyYW0ga2luZCBBIHtOdW1iZXJ9IHRoYXQgcmVwcmVzZW50cyB0aGUgc3VnZ2VzdGlvbiBraW5kIHRvIGJlIGNvbnZlcnRlZC5cbiAgICogQHJldHVybnMgQSB7U3RyaW5nfSBjb250YWluaW5nIHRoZSBBdXRvQ29tcGxldGUrIHN1Z2dlc3Rpb24gdHlwZSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiBjb21wbGV0aW9uIGtpbmQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbXBsZXRpb25LaW5kVG9TdWdnZXN0aW9uVHlwZShraW5kOiBudW1iZXIgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQ6XG4gICAgICAgIHJldHVybiBcImNvbnN0YW50XCJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZDpcbiAgICAgICAgcmV0dXJuIFwibWV0aG9kXCJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uOlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkOlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk6XG4gICAgICAgIHJldHVybiBcInByb3BlcnR5XCJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlOlxuICAgICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5DbGFzczpcbiAgICAgICAgcmV0dXJuIFwiY2xhc3NcIlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0OlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlcjpcbiAgICAgICAgcmV0dXJuIFwidHlwZVwiXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvcjpcbiAgICAgICAgcmV0dXJuIFwic2VsZWN0b3JcIlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlOlxuICAgICAgICByZXR1cm4gXCJtaXhpblwiXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU6XG4gICAgICAgIHJldHVybiBcIm1vZHVsZVwiXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5Vbml0OlxuICAgICAgICByZXR1cm4gXCJidWlsdGluXCJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW06XG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyOlxuICAgICAgICByZXR1cm4gXCJlbnVtXCJcbiAgICAgIGNhc2UgQ29tcGxldGlvbkl0ZW1LaW5kLktleXdvcmQ6XG4gICAgICAgIHJldHVybiBcImtleXdvcmRcIlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuU25pcHBldDpcbiAgICAgICAgcmV0dXJuIFwic25pcHBldFwiXG4gICAgICBjYXNlIENvbXBsZXRpb25JdGVtS2luZC5GaWxlOlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyOlxuICAgICAgICByZXR1cm4gXCJpbXBvcnRcIlxuICAgICAgY2FzZSBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlOlxuICAgICAgICByZXR1cm4gXCJyZXF1aXJlXCJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcInZhbHVlXCJcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBncmFtbWFyIHNjb3BlIGZvciBhdXRvQ29tcGxldGUgcGFja2FnZSBzbyBpdCBhbHdheXMgc3RhcnRzIHdpdGggYC5gIEJhc2VkIG9uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9hdXRvY29tcGxldGUtcGx1cy93aWtpL0F1dG9jb21wbGV0ZS1Qcm92aWRlcnNcbiAqXG4gKiBAcGFyYW0gZ3JhbW1hclNjb3BlIFN1Y2ggYXMgJ3NvdXJjZS5weXRob24nIG9yICcuc291cmNlLnB5dGhvbidcbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIGdyYW1tYXJTY29wZSBzdWNoIGFzIGAuc291cmNlLnB5dGhvbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyYW1tYXJTY29wZVRvQXV0b0NvbXBsZXRlU2VsZWN0b3IoZ3JhbW1hclNjb3BlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZ3JhbW1hclNjb3BlLmluY2x1ZGVzKFwiLlwiKSAmJiBncmFtbWFyU2NvcGVbMF0gIT09IFwiLlwiID8gYC4ke2dyYW1tYXJTY29wZX1gIDogZ3JhbW1hclNjb3BlXG59XG4iXX0=