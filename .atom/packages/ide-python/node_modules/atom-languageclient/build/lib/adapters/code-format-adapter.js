"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server protocol "textDocument/completion" to the
// Atom IDE UI Code-format package.
class CodeFormatAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing either a documentFormattingProvider
    // or a documentRangeFormattingProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating this adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return (serverCapabilities.documentRangeFormattingProvider === true ||
            serverCapabilities.documentFormattingProvider === true);
    }
    // Public: Format text in the editor using the given language server connection and an optional range.
    // If the server does not support range formatting then range will be ignored and the entire document formatted.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `editor` The Atom {TextEditor} containing the text that will be formatted.
    // * `range` The optional Atom {Range} containing the subset of the text to be formatted.
    //
    // Returns a {Promise} of an {Array} of {Object}s containing the AutoComplete+
    // suggestions to display.
    static format(connection, serverCapabilities, editor, range) {
        if (serverCapabilities.documentRangeFormattingProvider) {
            return CodeFormatAdapter.formatRange(connection, editor, range);
        }
        if (serverCapabilities.documentFormattingProvider) {
            return CodeFormatAdapter.formatDocument(connection, editor);
        }
        throw new Error('Can not format document, language server does not support it');
    }
    // Public: Format the entire document of an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatDocument(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentFormatting(CodeFormatAdapter.createDocumentFormattingParams(editor));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns {DocumentFormattingParams} containing the identity of the text document as well as
    // options to be used in formatting the document such as tab size and tabs vs spaces.
    static createDocumentFormattingParams(editor) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Format a range within an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `range` The Atom {Range} containing the range of text that should be formatted.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatRange(connection, editor, range) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentRangeFormatting(CodeFormatAdapter.createDocumentRangeFormattingParams(editor, range));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `range` The Atom {Range} containing the range of text that should be formatted.
    //
    // Returns {DocumentRangeFormattingParams} containing the identity of the text document, the
    // range of the text to be formatted as well as the options to be used in formatting the
    // document such as tab size and tabs vs spaces.
    static createDocumentRangeFormattingParams(editor, range) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            range: convert_1.default.atomRangeToLSRange(range),
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Format on type within an Atom {TextEditor} by using a given language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will format the text.
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `point` The {Point} at which the document to be formatted.
    // * `character` A character that triggered formatting request.
    //
    // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
    // to format the document.
    static formatOnType(connection, editor, point, character) {
        return __awaiter(this, void 0, void 0, function* () {
            const edits = yield connection.documentOnTypeFormatting(CodeFormatAdapter.createDocumentOnTypeFormattingParams(editor, point, character));
            return convert_1.default.convertLsTextEdits(edits);
        });
    }
    // Public: Create {DocumentOnTypeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `point` The {Point} at which the document to be formatted.
    // * `character` A character that triggered formatting request.
    //
    // Returns {DocumentOnTypeFormattingParams} containing the identity of the text document, the
    // position of the text to be formatted, the character that triggered formatting request
    // as well as the options to be used in formatting the document such as tab size and tabs vs spaces.
    static createDocumentOnTypeFormattingParams(editor, point, character) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            ch: character,
            options: CodeFormatAdapter.getFormatOptions(editor),
        };
    }
    // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
    // entire document is formatted.
    //
    // * `editor` The Atom {TextEditor} containing the document to be formatted.
    // * `range` The Atom {Range} containing the range of document that should be formatted.
    //
    // Returns the {FormattingOptions} to be used containing the keys:
    //  * `tabSize` The number of spaces a tab represents.
    //  * `insertSpaces` {True} if spaces should be used, {False} for tab characters.
    static getFormatOptions(editor) {
        return {
            tabSize: editor.getTabLength(),
            insertSpaces: editor.getSoftTabs(),
        };
    }
}
exports.default = CodeFormatAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1mb3JtYXQtYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDQSx3Q0FBaUM7QUFlakMsK0VBQStFO0FBQy9FLG1DQUFtQztBQUNuQyxNQUFxQixpQkFBaUI7SUFDcEMsZ0ZBQWdGO0lBQ2hGLHdGQUF3RjtJQUN4Rix3Q0FBd0M7SUFDeEMsRUFBRTtJQUNGLHNGQUFzRjtJQUN0RixFQUFFO0lBQ0YsZ0ZBQWdGO0lBQ2hGLDRCQUE0QjtJQUNyQixNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxPQUFPLENBQ0wsa0JBQWtCLENBQUMsK0JBQStCLEtBQUssSUFBSTtZQUMzRCxrQkFBa0IsQ0FBQywwQkFBMEIsS0FBSyxJQUFJLENBQ3ZELENBQUM7SUFDSixDQUFDO0lBRUQsc0dBQXNHO0lBQ3RHLGdIQUFnSDtJQUNoSCxFQUFFO0lBQ0YsZ0dBQWdHO0lBQ2hHLDRGQUE0RjtJQUM1RiwrRUFBK0U7SUFDL0UseUZBQXlGO0lBQ3pGLEVBQUU7SUFDRiw4RUFBOEU7SUFDOUUsMEJBQTBCO0lBQ25CLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLFVBQW9DLEVBQ3BDLGtCQUFzQyxFQUN0QyxNQUFrQixFQUNsQixLQUFZO1FBRVosSUFBSSxrQkFBa0IsQ0FBQywrQkFBK0IsRUFBRTtZQUN0RCxPQUFPLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2pFO1FBRUQsSUFBSSxrQkFBa0IsQ0FBQywwQkFBMEIsRUFBRTtZQUNqRCxPQUFPLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDN0Q7UUFFRCxNQUFNLElBQUksS0FBSyxDQUFDLDhEQUE4RCxDQUFDLENBQUM7SUFDbEYsQ0FBQztJQUVELCtG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Q0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDO1lBQ3hDLEVBQUUsRUFBRSxTQUFTO1lBQ2IsT0FBTyxFQUFFLGlCQUFpQixDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQztTQUNwRCxDQUFDO0lBQ0osQ0FBQztJQUVELHNHQUFzRztJQUN0RyxnQ0FBZ0M7SUFDaEMsRUFBRTtJQUNGLDRFQUE0RTtJQUM1RSx3RkFBd0Y7SUFDeEYsRUFBRTtJQUNGLGtFQUFrRTtJQUNsRSxzREFBc0Q7SUFDdEQsaUZBQWlGO0lBQzFFLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFrQjtRQUMvQyxPQUFPO1lBQ0wsT0FBTyxFQUFFLE1BQU0sQ0FBQyxZQUFZLEVBQUU7WUFDOUIsWUFBWSxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUU7U0FDbkMsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQTFLRCxvQ0EwS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcbmltcG9ydCB7XHJcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyxcclxuICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtcyxcclxuICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdQYXJhbXMsXHJcbiAgRm9ybWF0dGluZ09wdGlvbnMsXHJcbiAgU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IHtcclxuICBUZXh0RWRpdG9yLFxyXG4gIFJhbmdlLFxyXG4gIFBvaW50LFxyXG59IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBwcm90b2NvbCBcInRleHREb2N1bWVudC9jb21wbGV0aW9uXCIgdG8gdGhlXHJcbi8vIEF0b20gSURFIFVJIENvZGUtZm9ybWF0IHBhY2thZ2UuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvZGVGb3JtYXRBZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgZWl0aGVyIGEgZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXJcclxuICAvLyBvciBhIGRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIHRoaXMgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIgPT09IHRydWUgfHxcclxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyID09PSB0cnVlXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBGb3JtYXQgdGV4dCBpbiB0aGUgZWRpdG9yIHVzaW5nIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIgY29ubmVjdGlvbiBhbmQgYW4gb3B0aW9uYWwgcmFuZ2UuXHJcbiAgLy8gSWYgdGhlIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHJhbmdlIGZvcm1hdHRpbmcgdGhlbiByYW5nZSB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBlbnRpcmUgZG9jdW1lbnQgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBmb3JtYXQgdGhlIHRleHQuXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBmb3JtYXR0ZWQuXHJcbiAgLy8gKiBgcmFuZ2VgIFRoZSBvcHRpb25hbCBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgc3Vic2V0IG9mIHRoZSB0ZXh0IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7T2JqZWN0fXMgY29udGFpbmluZyB0aGUgQXV0b0NvbXBsZXRlK1xyXG4gIC8vIHN1Z2dlc3Rpb25zIHRvIGRpc3BsYXkuXHJcbiAgcHVibGljIHN0YXRpYyBmb3JtYXQoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHJhbmdlOiBSYW5nZSxcclxuICApOiBQcm9taXNlPGF0b21JZGUuVGV4dEVkaXRbXT4ge1xyXG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyKSB7XHJcbiAgICAgIHJldHVybiBDb2RlRm9ybWF0QWRhcHRlci5mb3JtYXRSYW5nZShjb25uZWN0aW9uLCBlZGl0b3IsIHJhbmdlKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyKSB7XHJcbiAgICAgIHJldHVybiBDb2RlRm9ybWF0QWRhcHRlci5mb3JtYXREb2N1bWVudChjb25uZWN0aW9uLCBlZGl0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBmb3JtYXQgZG9jdW1lbnQsIGxhbmd1YWdlIHNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IGl0Jyk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEZvcm1hdCB0aGUgZW50aXJlIGRvY3VtZW50IG9mIGFuIEF0b20ge1RleHRFZGl0b3J9IGJ5IHVzaW5nIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBmb3JtYXQgdGhlIHRleHQuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHtUZXh0RWRpdH0gb2JqZWN0cyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBBdG9tIFRleHRFZGl0b3JcclxuICAvLyB0byBmb3JtYXQgdGhlIGRvY3VtZW50LlxyXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZm9ybWF0RG9jdW1lbnQoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgKTogUHJvbWlzZTxhdG9tSWRlLlRleHRFZGl0W10+IHtcclxuICAgIGNvbnN0IGVkaXRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudEZvcm1hdHRpbmcoQ29kZUZvcm1hdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zKGVkaXRvcikpO1xyXG4gICAgcmV0dXJuIENvbnZlcnQuY29udmVydExzVGV4dEVkaXRzKGVkaXRzKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXN9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB3aGVuIHJlcXVlc3RpbmcgYW5cclxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB7RG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zfSBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGUgdGV4dCBkb2N1bWVudCBhcyB3ZWxsIGFzXHJcbiAgLy8gb3B0aW9ucyB0byBiZSB1c2VkIGluIGZvcm1hdHRpbmcgdGhlIGRvY3VtZW50IHN1Y2ggYXMgdGFiIHNpemUgYW5kIHRhYnMgdnMgc3BhY2VzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zKGVkaXRvcjogVGV4dEVkaXRvcik6IERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEZvcm1hdCBhIHJhbmdlIHdpdGhpbiBhbiBBdG9tIHtUZXh0RWRpdG9yfSBieSB1c2luZyBhIGdpdmVuIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxyXG4gIC8vICogYHJhbmdlYCBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIHRleHQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXHJcbiAgLy8gdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGZvcm1hdFJhbmdlKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgcmFuZ2U6IFJhbmdlLFxyXG4gICk6IFByb21pc2U8YXRvbUlkZS5UZXh0RWRpdFtdPiB7XHJcbiAgICBjb25zdCBlZGl0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmcoXHJcbiAgICAgIENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zKGVkaXRvciwgcmFuZ2UpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhlZGl0cyk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSB7RG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXN9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB3aGVuIHJlcXVlc3RpbmcgYW5cclxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxyXG4gIC8vICogYHJhbmdlYCBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIHRleHQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB7RG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXN9IGNvbnRhaW5pbmcgdGhlIGlkZW50aXR5IG9mIHRoZSB0ZXh0IGRvY3VtZW50LCB0aGVcclxuICAvLyByYW5nZSBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQgYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyB0byBiZSB1c2VkIGluIGZvcm1hdHRpbmcgdGhlXHJcbiAgLy8gZG9jdW1lbnQgc3VjaCBhcyB0YWIgc2l6ZSBhbmQgdGFicyB2cyBzcGFjZXMuXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtcyhcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHJhbmdlOiBSYW5nZSxcclxuICApOiBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtcyB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICAgIHJhbmdlOiBDb252ZXJ0LmF0b21SYW5nZVRvTFNSYW5nZShyYW5nZSksXHJcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEZvcm1hdCBvbiB0eXBlIHdpdGhpbiBhbiBBdG9tIHtUZXh0RWRpdG9yfSBieSB1c2luZyBhIGdpdmVuIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvLyAqIGBwb2ludGAgVGhlIHtQb2ludH0gYXQgd2hpY2ggdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cclxuICAvLyAqIGBjaGFyYWN0ZXJgIEEgY2hhcmFjdGVyIHRoYXQgdHJpZ2dlcmVkIGZvcm1hdHRpbmcgcmVxdWVzdC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXHJcbiAgLy8gdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGZvcm1hdE9uVHlwZShcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHBvaW50OiBQb2ludCxcclxuICAgIGNoYXJhY3Rlcjogc3RyaW5nLFxyXG4gICk6IFByb21pc2U8YXRvbUlkZS5UZXh0RWRpdFtdPiB7XHJcbiAgICBjb25zdCBlZGl0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nKFxyXG4gICAgICBDb2RlRm9ybWF0QWRhcHRlci5jcmVhdGVEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdQYXJhbXMoZWRpdG9yLCBwb2ludCwgY2hhcmFjdGVyKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4gQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoZWRpdHMpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUge0RvY3VtZW50T25UeXBlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxyXG4gIC8vIGVudGlyZSBkb2N1bWVudCBpcyBmb3JtYXR0ZWQuXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy8gKiBgcG9pbnRgIFRoZSB7UG9pbnR9IGF0IHdoaWNoIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy8gKiBgY2hhcmFjdGVyYCBBIGNoYXJhY3RlciB0aGF0IHRyaWdnZXJlZCBmb3JtYXR0aW5nIHJlcXVlc3QuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHtEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdQYXJhbXN9IGNvbnRhaW5pbmcgdGhlIGlkZW50aXR5IG9mIHRoZSB0ZXh0IGRvY3VtZW50LCB0aGVcclxuICAvLyBwb3NpdGlvbiBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQsIHRoZSBjaGFyYWN0ZXIgdGhhdCB0cmlnZ2VyZWQgZm9ybWF0dGluZyByZXF1ZXN0XHJcbiAgLy8gYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyB0byBiZSB1c2VkIGluIGZvcm1hdHRpbmcgdGhlIGRvY3VtZW50IHN1Y2ggYXMgdGFiIHNpemUgYW5kIHRhYnMgdnMgc3BhY2VzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zKFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IFBvaW50LFxyXG4gICAgY2hhcmFjdGVyOiBzdHJpbmcsXHJcbiAgKTogRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUGFyYW1zIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcclxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHBvaW50KSxcclxuICAgICAgY2g6IGNoYXJhY3RlcixcclxuICAgICAgb3B0aW9uczogQ29kZUZvcm1hdEFkYXB0ZXIuZ2V0Rm9ybWF0T3B0aW9ucyhlZGl0b3IpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxyXG4gIC8vIGVudGlyZSBkb2N1bWVudCBpcyBmb3JtYXR0ZWQuXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXHJcbiAgLy8gKiBgcmFuZ2VgIFRoZSBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgcmFuZ2Ugb2YgZG9jdW1lbnQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUge0Zvcm1hdHRpbmdPcHRpb25zfSB0byBiZSB1c2VkIGNvbnRhaW5pbmcgdGhlIGtleXM6XHJcbiAgLy8gICogYHRhYlNpemVgIFRoZSBudW1iZXIgb2Ygc3BhY2VzIGEgdGFiIHJlcHJlc2VudHMuXHJcbiAgLy8gICogYGluc2VydFNwYWNlc2Age1RydWV9IGlmIHNwYWNlcyBzaG91bGQgYmUgdXNlZCwge0ZhbHNlfSBmb3IgdGFiIGNoYXJhY3RlcnMuXHJcbiAgcHVibGljIHN0YXRpYyBnZXRGb3JtYXRPcHRpb25zKGVkaXRvcjogVGV4dEVkaXRvcik6IEZvcm1hdHRpbmdPcHRpb25zIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRhYlNpemU6IGVkaXRvci5nZXRUYWJMZW5ndGgoKSxcclxuICAgICAgaW5zZXJ0U3BhY2VzOiBlZGl0b3IuZ2V0U29mdFRhYnMoKSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdfQ==