"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const utils_1 = require("../utils");
// Public: Adapts the language server protocol "textDocument/hover" to the
// Atom IDE UI Datatip package.
class DatatipAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a hoverProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.hoverProvider === true;
    }
    // Public: Get the Datatip for this {Point} in a {TextEditor} by querying
    // the language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the hover text/datatip.
    // * `editor` The Atom {TextEditor} containing the text the Datatip should relate to.
    // * `point` The Atom {Point} containing the point within the text the Datatip should relate to.
    //
    // Returns a {Promise} containing the {Datatip} to display or {null} if no Datatip is available.
    getDatatip(connection, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const hover = yield connection.hover(documentPositionParams);
            if (hover == null ||
                hover.contents == null ||
                (typeof hover.contents === 'string' && hover.contents.length === 0) ||
                (Array.isArray(hover.contents) && hover.contents.length === 0)) {
                return null;
            }
            const range = hover.range == null ? utils_1.default.getWordAtPosition(editor, point) : convert_1.default.lsRangeToAtomRange(hover.range);
            const markedStrings = (Array.isArray(hover.contents) ? hover.contents : [hover.contents]).map((str) => DatatipAdapter.convertMarkedString(editor, str));
            return { range, markedStrings };
        });
    }
    static convertMarkedString(editor, markedString) {
        if (typeof markedString === 'string') {
            return { type: 'markdown', value: markedString };
        }
        if (markedString.kind) {
            return {
                type: 'markdown',
                value: markedString.value,
            };
        }
        // Must check as <{language: string}> to disambiguate between
        // string and the more explicit object type because MarkedString
        // is a union of the two types
        if (markedString.language) {
            return {
                type: 'snippet',
                // TODO: find a better mapping from language -> grammar
                grammar: atom.grammars.grammarForScopeName(`source.${markedString.language}`) || editor.getGrammar(),
                value: markedString.value,
            };
        }
        // Catch-all case
        return { type: 'markdown', value: markedString.toString() };
    }
}
exports.default = DatatipAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRpcC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RhdGF0aXAtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0Esd0NBQWlDO0FBQ2pDLG9DQUE2QjtBQVk3QiwwRUFBMEU7QUFDMUUsK0JBQStCO0FBQy9CO0lBQ0UsZ0ZBQWdGO0lBQ2hGLHFFQUFxRTtJQUNyRSxFQUFFO0lBQ0Ysc0ZBQXNGO0lBQ3RGLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsNEJBQTRCO0lBQ3JCLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDO0lBQ25ELENBQUM7SUFFRCx5RUFBeUU7SUFDekUsdUJBQXVCO0lBQ3ZCLEVBQUU7SUFDRiwwRkFBMEY7SUFDMUYsNkNBQTZDO0lBQzdDLHFGQUFxRjtJQUNyRixnR0FBZ0c7SUFDaEcsRUFBRTtJQUNGLGdHQUFnRztJQUNuRixVQUFVLENBQ3JCLFVBQW9DLEVBQ3BDLE1BQWtCLEVBQ2xCLEtBQVk7O1lBRVosTUFBTSxzQkFBc0IsR0FBRyxpQkFBTyxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztZQUV6RixNQUFNLEtBQUssR0FBRyxNQUFNLFVBQVUsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUM3RCxFQUFFLENBQUMsQ0FDRCxLQUFLLElBQUksSUFBSTtnQkFDYixLQUFLLENBQUMsUUFBUSxJQUFJLElBQUk7Z0JBQ3RCLENBQUMsT0FBTyxLQUFLLENBQUMsUUFBUSxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7Z0JBQ25FLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUMvRCxDQUFDLENBQUMsQ0FBQztnQkFDRCxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2QsQ0FBQztZQUVELE1BQU0sS0FBSyxHQUNULEtBQUssQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxlQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV6RyxNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQ3BHLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQ2hELENBQUM7WUFFRixNQUFNLENBQUMsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLENBQUM7UUFDbEMsQ0FBQztLQUFBO0lBRU8sTUFBTSxDQUFDLG1CQUFtQixDQUNoQyxNQUFrQixFQUNsQixZQUEwQztRQUUxQyxFQUFFLENBQUMsQ0FBQyxPQUFPLFlBQVksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3JDLE1BQU0sQ0FBQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxDQUFDO1FBQ25ELENBQUM7UUFFRCxFQUFFLENBQUMsQ0FBRSxZQUE4QixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDekMsTUFBTSxDQUFDO2dCQUNMLElBQUksRUFBRSxVQUFVO2dCQUNoQixLQUFLLEVBQUUsWUFBWSxDQUFDLEtBQUs7YUFDMUIsQ0FBQztRQUNKLENBQUM7UUFFRCw2REFBNkQ7UUFDN0QsZ0VBQWdFO1FBQ2hFLDhCQUE4QjtRQUM5QixFQUFFLENBQUMsQ0FBRSxZQUFtQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7WUFDbEQsTUFBTSxDQUFDO2dCQUNMLElBQUksRUFBRSxTQUFTO2dCQUNmLHVEQUF1RDtnQkFDdkQsT0FBTyxFQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQy9CLFVBQVcsWUFBbUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxVQUFVLEVBQUU7Z0JBQ3JGLEtBQUssRUFBRSxZQUFZLENBQUMsS0FBSzthQUMxQixDQUFDO1FBQ0osQ0FBQztRQUVELGlCQUFpQjtRQUNqQixNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQztJQUM5RCxDQUFDO0NBQ0Y7QUFoRkQsaUNBZ0ZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXRvbUlkZSBmcm9tICdhdG9tLWlkZSc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBNYXJrdXBDb250ZW50LFxyXG4gIE1hcmtlZFN0cmluZyxcclxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQge1xyXG4gIFBvaW50LFxyXG4gIFRleHRFZGl0b3IsXHJcbn0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIFwidGV4dERvY3VtZW50L2hvdmVyXCIgdG8gdGhlXHJcbi8vIEF0b20gSURFIFVJIERhdGF0aXAgcGFja2FnZS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXRpcEFkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGhvdmVyUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlciA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogR2V0IHRoZSBEYXRhdGlwIGZvciB0aGlzIHtQb2ludH0gaW4gYSB7VGV4dEVkaXRvcn0gYnkgcXVlcnlpbmdcclxuICAvLyB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXHJcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBob3ZlciB0ZXh0L2RhdGF0aXAuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgRGF0YXRpcCBzaG91bGQgcmVsYXRlIHRvLlxyXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgRGF0YXRpcCBzaG91bGQgcmVsYXRlIHRvLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIHRoZSB7RGF0YXRpcH0gdG8gZGlzcGxheSBvciB7bnVsbH0gaWYgbm8gRGF0YXRpcCBpcyBhdmFpbGFibGUuXHJcbiAgcHVibGljIGFzeW5jIGdldERhdGF0aXAoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogUG9pbnQsXHJcbiAgKTogUHJvbWlzZTxhdG9tSWRlLkRhdGF0aXAgfCBudWxsPiB7XHJcbiAgICBjb25zdCBkb2N1bWVudFBvc2l0aW9uUGFyYW1zID0gQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvciwgcG9pbnQpO1xyXG5cclxuICAgIGNvbnN0IGhvdmVyID0gYXdhaXQgY29ubmVjdGlvbi5ob3Zlcihkb2N1bWVudFBvc2l0aW9uUGFyYW1zKTtcclxuICAgIGlmIChcclxuICAgICAgaG92ZXIgPT0gbnVsbCB8fFxyXG4gICAgICBob3Zlci5jb250ZW50cyA9PSBudWxsIHx8XHJcbiAgICAgICh0eXBlb2YgaG92ZXIuY29udGVudHMgPT09ICdzdHJpbmcnICYmIGhvdmVyLmNvbnRlbnRzLmxlbmd0aCA9PT0gMCkgfHxcclxuICAgICAgKEFycmF5LmlzQXJyYXkoaG92ZXIuY29udGVudHMpICYmIGhvdmVyLmNvbnRlbnRzLmxlbmd0aCA9PT0gMClcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByYW5nZSA9XHJcbiAgICAgIGhvdmVyLnJhbmdlID09IG51bGwgPyBVdGlscy5nZXRXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KSA6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGhvdmVyLnJhbmdlKTtcclxuXHJcbiAgICBjb25zdCBtYXJrZWRTdHJpbmdzID0gKEFycmF5LmlzQXJyYXkoaG92ZXIuY29udGVudHMpID8gaG92ZXIuY29udGVudHMgOiBbaG92ZXIuY29udGVudHNdKS5tYXAoKHN0cikgPT5cclxuICAgICAgRGF0YXRpcEFkYXB0ZXIuY29udmVydE1hcmtlZFN0cmluZyhlZGl0b3IsIHN0ciksXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7IHJhbmdlLCBtYXJrZWRTdHJpbmdzIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHN0YXRpYyBjb252ZXJ0TWFya2VkU3RyaW5nKFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgbWFya2VkU3RyaW5nOiBNYXJrZWRTdHJpbmcgfCBNYXJrdXBDb250ZW50LFxyXG4gICk6IGF0b21JZGUuTWFya2VkU3RyaW5nIHtcclxuICAgIGlmICh0eXBlb2YgbWFya2VkU3RyaW5nID09PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4geyB0eXBlOiAnbWFya2Rvd24nLCB2YWx1ZTogbWFya2VkU3RyaW5nIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKChtYXJrZWRTdHJpbmcgYXMgTWFya3VwQ29udGVudCkua2luZCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdtYXJrZG93bicsXHJcbiAgICAgICAgdmFsdWU6IG1hcmtlZFN0cmluZy52YWx1ZSxcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNdXN0IGNoZWNrIGFzIDx7bGFuZ3VhZ2U6IHN0cmluZ30+IHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuXHJcbiAgICAvLyBzdHJpbmcgYW5kIHRoZSBtb3JlIGV4cGxpY2l0IG9iamVjdCB0eXBlIGJlY2F1c2UgTWFya2VkU3RyaW5nXHJcbiAgICAvLyBpcyBhIHVuaW9uIG9mIHRoZSB0d28gdHlwZXNcclxuICAgIGlmICgobWFya2VkU3RyaW5nIGFzIHtsYW5ndWFnZTogc3RyaW5nfSkubGFuZ3VhZ2UpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAnc25pcHBldCcsXHJcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBtYXBwaW5nIGZyb20gbGFuZ3VhZ2UgLT4gZ3JhbW1hclxyXG4gICAgICAgIGdyYW1tYXI6XHJcbiAgICAgICAgICBhdG9tLmdyYW1tYXJzLmdyYW1tYXJGb3JTY29wZU5hbWUoXHJcbiAgICAgICAgICAgIGBzb3VyY2UuJHsobWFya2VkU3RyaW5nIGFzIHtsYW5ndWFnZTogc3RyaW5nfSkubGFuZ3VhZ2V9YCkgfHwgZWRpdG9yLmdldEdyYW1tYXIoKSxcclxuICAgICAgICB2YWx1ZTogbWFya2VkU3RyaW5nLnZhbHVlLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhdGNoLWFsbCBjYXNlXHJcbiAgICByZXR1cm4geyB0eXBlOiAnbWFya2Rvd24nLCB2YWx1ZTogbWFya2VkU3RyaW5nLnRvU3RyaW5nKCkgfTtcclxuICB9XHJcbn1cclxuIl19