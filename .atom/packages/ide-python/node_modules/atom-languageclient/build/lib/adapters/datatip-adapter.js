"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
/** Public: Adapts the language server protocol "textDocument/hover" to the Atom IDE UI Datatip package. */
class DatatipAdapter {
    /**
     * Public: Determine whether this adapter can be used to adapt a language server based on the serverCapabilities
     * matrix containing a hoverProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating adapter can adapt the server based on the given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return serverCapabilities.hoverProvider === true;
    }
    /**
     * Public: Get the Datatip for this {Point} in a {TextEditor} by querying the language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will be queried for the hover text/datatip.
     * @param editor The Atom {TextEditor} containing the text the Datatip should relate to.
     * @param point The Atom {Point} containing the point within the text the Datatip should relate to.
     * @returns A {Promise} containing the {Datatip} to display or {null} if no Datatip is available.
     */
    getDatatip(connection, editor, point) {
        return __awaiter(this, void 0, void 0, function* () {
            const documentPositionParams = convert_1.default.editorToTextDocumentPositionParams(editor, point);
            const hover = yield connection.hover(documentPositionParams);
            if (hover == null || DatatipAdapter.isEmptyHover(hover)) {
                return null;
            }
            const range = hover.range == null ? Utils.getWordAtPosition(editor, point) : convert_1.default.lsRangeToAtomRange(hover.range);
            const markedStrings = (Array.isArray(hover.contents) ? hover.contents : [hover.contents]).map((str) => DatatipAdapter.convertMarkedString(editor, str));
            return { range, markedStrings };
        });
    }
    static isEmptyHover(hover) {
        return (hover.contents == null ||
            (typeof hover.contents === "string" && hover.contents.length === 0) ||
            (Array.isArray(hover.contents) && (hover.contents.length === 0 || hover.contents[0] === "")));
    }
    static convertMarkedString(editor, markedString) {
        if (typeof markedString === "string") {
            return { type: "markdown", value: markedString };
        }
        if (markedString.kind) {
            return {
                type: "markdown",
                value: markedString.value,
            };
        }
        // Must check as <{language: string}> to disambiguate between
        // string and the more explicit object type because MarkedString
        // is a union of the two types
        if (markedString.language) {
            return {
                type: "snippet",
                // TODO: find a better mapping from language -> grammar
                grammar: atom.grammars.grammarForScopeName(`source.${markedString.language}`) ||
                    editor.getGrammar(),
                value: markedString.value,
            };
        }
        // Catch-all case
        return { type: "markdown", value: markedString.toString() };
    }
}
exports.default = DatatipAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRpcC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL2RhdGF0aXAtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUNBLHdDQUFnQztBQUNoQyxrQ0FBaUM7QUFJakMsMkdBQTJHO0FBQzNHLE1BQXFCLGNBQWM7SUFDakM7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsT0FBTyxrQkFBa0IsQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFBO0lBQ2xELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ1UsVUFBVSxDQUNyQixVQUFvQyxFQUNwQyxNQUFrQixFQUNsQixLQUFZOztZQUVaLE1BQU0sc0JBQXNCLEdBQUcsaUJBQU8sQ0FBQyxrQ0FBa0MsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUE7WUFFeEYsTUFBTSxLQUFLLEdBQUcsTUFBTSxVQUFVLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUE7WUFDNUQsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLGNBQWMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3ZELE9BQU8sSUFBSSxDQUFBO2FBQ1o7WUFFRCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUE7WUFFcEgsTUFBTSxhQUFhLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUNwRyxjQUFjLENBQUMsbUJBQW1CLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUNoRCxDQUFBO1lBRUQsT0FBTyxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsQ0FBQTtRQUNqQyxDQUFDO0tBQUE7SUFFTyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQVk7UUFDdEMsT0FBTyxDQUNMLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSTtZQUN0QixDQUFDLE9BQU8sS0FBSyxDQUFDLFFBQVEsS0FBSyxRQUFRLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO1lBQ25FLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUM3RixDQUFBO0lBQ0gsQ0FBQztJQUVPLE1BQU0sQ0FBQyxtQkFBbUIsQ0FDaEMsTUFBa0IsRUFDbEIsWUFBMEM7UUFFMUMsSUFBSSxPQUFPLFlBQVksS0FBSyxRQUFRLEVBQUU7WUFDcEMsT0FBTyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxDQUFBO1NBQ2pEO1FBRUQsSUFBSyxZQUE4QixDQUFDLElBQUksRUFBRTtZQUN4QyxPQUFPO2dCQUNMLElBQUksRUFBRSxVQUFVO2dCQUNoQixLQUFLLEVBQUUsWUFBWSxDQUFDLEtBQUs7YUFDMUIsQ0FBQTtTQUNGO1FBRUQsNkRBQTZEO1FBQzdELGdFQUFnRTtRQUNoRSw4QkFBOEI7UUFDOUIsSUFBSyxZQUFxQyxDQUFDLFFBQVEsRUFBRTtZQUNuRCxPQUFPO2dCQUNMLElBQUksRUFBRSxTQUFTO2dCQUNmLHVEQUF1RDtnQkFDdkQsT0FBTyxFQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsVUFBVyxZQUFxQyxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUM5RixNQUFNLENBQUMsVUFBVSxFQUFFO2dCQUNyQixLQUFLLEVBQUUsWUFBWSxDQUFDLEtBQUs7YUFDMUIsQ0FBQTtTQUNGO1FBRUQsaUJBQWlCO1FBQ2pCLE9BQU8sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQTtJQUM3RCxDQUFDO0NBQ0Y7QUFqRkQsaUNBaUZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgKiBhcyBhdG9tSWRlIGZyb20gXCJhdG9tLWlkZS1iYXNlXCJcbmltcG9ydCBDb252ZXJ0IGZyb20gXCIuLi9jb252ZXJ0XCJcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gXCIuLi91dGlsc1wiXG5pbXBvcnQgeyBIb3ZlciwgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBNYXJrdXBDb250ZW50LCBNYXJrZWRTdHJpbmcsIFNlcnZlckNhcGFiaWxpdGllcyB9IGZyb20gXCIuLi9sYW5ndWFnZWNsaWVudFwiXG5pbXBvcnQgeyBQb2ludCwgVGV4dEVkaXRvciB9IGZyb20gXCJhdG9tXCJcblxuLyoqIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvaG92ZXJcIiB0byB0aGUgQXRvbSBJREUgVUkgRGF0YXRpcCBwYWNrYWdlLiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXRpcEFkYXB0ZXIge1xuICAvKipcbiAgICogUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXIgYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllc1xuICAgKiBtYXRyaXggY29udGFpbmluZyBhIGhvdmVyUHJvdmlkZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2ZXJDYXBhYmlsaXRpZXMgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gICAqIEByZXR1cm5zIEEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGUgZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlciA9PT0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYzogR2V0IHRoZSBEYXRhdGlwIGZvciB0aGlzIHtQb2ludH0gaW4gYSB7VGV4dEVkaXRvcn0gYnkgcXVlcnlpbmcgdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkIGZvciB0aGUgaG92ZXIgdGV4dC9kYXRhdGlwLlxuICAgKiBAcGFyYW0gZWRpdG9yIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBEYXRhdGlwIHNob3VsZCByZWxhdGUgdG8uXG4gICAqIEBwYXJhbSBwb2ludCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgRGF0YXRpcCBzaG91bGQgcmVsYXRlIHRvLlxuICAgKiBAcmV0dXJucyBBIHtQcm9taXNlfSBjb250YWluaW5nIHRoZSB7RGF0YXRpcH0gdG8gZGlzcGxheSBvciB7bnVsbH0gaWYgbm8gRGF0YXRpcCBpcyBhdmFpbGFibGUuXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0RGF0YXRpcChcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxuICAgIHBvaW50OiBQb2ludFxuICApOiBQcm9taXNlPGF0b21JZGUuRGF0YXRpcCB8IG51bGw+IHtcbiAgICBjb25zdCBkb2N1bWVudFBvc2l0aW9uUGFyYW1zID0gQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvciwgcG9pbnQpXG5cbiAgICBjb25zdCBob3ZlciA9IGF3YWl0IGNvbm5lY3Rpb24uaG92ZXIoZG9jdW1lbnRQb3NpdGlvblBhcmFtcylcbiAgICBpZiAoaG92ZXIgPT0gbnVsbCB8fCBEYXRhdGlwQWRhcHRlci5pc0VtcHR5SG92ZXIoaG92ZXIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0gaG92ZXIucmFuZ2UgPT0gbnVsbCA/IFV0aWxzLmdldFdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpIDogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoaG92ZXIucmFuZ2UpXG5cbiAgICBjb25zdCBtYXJrZWRTdHJpbmdzID0gKEFycmF5LmlzQXJyYXkoaG92ZXIuY29udGVudHMpID8gaG92ZXIuY29udGVudHMgOiBbaG92ZXIuY29udGVudHNdKS5tYXAoKHN0cikgPT5cbiAgICAgIERhdGF0aXBBZGFwdGVyLmNvbnZlcnRNYXJrZWRTdHJpbmcoZWRpdG9yLCBzdHIpXG4gICAgKVxuXG4gICAgcmV0dXJuIHsgcmFuZ2UsIG1hcmtlZFN0cmluZ3MgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgaXNFbXB0eUhvdmVyKGhvdmVyOiBIb3Zlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICBob3Zlci5jb250ZW50cyA9PSBudWxsIHx8XG4gICAgICAodHlwZW9mIGhvdmVyLmNvbnRlbnRzID09PSBcInN0cmluZ1wiICYmIGhvdmVyLmNvbnRlbnRzLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgIChBcnJheS5pc0FycmF5KGhvdmVyLmNvbnRlbnRzKSAmJiAoaG92ZXIuY29udGVudHMubGVuZ3RoID09PSAwIHx8IGhvdmVyLmNvbnRlbnRzWzBdID09PSBcIlwiKSlcbiAgICApXG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjb252ZXJ0TWFya2VkU3RyaW5nKFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICBtYXJrZWRTdHJpbmc6IE1hcmtlZFN0cmluZyB8IE1hcmt1cENvbnRlbnRcbiAgKTogYXRvbUlkZS5NYXJrZWRTdHJpbmcge1xuICAgIGlmICh0eXBlb2YgbWFya2VkU3RyaW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm1hcmtkb3duXCIsIHZhbHVlOiBtYXJrZWRTdHJpbmcgfVxuICAgIH1cblxuICAgIGlmICgobWFya2VkU3RyaW5nIGFzIE1hcmt1cENvbnRlbnQpLmtpbmQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWFya2Rvd25cIixcbiAgICAgICAgdmFsdWU6IG1hcmtlZFN0cmluZy52YWx1ZSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNdXN0IGNoZWNrIGFzIDx7bGFuZ3VhZ2U6IHN0cmluZ30+IHRvIGRpc2FtYmlndWF0ZSBiZXR3ZWVuXG4gICAgLy8gc3RyaW5nIGFuZCB0aGUgbW9yZSBleHBsaWNpdCBvYmplY3QgdHlwZSBiZWNhdXNlIE1hcmtlZFN0cmluZ1xuICAgIC8vIGlzIGEgdW5pb24gb2YgdGhlIHR3byB0eXBlc1xuICAgIGlmICgobWFya2VkU3RyaW5nIGFzIHsgbGFuZ3VhZ2U6IHN0cmluZyB9KS5sYW5ndWFnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzbmlwcGV0XCIsXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgbWFwcGluZyBmcm9tIGxhbmd1YWdlIC0+IGdyYW1tYXJcbiAgICAgICAgZ3JhbW1hcjpcbiAgICAgICAgICBhdG9tLmdyYW1tYXJzLmdyYW1tYXJGb3JTY29wZU5hbWUoYHNvdXJjZS4keyhtYXJrZWRTdHJpbmcgYXMgeyBsYW5ndWFnZTogc3RyaW5nIH0pLmxhbmd1YWdlfWApIHx8XG4gICAgICAgICAgZWRpdG9yLmdldEdyYW1tYXIoKSxcbiAgICAgICAgdmFsdWU6IG1hcmtlZFN0cmluZy52YWx1ZSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYXRjaC1hbGwgY2FzZVxuICAgIHJldHVybiB7IHR5cGU6IFwibWFya2Rvd25cIiwgdmFsdWU6IG1hcmtlZFN0cmluZy50b1N0cmluZygpIH1cbiAgfVxufVxuIl19