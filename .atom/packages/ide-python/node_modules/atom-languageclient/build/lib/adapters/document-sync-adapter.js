Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Synchronizes the documents between Atom and the language server by notifying
// each end of changes, opening, closing and other events as well as sending and applying
// changes either in whole or in part depending on what the language server supports.
class DocumentSyncAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix textDocumentSync capability either being Full or
  // Incremental.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return this.canAdaptV2(serverCapabilities) || this.canAdaptV3(serverCapabilities);
  }

  static canAdaptV2(serverCapabilities) {
    return serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Incremental || serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Full;
  }

  static canAdaptV3(serverCapabilities) {
    const options = serverCapabilities.textDocumentSync;
    return options !== null && typeof options === 'object' && (options.change === _languageclient.TextDocumentSyncKind.Incremental || options.change === _languageclient.TextDocumentSyncKind.Full);
  }

  // Public: Create a new {DocumentSyncAdapter} for the given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server to be kept in sync.
  // * `documentSyncKind` The type of document syncing supported - Full or Incremental.
  // * `editorSelector` A predicate function that takes a {TextEditor} and returns a {boolean}
  //                    indicating whether this adapter should care about the contents of the editor.
  constructor(connection, documentSyncKind, editorSelector) {
    this._disposable = new _atom.CompositeDisposable();
    this._editors = new WeakMap();
    this._versions = new Map();

    this._connection = connection;
    if (typeof documentSyncKind === 'number') {
      this._documentSyncKind = documentSyncKind;
    } else if (documentSyncKind != null && documentSyncKind.change != null) {
      this._documentSyncKind = documentSyncKind.change;
    } else {
      this._documentSyncKind = _languageclient.TextDocumentSyncKind.Full;
    }
    this._editorSelector = editorSelector;
    this._disposable.add(atom.textEditors.observe(this.observeTextEditor.bind(this)));
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Examine a {TextEditor} and decide if we wish to observe it. If so ensure that we stop observing it
  // when it is closed or otherwise destroyed.
  //
  // * `editor` A {TextEditor} to consider for observation.
  observeTextEditor(editor) {
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => {
      this._disposable.remove(listener);
      listener.dispose();
    }));
    this._disposable.add(listener);
    if (!this._editors.has(editor) && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleGrammarChange(editor) {
    const sync = this._editors.get(editor);
    if (sync != null && !this._editorSelector(editor)) {
      this._editors.delete(editor);
      this._disposable.remove(sync);
      sync.dispose();
    } else if (sync == null && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleNewEditor(editor) {
    const sync = new TextEditorSyncAdapter(editor, this._connection, this._documentSyncKind, this._versions);
    this._editors.set(editor, sync);
    this._disposable.add(sync);
    this._disposable.add(editor.onDidDestroy(() => {
      const destroyedSync = this._editors.get(editor);
      if (destroyedSync) {
        this._editors.delete(editor);
        this._disposable.remove(destroyedSync);
        destroyedSync.dispose();
      }
    }));
  }

  getEditorSyncAdapter(editor) {
    return this._editors.get(editor);
  }
}

exports.default = DocumentSyncAdapter; // Public: Keep a single {TextEditor} in sync with a given language server.

class TextEditorSyncAdapter {

  // Public: Create a {TextEditorSyncAdapter} in sync with a given language server.
  //
  // * `editor` A {TextEditor} to keep in sync.
  // * `connection` A {LanguageClientConnection} to a language server to keep in sync.
  // * `documentSyncKind` Whether to use Full (1) or Incremental (2) when sending changes.
  constructor(editor, connection, documentSyncKind, versions) {
    this._disposable = new _atom.CompositeDisposable();

    this._editor = editor;
    this._connection = connection;
    this._versions = versions;
    this._fakeDidChangeWatchedFiles = atom.project.onDidChangeFiles == null;

    const changeTracking = this.setupChangeTracking(documentSyncKind);
    if (changeTracking != null) {
      this._disposable.add(changeTracking);
    }

    this._disposable.add(editor.onDidSave(this.didSave.bind(this)), editor.onDidDestroy(this.didClose.bind(this)), editor.onDidChangePath(this.didRename.bind(this)));

    this._currentUri = this.getEditorUri();
    this.didOpen();
  }

  // The change tracking disposable listener that will ensure that changes are sent to the
  // language server as appropriate.
  setupChangeTracking(documentSyncKind) {
    switch (documentSyncKind) {
      case _languageclient.TextDocumentSyncKind.Full:
        return this._editor.onDidChange(this.sendFullChanges.bind(this));
      case _languageclient.TextDocumentSyncKind.Incremental:
        return this._editor.getBuffer().onDidChangeText(this.sendIncrementalChanges.bind(this));
    }
    return null;
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Get the languageId field that will be sent to the language server by simply
  // using the grammar name.
  getLanguageId() {
    return this._editor.getGrammar().name;
  }

  // Public: Create a {VersionedTextDocumentIdentifier} for the document observed by
  // this adapter including both the Uri and the current Version.
  getVersionedTextDocumentIdentifier() {
    return {
      uri: this.getEditorUri(),
      version: this._getVersion(this._editor.getPath() || '')
    };
  }

  // Public: Send the entire document to the language server. This is used when
  // operating in Full (1) sync mode.
  sendFullChanges() {
    if (!this._isPrimaryAdapter()) return; // Multiple editors, we are not first

    this._bumpVersion();
    this._connection.didChangeTextDocument({
      textDocument: this.getVersionedTextDocumentIdentifier(),
      contentChanges: [{ text: this._editor.getText() }]
    });
  }

  // Public: Send the incremental text changes to the language server. This is used
  // when operating in Incremental (2) sync mode.
  //
  // * `event` The event fired by Atom to indicate the document has stopped changing
  //           including a list of changes since the last time this event fired for this
  //           text editor.
  // Note: The order of changes in the event is guaranteed top to bottom.  Language server
  // expects this in reverse.
  sendIncrementalChanges(event) {
    if (event.changes.length > 0) {
      if (!this._isPrimaryAdapter()) return; // Multiple editors, we are not first

      this._bumpVersion();
      this._connection.didChangeTextDocument({
        textDocument: this.getVersionedTextDocumentIdentifier(),
        contentChanges: event.changes.map(TextEditorSyncAdapter.textEditToContentChange).reverse()
      });
    }
  }

  // Public: Convert an Atom {TextEditEvent} to a language server {TextDocumentContentChangeEvent}
  // object.
  //
  // * `change` The Atom {TextEditEvent} to convert.
  //
  // Returns a {TextDocumentContentChangeEvent} that represents the converted {TextEditEvent}.
  static textEditToContentChange(change) {
    return {
      range: _convert2.default.atomRangeToLSRange(change.oldRange),
      rangeLength: change.oldText.length,
      text: change.newText
    };
  }

  _isPrimaryAdapter() {
    const lowestIdForBuffer = Math.min(...atom.workspace.getTextEditors().filter(t => t.getBuffer() === this._editor.getBuffer()).map(t => t.id));
    return lowestIdForBuffer === this._editor.id;
  }

  _bumpVersion() {
    const filePath = this._editor.getPath();
    if (filePath == null) return;
    this._versions.set(filePath, this._getVersion(filePath) + 1);
  }

  // Ensure when the document is opened we send notification to the language server
  // so it can load it in and keep track of diagnostics etc.
  didOpen() {
    const filePath = this._editor.getPath();
    if (filePath == null) return; // Not yet saved

    if (!this._isPrimaryAdapter()) return; // Multiple editors, we are not first

    this._connection.didOpenTextDocument({
      textDocument: {
        uri: this.getEditorUri(),
        languageId: this.getLanguageId().toLowerCase(),
        version: this._getVersion(filePath),
        text: this._editor.getText()
      }
    });
  }

  _getVersion(filePath) {
    return this._versions.get(filePath) || 1;
  }

  // Called when the {TextEditor} is closed and sends the 'didCloseTextDocument' notification to
  // the connected language server.
  didClose() {
    if (this._editor.getPath() == null) return; // Not yet saved

    const fileStillOpen = atom.workspace.getTextEditors().find(t => t.getBuffer() === this._editor.getBuffer());
    if (fileStillOpen) {
      return; // Other windows or editors still have this file open
    }

    this._connection.didCloseTextDocument({ textDocument: { uri: this.getEditorUri() } });
  }

  // Called when the {TextEditor} saves and sends the 'didSaveTextDocument' notification to
  // the connected language server.
  // Note: Right now this also sends the `didChangeWatchedFiles` notification as well but that
  // will be sent from elsewhere soon.
  didSave() {
    if (!this._isPrimaryAdapter()) return;

    const uri = this.getEditorUri();
    this._connection.didSaveTextDocument({ textDocument: { uri } });
    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri, type: _languageclient.FileChangeType.Changed }]
      });
    }
  }

  didRename() {
    if (!this._isPrimaryAdapter()) return;

    const oldUri = this._currentUri;
    this._currentUri = this.getEditorUri();
    if (!oldUri) {
      return; // Didn't previously have a name
    }

    this._connection.didCloseTextDocument({
      textDocument: { uri: oldUri }
    });

    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri: oldUri, type: _languageclient.FileChangeType.Deleted }, { uri: this._currentUri, type: _languageclient.FileChangeType.Created }]
      });
    }

    // Send an equivalent open event for this editor, which will now use the new
    // file path.
    this.didOpen();
  }

  // Public: Obtain the current {TextEditor} path and convert it to a Uri.
  getEditorUri() {
    return _convert2.default.pathToUri(this._editor.getPath() || '');
  }
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRG9jdW1lbnRTeW5jQWRhcHRlciIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiY2FuQWRhcHRWMiIsImNhbkFkYXB0VjMiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwiSW5jcmVtZW50YWwiLCJGdWxsIiwib3B0aW9ucyIsImNoYW5nZSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsImRvY3VtZW50U3luY0tpbmQiLCJlZGl0b3JTZWxlY3RvciIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvcnMiLCJXZWFrTWFwIiwiX3ZlcnNpb25zIiwiTWFwIiwiX2Nvbm5lY3Rpb24iLCJfZG9jdW1lbnRTeW5jS2luZCIsIl9lZGl0b3JTZWxlY3RvciIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvciIsImJpbmQiLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsInJlbW92ZSIsImhhcyIsIl9oYW5kbGVOZXdFZGl0b3IiLCJzeW5jIiwiZ2V0IiwiZGVsZXRlIiwiVGV4dEVkaXRvclN5bmNBZGFwdGVyIiwic2V0IiwiZGVzdHJveWVkU3luYyIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwidmVyc2lvbnMiLCJfZWRpdG9yIiwiX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMiLCJwcm9qZWN0Iiwib25EaWRDaGFuZ2VGaWxlcyIsImNoYW5nZVRyYWNraW5nIiwic2V0dXBDaGFuZ2VUcmFja2luZyIsIm9uRGlkU2F2ZSIsImRpZFNhdmUiLCJkaWRDbG9zZSIsIm9uRGlkQ2hhbmdlUGF0aCIsImRpZFJlbmFtZSIsIl9jdXJyZW50VXJpIiwiZ2V0RWRpdG9yVXJpIiwiZGlkT3BlbiIsIm9uRGlkQ2hhbmdlIiwic2VuZEZ1bGxDaGFuZ2VzIiwiZ2V0QnVmZmVyIiwib25EaWRDaGFuZ2VUZXh0Iiwic2VuZEluY3JlbWVudGFsQ2hhbmdlcyIsImdldExhbmd1YWdlSWQiLCJnZXRHcmFtbWFyIiwibmFtZSIsImdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJ1cmkiLCJ2ZXJzaW9uIiwiX2dldFZlcnNpb24iLCJnZXRQYXRoIiwiX2lzUHJpbWFyeUFkYXB0ZXIiLCJfYnVtcFZlcnNpb24iLCJkaWRDaGFuZ2VUZXh0RG9jdW1lbnQiLCJ0ZXh0RG9jdW1lbnQiLCJjb250ZW50Q2hhbmdlcyIsInRleHQiLCJnZXRUZXh0IiwiZXZlbnQiLCJjaGFuZ2VzIiwibGVuZ3RoIiwibWFwIiwidGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UiLCJyZXZlcnNlIiwicmFuZ2UiLCJhdG9tUmFuZ2VUb0xTUmFuZ2UiLCJvbGRSYW5nZSIsInJhbmdlTGVuZ3RoIiwib2xkVGV4dCIsIm5ld1RleHQiLCJsb3dlc3RJZEZvckJ1ZmZlciIsIk1hdGgiLCJtaW4iLCJ3b3Jrc3BhY2UiLCJnZXRUZXh0RWRpdG9ycyIsImZpbHRlciIsInQiLCJpZCIsImZpbGVQYXRoIiwiZGlkT3BlblRleHREb2N1bWVudCIsImxhbmd1YWdlSWQiLCJ0b0xvd2VyQ2FzZSIsImZpbGVTdGlsbE9wZW4iLCJmaW5kIiwiZGlkQ2xvc2VUZXh0RG9jdW1lbnQiLCJkaWRTYXZlVGV4dERvY3VtZW50IiwiZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzIiwidHlwZSIsIkNoYW5nZWQiLCJvbGRVcmkiLCJEZWxldGVkIiwiQ3JlYXRlZCIsInBhdGhUb1VyaSJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOztBQVNBOzs7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDZSxNQUFNQSxtQkFBTixDQUEwQjs7QUFRdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFP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QUFMLEdBQW1CLEtBQUtDLFlBQUwsRUFBbkI7QUFDQSxRQUFJLENBQUNxRCxNQUFMLEVBQWE7QUFDWCxhQURXLENBQ0g7QUFDVDs7QUFFRCxTQUFLNUYsV0FBTCxDQUFpQnVGLG9CQUFqQixDQUFzQztBQUNwQzlCLG9CQUFjLEVBQUNQLEtBQUswQyxNQUFOO0FBRHNCLEtBQXRDOztBQUlBLFFBQUksS0FBS2hFLDBCQUFULEVBQXFDO0FBQ25DLFdBQUs1QixXQUFMLENBQWlCeUYscUJBQWpCLENBQXVDO0FBQ3JDM0IsaUJBQVMsQ0FBQyxFQUFDWixLQUFLMEMsTUFBTixFQUFjRixNQUFNLCtCQUFlRyxPQUFuQyxFQUFELEVBQThDLEVBQUMzQyxLQUFLLEtBQUtaLFdBQVgsRUFBd0JvRCxNQUFNLCtCQUFlSSxPQUE3QyxFQUE5QztBQUQ0QixPQUF2QztBQUdEOztBQUVEO0FBQ0E7QUFDQSxTQUFLdEQsT0FBTDtBQUNEOztBQUVEO0FBQ0FELGlCQUF1QjtBQUNyQixXQUFPLGtCQUFRd0QsU0FBUixDQUFrQixLQUFLcEUsT0FBTCxDQUFhMEIsT0FBYixNQUEwQixFQUE1QyxDQUFQO0FBQ0Q7QUFuTnlCIiwiZmlsZSI6ImRvY3VtZW50LXN5bmMtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBGaWxlQ2hhbmdlVHlwZSxcclxuICBUZXh0RG9jdW1lbnRTeW5jS2luZCxcclxuICBUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyxcclxuICB0eXBlIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCxcclxuICB0eXBlIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIsXHJcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFB1YmxpYzogU3luY2hyb25pemVzIHRoZSBkb2N1bWVudHMgYmV0d2VlbiBBdG9tIGFuZCB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGJ5IG5vdGlmeWluZ1xyXG4vLyBlYWNoIGVuZCBvZiBjaGFuZ2VzLCBvcGVuaW5nLCBjbG9zaW5nIGFuZCBvdGhlciBldmVudHMgYXMgd2VsbCBhcyBzZW5kaW5nIGFuZCBhcHBseWluZ1xyXG4vLyBjaGFuZ2VzIGVpdGhlciBpbiB3aG9sZSBvciBpbiBwYXJ0IGRlcGVuZGluZyBvbiB3aGF0IHRoZSBsYW5ndWFnZSBzZXJ2ZXIgc3VwcG9ydHMuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50U3luY0FkYXB0ZXIge1xyXG4gIF9lZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW47XHJcbiAgX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIF9kb2N1bWVudFN5bmNLaW5kOiBudW1iZXI7XHJcbiAgX2VkaXRvcnM6IFdlYWtNYXA8YXRvbSRUZXh0RWRpdG9yLCBUZXh0RWRpdG9yU3luY0FkYXB0ZXI+ID0gbmV3IFdlYWtNYXAoKTtcclxuICBfY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uO1xyXG4gIF92ZXJzaW9uczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCB0ZXh0RG9jdW1lbnRTeW5jIGNhcGFiaWxpdHkgZWl0aGVyIGJlaW5nIEZ1bGwgb3JcclxuICAvLyBJbmNyZW1lbnRhbC5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5jYW5BZGFwdFYyKHNlcnZlckNhcGFiaWxpdGllcykgfHwgdGhpcy5jYW5BZGFwdFYzKHNlcnZlckNhcGFiaWxpdGllcyk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FuQWRhcHRWMihzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkluY3JlbWVudGFsIHx8XHJcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jID09PSBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGNhbkFkYXB0VjMoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYztcclxuICAgIHJldHVybiAoXHJcbiAgICAgIG9wdGlvbnMgIT09IG51bGwgJiZcclxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmXHJcbiAgICAgIChvcHRpb25zLmNoYW5nZSA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgfHwgb3B0aW9ucy5jaGFuZ2UgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGwpXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSBuZXcge0RvY3VtZW50U3luY0FkYXB0ZXJ9IGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGJlIGtlcHQgaW4gc3luYy5cclxuICAvLyAqIGBkb2N1bWVudFN5bmNLaW5kYCBUaGUgdHlwZSBvZiBkb2N1bWVudCBzeW5jaW5nIHN1cHBvcnRlZCAtIEZ1bGwgb3IgSW5jcmVtZW50YWwuXHJcbiAgLy8gKiBgZWRpdG9yU2VsZWN0b3JgIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7VGV4dEVkaXRvcn0gYW5kIHJldHVybnMgYSB7Ym9vbGVhbn1cclxuICAvLyAgICAgICAgICAgICAgICAgICAgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgYWRhcHRlciBzaG91bGQgY2FyZSBhYm91dCB0aGUgY29udGVudHMgb2YgdGhlIGVkaXRvci5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGRvY3VtZW50U3luY0tpbmQ6ID8oVGV4dERvY3VtZW50U3luY09wdGlvbnMgfCBudW1iZXIpLFxyXG4gICAgZWRpdG9yU2VsZWN0b3I6IGF0b20kVGV4dEVkaXRvciA9PiBib29sZWFuLFxyXG4gICkge1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50U3luY0tpbmQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kO1xyXG4gICAgfSBlbHNlIGlmIChkb2N1bWVudFN5bmNLaW5kICE9IG51bGwgJiYgZG9jdW1lbnRTeW5jS2luZC5jaGFuZ2UgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9kb2N1bWVudFN5bmNLaW5kID0gZG9jdW1lbnRTeW5jS2luZC5jaGFuZ2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9kb2N1bWVudFN5bmNLaW5kID0gVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbDtcclxuICAgIH1cclxuICAgIHRoaXMuX2VkaXRvclNlbGVjdG9yID0gZWRpdG9yU2VsZWN0b3I7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnRleHRFZGl0b3JzLm9ic2VydmUodGhpcy5vYnNlcnZlVGV4dEVkaXRvci5iaW5kKHRoaXMpKSk7XHJcbiAgfVxyXG5cclxuICAvLyBEaXNwb3NlIHRoaXMgYWRhcHRlciBlbnN1cmluZyBhbnkgcmVzb3VyY2VzIGFyZSBmcmVlZCBhbmQgZXZlbnRzIHVuaG9va2VkLlxyXG4gIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIC8vIEV4YW1pbmUgYSB7VGV4dEVkaXRvcn0gYW5kIGRlY2lkZSBpZiB3ZSB3aXNoIHRvIG9ic2VydmUgaXQuIElmIHNvIGVuc3VyZSB0aGF0IHdlIHN0b3Agb2JzZXJ2aW5nIGl0XHJcbiAgLy8gd2hlbiBpdCBpcyBjbG9zZWQgb3Igb3RoZXJ3aXNlIGRlc3Ryb3llZC5cclxuICAvL1xyXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdG8gY29uc2lkZXIgZm9yIG9ic2VydmF0aW9uLlxyXG4gIG9ic2VydmVUZXh0RWRpdG9yKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IGVkaXRvci5vYnNlcnZlR3JhbW1hcihncmFtbWFyID0+IHRoaXMuX2hhbmRsZUdyYW1tYXJDaGFuZ2UoZWRpdG9yKSk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChcclxuICAgICAgZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUobGlzdGVuZXIpO1xyXG4gICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQobGlzdGVuZXIpO1xyXG4gICAgaWYgKCF0aGlzLl9lZGl0b3JzLmhhcyhlZGl0b3IpICYmIHRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcclxuICAgICAgdGhpcy5faGFuZGxlTmV3RWRpdG9yKGVkaXRvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IHZvaWQge1xyXG4gICAgY29uc3Qgc3luYyA9IHRoaXMuX2VkaXRvcnMuZ2V0KGVkaXRvcik7XHJcbiAgICBpZiAoc3luYyAhPSBudWxsICYmICF0aGlzLl9lZGl0b3JTZWxlY3RvcihlZGl0b3IpKSB7XHJcbiAgICAgIHRoaXMuX2VkaXRvcnMuZGVsZXRlKGVkaXRvcik7XHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGUucmVtb3ZlKHN5bmMpO1xyXG4gICAgICBzeW5jLmRpc3Bvc2UoKTtcclxuICAgIH0gZWxzZSBpZiAoc3luYyA9PSBudWxsICYmIHRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcclxuICAgICAgdGhpcy5faGFuZGxlTmV3RWRpdG9yKGVkaXRvcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlTmV3RWRpdG9yKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICBjb25zdCBzeW5jID0gbmV3IFRleHRFZGl0b3JTeW5jQWRhcHRlcihlZGl0b3IsIHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2RvY3VtZW50U3luY0tpbmQsIHRoaXMuX3ZlcnNpb25zKTtcclxuICAgIHRoaXMuX2VkaXRvcnMuc2V0KGVkaXRvciwgc3luYyk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChzeW5jKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgICBjb25zdCBkZXN0cm95ZWRTeW5jID0gdGhpcy5fZWRpdG9ycy5nZXQoZWRpdG9yKTtcclxuICAgICAgICBpZiAoZGVzdHJveWVkU3luYykge1xyXG4gICAgICAgICAgdGhpcy5fZWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUucmVtb3ZlKGRlc3Ryb3llZFN5bmMpO1xyXG4gICAgICAgICAgZGVzdHJveWVkU3luYy5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBnZXRFZGl0b3JTeW5jQWRhcHRlcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9UZXh0RWRpdG9yU3luY0FkYXB0ZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvcnMuZ2V0KGVkaXRvcik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQdWJsaWM6IEtlZXAgYSBzaW5nbGUge1RleHRFZGl0b3J9IGluIHN5bmMgd2l0aCBhIGdpdmVuIGxhbmd1YWdlIHNlcnZlci5cclxuY2xhc3MgVGV4dEVkaXRvclN5bmNBZGFwdGVyIHtcclxuICBfZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgX2VkaXRvcjogYXRvbSRUZXh0RWRpdG9yO1xyXG4gIF9jdXJyZW50VXJpOiBzdHJpbmc7XHJcbiAgX2Nvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbjtcclxuICBfZmFrZURpZENoYW5nZVdhdGNoZWRGaWxlczogYm9vbGVhbjtcclxuICBfdmVyc2lvbnM6IE1hcDxzdHJpbmcsIG51bWJlcj47XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1RleHRFZGl0b3JTeW5jQWRhcHRlcn0gaW4gc3luYyB3aXRoIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0byBrZWVwIGluIHN5bmMuXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byBhIGxhbmd1YWdlIHNlcnZlciB0byBrZWVwIGluIHN5bmMuXHJcbiAgLy8gKiBgZG9jdW1lbnRTeW5jS2luZGAgV2hldGhlciB0byB1c2UgRnVsbCAoMSkgb3IgSW5jcmVtZW50YWwgKDIpIHdoZW4gc2VuZGluZyBjaGFuZ2VzLlxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBkb2N1bWVudFN5bmNLaW5kOiBudW1iZXIsXHJcbiAgICB2ZXJzaW9uczogTWFwPHN0cmluZywgbnVtYmVyPixcclxuICApIHtcclxuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xyXG4gICAgdGhpcy5fdmVyc2lvbnMgPSB2ZXJzaW9ucztcclxuICAgIHRoaXMuX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMgPSBhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VGaWxlcyA9PSBudWxsO1xyXG5cclxuICAgIGNvbnN0IGNoYW5nZVRyYWNraW5nID0gdGhpcy5zZXR1cENoYW5nZVRyYWNraW5nKGRvY3VtZW50U3luY0tpbmQpO1xyXG4gICAgaWYgKGNoYW5nZVRyYWNraW5nICE9IG51bGwpIHtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoY2hhbmdlVHJhY2tpbmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICBlZGl0b3Iub25EaWRTYXZlKHRoaXMuZGlkU2F2ZS5iaW5kKHRoaXMpKSxcclxuICAgICAgZWRpdG9yLm9uRGlkRGVzdHJveSh0aGlzLmRpZENsb3NlLmJpbmQodGhpcykpLFxyXG4gICAgICBlZGl0b3Iub25EaWRDaGFuZ2VQYXRoKHRoaXMuZGlkUmVuYW1lLmJpbmQodGhpcykpLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLl9jdXJyZW50VXJpID0gdGhpcy5nZXRFZGl0b3JVcmkoKTtcclxuICAgIHRoaXMuZGlkT3BlbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGhlIGNoYW5nZSB0cmFja2luZyBkaXNwb3NhYmxlIGxpc3RlbmVyIHRoYXQgd2lsbCBlbnN1cmUgdGhhdCBjaGFuZ2VzIGFyZSBzZW50IHRvIHRoZVxyXG4gIC8vIGxhbmd1YWdlIHNlcnZlciBhcyBhcHByb3ByaWF0ZS5cclxuICBzZXR1cENoYW5nZVRyYWNraW5nKGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcik6ID9JRGlzcG9zYWJsZSB7XHJcbiAgICBzd2l0Y2ggKGRvY3VtZW50U3luY0tpbmQpIHtcclxuICAgICAgY2FzZSBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsOlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3Iub25EaWRDaGFuZ2UodGhpcy5zZW5kRnVsbENoYW5nZXMuYmluZCh0aGlzKSk7XHJcbiAgICAgIGNhc2UgVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWw6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRvci5nZXRCdWZmZXIoKS5vbkRpZENoYW5nZVRleHQodGhpcy5zZW5kSW5jcmVtZW50YWxDaGFuZ2VzLmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBEaXNwb3NlIHRoaXMgYWRhcHRlciBlbnN1cmluZyBhbnkgcmVzb3VyY2VzIGFyZSBmcmVlZCBhbmQgZXZlbnRzIHVuaG9va2VkLlxyXG4gIGRpc3Bvc2UoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIC8vIEdldCB0aGUgbGFuZ3VhZ2VJZCBmaWVsZCB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGJ5IHNpbXBseVxyXG4gIC8vIHVzaW5nIHRoZSBncmFtbWFyIG5hbWUuXHJcbiAgZ2V0TGFuZ3VhZ2VJZCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvci5nZXRHcmFtbWFyKCkubmFtZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGZvciB0aGUgZG9jdW1lbnQgb2JzZXJ2ZWQgYnlcclxuICAvLyB0aGlzIGFkYXB0ZXIgaW5jbHVkaW5nIGJvdGggdGhlIFVyaSBhbmQgdGhlIGN1cnJlbnQgVmVyc2lvbi5cclxuICBnZXRWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKCk6IFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdXJpOiB0aGlzLmdldEVkaXRvclVyaSgpLFxyXG4gICAgICB2ZXJzaW9uOiB0aGlzLl9nZXRWZXJzaW9uKHRoaXMuX2VkaXRvci5nZXRQYXRoKCkgfHwgJycpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogU2VuZCB0aGUgZW50aXJlIGRvY3VtZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaXMgdXNlZCB3aGVuXHJcbiAgLy8gb3BlcmF0aW5nIGluIEZ1bGwgKDEpIHN5bmMgbW9kZS5cclxuICBzZW5kRnVsbENoYW5nZXMoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2lzUHJpbWFyeUFkYXB0ZXIoKSkgcmV0dXJuOyAvLyBNdWx0aXBsZSBlZGl0b3JzLCB3ZSBhcmUgbm90IGZpcnN0XHJcblxyXG4gICAgdGhpcy5fYnVtcFZlcnNpb24oKTtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlVGV4dERvY3VtZW50KHtcclxuICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcclxuICAgICAgY29udGVudENoYW5nZXM6IFt7dGV4dDogdGhpcy5fZWRpdG9yLmdldFRleHQoKX1dLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IFNlbmQgdGhlIGluY3JlbWVudGFsIHRleHQgY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGlzIHVzZWRcclxuICAvLyB3aGVuIG9wZXJhdGluZyBpbiBJbmNyZW1lbnRhbCAoMikgc3luYyBtb2RlLlxyXG4gIC8vXHJcbiAgLy8gKiBgZXZlbnRgIFRoZSBldmVudCBmaXJlZCBieSBBdG9tIHRvIGluZGljYXRlIHRoZSBkb2N1bWVudCBoYXMgc3RvcHBlZCBjaGFuZ2luZ1xyXG4gIC8vICAgICAgICAgICBpbmNsdWRpbmcgYSBsaXN0IG9mIGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgdGltZSB0aGlzIGV2ZW50IGZpcmVkIGZvciB0aGlzXHJcbiAgLy8gICAgICAgICAgIHRleHQgZWRpdG9yLlxyXG4gIC8vIE5vdGU6IFRoZSBvcmRlciBvZiBjaGFuZ2VzIGluIHRoZSBldmVudCBpcyBndWFyYW50ZWVkIHRvcCB0byBib3R0b20uICBMYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBleHBlY3RzIHRoaXMgaW4gcmV2ZXJzZS5cclxuICBzZW5kSW5jcmVtZW50YWxDaGFuZ2VzKGV2ZW50OiBhdG9tJERpZFN0b3BDaGFuZ2luZ0V2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAoZXZlbnQuY2hhbmdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSByZXR1cm47IC8vIE11bHRpcGxlIGVkaXRvcnMsIHdlIGFyZSBub3QgZmlyc3RcclxuXHJcbiAgICAgIHRoaXMuX2J1bXBWZXJzaW9uKCk7XHJcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlVGV4dERvY3VtZW50KHtcclxuICAgICAgICB0ZXh0RG9jdW1lbnQ6IHRoaXMuZ2V0VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcigpLFxyXG4gICAgICAgIGNvbnRlbnRDaGFuZ2VzOiBldmVudC5jaGFuZ2VzLm1hcChUZXh0RWRpdG9yU3luY0FkYXB0ZXIudGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UpLnJldmVyc2UoKSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gQXRvbSB7VGV4dEVkaXRFdmVudH0gdG8gYSBsYW5ndWFnZSBzZXJ2ZXIge1RleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudH1cclxuICAvLyBvYmplY3QuXHJcbiAgLy9cclxuICAvLyAqIGBjaGFuZ2VgIFRoZSBBdG9tIHtUZXh0RWRpdEV2ZW50fSB0byBjb252ZXJ0LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnR9IHRoYXQgcmVwcmVzZW50cyB0aGUgY29udmVydGVkIHtUZXh0RWRpdEV2ZW50fS5cclxuICBzdGF0aWMgdGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UoY2hhbmdlOiBhdG9tJFRleHRFZGl0RXZlbnQpOiBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgcmFuZ2U6IENvbnZlcnQuYXRvbVJhbmdlVG9MU1JhbmdlKGNoYW5nZS5vbGRSYW5nZSksXHJcbiAgICAgIHJhbmdlTGVuZ3RoOiBjaGFuZ2Uub2xkVGV4dC5sZW5ndGgsXHJcbiAgICAgIHRleHQ6IGNoYW5nZS5uZXdUZXh0LFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIF9pc1ByaW1hcnlBZGFwdGVyKCk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgbG93ZXN0SWRGb3JCdWZmZXIgPSBNYXRoLm1pbihcclxuICAgICAgLi4uYXRvbS53b3Jrc3BhY2VcclxuICAgICAgICAuZ2V0VGV4dEVkaXRvcnMoKVxyXG4gICAgICAgIC5maWx0ZXIodCA9PiB0LmdldEJ1ZmZlcigpID09PSB0aGlzLl9lZGl0b3IuZ2V0QnVmZmVyKCkpXHJcbiAgICAgICAgLm1hcCh0ID0+IHQuaWQpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBsb3dlc3RJZEZvckJ1ZmZlciA9PT0gdGhpcy5fZWRpdG9yLmlkO1xyXG4gIH1cclxuXHJcbiAgX2J1bXBWZXJzaW9uKCk6IHZvaWQge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSB0aGlzLl9lZGl0b3IuZ2V0UGF0aCgpO1xyXG4gICAgaWYgKGZpbGVQYXRoID09IG51bGwpIHJldHVybjtcclxuICAgIHRoaXMuX3ZlcnNpb25zLnNldChmaWxlUGF0aCwgdGhpcy5fZ2V0VmVyc2lvbihmaWxlUGF0aCkgKyAxKTtcclxuICB9XHJcblxyXG4gIC8vIEVuc3VyZSB3aGVuIHRoZSBkb2N1bWVudCBpcyBvcGVuZWQgd2Ugc2VuZCBub3RpZmljYXRpb24gdG8gdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIHNvIGl0IGNhbiBsb2FkIGl0IGluIGFuZCBrZWVwIHRyYWNrIG9mIGRpYWdub3N0aWNzIGV0Yy5cclxuICBkaWRPcGVuKCk6IHZvaWQge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSB0aGlzLl9lZGl0b3IuZ2V0UGF0aCgpO1xyXG4gICAgaWYgKGZpbGVQYXRoID09IG51bGwpIHJldHVybjsgLy8gTm90IHlldCBzYXZlZFxyXG5cclxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSByZXR1cm47IC8vIE11bHRpcGxlIGVkaXRvcnMsIHdlIGFyZSBub3QgZmlyc3RcclxuXHJcbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZE9wZW5UZXh0RG9jdW1lbnQoe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IHtcclxuICAgICAgICB1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCksXHJcbiAgICAgICAgbGFuZ3VhZ2VJZDogdGhpcy5nZXRMYW5ndWFnZUlkKCkudG9Mb3dlckNhc2UoKSxcclxuICAgICAgICB2ZXJzaW9uOiB0aGlzLl9nZXRWZXJzaW9uKGZpbGVQYXRoKSxcclxuICAgICAgICB0ZXh0OiB0aGlzLl9lZGl0b3IuZ2V0VGV4dCgpLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfZ2V0VmVyc2lvbihmaWxlUGF0aDogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgIHJldHVybiB0aGlzLl92ZXJzaW9ucy5nZXQoZmlsZVBhdGgpIHx8IDE7XHJcbiAgfVxyXG5cclxuICAvLyBDYWxsZWQgd2hlbiB0aGUge1RleHRFZGl0b3J9IGlzIGNsb3NlZCBhbmQgc2VuZHMgdGhlICdkaWRDbG9zZVRleHREb2N1bWVudCcgbm90aWZpY2F0aW9uIHRvXHJcbiAgLy8gdGhlIGNvbm5lY3RlZCBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgZGlkQ2xvc2UoKTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fZWRpdG9yLmdldFBhdGgoKSA9PSBudWxsKSByZXR1cm47IC8vIE5vdCB5ZXQgc2F2ZWRcclxuXHJcbiAgICBjb25zdCBmaWxlU3RpbGxPcGVuID0gYXRvbS53b3Jrc3BhY2UuZ2V0VGV4dEVkaXRvcnMoKS5maW5kKHQgPT4gdC5nZXRCdWZmZXIoKSA9PT0gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpKTtcclxuICAgIGlmIChmaWxlU3RpbGxPcGVuKSB7XHJcbiAgICAgIHJldHVybjsgLy8gT3RoZXIgd2luZG93cyBvciBlZGl0b3JzIHN0aWxsIGhhdmUgdGhpcyBmaWxlIG9wZW5cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENsb3NlVGV4dERvY3VtZW50KHt0ZXh0RG9jdW1lbnQ6IHt1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCl9fSk7XHJcbiAgfVxyXG5cclxuICAvLyBDYWxsZWQgd2hlbiB0aGUge1RleHRFZGl0b3J9IHNhdmVzIGFuZCBzZW5kcyB0aGUgJ2RpZFNhdmVUZXh0RG9jdW1lbnQnIG5vdGlmaWNhdGlvbiB0b1xyXG4gIC8vIHRoZSBjb25uZWN0ZWQgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vIE5vdGU6IFJpZ2h0IG5vdyB0aGlzIGFsc28gc2VuZHMgdGhlIGBkaWRDaGFuZ2VXYXRjaGVkRmlsZXNgIG5vdGlmaWNhdGlvbiBhcyB3ZWxsIGJ1dCB0aGF0XHJcbiAgLy8gd2lsbCBiZSBzZW50IGZyb20gZWxzZXdoZXJlIHNvb24uXHJcbiAgZGlkU2F2ZSgpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgdXJpID0gdGhpcy5nZXRFZGl0b3JVcmkoKTtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkU2F2ZVRleHREb2N1bWVudCh7dGV4dERvY3VtZW50OiB7dXJpfX0pO1xyXG4gICAgaWYgKHRoaXMuX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMpIHtcclxuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VXYXRjaGVkRmlsZXMoe1xyXG4gICAgICAgIGNoYW5nZXM6IFt7dXJpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5DaGFuZ2VkfV0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGlkUmVuYW1lKCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCBvbGRVcmkgPSB0aGlzLl9jdXJyZW50VXJpO1xyXG4gICAgdGhpcy5fY3VycmVudFVyaSA9IHRoaXMuZ2V0RWRpdG9yVXJpKCk7XHJcbiAgICBpZiAoIW9sZFVyaSkge1xyXG4gICAgICByZXR1cm47IC8vIERpZG4ndCBwcmV2aW91c2x5IGhhdmUgYSBuYW1lXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDbG9zZVRleHREb2N1bWVudCh7XHJcbiAgICAgIHRleHREb2N1bWVudDoge3VyaTogb2xkVXJpfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKSB7XHJcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKHtcclxuICAgICAgICBjaGFuZ2VzOiBbe3VyaTogb2xkVXJpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5EZWxldGVkfSwge3VyaTogdGhpcy5fY3VycmVudFVyaSwgdHlwZTogRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZH1dLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZW5kIGFuIGVxdWl2YWxlbnQgb3BlbiBldmVudCBmb3IgdGhpcyBlZGl0b3IsIHdoaWNoIHdpbGwgbm93IHVzZSB0aGUgbmV3XHJcbiAgICAvLyBmaWxlIHBhdGguXHJcbiAgICB0aGlzLmRpZE9wZW4oKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSBjdXJyZW50IHtUZXh0RWRpdG9yfSBwYXRoIGFuZCBjb252ZXJ0IGl0IHRvIGEgVXJpLlxyXG4gIGdldEVkaXRvclVyaSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIENvbnZlcnQucGF0aFRvVXJpKHRoaXMuX2VkaXRvci5nZXRQYXRoKCkgfHwgJycpO1xyXG4gIH1cclxufVxyXG4iXX0=