Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Synchronizes the documents between Atom and the language server by notifying
// each end of changes, opening, closing and other events as well as sending and applying
// changes either in whole or in part depending on what the language server supports.
let DocumentSyncAdapter = class DocumentSyncAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix textDocumentSync capability either being Full or
  // Incremental.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return this.canAdaptV2(serverCapabilities) || this.canAdaptV3(serverCapabilities);
  }

  static canAdaptV2(serverCapabilities) {
    return serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Incremental || serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Full;
  }

  static canAdaptV3(serverCapabilities) {
    const options = serverCapabilities.textDocumentSync;
    return options !== null && typeof options === 'object' && (options.change === _languageclient.TextDocumentSyncKind.Incremental || options.change === _languageclient.TextDocumentSyncKind.Full);
  }

  // Public: Create a new {DocumentSyncAdapter} for the given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server to be kept in sync.
  // * `documentSyncKind` The type of document syncing supported - Full or Incremental.
  // * `editorSelector` A predicate function that takes a {TextEditor} and returns a {boolean}
  //                    indicating whether this adapter should care about the contents of the editor.
  constructor(connection, documentSyncKind, editorSelector) {
    this._disposable = new _atom.CompositeDisposable();
    this._editors = new WeakMap();
    this._versions = new Map();

    this._connection = connection;
    if (typeof documentSyncKind === 'number') {
      this._documentSyncKind = documentSyncKind;
    } else if (documentSyncKind != null && documentSyncKind.change != null) {
      this._documentSyncKind = documentSyncKind.change;
    } else {
      this._documentSyncKind = _languageclient.TextDocumentSyncKind.Full;
    }
    this._editorSelector = editorSelector;
    this._disposable.add(atom.textEditors.observe(this.observeTextEditor.bind(this)));
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Examine a {TextEditor} and decide if we wish to observe it. If so ensure that we stop observing it
  // when it is closed or otherwise destroyed.
  //
  // * `editor` A {TextEditor} to consider for observation.
  observeTextEditor(editor) {
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => {
      this._disposable.remove(listener);
      listener.dispose();
    }));
    this._disposable.add(listener);
    if (!this._editors.has(editor) && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleGrammarChange(editor) {
    const sync = this._editors.get(editor);
    if (sync != null && !this._editorSelector(editor)) {
      this._editors.delete(editor);
      this._disposable.remove(sync);
      sync.dispose();
    } else if (sync == null && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleNewEditor(editor) {
    const sync = new TextEditorSyncAdapter(editor, this._connection, this._documentSyncKind, this._versions);
    this._editors.set(editor, sync);
    this._disposable.add(sync);
    this._disposable.add(editor.onDidDestroy(() => {
      const destroyedSync = this._editors.get(editor);
      if (destroyedSync) {
        this._editors.delete(editor);
        this._disposable.remove(destroyedSync);
        destroyedSync.dispose();
      }
    }));
  }

  getEditorSyncAdapter(editor) {
    return this._editors.get(editor);
  }
};

// Public: Keep a single {TextEditor} in sync with a given language server.

exports.default = DocumentSyncAdapter;
let TextEditorSyncAdapter = class TextEditorSyncAdapter {

  // Public: Create a {TextEditorSyncAdapter} in sync with a given language server.
  //
  // * `editor` A {TextEditor} to keep in sync.
  // * `connection` A {LanguageClientConnection} to a language server to keep in sync.
  // * `documentSyncKind` Whether to use Full (1) or Incremental (2) when sending changes.
  constructor(editor, connection, documentSyncKind, versions) {
    this._disposable = new _atom.CompositeDisposable();

    this._editor = editor;
    this._connection = connection;
    this._versions = versions;
    this._fakeDidChangeWatchedFiles = atom.project.onDidChangeFiles == null;

    const changeTracking = this.setupChangeTracking(documentSyncKind);
    if (changeTracking != null) {
      this._disposable.add(changeTracking);
    }

    this._disposable.add(editor.onDidSave(this.didSave.bind(this)), editor.onDidDestroy(this.didClose.bind(this)), editor.onDidChangePath(this.didRename.bind(this)));

    this._currentUri = this.getEditorUri();
    this.didOpen();
  }

  // The change tracking disposable listener that will ensure that changes are sent to the
  // language server as appropriate.
  setupChangeTracking(documentSyncKind) {
    switch (documentSyncKind) {
      case _languageclient.TextDocumentSyncKind.Full:
        return this._editor.onDidChange(this.sendFullChanges.bind(this));
      case _languageclient.TextDocumentSyncKind.Incremental:
        return this._editor.getBuffer().onDidChangeText(this.sendIncrementalChanges.bind(this));
    }
    return null;
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Get the languageId field that will be sent to the language server by simply
  // using the grammar name.
  getLanguageId() {
    return this._editor.getGrammar().name;
  }

  // Public: Create a {VersionedTextDocumentIdentifier} for the document observed by
  // this adapter including both the Uri and the current Version.
  getVersionedTextDocumentIdentifier() {
    return {
      uri: this.getEditorUri(),
      version: this._getVersion(this._editor.getPath() || '')
    };
  }

  // Public: Send the entire document to the language server. This is used when
  // operating in Full (1) sync mode.
  sendFullChanges() {
    if (!this._isPrimaryAdapter()) return; // Multiple editors, we are not first

    this._bumpVersion();
    this._connection.didChangeTextDocument({
      textDocument: this.getVersionedTextDocumentIdentifier(),
      contentChanges: [{ text: this._editor.getText() }]
    });
  }

  // Public: Send the incremental text changes to the language server. This is used
  // when operating in Incremental (2) sync mode.
  //
  // * `event` The event fired by Atom to indicate the document has stopped changing
  //           including a list of changes since the last time this event fired for this
  //           text editor.
  // Note: The order of changes in the event is guaranteed top to bottom.  Language server
  // expects this in reverse.
  sendIncrementalChanges(event) {
    if (event.changes.length > 0) {
      if (!this._isPrimaryAdapter()) return; // Multiple editors, we are not first

      this._bumpVersion();
      this._connection.didChangeTextDocument({
        textDocument: this.getVersionedTextDocumentIdentifier(),
        contentChanges: event.changes.map(TextEditorSyncAdapter.textEditToContentChange).reverse()
      });
    }
  }

  // Public: Convert an Atom {TextEditEvent} to a language server {TextDocumentContentChangeEvent}
  // object.
  //
  // * `change` The Atom {TextEditEvent} to convert.
  //
  // Returns a {TextDocumentContentChangeEvent} that represents the converted {TextEditEvent}.
  static textEditToContentChange(change) {
    return {
      range: _convert2.default.atomRangeToLSRange(change.oldRange),
      rangeLength: change.oldText.length,
      text: change.newText
    };
  }

  _isPrimaryAdapter() {
    const lowestIdForBuffer = Math.min(...atom.workspace.getTextEditors().filter(t => t.getBuffer() === this._editor.getBuffer()).map(t => t.id));
    return lowestIdForBuffer === this._editor.id;
  }

  _bumpVersion() {
    const filePath = this._editor.getPath();
    if (filePath == null) return;
    this._versions.set(filePath, this._getVersion(filePath) + 1);
  }

  // Ensure when the document is opened we send notification to the language server
  // so it can load it in and keep track of diagnostics etc.
  didOpen() {
    const filePath = this._editor.getPath();
    if (filePath == null) return; // Not yet saved

    if (!this._isPrimaryAdapter()) return; // Multiple editors, we are not first

    this._connection.didOpenTextDocument({
      textDocument: {
        uri: this.getEditorUri(),
        languageId: this.getLanguageId().toLowerCase(),
        version: this._getVersion(filePath),
        text: this._editor.getText()
      }
    });
  }

  _getVersion(filePath) {
    return this._versions.get(filePath) || 1;
  }

  // Called when the {TextEditor} is closed and sends the 'didCloseTextDocument' notification to
  // the connected language server.
  didClose() {
    if (this._editor.getPath() == null) return; // Not yet saved

    const fileStillOpen = atom.workspace.getTextEditors().find(t => t.getBuffer() === this._editor.getBuffer());
    if (fileStillOpen) {
      return; // Other windows or editors still have this file open
    }

    this._connection.didCloseTextDocument({ textDocument: { uri: this.getEditorUri() } });
  }

  // Called when the {TextEditor} saves and sends the 'didSaveTextDocument' notification to
  // the connected language server.
  // Note: Right now this also sends the `didChangeWatchedFiles` notification as well but that
  // will be sent from elsewhere soon.
  didSave() {
    if (!this._isPrimaryAdapter()) return;

    const uri = this.getEditorUri();
    this._connection.didSaveTextDocument({ textDocument: { uri } });
    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri, type: _languageclient.FileChangeType.Changed }]
      });
    }
  }

  didRename() {
    if (!this._isPrimaryAdapter()) return;

    const oldUri = this._currentUri;
    this._currentUri = this.getEditorUri();
    if (!oldUri) {
      return; // Didn't previously have a name
    }

    this._connection.didCloseTextDocument({
      textDocument: { uri: oldUri }
    });

    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri: oldUri, type: _languageclient.FileChangeType.Deleted }, { uri: this._currentUri, type: _languageclient.FileChangeType.Created }]
      });
    }

    // Send an equivalent open event for this editor, which will now use the new
    // file path.
    this.didOpen();
  }

  // Public: Obtain the current {TextEditor} path and convert it to a Uri.
  getEditorUri() {
    return _convert2.default.pathToUri(this._editor.getPath() || '');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRG9jdW1lbnRTeW5jQWRhcHRlciIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiY2FuQWRhcHRWMiIsImNhbkFkYXB0VjMiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwiSW5jcmVtZW50YWwiLCJGdWxsIiwib3B0aW9ucyIsImNoYW5nZSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsImRvY3VtZW50U3luY0tpbmQiLCJlZGl0b3JTZWxlY3RvciIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvcnMiLCJXZWFrTWFwIiwiX3ZlcnNpb25zIiwiTWFwIiwiX2Nvbm5lY3Rpb24iLCJfZG9jdW1lbnRTeW5jS2luZCIsIl9lZGl0b3JTZWxlY3RvciIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvciIsImJpbmQiLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsInJlbW92ZSIsImhhcyIsIl9oYW5kbGVOZXdFZGl0b3IiLCJzeW5jIiwiZ2V0IiwiZGVsZXRlIiwiVGV4dEVkaXRvclN5bmNBZGFwdGVyIiwic2V0IiwiZGVzdHJveWVkU3luYyIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwidmVyc2lvbnMiLCJfZWRpdG9yIiwiX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMiLCJwcm9qZWN0Iiwib25EaWRDaGFuZ2VGaWxlcyIsImNoYW5nZVRyYWNraW5nIiwic2V0dXBDaGFuZ2VUcmFja2luZyIsIm9uRGlkU2F2ZSIsImRpZFNhdmUiLCJkaWRDbG9zZSIsIm9uRGlkQ2hhbmdlUGF0aCIsImRpZFJlbmFtZSIsIl9jdXJyZW50VXJpIiwiZ2V0RWRpdG9yVXJpIiwiZGlkT3BlbiIsIm9uRGlkQ2hhbmdlIiwic2VuZEZ1bGxDaGFuZ2VzIiwiZ2V0QnVmZmVyIiwib25EaWRDaGFuZ2VUZXh0Iiwic2VuZEluY3JlbWVudGFsQ2hhbmdlcyIsImdldExhbmd1YWdlSWQiLCJnZXRHcmFtbWFyIiwibmFtZSIsImdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJ1cmkiLCJ2ZXJzaW9uIiwiX2dldFZlcnNpb24iLCJnZXRQYXRoIiwiX2lzUHJpbWFyeUFkYXB0ZXIiLCJfYnVtcFZlcnNpb24iLCJkaWRDaGFuZ2VUZXh0RG9jdW1lbnQiLCJ0ZXh0RG9jdW1lbnQiLCJjb250ZW50Q2hhbmdlcyIsInRleHQiLCJnZXRUZXh0IiwiZXZlbnQiLCJjaGFuZ2VzIiwibGVuZ3RoIiwibWFwIiwidGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UiLCJyZXZlcnNlIiwicmFuZ2UiLCJhdG9tUmFuZ2VUb0xTUmFuZ2UiLCJvbGRSYW5nZSIsInJhbmdlTGVuZ3RoIiwib2xkVGV4dCIsIm5ld1RleHQiLCJsb3dlc3RJZEZvckJ1ZmZlciIsIk1hdGgiLCJtaW4iLCJ3b3Jrc3BhY2UiLCJnZXRUZXh0RWRpdG9ycyIsImZpbHRlciIsInQiLCJpZCIsImZpbGVQYXRoIiwiZGlkT3BlblRleHREb2N1bWVudCIsImxhbmd1YWdlSWQiLCJ0b0xvd2VyQ2FzZSIsImZpbGVTdGlsbE9wZW4iLCJmaW5kIiwiZGlkQ2xvc2VUZXh0RG9jdW1lbnQiLCJkaWRTYXZlVGV4dERvY3VtZW50IiwiZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzIiwidHlwZSIsIkNoYW5nZWQiLCJvbGRVcmkiLCJEZWxldGVkIiwiQ3JlYXRlZCIsInBhdGhUb1VyaSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7QUFTQTs7OztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0lBQ3FCQSxtQixHQUFOLE1BQU1BLG1CQUFOLENBQTBCOztBQVF2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsUUFBUCxDQUFnQkMsa0JBQWhCLEVBQWlF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QUFLdEQsV0FBcEI7QUFDQSxTQUFLQSxXQUFMLEdBQW1CLEtBQUtDLFlBQUwsRUFBbkI7QUFDQSxRQUFJLENBQUNxRCxNQUFMLEVBQWE7QUFDWCxhQURXLENBQ0g7QUFDVDs7QUFFRCxTQUFLNUYsV0FBTCxDQUFpQnVGLG9CQUFqQixDQUFzQztBQUNwQzlCLG9CQUFjLEVBQUNQLEtBQUswQyxNQUFOO0FBRHNCLEtBQXRDOztBQUlBLFFBQUksS0FBS2hFLDBCQUFULEVBQXFDO0FBQ25DLFdBQUs1QixXQUFMLENBQWlCeUYscUJBQWpCLENBQXVDO0FBQ3JDM0IsaUJBQVMsQ0FBQyxFQUFDWixLQUFLMEMsTUFBTixFQUFjRixNQUFNLCtCQUFlRyxPQUFuQyxFQUFELEVBQThDLEVBQUMzQyxLQUFLLEtBQUtaLFdBQVgsRUFBd0JvRCxNQUFNLCtCQUFlSSxPQUE3QyxFQUE5QztBQUQ0QixPQUF2QztBQUdEOztBQUVEO0FBQ0E7QUFDQSxTQUFLdEQsT0FBTDtBQUNEOztBQUVEO0FBQ0FELGlCQUF1QjtBQUNyQixXQUFPLGtCQUFRd0QsU0FBUixDQUFrQixLQUFLcEUsT0FBTCxDQUFhMEIsT0FBYixNQUEwQixFQUE1QyxDQUFQO0FBQ0Q7QUFuTnlCLEMiLCJmaWxlIjoiZG9jdW1lbnQtc3luYy1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7XHJcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIEZpbGVDaGFuZ2VUeXBlLFxyXG4gIFRleHREb2N1bWVudFN5bmNLaW5kLFxyXG4gIFRleHREb2N1bWVudFN5bmNPcHRpb25zLFxyXG4gIHR5cGUgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50LFxyXG4gIHR5cGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcixcclxuICB0eXBlIFNlcnZlckNhcGFiaWxpdGllcyxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQge0NvbXBvc2l0ZURpc3Bvc2FibGV9IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBTeW5jaHJvbml6ZXMgdGhlIGRvY3VtZW50cyBiZXR3ZWVuIEF0b20gYW5kIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYnkgbm90aWZ5aW5nXHJcbi8vIGVhY2ggZW5kIG9mIGNoYW5nZXMsIG9wZW5pbmcsIGNsb3NpbmcgYW5kIG90aGVyIGV2ZW50cyBhcyB3ZWxsIGFzIHNlbmRpbmcgYW5kIGFwcGx5aW5nXHJcbi8vIGNoYW5nZXMgZWl0aGVyIGluIHdob2xlIG9yIGluIHBhcnQgZGVwZW5kaW5nIG9uIHdoYXQgdGhlIGxhbmd1YWdlIHNlcnZlciBzdXBwb3J0cy5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRTeW5jQWRhcHRlciB7XHJcbiAgX2VkaXRvclNlbGVjdG9yOiBhdG9tJFRleHRFZGl0b3IgPT4gYm9vbGVhbjtcclxuICBfZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgX2RvY3VtZW50U3luY0tpbmQ6IG51bWJlcjtcclxuICBfZWRpdG9yczogV2Vha01hcDxhdG9tJFRleHRFZGl0b3IsIFRleHRFZGl0b3JTeW5jQWRhcHRlcj4gPSBuZXcgV2Vha01hcCgpO1xyXG4gIF9jb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb247XHJcbiAgX3ZlcnNpb25zOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IHRleHREb2N1bWVudFN5bmMgY2FwYWJpbGl0eSBlaXRoZXIgYmVpbmcgRnVsbCBvclxyXG4gIC8vIEluY3JlbWVudGFsLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmNhbkFkYXB0VjIoc2VydmVyQ2FwYWJpbGl0aWVzKSB8fCB0aGlzLmNhbkFkYXB0VjMoc2VydmVyQ2FwYWJpbGl0aWVzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYW5BZGFwdFYyKHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYyA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgfHxcclxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FuQWRhcHRWMyhzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHNlcnZlckNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgKG9wdGlvbnMuY2hhbmdlID09PSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCB8fCBvcHRpb25zLmNoYW5nZSA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIG5ldyB7RG9jdW1lbnRTeW5jQWRhcHRlcn0gZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gYmUga2VwdCBpbiBzeW5jLlxyXG4gIC8vICogYGRvY3VtZW50U3luY0tpbmRgIFRoZSB0eXBlIG9mIGRvY3VtZW50IHN5bmNpbmcgc3VwcG9ydGVkIC0gRnVsbCBvciBJbmNyZW1lbnRhbC5cclxuICAvLyAqIGBlZGl0b3JTZWxlY3RvcmAgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtUZXh0RWRpdG9yfSBhbmQgcmV0dXJucyBhIHtib29sZWFufVxyXG4gIC8vICAgICAgICAgICAgICAgICAgICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBhZGFwdGVyIHNob3VsZCBjYXJlIGFib3V0IHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdG9yLlxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZG9jdW1lbnRTeW5jS2luZDogPyhUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyB8IG51bWJlciksXHJcbiAgICBlZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW4sXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRTeW5jS2luZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCA9IGRvY3VtZW50U3luY0tpbmQ7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50U3luY0tpbmQgIT0gbnVsbCAmJiBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZSAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZWRpdG9yU2VsZWN0b3IgPSBlZGl0b3JTZWxlY3RvcjtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20udGV4dEVkaXRvcnMub2JzZXJ2ZSh0aGlzLm9ic2VydmVUZXh0RWRpdG9yLmJpbmQodGhpcykpKTtcclxuICB9XHJcblxyXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gRXhhbWluZSBhIHtUZXh0RWRpdG9yfSBhbmQgZGVjaWRlIGlmIHdlIHdpc2ggdG8gb2JzZXJ2ZSBpdC4gSWYgc28gZW5zdXJlIHRoYXQgd2Ugc3RvcCBvYnNlcnZpbmcgaXRcclxuICAvLyB3aGVuIGl0IGlzIGNsb3NlZCBvciBvdGhlcndpc2UgZGVzdHJveWVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0byBjb25zaWRlciBmb3Igb2JzZXJ2YXRpb24uXHJcbiAgb2JzZXJ2ZVRleHRFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gZWRpdG9yLm9ic2VydmVHcmFtbWFyKGdyYW1tYXIgPT4gdGhpcy5faGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3IpKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShsaXN0ZW5lcik7XHJcbiAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChsaXN0ZW5lcik7XHJcbiAgICBpZiAoIXRoaXMuX2VkaXRvcnMuaGFzKGVkaXRvcikgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xyXG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICBjb25zdCBzeW5jID0gdGhpcy5fZWRpdG9ycy5nZXQoZWRpdG9yKTtcclxuICAgIGlmIChzeW5jICE9IG51bGwgJiYgIXRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcclxuICAgICAgdGhpcy5fZWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUoc3luYyk7XHJcbiAgICAgIHN5bmMuZGlzcG9zZSgpO1xyXG4gICAgfSBlbHNlIGlmIChzeW5jID09IG51bGwgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xyXG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IHN5bmMgPSBuZXcgVGV4dEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvciwgdGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCwgdGhpcy5fdmVyc2lvbnMpO1xyXG4gICAgdGhpcy5fZWRpdG9ycy5zZXQoZWRpdG9yLCBzeW5jKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKHN5bmMpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlc3Ryb3llZFN5bmMgPSB0aGlzLl9lZGl0b3JzLmdldChlZGl0b3IpO1xyXG4gICAgICAgIGlmIChkZXN0cm95ZWRTeW5jKSB7XHJcbiAgICAgICAgICB0aGlzLl9lZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUoZGVzdHJveWVkU3luYyk7XHJcbiAgICAgICAgICBkZXN0cm95ZWRTeW5jLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogP1RleHRFZGl0b3JTeW5jQWRhcHRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9ycy5nZXQoZWRpdG9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFB1YmxpYzogS2VlcCBhIHNpbmdsZSB7VGV4dEVkaXRvcn0gaW4gc3luYyB3aXRoIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxyXG5jbGFzcyBUZXh0RWRpdG9yU3luY0FkYXB0ZXIge1xyXG4gIF9kaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICBfZWRpdG9yOiBhdG9tJFRleHRFZGl0b3I7XHJcbiAgX2N1cnJlbnRVcmk6IHN0cmluZztcclxuICBfY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uO1xyXG4gIF9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzOiBib29sZWFuO1xyXG4gIF92ZXJzaW9uczogTWFwPHN0cmluZywgbnVtYmVyPjtcclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dEVkaXRvclN5bmNBZGFwdGVyfSBpbiBzeW5jIHdpdGggYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRvIGtlZXAgaW4gc3luYy5cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHRvIGtlZXAgaW4gc3luYy5cclxuICAvLyAqIGBkb2N1bWVudFN5bmNLaW5kYCBXaGV0aGVyIHRvIHVzZSBGdWxsICgxKSBvciBJbmNyZW1lbnRhbCAoMikgd2hlbiBzZW5kaW5nIGNoYW5nZXMuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcixcclxuICAgIHZlcnNpb25zOiBNYXA8c3RyaW5nLCBudW1iZXI+LFxyXG4gICkge1xyXG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICB0aGlzLl92ZXJzaW9ucyA9IHZlcnNpb25zO1xyXG4gICAgdGhpcy5fZmFrZURpZENoYW5nZVdhdGNoZWRGaWxlcyA9IGF0b20ucHJvamVjdC5vbkRpZENoYW5nZUZpbGVzID09IG51bGw7XHJcblxyXG4gICAgY29uc3QgY2hhbmdlVHJhY2tpbmcgPSB0aGlzLnNldHVwQ2hhbmdlVHJhY2tpbmcoZG9jdW1lbnRTeW5jS2luZCk7XHJcbiAgICBpZiAoY2hhbmdlVHJhY2tpbmcgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChjaGFuZ2VUcmFja2luZyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGVkaXRvci5vbkRpZFNhdmUodGhpcy5kaWRTYXZlLmJpbmQodGhpcykpLFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KHRoaXMuZGlkQ2xvc2UuYmluZCh0aGlzKSksXHJcbiAgICAgIGVkaXRvci5vbkRpZENoYW5nZVBhdGgodGhpcy5kaWRSZW5hbWUuYmluZCh0aGlzKSksXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRVcmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xyXG4gICAgdGhpcy5kaWRPcGVuKCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgY2hhbmdlIHRyYWNraW5nIGRpc3Bvc2FibGUgbGlzdGVuZXIgdGhhdCB3aWxsIGVuc3VyZSB0aGF0IGNoYW5nZXMgYXJlIHNlbnQgdG8gdGhlXHJcbiAgLy8gbGFuZ3VhZ2Ugc2VydmVyIGFzIGFwcHJvcHJpYXRlLlxyXG4gIHNldHVwQ2hhbmdlVHJhY2tpbmcoZG9jdW1lbnRTeW5jS2luZDogbnVtYmVyKTogP0lEaXNwb3NhYmxlIHtcclxuICAgIHN3aXRjaCAoZG9jdW1lbnRTeW5jS2luZCkge1xyXG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRvci5vbkRpZENoYW5nZSh0aGlzLnNlbmRGdWxsQ2hhbmdlcy5iaW5kKHRoaXMpKTtcclxuICAgICAgY2FzZSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbDpcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpLm9uRGlkQ2hhbmdlVGV4dCh0aGlzLnNlbmRJbmNyZW1lbnRhbENoYW5nZXMuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBsYW5ndWFnZUlkIGZpZWxkIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYnkgc2ltcGx5XHJcbiAgLy8gdXNpbmcgdGhlIGdyYW1tYXIgbmFtZS5cclxuICBnZXRMYW5ndWFnZUlkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEdyYW1tYXIoKS5uYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gZm9yIHRoZSBkb2N1bWVudCBvYnNlcnZlZCBieVxyXG4gIC8vIHRoaXMgYWRhcHRlciBpbmNsdWRpbmcgYm90aCB0aGUgVXJpIGFuZCB0aGUgY3VycmVudCBWZXJzaW9uLlxyXG4gIGdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKTogVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCksXHJcbiAgICAgIHZlcnNpb246IHRoaXMuX2dldFZlcnNpb24odGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBTZW5kIHRoZSBlbnRpcmUgZG9jdW1lbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpcyB1c2VkIHdoZW5cclxuICAvLyBvcGVyYXRpbmcgaW4gRnVsbCAoMSkgc3luYyBtb2RlLlxyXG4gIHNlbmRGdWxsQ2hhbmdlcygpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSByZXR1cm47IC8vIE11bHRpcGxlIGVkaXRvcnMsIHdlIGFyZSBub3QgZmlyc3RcclxuXHJcbiAgICB0aGlzLl9idW1wVmVyc2lvbigpO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VUZXh0RG9jdW1lbnQoe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IHRoaXMuZ2V0VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcigpLFxyXG4gICAgICBjb250ZW50Q2hhbmdlczogW3t0ZXh0OiB0aGlzLl9lZGl0b3IuZ2V0VGV4dCgpfV0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogU2VuZCB0aGUgaW5jcmVtZW50YWwgdGV4dCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaXMgdXNlZFxyXG4gIC8vIHdoZW4gb3BlcmF0aW5nIGluIEluY3JlbWVudGFsICgyKSBzeW5jIG1vZGUuXHJcbiAgLy9cclxuICAvLyAqIGBldmVudGAgVGhlIGV2ZW50IGZpcmVkIGJ5IEF0b20gdG8gaW5kaWNhdGUgdGhlIGRvY3VtZW50IGhhcyBzdG9wcGVkIGNoYW5naW5nXHJcbiAgLy8gICAgICAgICAgIGluY2x1ZGluZyBhIGxpc3Qgb2YgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoaXMgZXZlbnQgZmlyZWQgZm9yIHRoaXNcclxuICAvLyAgICAgICAgICAgdGV4dCBlZGl0b3IuXHJcbiAgLy8gTm90ZTogVGhlIG9yZGVyIG9mIGNoYW5nZXMgaW4gdGhlIGV2ZW50IGlzIGd1YXJhbnRlZWQgdG9wIHRvIGJvdHRvbS4gIExhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGV4cGVjdHMgdGhpcyBpbiByZXZlcnNlLlxyXG4gIHNlbmRJbmNyZW1lbnRhbENoYW5nZXMoZXZlbnQ6IGF0b20kRGlkU3RvcENoYW5naW5nRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmIChldmVudC5jaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHJldHVybjsgLy8gTXVsdGlwbGUgZWRpdG9ycywgd2UgYXJlIG5vdCBmaXJzdFxyXG5cclxuICAgICAgdGhpcy5fYnVtcFZlcnNpb24oKTtcclxuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VUZXh0RG9jdW1lbnQoe1xyXG4gICAgICAgIHRleHREb2N1bWVudDogdGhpcy5nZXRWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKCksXHJcbiAgICAgICAgY29udGVudENoYW5nZXM6IGV2ZW50LmNoYW5nZXMubWFwKFRleHRFZGl0b3JTeW5jQWRhcHRlci50ZXh0RWRpdFRvQ29udGVudENoYW5nZSkucmV2ZXJzZSgpLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBBdG9tIHtUZXh0RWRpdEV2ZW50fSB0byBhIGxhbmd1YWdlIHNlcnZlciB7VGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50fVxyXG4gIC8vIG9iamVjdC5cclxuICAvL1xyXG4gIC8vICogYGNoYW5nZWAgVGhlIEF0b20ge1RleHRFZGl0RXZlbnR9IHRvIGNvbnZlcnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1RleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudH0gdGhhdCByZXByZXNlbnRzIHRoZSBjb252ZXJ0ZWQge1RleHRFZGl0RXZlbnR9LlxyXG4gIHN0YXRpYyB0ZXh0RWRpdFRvQ29udGVudENoYW5nZShjaGFuZ2U6IGF0b20kVGV4dEVkaXRFdmVudCk6IFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudCB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICByYW5nZTogQ29udmVydC5hdG9tUmFuZ2VUb0xTUmFuZ2UoY2hhbmdlLm9sZFJhbmdlKSxcclxuICAgICAgcmFuZ2VMZW5ndGg6IGNoYW5nZS5vbGRUZXh0Lmxlbmd0aCxcclxuICAgICAgdGV4dDogY2hhbmdlLm5ld1RleHQsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgX2lzUHJpbWFyeUFkYXB0ZXIoKTogYm9vbGVhbiB7XHJcbiAgICBjb25zdCBsb3dlc3RJZEZvckJ1ZmZlciA9IE1hdGgubWluKFxyXG4gICAgICAuLi5hdG9tLndvcmtzcGFjZVxyXG4gICAgICAgIC5nZXRUZXh0RWRpdG9ycygpXHJcbiAgICAgICAgLmZpbHRlcih0ID0+IHQuZ2V0QnVmZmVyKCkgPT09IHRoaXMuX2VkaXRvci5nZXRCdWZmZXIoKSlcclxuICAgICAgICAubWFwKHQgPT4gdC5pZCksXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIGxvd2VzdElkRm9yQnVmZmVyID09PSB0aGlzLl9lZGl0b3IuaWQ7XHJcbiAgfVxyXG5cclxuICBfYnVtcFZlcnNpb24oKTogdm9pZCB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IHRoaXMuX2VkaXRvci5nZXRQYXRoKCk7XHJcbiAgICBpZiAoZmlsZVBhdGggPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgdGhpcy5fdmVyc2lvbnMuc2V0KGZpbGVQYXRoLCB0aGlzLl9nZXRWZXJzaW9uKGZpbGVQYXRoKSArIDEpO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIHdoZW4gdGhlIGRvY3VtZW50IGlzIG9wZW5lZCB3ZSBzZW5kIG5vdGlmaWNhdGlvbiB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gc28gaXQgY2FuIGxvYWQgaXQgaW4gYW5kIGtlZXAgdHJhY2sgb2YgZGlhZ25vc3RpY3MgZXRjLlxyXG4gIGRpZE9wZW4oKTogdm9pZCB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IHRoaXMuX2VkaXRvci5nZXRQYXRoKCk7XHJcbiAgICBpZiAoZmlsZVBhdGggPT0gbnVsbCkgcmV0dXJuOyAvLyBOb3QgeWV0IHNhdmVkXHJcblxyXG4gICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHJldHVybjsgLy8gTXVsdGlwbGUgZWRpdG9ycywgd2UgYXJlIG5vdCBmaXJzdFxyXG5cclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkT3BlblRleHREb2N1bWVudCh7XHJcbiAgICAgIHRleHREb2N1bWVudDoge1xyXG4gICAgICAgIHVyaTogdGhpcy5nZXRFZGl0b3JVcmkoKSxcclxuICAgICAgICBsYW5ndWFnZUlkOiB0aGlzLmdldExhbmd1YWdlSWQoKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIHZlcnNpb246IHRoaXMuX2dldFZlcnNpb24oZmlsZVBhdGgpLFxyXG4gICAgICAgIHRleHQ6IHRoaXMuX2VkaXRvci5nZXRUZXh0KCksXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIF9nZXRWZXJzaW9uKGZpbGVQYXRoOiBzdHJpbmcpOiBudW1iZXIge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25zLmdldChmaWxlUGF0aCkgfHwgMTtcclxuICB9XHJcblxyXG4gIC8vIENhbGxlZCB3aGVuIHRoZSB7VGV4dEVkaXRvcn0gaXMgY2xvc2VkIGFuZCBzZW5kcyB0aGUgJ2RpZENsb3NlVGV4dERvY3VtZW50JyBub3RpZmljYXRpb24gdG9cclxuICAvLyB0aGUgY29ubmVjdGVkIGxhbmd1YWdlIHNlcnZlci5cclxuICBkaWRDbG9zZSgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9lZGl0b3IuZ2V0UGF0aCgpID09IG51bGwpIHJldHVybjsgLy8gTm90IHlldCBzYXZlZFxyXG5cclxuICAgIGNvbnN0IGZpbGVTdGlsbE9wZW4gPSBhdG9tLndvcmtzcGFjZS5nZXRUZXh0RWRpdG9ycygpLmZpbmQodCA9PiB0LmdldEJ1ZmZlcigpID09PSB0aGlzLl9lZGl0b3IuZ2V0QnVmZmVyKCkpO1xyXG4gICAgaWYgKGZpbGVTdGlsbE9wZW4pIHtcclxuICAgICAgcmV0dXJuOyAvLyBPdGhlciB3aW5kb3dzIG9yIGVkaXRvcnMgc3RpbGwgaGF2ZSB0aGlzIGZpbGUgb3BlblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2xvc2VUZXh0RG9jdW1lbnQoe3RleHREb2N1bWVudDoge3VyaTogdGhpcy5nZXRFZGl0b3JVcmkoKX19KTtcclxuICB9XHJcblxyXG4gIC8vIENhbGxlZCB3aGVuIHRoZSB7VGV4dEVkaXRvcn0gc2F2ZXMgYW5kIHNlbmRzIHRoZSAnZGlkU2F2ZVRleHREb2N1bWVudCcgbm90aWZpY2F0aW9uIHRvXHJcbiAgLy8gdGhlIGNvbm5lY3RlZCBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy8gTm90ZTogUmlnaHQgbm93IHRoaXMgYWxzbyBzZW5kcyB0aGUgYGRpZENoYW5nZVdhdGNoZWRGaWxlc2Agbm90aWZpY2F0aW9uIGFzIHdlbGwgYnV0IHRoYXRcclxuICAvLyB3aWxsIGJlIHNlbnQgZnJvbSBlbHNld2hlcmUgc29vbi5cclxuICBkaWRTYXZlKCk6IHZvaWQge1xyXG4gICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHJldHVybjtcclxuXHJcbiAgICBjb25zdCB1cmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRTYXZlVGV4dERvY3VtZW50KHt0ZXh0RG9jdW1lbnQ6IHt1cml9fSk7XHJcbiAgICBpZiAodGhpcy5fZmFrZURpZENoYW5nZVdhdGNoZWRGaWxlcykge1xyXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVdhdGNoZWRGaWxlcyh7XHJcbiAgICAgICAgY2hhbmdlczogW3t1cmksIHR5cGU6IEZpbGVDaGFuZ2VUeXBlLkNoYW5nZWR9XSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaWRSZW5hbWUoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2lzUHJpbWFyeUFkYXB0ZXIoKSkgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IG9sZFVyaSA9IHRoaXMuX2N1cnJlbnRVcmk7XHJcbiAgICB0aGlzLl9jdXJyZW50VXJpID0gdGhpcy5nZXRFZGl0b3JVcmkoKTtcclxuICAgIGlmICghb2xkVXJpKSB7XHJcbiAgICAgIHJldHVybjsgLy8gRGlkbid0IHByZXZpb3VzbHkgaGF2ZSBhIG5hbWVcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENsb3NlVGV4dERvY3VtZW50KHtcclxuICAgICAgdGV4dERvY3VtZW50OiB7dXJpOiBvbGRVcml9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMpIHtcclxuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VXYXRjaGVkRmlsZXMoe1xyXG4gICAgICAgIGNoYW5nZXM6IFt7dXJpOiBvbGRVcmksIHR5cGU6IEZpbGVDaGFuZ2VUeXBlLkRlbGV0ZWR9LCB7dXJpOiB0aGlzLl9jdXJyZW50VXJpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5DcmVhdGVkfV0sXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNlbmQgYW4gZXF1aXZhbGVudCBvcGVuIGV2ZW50IGZvciB0aGlzIGVkaXRvciwgd2hpY2ggd2lsbCBub3cgdXNlIHRoZSBuZXdcclxuICAgIC8vIGZpbGUgcGF0aC5cclxuICAgIHRoaXMuZGlkT3BlbigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIGN1cnJlbnQge1RleHRFZGl0b3J9IHBhdGggYW5kIGNvbnZlcnQgaXQgdG8gYSBVcmkuXHJcbiAgZ2V0RWRpdG9yVXJpKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gQ29udmVydC5wYXRoVG9VcmkodGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==