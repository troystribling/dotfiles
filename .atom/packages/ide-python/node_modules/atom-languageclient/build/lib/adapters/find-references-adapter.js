"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
/**
 * Public: Adapts the language server definition provider to the Atom IDE UI Definitions package for 'Go To Definition'
 * functionality.
 */
class FindReferencesAdapter {
    /**
     * Public: Determine whether this adapter can be used to adapt a language server based on the serverCapabilities
     * matrix containing a referencesProvider.
     *
     * @param serverCapabilities The {ServerCapabilities} of the language server to consider.
     * @returns A {Boolean} indicating adapter can adapt the server based on the given serverCapabilities.
     */
    static canAdapt(serverCapabilities) {
        return serverCapabilities.referencesProvider === true;
    }
    /**
     * Public: Get the references for a specific symbol within the document as represented by the {TextEditor} and {Point}
     * within it via the language server.
     *
     * @param connection A {LanguageClientConnection} to the language server that will be queried for the references.
     * @param editor The Atom {TextEditor} containing the text the references should relate to.
     * @param point The Atom {Point} containing the point within the text the references should relate to.
     * @returns A {Promise} containing a {FindReferencesReturn} with all the references the language server could find.
     */
    getReferences(connection, editor, point, projectRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const locations = yield connection.findReferences(FindReferencesAdapter.createReferenceParams(editor, point));
            if (locations == null) {
                return null;
            }
            const references = locations.map(FindReferencesAdapter.locationToReference);
            return {
                type: "data",
                baseUri: projectRoot || "",
                referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
                references,
            };
        });
    }
    /**
     * Public: Create a {ReferenceParams} from a given {TextEditor} for a specific {Point}.
     *
     * @param editor A {TextEditor} that represents the document.
     * @param point A {Point} within the document.
     * @returns A {ReferenceParams} built from the given parameters.
     */
    static createReferenceParams(editor, point) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            context: { includeDeclaration: true },
        };
    }
    /**
     * Public: Convert a {Location} into a {Reference}.
     *
     * @param location A {Location} to convert.
     * @returns A {Reference} equivalent to the given {Location}.
     */
    static locationToReference(location) {
        return {
            uri: convert_1.default.uriToPath(location.uri),
            name: null,
            range: convert_1.default.lsRangeToAtomRange(location.range),
        };
    }
    /** Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document. */
    static getReferencedSymbolName(editor, point, references) {
        if (references.length === 0) {
            return "";
        }
        const currentReference = references.find((r) => r.range.containsPoint(point)) || references[0];
        return editor.getBuffer().getTextInRange(currentReference.range);
    }
}
exports.default = FindReferencesAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFDQSx3Q0FBZ0M7QUFJaEM7OztHQUdHO0FBQ0gsTUFBcUIscUJBQXFCO0lBQ3hDOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE9BQU8sa0JBQWtCLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFBO0lBQ3ZELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNVLGFBQWEsQ0FDeEIsVUFBb0MsRUFDcEMsTUFBa0IsRUFDbEIsS0FBWSxFQUNaLFdBQTBCOztZQUUxQixNQUFNLFNBQVMsR0FBRyxNQUFNLFVBQVUsQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUE7WUFDN0csSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFO2dCQUNyQixPQUFPLElBQUksQ0FBQTthQUNaO1lBRUQsTUFBTSxVQUFVLEdBQXdCLFNBQVMsQ0FBQyxHQUFHLENBQUMscUJBQXFCLENBQUMsbUJBQW1CLENBQUMsQ0FBQTtZQUNoRyxPQUFPO2dCQUNMLElBQUksRUFBRSxNQUFNO2dCQUNaLE9BQU8sRUFBRSxXQUFXLElBQUksRUFBRTtnQkFDMUIsb0JBQW9CLEVBQUUscUJBQXFCLENBQUMsdUJBQXVCLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxVQUFVLENBQUM7Z0JBQzlGLFVBQVU7YUFDWCxDQUFBO1FBQ0gsQ0FBQztLQUFBO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLHFCQUFxQixDQUFDLE1BQWtCLEVBQUUsS0FBWTtRQUNsRSxPQUFPO1lBQ0wsWUFBWSxFQUFFLGlCQUFPLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDO1lBQzVELFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7WUFDeEMsT0FBTyxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFO1NBQ3RDLENBQUE7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBa0I7UUFDbEQsT0FBTztZQUNMLEdBQUcsRUFBRSxpQkFBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO1lBQ3BDLElBQUksRUFBRSxJQUFJO1lBQ1YsS0FBSyxFQUFFLGlCQUFPLENBQUMsa0JBQWtCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztTQUNsRCxDQUFBO0lBQ0gsQ0FBQztJQUVELDRGQUE0RjtJQUNyRixNQUFNLENBQUMsdUJBQXVCLENBQUMsTUFBa0IsRUFBRSxLQUFZLEVBQUUsVUFBK0I7UUFDckcsSUFBSSxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMzQixPQUFPLEVBQUUsQ0FBQTtTQUNWO1FBQ0QsTUFBTSxnQkFBZ0IsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQTtRQUM5RixPQUFPLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUE7SUFDbEUsQ0FBQztDQUNGO0FBOUVELHdDQThFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlICogYXMgYXRvbUlkZSBmcm9tIFwiYXRvbS1pZGUtYmFzZVwiXG5pbXBvcnQgQ29udmVydCBmcm9tIFwiLi4vY29udmVydFwiXG5pbXBvcnQgeyBQb2ludCwgVGV4dEVkaXRvciB9IGZyb20gXCJhdG9tXCJcbmltcG9ydCB7IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgTG9jYXRpb24sIFNlcnZlckNhcGFiaWxpdGllcywgUmVmZXJlbmNlUGFyYW1zIH0gZnJvbSBcIi4uL2xhbmd1YWdlY2xpZW50XCJcblxuLyoqXG4gKiBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJ1xuICogZnVuY3Rpb25hbGl0eS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmluZFJlZmVyZW5jZXNBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXNcbiAgICogbWF0cml4IGNvbnRhaW5pbmcgYSByZWZlcmVuY2VzUHJvdmlkZXIuXG4gICAqXG4gICAqIEBwYXJhbSBzZXJ2ZXJDYXBhYmlsaXRpZXMgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gICAqIEByZXR1cm5zIEEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGUgZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMucmVmZXJlbmNlc1Byb3ZpZGVyID09PSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBHZXQgdGhlIHJlZmVyZW5jZXMgZm9yIGEgc3BlY2lmaWMgc3ltYm9sIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXMgcmVwcmVzZW50ZWQgYnkgdGhlIHtUZXh0RWRpdG9yfSBhbmQge1BvaW50fVxuICAgKiB3aXRoaW4gaXQgdmlhIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZCBmb3IgdGhlIHJlZmVyZW5jZXMuXG4gICAqIEBwYXJhbSBlZGl0b3IgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cbiAgICogQHBhcmFtIHBvaW50IFRoZSBBdG9tIHtQb2ludH0gY29udGFpbmluZyB0aGUgcG9pbnQgd2l0aGluIHRoZSB0ZXh0IHRoZSByZWZlcmVuY2VzIHNob3VsZCByZWxhdGUgdG8uXG4gICAqIEByZXR1cm5zIEEge1Byb21pc2V9IGNvbnRhaW5pbmcgYSB7RmluZFJlZmVyZW5jZXNSZXR1cm59IHdpdGggYWxsIHRoZSByZWZlcmVuY2VzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgY291bGQgZmluZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRSZWZlcmVuY2VzKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IFBvaW50LFxuICAgIHByb2plY3RSb290OiBzdHJpbmcgfCBudWxsXG4gICk6IFByb21pc2U8YXRvbUlkZS5GaW5kUmVmZXJlbmNlc1JldHVybiB8IG51bGw+IHtcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBhd2FpdCBjb25uZWN0aW9uLmZpbmRSZWZlcmVuY2VzKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5jcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yLCBwb2ludCkpXG4gICAgaWYgKGxvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHJlZmVyZW5jZXM6IGF0b21JZGUuUmVmZXJlbmNlW10gPSBsb2NhdGlvbnMubWFwKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5sb2NhdGlvblRvUmVmZXJlbmNlKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFcIixcbiAgICAgIGJhc2VVcmk6IHByb2plY3RSb290IHx8IFwiXCIsXG4gICAgICByZWZlcmVuY2VkU3ltYm9sTmFtZTogRmluZFJlZmVyZW5jZXNBZGFwdGVyLmdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKGVkaXRvciwgcG9pbnQsIHJlZmVyZW5jZXMpLFxuICAgICAgcmVmZXJlbmNlcyxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVibGljOiBDcmVhdGUgYSB7UmVmZXJlbmNlUGFyYW1zfSBmcm9tIGEgZ2l2ZW4ge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0uXG4gICAqXG4gICAqIEBwYXJhbSBlZGl0b3IgQSB7VGV4dEVkaXRvcn0gdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudC5cbiAgICogQHBhcmFtIHBvaW50IEEge1BvaW50fSB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICAgKiBAcmV0dXJucyBBIHtSZWZlcmVuY2VQYXJhbXN9IGJ1aWx0IGZyb20gdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNyZWF0ZVJlZmVyZW5jZVBhcmFtcyhlZGl0b3I6IFRleHRFZGl0b3IsIHBvaW50OiBQb2ludCk6IFJlZmVyZW5jZVBhcmFtcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcbiAgICAgIHBvc2l0aW9uOiBDb252ZXJ0LnBvaW50VG9Qb3NpdGlvbihwb2ludCksXG4gICAgICBjb250ZXh0OiB7IGluY2x1ZGVEZWNsYXJhdGlvbjogdHJ1ZSB9LFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWM6IENvbnZlcnQgYSB7TG9jYXRpb259IGludG8gYSB7UmVmZXJlbmNlfS5cbiAgICpcbiAgICogQHBhcmFtIGxvY2F0aW9uIEEge0xvY2F0aW9ufSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyBBIHtSZWZlcmVuY2V9IGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHtMb2NhdGlvbn0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGxvY2F0aW9uVG9SZWZlcmVuY2UobG9jYXRpb246IExvY2F0aW9uKTogYXRvbUlkZS5SZWZlcmVuY2Uge1xuICAgIHJldHVybiB7XG4gICAgICB1cmk6IENvbnZlcnQudXJpVG9QYXRoKGxvY2F0aW9uLnVyaSksXG4gICAgICBuYW1lOiBudWxsLFxuICAgICAgcmFuZ2U6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGxvY2F0aW9uLnJhbmdlKSxcbiAgICB9XG4gIH1cblxuICAvKiogUHVibGljOiBHZXQgYSBzeW1ib2wgbmFtZSBmcm9tIGEge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0gaW4gdGhlIGRvY3VtZW50LiAqL1xuICBwdWJsaWMgc3RhdGljIGdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKGVkaXRvcjogVGV4dEVkaXRvciwgcG9pbnQ6IFBvaW50LCByZWZlcmVuY2VzOiBhdG9tSWRlLlJlZmVyZW5jZVtdKTogc3RyaW5nIHtcbiAgICBpZiAocmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiXG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRSZWZlcmVuY2UgPSByZWZlcmVuY2VzLmZpbmQoKHIpID0+IHIucmFuZ2UuY29udGFpbnNQb2ludChwb2ludCkpIHx8IHJlZmVyZW5jZXNbMF1cbiAgICByZXR1cm4gZWRpdG9yLmdldEJ1ZmZlcigpLmdldFRleHRJblJhbmdlKGN1cnJlbnRSZWZlcmVuY2UucmFuZ2UpXG4gIH1cbn1cbiJdfQ==