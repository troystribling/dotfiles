Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
let FindReferencesAdapter = class FindReferencesAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a referencesProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.referencesProvider === true;
  }

  // Public: Get the references for a specific symbol within the document as represented by
  // the {TextEditor} and {Point} within it via the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the references.
  // * `editor` The Atom {TextEditor} containing the text the references should relate to.
  // * `point` The Atom {Point} containing the point within the text the references should relate to.
  //
  // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
  // could find.
  getReferences(connection, editor, point, projectRoot) {
    return _asyncToGenerator(function* () {
      const locations = yield connection.findReferences(FindReferencesAdapter.createTextDocumentPositionParams(editor, point));
      if (locations == null) {
        return null;
      }

      const references = locations.map(FindReferencesAdapter.locationToReference);
      return {
        type: 'data',
        baseUri: projectRoot || '',
        referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
        references
      };
    })();
  }

  // Public: Create a {TextDocumentPositionParams} from a given {TextEditor} for a specific {Point}.
  //
  // * `editor` A {TextEditor} that represents the document.
  // * `point` A {Point} within the document.
  //
  // Returns a {DocumentPositionParams} built from the given parameters.
  static createTextDocumentPositionParams(editor, point) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      position: _convert2.default.pointToPosition(point),
      context: { includeDeclaration: true }
    };
  }

  // Public: Convert a {Location} into a {Reference}.
  //
  // * `location` A {Location} to convert.
  //
  // Returns a {Reference} equivalent to the given {Location}.
  static locationToReference(location) {
    return {
      uri: _convert2.default.uriToPath(location.uri),
      name: null,
      range: _convert2.default.lsRangeToAtomRange(location.range)
    };
  }

  // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
  static getReferencedSymbolName(editor, point, references) {
    if (references.length === 0) {
      return '';
    }
    const currentReference = references.find(r => r.range.containsPoint(point)) || references[0];
    return editor.getBuffer().getTextInRange(currentReference.range);
  }
};
exports.default = FindReferencesAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9maW5kLXJlZmVyZW5jZXMtYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJGaW5kUmVmZXJlbmNlc0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsInJlZmVyZW5jZXNQcm92aWRlciIsImdldFJlZmVyZW5jZXMiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicG9pbnQiLCJwcm9qZWN0Um9vdCIsImxvY2F0aW9ucyIsImZpbmRSZWZlcmVuY2VzIiwiY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJyZWZlcmVuY2VzIiwibWFwIiwibG9jYXRpb25Ub1JlZmVyZW5jZSIsInR5cGUiLCJiYXNlVXJpIiwicmVmZXJlbmNlZFN5bWJvbE5hbWUiLCJnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZSIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInBvc2l0aW9uIiwicG9pbnRUb1Bvc2l0aW9uIiwiY29udGV4dCIsImluY2x1ZGVEZWNsYXJhdGlvbiIsImxvY2F0aW9uIiwidXJpIiwidXJpVG9QYXRoIiwibmFtZSIsInJhbmdlIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwibGVuZ3RoIiwiY3VycmVudFJlZmVyZW5jZSIsImZpbmQiLCJyIiwiY29udGFpbnNQb2ludCIsImdldEJ1ZmZlciIsImdldFRleHRJblJhbmdlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBOztBQU1BOzs7Ozs7OztBQUVBO0FBQ0E7SUFDcUJBLHFCLEdBQU4sTUFBTUEscUJBQU4sQ0FBNEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxrQkFBbkIsS0FBMEMsSUFBakQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNQyxlQUFOLENBQ0VDLFVBREYsRUFFRUMsTUFGRixFQUdFQyxLQUhGLEVBSUVDLFdBSkYsRUFLMEM7QUFBQTtBQUN4QyxZQUFNQyxZQUFZLE1BQU1KLFdBQVdLLGNBQVgsQ0FDdEJWLHNCQUFzQlcsZ0NBQXRCLENBQXVETCxNQUF2RCxFQUErREMsS0FBL0QsQ0FEc0IsQ0FBeEI7QUFHQSxVQUFJRSxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCLGVBQU8sSUFBUDtBQUNEOztBQUVELFlBQU1HLGFBQWFILFVBQVVJLEdBQVYsQ0FBY2Isc0JBQXNCYyxtQkFBcEMsQ0FBbkI7QUFDQSxhQUFPO0FBQ0xDLGNBQU0sTUFERDtBQUVMQyxpQkFBU1IsZUFBZSxFQUZuQjtBQUdMUyw4QkFBc0JqQixzQkFBc0JrQix1QkFBdEIsQ0FBOENaLE1BQTlDLEVBQXNEQyxLQUF0RCxFQUE2REssVUFBN0QsQ0FIakI7QUFJTEE7QUFKSyxPQUFQO0FBVHdDO0FBZXpDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9ELGdDQUFQLENBQXdDTCxNQUF4QyxFQUFpRUMsS0FBakUsRUFBZ0g7QUFDOUcsV0FBTztBQUNMWSxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNkLE1BQXZDLENBRFQ7QUFFTGUsZ0JBQVUsa0JBQVFDLGVBQVIsQ0FBd0JmLEtBQXhCLENBRkw7QUFHTGdCLGVBQVMsRUFBQ0Msb0JBQW9CLElBQXJCO0FBSEosS0FBUDtBQUtEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPVixtQkFBUCxDQUEyQlcsUUFBM0IsRUFBa0U7QUFDaEUsV0FBTztBQUNMQyxXQUFLLGtCQUFRQyxTQUFSLENBQWtCRixTQUFTQyxHQUEzQixDQURBO0FBRUxFLFlBQU0sSUFGRDtBQUdMQyxhQUFPLGtCQUFRQyxrQkFBUixDQUEyQkwsU0FBU0ksS0FBcEM7QUFIRixLQUFQO0FBS0Q7O0FBRUQ7QUFDQSxTQUFPWCx1QkFBUCxDQUNFWixNQURGLEVBRUVDLEtBRkYsRUFHRUssVUFIRixFQUlVO0FBQ1IsUUFBSUEsV0FBV21CLE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0IsYUFBTyxFQUFQO0FBQ0Q7QUFDRCxVQUFNQyxtQkFBbUJwQixXQUFXcUIsSUFBWCxDQUFnQkMsS0FBS0EsRUFBRUwsS0FBRixDQUFRTSxhQUFSLENBQXNCNUIsS0FBdEIsQ0FBckIsS0FBc0RLLFdBQVcsQ0FBWCxDQUEvRTtBQUNBLFdBQU9OLE9BQU84QixTQUFQLEdBQW1CQyxjQUFuQixDQUFrQ0wsaUJBQWlCSCxLQUFuRCxDQUFQO0FBQ0Q7QUFsRndDLEM7a0JBQXRCN0IscUIiLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgdHlwZSBMb2NhdGlvbixcclxuICB0eXBlIFNlcnZlckNhcGFiaWxpdGllcyxcclxuICB0eXBlIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXHJcbi8vIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJyBmdW5jdGlvbmFsaXR5LlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIHJlZmVyZW5jZXNQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLnJlZmVyZW5jZXNQcm92aWRlciA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogR2V0IHRoZSByZWZlcmVuY2VzIGZvciBhIHNwZWNpZmljIHN5bWJvbCB3aXRoaW4gdGhlIGRvY3VtZW50IGFzIHJlcHJlc2VudGVkIGJ5XHJcbiAgLy8gdGhlIHtUZXh0RWRpdG9yfSBhbmQge1BvaW50fSB3aXRoaW4gaXQgdmlhIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcclxuICAvLyAgICAgICAgICAgICAgICBmb3IgdGhlIHJlZmVyZW5jZXMuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxyXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIGEge0ZpbmRSZWZlcmVuY2VzUmV0dXJufSB3aXRoIGFsbCB0aGUgcmVmZXJlbmNlcyB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gY291bGQgZmluZC5cclxuICBhc3luYyBnZXRSZWZlcmVuY2VzKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogYXRvbSRQb2ludCxcclxuICAgIHByb2plY3RSb290OiA/c3RyaW5nLFxyXG4gICk6IFByb21pc2U8P2F0b21JZGUkRmluZFJlZmVyZW5jZXNSZXR1cm4+IHtcclxuICAgIGNvbnN0IGxvY2F0aW9ucyA9IGF3YWl0IGNvbm5lY3Rpb24uZmluZFJlZmVyZW5jZXMoXHJcbiAgICAgIEZpbmRSZWZlcmVuY2VzQWRhcHRlci5jcmVhdGVUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvaW50KSxcclxuICAgICk7XHJcbiAgICBpZiAobG9jYXRpb25zID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IGxvY2F0aW9ucy5tYXAoRmluZFJlZmVyZW5jZXNBZGFwdGVyLmxvY2F0aW9uVG9SZWZlcmVuY2UpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogJ2RhdGEnLFxyXG4gICAgICBiYXNlVXJpOiBwcm9qZWN0Um9vdCB8fCAnJyxcclxuICAgICAgcmVmZXJlbmNlZFN5bWJvbE5hbWU6IEZpbmRSZWZlcmVuY2VzQWRhcHRlci5nZXRSZWZlcmVuY2VkU3ltYm9sTmFtZShlZGl0b3IsIHBvaW50LCByZWZlcmVuY2VzKSxcclxuICAgICAgcmVmZXJlbmNlcyxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIHtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc30gZnJvbSBhIGdpdmVuIHtUZXh0RWRpdG9yfSBmb3IgYSBzcGVjaWZpYyB7UG9pbnR9LlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50LlxyXG4gIC8vICogYHBvaW50YCBBIHtQb2ludH0gd2l0aGluIHRoZSBkb2N1bWVudC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7RG9jdW1lbnRQb3NpdGlvblBhcmFtc30gYnVpbHQgZnJvbSB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cclxuICBzdGF0aWMgY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHBvaW50OiBhdG9tJFBvaW50KTogVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxyXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocG9pbnQpLFxyXG4gICAgICBjb250ZXh0OiB7aW5jbHVkZURlY2xhcmF0aW9uOiB0cnVlfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSB7TG9jYXRpb259IGludG8gYSB7UmVmZXJlbmNlfS5cclxuICAvL1xyXG4gIC8vICogYGxvY2F0aW9uYCBBIHtMb2NhdGlvbn0gdG8gY29udmVydC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UmVmZXJlbmNlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7TG9jYXRpb259LlxyXG4gIHN0YXRpYyBsb2NhdGlvblRvUmVmZXJlbmNlKGxvY2F0aW9uOiBMb2NhdGlvbik6IGF0b21JZGUkUmVmZXJlbmNlIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVyaTogQ29udmVydC51cmlUb1BhdGgobG9jYXRpb24udXJpKSxcclxuICAgICAgbmFtZTogbnVsbCxcclxuICAgICAgcmFuZ2U6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGxvY2F0aW9uLnJhbmdlKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCBhIHN5bWJvbCBuYW1lIGZyb20gYSB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fSBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgc3RhdGljIGdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKFxyXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogYXRvbSRQb2ludCxcclxuICAgIHJlZmVyZW5jZXM6IEFycmF5PGF0b21JZGUkUmVmZXJlbmNlPixcclxuICApOiBzdHJpbmcge1xyXG4gICAgaWYgKHJlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGNvbnN0IGN1cnJlbnRSZWZlcmVuY2UgPSByZWZlcmVuY2VzLmZpbmQociA9PiByLnJhbmdlLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB8fCByZWZlcmVuY2VzWzBdO1xyXG4gICAgcmV0dXJuIGVkaXRvci5nZXRCdWZmZXIoKS5nZXRUZXh0SW5SYW5nZShjdXJyZW50UmVmZXJlbmNlLnJhbmdlKTtcclxuICB9XHJcbn1cclxuIl19