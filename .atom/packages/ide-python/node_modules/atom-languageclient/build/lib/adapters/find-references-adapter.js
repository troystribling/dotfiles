"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class FindReferencesAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a referencesProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.referencesProvider === true;
    }
    // Public: Get the references for a specific symbol within the document as represented by
    // the {TextEditor} and {Point} within it via the language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the references.
    // * `editor` The Atom {TextEditor} containing the text the references should relate to.
    // * `point` The Atom {Point} containing the point within the text the references should relate to.
    //
    // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
    // could find.
    getReferences(connection, editor, point, projectRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const locations = yield connection.findReferences(FindReferencesAdapter.createReferenceParams(editor, point));
            if (locations == null) {
                return null;
            }
            const references = locations.map(FindReferencesAdapter.locationToReference);
            return {
                type: 'data',
                baseUri: projectRoot || '',
                referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
                references,
            };
        });
    }
    // Public: Create a {ReferenceParams} from a given {TextEditor} for a specific {Point}.
    //
    // * `editor` A {TextEditor} that represents the document.
    // * `point` A {Point} within the document.
    //
    // Returns a {ReferenceParams} built from the given parameters.
    static createReferenceParams(editor, point) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            context: { includeDeclaration: true },
        };
    }
    // Public: Convert a {Location} into a {Reference}.
    //
    // * `location` A {Location} to convert.
    //
    // Returns a {Reference} equivalent to the given {Location}.
    static locationToReference(location) {
        return {
            uri: convert_1.default.uriToPath(location.uri),
            name: null,
            range: convert_1.default.lsRangeToAtomRange(location.range),
        };
    }
    // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
    static getReferencedSymbolName(editor, point, references) {
        if (references.length === 0) {
            return '';
        }
        const currentReference = references.find((r) => r.range.containsPoint(point)) || references[0];
        return editor.getBuffer().getTextInRange(currentReference.range);
    }
}
exports.default = FindReferencesAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQVlqQyxnRUFBZ0U7QUFDaEUsd0VBQXdFO0FBQ3hFLE1BQXFCLHFCQUFxQjtJQUN4QyxnRkFBZ0Y7SUFDaEYsMEVBQTBFO0lBQzFFLEVBQUU7SUFDRixzRkFBc0Y7SUFDdEYsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSw0QkFBNEI7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsT0FBTyxrQkFBa0IsQ0FBQyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7SUFDeEQsQ0FBQztJQUVELHlGQUF5RjtJQUN6RixrRUFBa0U7SUFDbEUsRUFBRTtJQUNGLDBGQUEwRjtJQUMxRixxQ0FBcUM7SUFDckMsd0ZBQXdGO0lBQ3hGLG1HQUFtRztJQUNuRyxFQUFFO0lBQ0Ysc0dBQXNHO0lBQ3RHLGNBQWM7SUFDRCxhQUFhLENBQ3hCLFVBQW9DLEVBQ3BDLE1BQWtCLEVBQ2xCLEtBQVksRUFDWixXQUEwQjs7WUFFMUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxVQUFVLENBQUMsY0FBYyxDQUMvQyxxQkFBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQzNELENBQUM7WUFDRixJQUFJLFNBQVMsSUFBSSxJQUFJLEVBQUU7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDO2FBQ2I7WUFFRCxNQUFNLFVBQVUsR0FBd0IsU0FBUyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2pHLE9BQU87Z0JBQ0wsSUFBSSxFQUFFLE1BQU07Z0JBQ1osT0FBTyxFQUFFLFdBQVcsSUFBSSxFQUFFO2dCQUMxQixvQkFBb0IsRUFBRSxxQkFBcUIsQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQztnQkFDOUYsVUFBVTthQUNYLENBQUM7UUFDSixDQUFDO0tBQUE7SUFFRCx1RkFBdUY7SUFDdkYsRUFBRTtJQUNGLDBEQUEwRDtJQUMxRCwyQ0FBMkM7SUFDM0MsRUFBRTtJQUNGLCtEQUErRDtJQUN4RCxNQUFNLENBQUMscUJBQXFCLENBQUMsTUFBa0IsRUFBRSxLQUFZO1FBQ2xFLE9BQU87WUFDTCxZQUFZLEVBQUUsaUJBQU8sQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUM7WUFDNUQsUUFBUSxFQUFFLGlCQUFPLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQztZQUN4QyxPQUFPLEVBQUUsRUFBQyxrQkFBa0IsRUFBRSxJQUFJLEVBQUM7U0FDcEMsQ0FBQztJQUNKLENBQUM7SUFFRCxtREFBbUQ7SUFDbkQsRUFBRTtJQUNGLHdDQUF3QztJQUN4QyxFQUFFO0lBQ0YsNERBQTREO0lBQ3JELE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxRQUFrQjtRQUNsRCxPQUFPO1lBQ0wsR0FBRyxFQUFFLGlCQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUM7WUFDcEMsSUFBSSxFQUFFLElBQUk7WUFDVixLQUFLLEVBQUUsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1NBQ2xELENBQUM7SUFDSixDQUFDO0lBRUQsd0ZBQXdGO0lBQ2pGLE1BQU0sQ0FBQyx1QkFBdUIsQ0FDbkMsTUFBa0IsRUFDbEIsS0FBWSxFQUNaLFVBQStCO1FBRS9CLElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDM0IsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUNELE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0YsT0FBTyxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ25FLENBQUM7Q0FDRjtBQW5GRCx3Q0FtRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcbmltcG9ydCB7XHJcbiAgUG9pbnQsXHJcbiAgVGV4dEVkaXRvcixcclxufSBmcm9tICdhdG9tJztcclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgTG9jYXRpb24sXHJcbiAgU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG4gIFJlZmVyZW5jZVBhcmFtcyxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXHJcbi8vIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJyBmdW5jdGlvbmFsaXR5LlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIHJlZmVyZW5jZXNQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5yZWZlcmVuY2VzUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCB0aGUgcmVmZXJlbmNlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgd2l0aGluIHRoZSBkb2N1bWVudCBhcyByZXByZXNlbnRlZCBieVxyXG4gIC8vIHRoZSB7VGV4dEVkaXRvcn0gYW5kIHtQb2ludH0gd2l0aGluIGl0IHZpYSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXHJcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSByZWZlcmVuY2VzLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cclxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb2ludCB3aXRoaW4gdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyBhIHtGaW5kUmVmZXJlbmNlc1JldHVybn0gd2l0aCBhbGwgdGhlIHJlZmVyZW5jZXMgdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGNvdWxkIGZpbmQuXHJcbiAgcHVibGljIGFzeW5jIGdldFJlZmVyZW5jZXMoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogUG9pbnQsXHJcbiAgICBwcm9qZWN0Um9vdDogc3RyaW5nIHwgbnVsbCxcclxuICApOiBQcm9taXNlPGF0b21JZGUuRmluZFJlZmVyZW5jZXNSZXR1cm4gfCBudWxsPiB7XHJcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBhd2FpdCBjb25uZWN0aW9uLmZpbmRSZWZlcmVuY2VzKFxyXG4gICAgICBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIuY3JlYXRlUmVmZXJlbmNlUGFyYW1zKGVkaXRvciwgcG9pbnQpLFxyXG4gICAgKTtcclxuICAgIGlmIChsb2NhdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWZlcmVuY2VzOiBhdG9tSWRlLlJlZmVyZW5jZVtdID0gbG9jYXRpb25zLm1hcChGaW5kUmVmZXJlbmNlc0FkYXB0ZXIubG9jYXRpb25Ub1JlZmVyZW5jZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiAnZGF0YScsXHJcbiAgICAgIGJhc2VVcmk6IHByb2plY3RSb290IHx8ICcnLFxyXG4gICAgICByZWZlcmVuY2VkU3ltYm9sTmFtZTogRmluZFJlZmVyZW5jZXNBZGFwdGVyLmdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKGVkaXRvciwgcG9pbnQsIHJlZmVyZW5jZXMpLFxyXG4gICAgICByZWZlcmVuY2VzLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1JlZmVyZW5jZVBhcmFtc30gZnJvbSBhIGdpdmVuIHtUZXh0RWRpdG9yfSBmb3IgYSBzcGVjaWZpYyB7UG9pbnR9LlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50LlxyXG4gIC8vICogYHBvaW50YCBBIHtQb2ludH0gd2l0aGluIHRoZSBkb2N1bWVudC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UmVmZXJlbmNlUGFyYW1zfSBidWlsdCBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlUmVmZXJlbmNlUGFyYW1zKGVkaXRvcjogVGV4dEVkaXRvciwgcG9pbnQ6IFBvaW50KTogUmVmZXJlbmNlUGFyYW1zIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcclxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHBvaW50KSxcclxuICAgICAgY29udGV4dDoge2luY2x1ZGVEZWNsYXJhdGlvbjogdHJ1ZX0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEge0xvY2F0aW9ufSBpbnRvIGEge1JlZmVyZW5jZX0uXHJcbiAgLy9cclxuICAvLyAqIGBsb2NhdGlvbmAgQSB7TG9jYXRpb259IHRvIGNvbnZlcnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1JlZmVyZW5jZX0gZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4ge0xvY2F0aW9ufS5cclxuICBwdWJsaWMgc3RhdGljIGxvY2F0aW9uVG9SZWZlcmVuY2UobG9jYXRpb246IExvY2F0aW9uKTogYXRvbUlkZS5SZWZlcmVuY2Uge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdXJpOiBDb252ZXJ0LnVyaVRvUGF0aChsb2NhdGlvbi51cmkpLFxyXG4gICAgICBuYW1lOiBudWxsLFxyXG4gICAgICByYW5nZTogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UobG9jYXRpb24ucmFuZ2UpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogR2V0IGEgc3ltYm9sIG5hbWUgZnJvbSBhIHtUZXh0RWRpdG9yfSBmb3IgYSBzcGVjaWZpYyB7UG9pbnR9IGluIHRoZSBkb2N1bWVudC5cclxuICBwdWJsaWMgc3RhdGljIGdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKFxyXG4gICAgZWRpdG9yOiBUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IFBvaW50LFxyXG4gICAgcmVmZXJlbmNlczogYXRvbUlkZS5SZWZlcmVuY2VbXSxcclxuICApOiBzdHJpbmcge1xyXG4gICAgaWYgKHJlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGNvbnN0IGN1cnJlbnRSZWZlcmVuY2UgPSByZWZlcmVuY2VzLmZpbmQoKHIpID0+IHIucmFuZ2UuY29udGFpbnNQb2ludChwb2ludCkpIHx8IHJlZmVyZW5jZXNbMF07XHJcbiAgICByZXR1cm4gZWRpdG9yLmdldEJ1ZmZlcigpLmdldFRleHRJblJhbmdlKGN1cnJlbnRSZWZlcmVuY2UucmFuZ2UpO1xyXG4gIH1cclxufVxyXG4iXX0=