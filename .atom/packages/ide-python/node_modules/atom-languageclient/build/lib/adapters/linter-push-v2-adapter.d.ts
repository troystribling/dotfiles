import * as linter from "atom/linter";
import { Diagnostic, LanguageClientConnection, PublishDiagnosticsParams } from "../languageclient";
/**
 * Public: Listen to diagnostics messages from the language server and publish them to the user by way of the Linter
 * Push (Indie) v2 API provided by the Base Linter package.
 */
export default class LinterPushV2Adapter {
    protected _diagnosticMap: Map<string, linter.Message[]>;
    /**
     * A map from file path {linter.Message["location"]["file"]} to a Map of all Message keys to Diagnostics
     * ${Map<linter.Message["key"], Diagnostic>} It has to be stored separately because a {Message} object cannot hold all
     * of the information that a {Diagnostic} provides, thus we store the original {Diagnostic} object.
     */
    protected _lsDiagnosticMap: Map<linter.Message["location"]["file"], Map<linter.Message["key"], Diagnostic>>;
    protected _indies: Set<linter.IndieDelegate>;
    /**
     * Public: Create a new {LinterPushV2Adapter} that will listen for diagnostics via the supplied {LanguageClientConnection}.
     *
     * @param connection A {LanguageClientConnection} to the language server that will provide diagnostics.
     */
    constructor(connection: LanguageClientConnection);
    /** Dispose this adapter ensuring any resources are freed and events unhooked. */
    dispose(): void;
    /**
     * Public: Attach this {LinterPushV2Adapter} to a given {V2IndieDelegate} registry.
     *
     * @param indie A {V2IndieDelegate} that wants to receive messages.
     */
    attach(indie: linter.IndieDelegate): void;
    /** Public: Remove all {V2IndieDelegate} registries attached to this adapter and clear them. */
    detachAll(): void;
    /**
     * Public: Capture the diagnostics sent from a langguage server, convert them to the Linter V2 format and forward them
     * on to any attached {V2IndieDelegate}s.
     *
     * @param params The {PublishDiagnosticsParams} received from the language server that should be captured and
     *   forwarded on to any attached {V2IndieDelegate}s.
     */
    captureDiagnostics(params: PublishDiagnosticsParams): void;
    /**
     * Public: Convert a single {Diagnostic} received from a language server into a single {V2Message} expected by the
     * Linter V2 API.
     *
     * @param path A string representing the path of the file the diagnostic belongs to.
     * @param diagnostics A {Diagnostic} object received from the language server.
     * @returns A {V2Message} equivalent to the {Diagnostic} object supplied by the language server.
     */
    diagnosticToV2Message(path: string, diagnostic: Diagnostic): linter.Message;
    /**
     * Public: get diagnostics for the given linter messages
     *
     * @param linterMessages An array of linter {V2Message}
     * @returns An array of LS {Diagnostic[]}
     */
    getLSDiagnosticsForMessages(linterMessages: linter.Message[]): Diagnostic[];
    /**
     * Public: Get the {Diagnostic} that is associated with the given Base Linter v2 {Message}.
     *
     * @param message The {Message} object to fetch the {Diagnostic} for.
     * @returns The associated {Diagnostic}.
     */
    getLSDiagnosticForMessage(message: linter.Message): Diagnostic | undefined;
    /**
     * Public: Convert a diagnostic severity number obtained from the language server into the textual equivalent for a
     * Linter {V2Message}.
     *
     * @param severity A number representing the severity of the diagnostic.
     * @returns A string of 'error', 'warning' or 'info' depending on the severity.
     */
    static diagnosticSeverityToSeverity(severity: number): "error" | "warning" | "info";
}
