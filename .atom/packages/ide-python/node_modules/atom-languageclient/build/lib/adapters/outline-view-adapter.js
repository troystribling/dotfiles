Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  async getOutline(connection, editor) {
    const results = await connection.documentSymbol({
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor)
    });
    results.sort((a, b) => a.location.range.start.line === b.location.range.start.line ? a.location.range.start.character - b.location.range.start.character : a.location.range.start.line - b.location.range.start.line);
    return {
      outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
    };
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    // Temporarily keep containerName through the conversion process
    const allItems = symbols.map(symbol => ({
      containerName: symbol.containerName,
      outline: OutlineViewAdapter.symbolToOutline(symbol)
    }));

    // Create a map of containers by name with all items that have that name
    const containers = allItems.reduce((map, item) => {
      const name = item.outline.representativeName;
      if (name != null) {
        const container = map.get(name);
        if (container == null) {
          map.set(name, [item.outline]);
        } else {
          container.push(item.outline);
        }
      }
      return map;
    }, new Map());

    const roots = [];

    // Put each item within its parent and extract out the roots
    for (const item of allItems) {
      const containerName = item.containerName;
      const child = item.outline;
      if (containerName == null || containerName === '') {
        roots.push(item.outline);
      } else {
        const possibleParents = containers.get(containerName);
        let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
        if (closestParent == null) {
          closestParent = {
            plainText: containerName,
            representativeName: containerName,
            startPosition: new _atom.Point(0, 0),
            children: [child]
          };
          roots.push(closestParent);
          if (possibleParents == null) {
            containers.set(containerName, [closestParent]);
          } else {
            possibleParents.push(closestParent);
          }
        } else {
          closestParent.children.push(child);
        }
      }
    }

    return roots;
  }

  static _getClosestParent(candidates, child) {
    if (candidates == null || candidates.length === 0) {
      return null;
    }

    let parent = null;
    for (const candidate of candidates) {
      if (candidate !== child && candidate.startPosition.isLessThanOrEqual(child.startPosition) && (candidate.endPosition == null || candidate.endPosition.isGreaterThanOrEqual(child.endPosition))) {
        if (parent == null || parent.startPosition.isLessThanOrEqual(candidate.startPosition) || parent.endPosition != null && parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)) {
          parent = candidate;
        }
      }
    }

    return parent;
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
}
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRvY3VtZW50U3ltYm9sUHJvdmlkZXIiLCJnZXRPdXRsaW5lIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInJlc3VsdHMiLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInNvcnQiLCJhIiwiYiIsImxvY2F0aW9uIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJvdXRsaW5lVHJlZXMiLCJjcmVhdGVPdXRsaW5lVHJlZXMiLCJzeW1ib2xzIiwiYWxsSXRlbXMiLCJtYXAiLCJzeW1ib2wiLCJjb250YWluZXJOYW1lIiwib3V0bGluZSIsInN5bWJvbFRvT3V0bGluZSIsImNvbnRhaW5lcnMiLCJyZWR1Y2UiLCJpdGVtIiwibmFtZSIsInJlcHJlc2VudGF0aXZlTmFtZSIsImNvbnRhaW5lciIsImdldCIsInNldCIsInB1c2giLCJNYXAiLCJyb290cyIsImNoaWxkIiwicG9zc2libGVQYXJlbnRzIiwiY2xvc2VzdFBhcmVudCIsIl9nZXRDbG9zZXN0UGFyZW50IiwicGxhaW5UZXh0Iiwic3RhcnRQb3NpdGlvbiIsImNoaWxkcmVuIiwiY2FuZGlkYXRlcyIsImxlbmd0aCIsInBhcmVudCIsImNhbmRpZGF0ZSIsImlzTGVzc1RoYW5PckVxdWFsIiwiZW5kUG9zaXRpb24iLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbCIsImljb24iLCJzeW1ib2xLaW5kVG9FbnRpdHlLaW5kIiwia2luZCIsInRva2VuaXplZFRleHQiLCJzeW1ib2xLaW5kVG9Ub2tlbktpbmQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInBvc2l0aW9uVG9Qb2ludCIsImVuZCIsIkFycmF5IiwiQm9vbGVhbiIsIkNsYXNzIiwiQ29uc3RhbnQiLCJDb25zdHJ1Y3RvciIsIkVudW0iLCJGaWVsZCIsIkZpbGUiLCJGdW5jdGlvbiIsIkludGVyZmFjZSIsIk1ldGhvZCIsIk1vZHVsZSIsIk5hbWVzcGFjZSIsIk51bWJlciIsIlBhY2thZ2UiLCJQcm9wZXJ0eSIsIlN0cmluZyIsIlZhcmlhYmxlIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDZSxNQUFNQSxrQkFBTixDQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLHNCQUFuQixLQUE4QyxJQUFyRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxVQUFOLENBQWlCQyxVQUFqQixFQUF1REMsTUFBdkQsRUFBMkc7QUFDekcsVUFBTUMsVUFBVSxNQUFNRixXQUFXRyxjQUFYLENBQTBCO0FBQzlDQyxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNKLE1BQXZDO0FBRGdDLEtBQTFCLENBQXRCO0FBR0FDLFlBQVFJLElBQVIsQ0FDRSxDQUFDQyxDQUFELEVBQUlDLENBQUosS0FDRUQsRUFBRUUsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFBdkIsS0FBZ0NKLEVBQUVDLFFBQUYsQ0FBV0MsS0FBWCxDQUFpQkMsS0FBakIsQ0FBdUJDLElBQXZELEdBQ0lMLEVBQUVFLFFBQUYsQ0FBV0MsS0FBWCxDQUFpQkMsS0FBakIsQ0FBdUJFLFNBQXZCLEdBQW1DTCxFQUFFQyxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCRSxTQUQ5RCxHQUVJTixFQUFFRSxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCQyxJQUF2QixHQUE4QkosRUFBRUMsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFKN0Q7QUFNQSxX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QUF0TnFDO2tCQUFuQjlFLGtCIiwiZmlsZSI6Im91dGxpbmUtdmlldy1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBTeW1ib2xLaW5kLCB0eXBlIFNlcnZlckNhcGFiaWxpdGllcywgdHlwZSBTeW1ib2xJbmZvcm1hdGlvbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgZG9jdW1lbnRTeW1ib2xQcm92aWRlciBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHRoZSBPdXRsaW5lIFZpZXdcclxuLy8gc3VwcGxpZWQgYnkgQXRvbSBJREUgVUkuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dGxpbmVWaWV3QWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZG9jdW1lbnRTeW1ib2xQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50U3ltYm9sUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IE9idGFpbiB0aGUgT3V0bGluZSBmb3IgZG9jdW1lbnQgdmlhIHRoZSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSBhcyBpZGVudGlmaWVkXHJcbiAgLy8gYnkgdGhlIHtUZXh0RWRpdG9yfS5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZFxyXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgb3V0bGluZS5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGNvbnRhaW5pbmcgdGhlIHtPdXRsaW5lfSBvZiB0aGlzIGRvY3VtZW50LlxyXG4gIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P2F0b21JZGUkT3V0bGluZT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRTeW1ib2woe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICB9KTtcclxuICAgIHJlc3VsdHMuc29ydChcclxuICAgICAgKGEsIGIpID0+XHJcbiAgICAgICAgYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lID09PSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmVcclxuICAgICAgICAgID8gYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmNoYXJhY3RlclxyXG4gICAgICAgICAgOiBhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgb3V0bGluZVRyZWVzOiBPdXRsaW5lVmlld0FkYXB0ZXIuY3JlYXRlT3V0bGluZVRyZWVzKHJlc3VsdHMpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGFuIHtBcnJheX0gb2Yge091dGxpbmVUcmVlfXMgZnJvbSB0aGUgQXJyYXkgb2Yge1N5bWJvbEluZm9ybWF0aW9ufSByZWNpZXZlZFxyXG4gIC8vIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpbmNsdWRlcyBkZXRlcm1pbmluZyB0aGUgYXBwcm9wcmlhdGUgY2hpbGQgYW5kIHBhcmVudFxyXG4gIC8vIHJlbGF0aW9uc2hpcHMgZm9yIHRoZSBoaWVyYXJjaHkuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xzYCBBbiB7QXJyYXl9IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn1zIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0XHJcbiAgLy8gICAgICAgICAgICAgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhbiB7T3V0bGluZVRyZWV9LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiB7T3V0bGluZVRyZWV9IGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN5bWJvbHMgdGhhdCB0aGUgT3V0bGluZSBWaWV3IGNhbiBkaXNwbGF5LlxyXG4gIHN0YXRpYyBjcmVhdGVPdXRsaW5lVHJlZXMoc3ltYm9sczogQXJyYXk8U3ltYm9sSW5mb3JtYXRpb24+KTogQXJyYXk8YXRvbUlkZSRPdXRsaW5lVHJlZT4ge1xyXG4gICAgLy8gVGVtcG9yYXJpbHkga2VlcCBjb250YWluZXJOYW1lIHRocm91Z2ggdGhlIGNvbnZlcnNpb24gcHJvY2Vzc1xyXG4gICAgY29uc3QgYWxsSXRlbXMgPSBzeW1ib2xzLm1hcChzeW1ib2wgPT4gKHtcclxuICAgICAgY29udGFpbmVyTmFtZTogc3ltYm9sLmNvbnRhaW5lck5hbWUsXHJcbiAgICAgIG91dGxpbmU6IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xUb091dGxpbmUoc3ltYm9sKSxcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBtYXAgb2YgY29udGFpbmVycyBieSBuYW1lIHdpdGggYWxsIGl0ZW1zIHRoYXQgaGF2ZSB0aGF0IG5hbWVcclxuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBhbGxJdGVtcy5yZWR1Y2UoKG1hcCwgaXRlbSkgPT4ge1xyXG4gICAgICBjb25zdCBuYW1lID0gaXRlbS5vdXRsaW5lLnJlcHJlc2VudGF0aXZlTmFtZTtcclxuICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXQobmFtZSk7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICBtYXAuc2V0KG5hbWUsIFtpdGVtLm91dGxpbmVdKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udGFpbmVyLnB1c2goaXRlbS5vdXRsaW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH0sIG5ldyBNYXAoKSk7XHJcblxyXG4gICAgY29uc3Qgcm9vdHM6IEFycmF5PGF0b21JZGUkT3V0bGluZVRyZWU+ID0gW107XHJcblxyXG4gICAgLy8gUHV0IGVhY2ggaXRlbSB3aXRoaW4gaXRzIHBhcmVudCBhbmQgZXh0cmFjdCBvdXQgdGhlIHJvb3RzXHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWxsSXRlbXMpIHtcclxuICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGl0ZW0uY29udGFpbmVyTmFtZTtcclxuICAgICAgY29uc3QgY2hpbGQgPSBpdGVtLm91dGxpbmU7XHJcbiAgICAgIGlmIChjb250YWluZXJOYW1lID09IG51bGwgfHwgY29udGFpbmVyTmFtZSA9PT0gJycpIHtcclxuICAgICAgICByb290cy5wdXNoKGl0ZW0ub3V0bGluZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcG9zc2libGVQYXJlbnRzID0gY29udGFpbmVycy5nZXQoY29udGFpbmVyTmFtZSk7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RQYXJlbnQgPSBPdXRsaW5lVmlld0FkYXB0ZXIuX2dldENsb3Nlc3RQYXJlbnQocG9zc2libGVQYXJlbnRzLCBjaGlsZCk7XHJcbiAgICAgICAgaWYgKGNsb3Nlc3RQYXJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgY2xvc2VzdFBhcmVudCA9IHtcclxuICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IGNvbnRhaW5lck5hbWUsXHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246IG5ldyBQb2ludCgwLCAwKSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgcm9vdHMucHVzaChjbG9zZXN0UGFyZW50KTtcclxuICAgICAgICAgIGlmIChwb3NzaWJsZVBhcmVudHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250YWluZXJzLnNldChjb250YWluZXJOYW1lLCBbY2xvc2VzdFBhcmVudF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zc2libGVQYXJlbnRzLnB1c2goY2xvc2VzdFBhcmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvb3RzO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9nZXRDbG9zZXN0UGFyZW50KGNhbmRpZGF0ZXM6ID9BcnJheTxhdG9tSWRlJE91dGxpbmVUcmVlPiwgY2hpbGQ6IGF0b21JZGUkT3V0bGluZVRyZWUpOiA/YXRvbUlkZSRPdXRsaW5lVHJlZSB7XHJcbiAgICBpZiAoY2FuZGlkYXRlcyA9PSBudWxsIHx8IGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBwYXJlbnQgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY2FuZGlkYXRlICE9PSBjaGlsZCAmJlxyXG4gICAgICAgIGNhbmRpZGF0ZS5zdGFydFBvc2l0aW9uLmlzTGVzc1RoYW5PckVxdWFsKGNoaWxkLnN0YXJ0UG9zaXRpb24pICYmXHJcbiAgICAgICAgKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiA9PSBudWxsIHx8IGNhbmRpZGF0ZS5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjaGlsZC5lbmRQb3NpdGlvbikpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHBhcmVudCA9PSBudWxsIHx8XHJcbiAgICAgICAgICAocGFyZW50LnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24pIHx8XHJcbiAgICAgICAgICAgIChwYXJlbnQuZW5kUG9zaXRpb24gIT0gbnVsbCAmJiBwYXJlbnQuZW5kUG9zaXRpb24uaXNHcmVhdGVyVGhhbk9yRXF1YWwoY2FuZGlkYXRlLmVuZFBvc2l0aW9uKSkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBwYXJlbnQgPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhcmVudDtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBpbmRpdmlkdWFsIHtTeW1ib2xJbmZvcm1hdGlvbn0gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gdG8gYW4ge091dGxpbmVUcmVlfSBmb3IgdXNlIGJ5IHRoZSBPdXRsaW5lIFZpZXcuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xgIFRoZSB7U3ltYm9sSW5mb3JtYXRpb259IHRvIGNvbnZlcnQgdG8gYW4ge091dGxpbmVUcmVlfS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgdGhlIHtPdXRsaW5lVHJlZX0gZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4ge1N5bWJvbEluZm9ybWF0aW9ufS5cclxuICBzdGF0aWMgc3ltYm9sVG9PdXRsaW5lKHN5bWJvbDogU3ltYm9sSW5mb3JtYXRpb24pOiBhdG9tSWRlJE91dGxpbmVUcmVlIHtcclxuICAgIGNvbnN0IGljb24gPSBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2wua2luZCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b2tlbml6ZWRUZXh0OiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAga2luZDogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2wua2luZCksXHJcbiAgICAgICAgICB2YWx1ZTogc3ltYm9sLm5hbWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgaWNvbjogaWNvbiAhPSBudWxsID8gaWNvbiA6IHVuZGVmaW5lZCxcclxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcclxuICAgICAgc3RhcnRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgZW5kUG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5lbmQpLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgc3ltYm9sIGtpbmQgaW50byBhbiBvdXRsaW5lIGVudGl0eSBraW5kIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAgLy8gdGhlIHN0eWxpbmcgc3VjaCBhcyB0aGUgYXBwcm9wcmlhdGUgaWNvbiBpbiB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBPdXRsaW5lVmlldyBlbnRpdHkga2luZC5cclxuICBzdGF0aWMgc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2w6IG51bWJlcik6ID9zdHJpbmcge1xyXG4gICAgc3dpdGNoIChzeW1ib2wpIHtcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkFycmF5OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1hcnJheSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Cb29sZWFuOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1ib29sZWFuJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNsYXNzOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jbGFzcyc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdGFudDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY29uc3RhbnQnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0cnVjdG9yJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkVudW06XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWVudW0nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmllbGQ6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpZWxkJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpbGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpbGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZ1bmN0aW9uJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkludGVyZmFjZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtaW50ZXJmYWNlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbWV0aG9kJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1vZHVsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbW9kdWxlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk5hbWVzcGFjZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbmFtZXNwYWNlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk51bWJlcjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbnVtYmVyJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlBhY2thZ2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXBhY2thZ2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUHJvcGVydHk6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXByb3BlcnR5JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtc3RyaW5nJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlZhcmlhYmxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS12YXJpYWJsZSc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCB0byB0aGUgYXBwcm9wcmlhdGUgdG9rZW4ga2luZCB1c2VkIHRvIHN5bnRheFxyXG4gIC8vIGhpZ2hsaWdodCB0aGUgc3ltYm9sIG5hbWUgaW4gdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgc3ludGF4IHRva2VuIGtpbmQuXHJcbiAgc3RhdGljIHN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2w6IG51bWJlcik6IGF0b21JZGUkVG9rZW5LaW5kIHtcclxuICAgIHN3aXRjaCAoc3ltYm9sKSB7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcclxuICAgICAgICByZXR1cm4gJ3R5cGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XHJcbiAgICAgICAgcmV0dXJuICdjb25zdHJ1Y3Rvcic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5NZXRob2Q6XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcclxuICAgICAgICByZXR1cm4gJ21ldGhvZCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5TdHJpbmc6XHJcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAncGxhaW4nO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=