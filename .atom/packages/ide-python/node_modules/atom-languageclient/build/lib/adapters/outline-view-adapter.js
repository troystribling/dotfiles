Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _atom = require('atom');

var _vscodeJsonrpc = require('vscode-jsonrpc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
  constructor() {
    this._cancellationTokens = new WeakMap();
  }

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  async getOutline(connection, editor) {
    const results = await _utils2.default.doWithCancellationToken(connection, this._cancellationTokens, cancellationToken => connection.documentSymbol({ textDocument: _convert2.default.editorToTextDocumentIdentifier(editor) }, cancellationToken));
    results.sort((a, b) => a.location.range.start.line === b.location.range.start.line ? a.location.range.start.character - b.location.range.start.character : a.location.range.start.line - b.location.range.start.line);
    return {
      outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
    };
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    // Temporarily keep containerName through the conversion process
    const allItems = symbols.map(symbol => ({
      containerName: symbol.containerName,
      outline: OutlineViewAdapter.symbolToOutline(symbol)
    }));

    // Create a map of containers by name with all items that have that name
    const containers = allItems.reduce((map, item) => {
      const name = item.outline.representativeName;
      if (name != null) {
        const container = map.get(name);
        if (container == null) {
          map.set(name, [item.outline]);
        } else {
          container.push(item.outline);
        }
      }
      return map;
    }, new Map());

    const roots = [];

    // Put each item within its parent and extract out the roots
    for (const item of allItems) {
      const containerName = item.containerName;
      const child = item.outline;
      if (containerName == null || containerName === '') {
        roots.push(item.outline);
      } else {
        const possibleParents = containers.get(containerName);
        let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
        if (closestParent == null) {
          closestParent = {
            plainText: containerName,
            representativeName: containerName,
            startPosition: new _atom.Point(0, 0),
            children: [child]
          };
          roots.push(closestParent);
          if (possibleParents == null) {
            containers.set(containerName, [closestParent]);
          } else {
            possibleParents.push(closestParent);
          }
        } else {
          closestParent.children.push(child);
        }
      }
    }

    return roots;
  }

  static _getClosestParent(candidates, child) {
    if (candidates == null || candidates.length === 0) {
      return null;
    }

    let parent = null;
    for (const candidate of candidates) {
      if (candidate !== child && candidate.startPosition.isLessThanOrEqual(child.startPosition) && (candidate.endPosition == null || candidate.endPosition.isGreaterThanOrEqual(child.endPosition))) {
        if (parent == null || parent.startPosition.isLessThanOrEqual(candidate.startPosition) || parent.endPosition != null && parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)) {
          parent = candidate;
        }
      }
    }

    return parent;
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
}
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJfY2FuY2VsbGF0aW9uVG9rZW5zIiwiV2Vha01hcCIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiZG9jdW1lbnRTeW1ib2xQcm92aWRlciIsImdldE91dGxpbmUiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicmVzdWx0cyIsImRvV2l0aENhbmNlbGxhdGlvblRva2VuIiwiY2FuY2VsbGF0aW9uVG9rZW4iLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInNvcnQiLCJhIiwiYiIsImxvY2F0aW9uIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJvdXRsaW5lVHJlZXMiLCJjcmVhdGVPdXRsaW5lVHJlZXMiLCJzeW1ib2xzIiwiYWxsSXRlbXMiLCJtYXAiLCJzeW1ib2wiLCJjb250YWluZXJOYW1lIiwib3V0bGluZSIsInN5bWJvbFRvT3V0bGluZSIsImNvbnRhaW5lcnMiLCJyZWR1Y2UiLCJpdGVtIiwibmFtZSIsInJlcHJlc2VudGF0aXZlTmFtZSIsImNvbnRhaW5lciIsImdldCIsInNldCIsInB1c2giLCJNYXAiLCJyb290cyIsImNoaWxkIiwicG9zc2libGVQYXJlbnRzIiwiY2xvc2VzdFBhcmVudCIsIl9nZXRDbG9zZXN0UGFyZW50IiwicGxhaW5UZXh0Iiwic3RhcnRQb3NpdGlvbiIsImNoaWxkcmVuIiwiY2FuZGlkYXRlcyIsImxlbmd0aCIsInBhcmVudCIsImNhbmRpZGF0ZSIsImlzTGVzc1RoYW5PckVxdWFsIiwiZW5kUG9zaXRpb24iLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbCIsImljb24iLCJzeW1ib2xLaW5kVG9FbnRpdHlLaW5kIiwia2luZCIsInRva2VuaXplZFRleHQiLCJzeW1ib2xLaW5kVG9Ub2tlbktpbmQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInBvc2l0aW9uVG9Qb2ludCIsImVuZCIsIkFycmF5IiwiQm9vbGVhbiIsIkNsYXNzIiwiQ29uc3RhbnQiLCJDb25zdHJ1Y3RvciIsIkVudW0iLCJGaWVsZCIsIkZpbGUiLCJGdW5jdGlvbiIsIkludGVyZmFjZSIsIk1ldGhvZCIsIk1vZHVsZSIsIk5hbWVzcGFjZSIsIk51bWJlciIsIlBhY2thZ2UiLCJQcm9wZXJ0eSIsIlN0cmluZyIsIlZhcmlhYmxlIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNlLE1BQU1BLGtCQUFOLENBQXlCO0FBQUE7QUFBQSxTQUV0Q0MsbUJBRnNDLEdBRTRDLElBQUlDLE9BQUosRUFGNUM7QUFBQTs7QUFJdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxzQkFBbkIsS0FBOEMsSUFBckQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsVUFBTixDQUFpQkMsVUFBakIsRUFBdURDLE1BQXZELEVBQTJHO0FBQ3pHLFVBQU1DLFVBQVUsTUFBTSxnQkFBTUMsdUJBQU4sQ0FBOEJILFVBQTlCLEVBQTBDLEtBQUtOLG1CQUEvQyxFQUFvRVUscUJBQ3hGSixXQUFXSyxjQUFYLENBQTBCLEVBQUNDLGNBQWMsa0JBQVFDLDhCQUFSLENBQXVDTixNQUF2QyxDQUFmLEVBQTFCLEVBQTBGRyxpQkFBMUYsQ0FEb0IsQ0FBdEI7QUFHQUYsWUFBUU0sSUFBUixDQUNFLENBQUNDLENBQUQsRUFBSUMsQ0FBSixLQUNHRCxFQUFFRSxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCQyxJQUF2QixLQUFnQ0osRUFBRUMsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFBdkQsR0FD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QzlELFlBQVFBLE1BQVI7QUFDRSxXQUFLLDJCQUFXd0MsS0FBaEI7QUFDRSxlQUFPLE1BQVA7QUFDRixXQUFLLDJCQUFXRSxXQUFoQjtBQUNFLGVBQU8sYUFBUDtBQUNGLFdBQUssMkJBQVdNLE1BQWhCO0FBQ0EsV0FBSywyQkFBV0YsUUFBaEI7QUFDRSxlQUFPLFFBQVA7QUFDRixXQUFLLDJCQUFXUSxNQUFoQjtBQUNFLGVBQU8sUUFBUDtBQUNGO0FBQ0UsZUFBTyxPQUFQO0FBWEo7QUFhRDtBQXpOcUM7a0JBQW5CbEYsa0IiLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgU3ltYm9sS2luZCwgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsIHR5cGUgU3ltYm9sSW5mb3JtYXRpb259IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7UG9pbnR9IGZyb20gJ2F0b20nO1xuaW1wb3J0IHtDYW5jZWxsYXRpb25Ub2tlblNvdXJjZX0gZnJvbSAndnNjb2RlLWpzb25ycGMnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgZG9jdW1lbnRTeW1ib2xQcm92aWRlciBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHRoZSBPdXRsaW5lIFZpZXdcbi8vIHN1cHBsaWVkIGJ5IEF0b20gSURFIFVJLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0bGluZVZpZXdBZGFwdGVyIHtcblxuICBfY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+ID0gbmV3IFdlYWtNYXAoKTtcblxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZG9jdW1lbnRTeW1ib2xQcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIE91dGxpbmUgZm9yIGRvY3VtZW50IHZpYSB0aGUge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gYXMgaWRlbnRpZmllZFxuICAvLyBieSB0aGUge1RleHRFZGl0b3J9LlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBvdXRsaW5lLlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge091dGxpbmV9IG9mIHRoaXMgZG9jdW1lbnQuXG4gIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P2F0b21JZGUkT3V0bGluZT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBVdGlscy5kb1dpdGhDYW5jZWxsYXRpb25Ub2tlbihjb25uZWN0aW9uLCB0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbnMsIGNhbmNlbGxhdGlvblRva2VuID0+XG4gICAgICBjb25uZWN0aW9uLmRvY3VtZW50U3ltYm9sKHt0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvcil9LCBjYW5jZWxsYXRpb25Ub2tlbiksXG4gICAgKTtcbiAgICByZXN1bHRzLnNvcnQoXG4gICAgICAoYSwgYikgPT5cbiAgICAgICAgKGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZSA9PT0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lXG4gICAgICAgICAgPyBhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIubG9jYXRpb24ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyXG4gICAgICAgICAgOiBhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUpLFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmVUcmVlczogT3V0bGluZVZpZXdBZGFwdGVyLmNyZWF0ZU91dGxpbmVUcmVlcyhyZXN1bHRzKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUgYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9cyBmcm9tIHRoZSBBcnJheSBvZiB7U3ltYm9sSW5mb3JtYXRpb259IHJlY2lldmVkXG4gIC8vIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpbmNsdWRlcyBkZXRlcm1pbmluZyB0aGUgYXBwcm9wcmlhdGUgY2hpbGQgYW5kIHBhcmVudFxuICAvLyByZWxhdGlvbnNoaXBzIGZvciB0aGUgaGllcmFyY2h5LlxuICAvL1xuICAvLyAqIGBzeW1ib2xzYCBBbiB7QXJyYXl9IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn1zIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0XG4gIC8vICAgICAgICAgICAgIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4ge091dGxpbmVUcmVlfS5cbiAgLy9cbiAgLy8gUmV0dXJucyBhbiB7T3V0bGluZVRyZWV9IGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN5bWJvbHMgdGhhdCB0aGUgT3V0bGluZSBWaWV3IGNhbiBkaXNwbGF5LlxuICBzdGF0aWMgY3JlYXRlT3V0bGluZVRyZWVzKHN5bWJvbHM6IEFycmF5PFN5bWJvbEluZm9ybWF0aW9uPik6IEFycmF5PGF0b21JZGUkT3V0bGluZVRyZWU+IHtcbiAgICAvLyBUZW1wb3JhcmlseSBrZWVwIGNvbnRhaW5lck5hbWUgdGhyb3VnaCB0aGUgY29udmVyc2lvbiBwcm9jZXNzXG4gICAgY29uc3QgYWxsSXRlbXMgPSBzeW1ib2xzLm1hcChzeW1ib2wgPT4gKHtcbiAgICAgIGNvbnRhaW5lck5hbWU6IHN5bWJvbC5jb250YWluZXJOYW1lLFxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxuICAgIH0pKTtcblxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxuICAgIGNvbnN0IGNvbnRhaW5lcnMgPSBhbGxJdGVtcy5yZWR1Y2UoKG1hcCwgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ub3V0bGluZS5yZXByZXNlbnRhdGl2ZU5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGl0ZW0ub3V0bGluZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgbmV3IE1hcCgpKTtcblxuICAgIGNvbnN0IHJvb3RzOiBBcnJheTxhdG9tSWRlJE91dGxpbmVUcmVlPiA9IFtdO1xuXG4gICAgLy8gUHV0IGVhY2ggaXRlbSB3aXRoaW4gaXRzIHBhcmVudCBhbmQgZXh0cmFjdCBvdXQgdGhlIHJvb3RzXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFsbEl0ZW1zKSB7XG4gICAgICBjb25zdCBjb250YWluZXJOYW1lID0gaXRlbS5jb250YWluZXJOYW1lO1xuICAgICAgY29uc3QgY2hpbGQgPSBpdGVtLm91dGxpbmU7XG4gICAgICBpZiAoY29udGFpbmVyTmFtZSA9PSBudWxsIHx8IGNvbnRhaW5lck5hbWUgPT09ICcnKSB7XG4gICAgICAgIHJvb3RzLnB1c2goaXRlbS5vdXRsaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlUGFyZW50cyA9IGNvbnRhaW5lcnMuZ2V0KGNvbnRhaW5lck5hbWUpO1xuICAgICAgICBsZXQgY2xvc2VzdFBhcmVudCA9IE91dGxpbmVWaWV3QWRhcHRlci5fZ2V0Q2xvc2VzdFBhcmVudChwb3NzaWJsZVBhcmVudHMsIGNoaWxkKTtcbiAgICAgICAgaWYgKGNsb3Nlc3RQYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQgPSB7XG4gICAgICAgICAgICBwbGFpblRleHQ6IGNvbnRhaW5lck5hbWUsXG4gICAgICAgICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IGNvbnRhaW5lck5hbWUsXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uOiBuZXcgUG9pbnQoMCwgMCksXG4gICAgICAgICAgICBjaGlsZHJlbjogW2NoaWxkXSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJvb3RzLnB1c2goY2xvc2VzdFBhcmVudCk7XG4gICAgICAgICAgaWYgKHBvc3NpYmxlUGFyZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250YWluZXJzLnNldChjb250YWluZXJOYW1lLCBbY2xvc2VzdFBhcmVudF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NzaWJsZVBhcmVudHMucHVzaChjbG9zZXN0UGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2VzdFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb290cztcbiAgfVxuXG4gIHN0YXRpYyBfZ2V0Q2xvc2VzdFBhcmVudChjYW5kaWRhdGVzOiA/QXJyYXk8YXRvbUlkZSRPdXRsaW5lVHJlZT4sIGNoaWxkOiBhdG9tSWRlJE91dGxpbmVUcmVlKTogP2F0b21JZGUkT3V0bGluZVRyZWUge1xuICAgIGlmIChjYW5kaWRhdGVzID09IG51bGwgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBwYXJlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY2FuZGlkYXRlICE9PSBjaGlsZCAmJlxuICAgICAgICBjYW5kaWRhdGUuc3RhcnRQb3NpdGlvbi5pc0xlc3NUaGFuT3JFcXVhbChjaGlsZC5zdGFydFBvc2l0aW9uKSAmJlxuICAgICAgICAoY2FuZGlkYXRlLmVuZFBvc2l0aW9uID09IG51bGwgfHwgY2FuZGlkYXRlLmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNoaWxkLmVuZFBvc2l0aW9uKSlcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFyZW50ID09IG51bGwgfHxcbiAgICAgICAgICAocGFyZW50LnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24pIHx8XG4gICAgICAgICAgICAocGFyZW50LmVuZFBvc2l0aW9uICE9IG51bGwgJiYgcGFyZW50LmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbikpKVxuICAgICAgICApIHtcbiAgICAgICAgICBwYXJlbnQgPSBjYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIGluZGl2aWR1YWwge1N5bWJvbEluZm9ybWF0aW9ufSBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gdG8gYW4ge091dGxpbmVUcmVlfSBmb3IgdXNlIGJ5IHRoZSBPdXRsaW5lIFZpZXcuXG4gIC8vXG4gIC8vICogYHN5bWJvbGAgVGhlIHtTeW1ib2xJbmZvcm1hdGlvbn0gdG8gY29udmVydCB0byBhbiB7T3V0bGluZVRyZWV9LlxuICAvL1xuICAvLyBSZXR1cm5zIHRoZSB7T3V0bGluZVRyZWV9IGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHtTeW1ib2xJbmZvcm1hdGlvbn0uXG4gIHN0YXRpYyBzeW1ib2xUb091dGxpbmUoc3ltYm9sOiBTeW1ib2xJbmZvcm1hdGlvbik6IGF0b21JZGUkT3V0bGluZVRyZWUge1xuICAgIGNvbnN0IGljb24gPSBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2wua2luZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplZFRleHQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQ6IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sLmtpbmQpLFxuICAgICAgICAgIHZhbHVlOiBzeW1ib2wubmFtZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBpY29uOiBpY29uICE9IG51bGwgPyBpY29uIDogdW5kZWZpbmVkLFxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcbiAgICAgIHN0YXJ0UG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5zdGFydCksXG4gICAgICBlbmRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLmVuZCksXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIGludG8gYW4gb3V0bGluZSBlbnRpdHkga2luZCB1c2VkIHRvIGRldGVybWluZVxuICAvLyB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXG4gIC8vXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBPdXRsaW5lVmlldyBlbnRpdHkga2luZC5cbiAgc3RhdGljIHN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sOiBudW1iZXIpOiA/c3RyaW5nIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkFycmF5OlxuICAgICAgICByZXR1cm4gJ3R5cGUtYXJyYXknO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkJvb2xlYW46XG4gICAgICAgIHJldHVybiAndHlwZS1ib29sZWFuJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNsYXNzJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdGFudDpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0YW50JztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0cnVjdG9yJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5FbnVtOlxuICAgICAgICByZXR1cm4gJ3R5cGUtZW51bSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmllbGQ6XG4gICAgICAgIHJldHVybiAndHlwZS1maWVsZCc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmlsZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpbGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxuICAgICAgICByZXR1cm4gJ3R5cGUtZnVuY3Rpb24nO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkludGVyZmFjZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLWludGVyZmFjZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxuICAgICAgICByZXR1cm4gJ3R5cGUtbWV0aG9kJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Nb2R1bGU6XG4gICAgICAgIHJldHVybiAndHlwZS1tb2R1bGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk5hbWVzcGFjZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLW5hbWVzcGFjZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTnVtYmVyOlxuICAgICAgICByZXR1cm4gJ3R5cGUtbnVtYmVyJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5QYWNrYWdlOlxuICAgICAgICByZXR1cm4gJ3R5cGUtcGFja2FnZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUHJvcGVydHk6XG4gICAgICAgIHJldHVybiAndHlwZS1wcm9wZXJ0eSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxuICAgICAgICByZXR1cm4gJ3R5cGUtc3RyaW5nJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5WYXJpYWJsZTpcbiAgICAgICAgcmV0dXJuICd0eXBlLXZhcmlhYmxlJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIHRvIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBraW5kIHVzZWQgdG8gc3ludGF4XG4gIC8vIGhpZ2hsaWdodCB0aGUgc3ltYm9sIG5hbWUgaW4gdGhlIE91dGxpbmUgVmlldy5cbiAgLy9cbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcXVpdmFsZW50IHN5bnRheCB0b2tlbiBraW5kLlxuICBzdGF0aWMgc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbDogbnVtYmVyKTogYXRvbUlkZSRUb2tlbktpbmQge1xuICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XG4gICAgICAgIHJldHVybiAndHlwZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgIHJldHVybiAnY29uc3RydWN0b3InO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcbiAgICAgICAgcmV0dXJuICdtZXRob2QnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdwbGFpbic7XG4gICAgfVxuICB9XG59XG4iXX0=