"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const Utils = require("../utils");
const languageclient_1 = require("../languageclient");
const atom_1 = require("atom");
// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
    constructor() {
        this._cancellationTokens = new WeakMap();
    }
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a documentSymbolProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.documentSymbolProvider === true;
    }
    // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
    // by the {TextEditor}.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the outline.
    // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
    //
    // Returns a {Promise} containing the {Outline} of this document.
    getOutline(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Utils.doWithCancellationToken(connection, this._cancellationTokens, (cancellationToken) => connection.documentSymbol({ textDocument: convert_1.default.editorToTextDocumentIdentifier(editor) }, cancellationToken));
            if (results.length === 0) {
                return {
                    outlineTrees: [],
                };
            }
            if (results[0].selectionRange !== undefined) {
                // If the server is giving back the newer DocumentSymbol format.
                return {
                    outlineTrees: OutlineViewAdapter.createHierarchicalOutlineTrees(results),
                };
            }
            else {
                // If the server is giving back the original SymbolInformation format.
                return {
                    outlineTrees: OutlineViewAdapter.createOutlineTrees(results),
                };
            }
        });
    }
    // Public: Create an {Array} of {OutlineTree}s from the Array of {DocumentSymbol} recieved
    // from the language server. This includes converting all the children nodes in the entire
    // hierarchy.
    //
    // * `symbols` An {Array} of {DocumentSymbol}s received from the language server that
    //             should be converted to an {Array} of {OutlineTree}.
    //
    // Returns an {Array} of {OutlineTree} containing the given symbols that the Outline View can display.
    static createHierarchicalOutlineTrees(symbols) {
        // Sort all the incoming symbols
        symbols.sort((a, b) => {
            if (a.range.start.line !== b.range.start.line) {
                return a.range.start.line - b.range.start.line;
            }
            if (a.range.start.character !== b.range.start.character) {
                return a.range.start.character - b.range.start.character;
            }
            if (a.range.end.line !== b.range.end.line) {
                return a.range.end.line - b.range.end.line;
            }
            return a.range.end.character - b.range.end.character;
        });
        return symbols.map((symbol) => {
            const tree = OutlineViewAdapter.hierarchicalSymbolToOutline(symbol);
            if (symbol.children != null) {
                tree.children = OutlineViewAdapter.createHierarchicalOutlineTrees(symbol.children);
            }
            return tree;
        });
    }
    // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
    // from the language server. This includes determining the appropriate child and parent
    // relationships for the hierarchy.
    //
    // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
    //             should be converted to an {OutlineTree}.
    //
    // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
    static createOutlineTrees(symbols) {
        symbols.sort((a, b) => (a.location.range.start.line === b.location.range.start.line
            ? a.location.range.start.character - b.location.range.start.character
            : a.location.range.start.line - b.location.range.start.line));
        // Temporarily keep containerName through the conversion process
        // Also filter out symbols without a name - it's part of the spec but some don't include it
        const allItems = symbols.filter((symbol) => symbol.name).map((symbol) => ({
            containerName: symbol.containerName,
            outline: OutlineViewAdapter.symbolToOutline(symbol),
        }));
        // Create a map of containers by name with all items that have that name
        const containers = allItems.reduce((map, item) => {
            const name = item.outline.representativeName;
            if (name != null) {
                const container = map.get(name);
                if (container == null) {
                    map.set(name, [item.outline]);
                }
                else {
                    container.push(item.outline);
                }
            }
            return map;
        }, new Map());
        const roots = [];
        // Put each item within its parent and extract out the roots
        for (const item of allItems) {
            const containerName = item.containerName;
            const child = item.outline;
            if (containerName == null || containerName === '') {
                roots.push(item.outline);
            }
            else {
                const possibleParents = containers.get(containerName);
                let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
                if (closestParent == null) {
                    closestParent = {
                        plainText: containerName,
                        representativeName: containerName,
                        startPosition: new atom_1.Point(0, 0),
                        children: [child],
                    };
                    roots.push(closestParent);
                    if (possibleParents == null) {
                        containers.set(containerName, [closestParent]);
                    }
                    else {
                        possibleParents.push(closestParent);
                    }
                }
                else {
                    closestParent.children.push(child);
                }
            }
        }
        return roots;
    }
    static _getClosestParent(candidates, child) {
        if (candidates == null || candidates.length === 0) {
            return null;
        }
        let parent;
        for (const candidate of candidates) {
            if (candidate !== child &&
                candidate.startPosition.isLessThanOrEqual(child.startPosition) &&
                (candidate.endPosition === undefined ||
                    (child.endPosition && candidate.endPosition.isGreaterThanOrEqual(child.endPosition)))) {
                if (parent === undefined ||
                    (parent.startPosition.isLessThanOrEqual(candidate.startPosition) ||
                        (parent.endPosition != null &&
                            candidate.endPosition &&
                            parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)))) {
                    parent = candidate;
                }
            }
        }
        return parent || null;
    }
    // Public: Convert an individual {DocumentSymbol} from the language server
    // to an {OutlineTree} for use by the Outline View. It does NOT recursively
    // process the given symbol's children (if any).
    //
    // * `symbol` The {DocumentSymbol} to convert to an {OutlineTree}.
    //
    // Returns the {OutlineTree} corresponding to the given {DocumentSymbol}.
    static hierarchicalSymbolToOutline(symbol) {
        const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
        return {
            tokenizedText: [
                {
                    kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
                    value: symbol.name,
                },
            ],
            icon: icon != null ? icon : undefined,
            representativeName: symbol.name,
            startPosition: convert_1.default.positionToPoint(symbol.selectionRange.start),
            endPosition: convert_1.default.positionToPoint(symbol.selectionRange.end),
            children: [],
        };
    }
    // Public: Convert an individual {SymbolInformation} from the language server
    // to an {OutlineTree} for use by the Outline View.
    //
    // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
    //
    // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
    static symbolToOutline(symbol) {
        const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
        return {
            tokenizedText: [
                {
                    kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
                    value: symbol.name,
                },
            ],
            icon: icon != null ? icon : undefined,
            representativeName: symbol.name,
            startPosition: convert_1.default.positionToPoint(symbol.location.range.start),
            endPosition: convert_1.default.positionToPoint(symbol.location.range.end),
            children: [],
        };
    }
    // Public: Convert a symbol kind into an outline entity kind used to determine
    // the styling such as the appropriate icon in the Outline View.
    //
    // * `symbol` The numeric symbol kind received from the language server.
    //
    // Returns a string representing the equivalent OutlineView entity kind.
    static symbolKindToEntityKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Array:
                return 'type-array';
            case languageclient_1.SymbolKind.Boolean:
                return 'type-boolean';
            case languageclient_1.SymbolKind.Class:
                return 'type-class';
            case languageclient_1.SymbolKind.Constant:
                return 'type-constant';
            case languageclient_1.SymbolKind.Constructor:
                return 'type-constructor';
            case languageclient_1.SymbolKind.Enum:
                return 'type-enum';
            case languageclient_1.SymbolKind.Field:
                return 'type-field';
            case languageclient_1.SymbolKind.File:
                return 'type-file';
            case languageclient_1.SymbolKind.Function:
                return 'type-function';
            case languageclient_1.SymbolKind.Interface:
                return 'type-interface';
            case languageclient_1.SymbolKind.Method:
                return 'type-method';
            case languageclient_1.SymbolKind.Module:
                return 'type-module';
            case languageclient_1.SymbolKind.Namespace:
                return 'type-namespace';
            case languageclient_1.SymbolKind.Number:
                return 'type-number';
            case languageclient_1.SymbolKind.Package:
                return 'type-package';
            case languageclient_1.SymbolKind.Property:
                return 'type-property';
            case languageclient_1.SymbolKind.String:
                return 'type-string';
            case languageclient_1.SymbolKind.Variable:
                return 'type-variable';
            case languageclient_1.SymbolKind.Struct:
                return 'type-class';
            case languageclient_1.SymbolKind.EnumMember:
                return 'type-constant';
            default:
                return null;
        }
    }
    // Public: Convert a symbol kind to the appropriate token kind used to syntax
    // highlight the symbol name in the Outline View.
    //
    // * `symbol` The numeric symbol kind received from the language server.
    //
    // Returns a string representing the equivalent syntax token kind.
    static symbolKindToTokenKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Class:
                return 'type';
            case languageclient_1.SymbolKind.Constructor:
                return 'constructor';
            case languageclient_1.SymbolKind.Method:
            case languageclient_1.SymbolKind.Function:
                return 'method';
            case languageclient_1.SymbolKind.String:
                return 'string';
            default:
                return 'plain';
        }
    }
}
exports.default = OutlineViewAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvb3V0bGluZS12aWV3LWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQUNqQyxrQ0FBa0M7QUFFbEMsc0RBTTJCO0FBQzNCLCtCQUdjO0FBRWQsdUZBQXVGO0FBQ3ZGLDJCQUEyQjtBQUMzQixNQUFxQixrQkFBa0I7SUFBdkM7UUFFVSx3QkFBbUIsR0FBK0QsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQW9UMUcsQ0FBQztJQWxUQyxnRkFBZ0Y7SUFDaEYsOEVBQThFO0lBQzlFLEVBQUU7SUFDRixzRkFBc0Y7SUFDdEYsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSw0QkFBNEI7SUFDckIsTUFBTSxDQUFDLFFBQVEsQ0FBQyxrQkFBc0M7UUFDM0QsT0FBTyxrQkFBa0IsQ0FBQyxzQkFBc0IsS0FBSyxJQUFJLENBQUM7SUFDNUQsQ0FBQztJQUVELDJGQUEyRjtJQUMzRix1QkFBdUI7SUFDdkIsRUFBRTtJQUNGLDBGQUEwRjtJQUMxRixrQ0FBa0M7SUFDbEMscUZBQXFGO0lBQ3JGLEVBQUU7SUFDRixpRUFBaUU7SUFDcEQsVUFBVSxDQUFDLFVBQW9DLEVBQUUsTUFBa0I7O1lBQzlFLE1BQU0sT0FBTyxHQUFHLE1BQU0sS0FBSyxDQUFDLHVCQUF1QixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQzlHLFVBQVUsQ0FBQyxjQUFjLENBQUMsRUFBQyxZQUFZLEVBQUUsaUJBQU8sQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUMsRUFBQyxFQUFFLGlCQUFpQixDQUFDLENBQzdHLENBQUM7WUFFRixJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN4QixPQUFPO29CQUNMLFlBQVksRUFBRSxFQUFFO2lCQUNqQixD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TUFBTTtnQkFDcEIsT0FBTyxhQUFhLENBQUM7WUFDdkIsS0FBSywyQkFBVSxDQUFDLE9BQU87Z0JBQ3JCLE9BQU8sY0FBYyxDQUFDO1lBQ3hCLEtBQUssMkJBQVUsQ0FBQyxRQUFRO2dCQUN0QixPQUFPLGVBQWUsQ0FBQztZQUN6QixLQUFLLDJCQUFVLENBQUMsTUFBTTtnQkFDcEIsT0FBTyxhQUFhLENBQUM7WUFDdkIsS0FBSywyQkFBVSxDQUFDLFFBQVE7Z0JBQ3RCLE9BQU8sZUFBZSxDQUFDO1lBQ3pCLEtBQUssMkJBQVUsQ0FBQyxNQUFNO2dCQUNwQixPQUFPLFlBQVksQ0FBQztZQUN0QixLQUFLLDJCQUFVLENBQUMsVUFBVTtnQkFDeEIsT0FBTyxlQUFlLENBQUM7WUFDekI7Z0JBQ0UsT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNILENBQUM7SUFFRCw2RUFBNkU7SUFDN0UsaURBQWlEO0lBQ2pELEVBQUU7SUFDRix3RUFBd0U7SUFDeEUsRUFBRTtJQUNGLGtFQUFrRTtJQUMzRCxNQUFNLENBQUMscUJBQXFCLENBQUMsTUFBYztRQUNoRCxRQUFRLE1BQU0sRUFBRTtZQUNkLEtBQUssMkJBQVUsQ0FBQyxLQUFLO2dCQUNuQixPQUFPLE1BQU0sQ0FBQztZQUNoQixLQUFLLDJCQUFVLENBQUMsV0FBVztnQkFDekIsT0FBTyxhQUFhLENBQUM7WUFDdkIsS0FBSywyQkFBVSxDQUFDLE1BQU0sQ0FBQztZQUN2QixLQUFLLDJCQUFVLENBQUMsUUFBUTtnQkFDdEIsT0FBTyxRQUFRLENBQUM7WUFDbEIsS0FBSywyQkFBVSxDQUFDLE1BQU07Z0JBQ3BCLE9BQU8sUUFBUSxDQUFDO1lBQ2xCO2dCQUNFLE9BQU8sT0FBTyxDQUFDO1NBQ2xCO0lBQ0gsQ0FBQztDQUNGO0FBdFRELHFDQXNUQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xyXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJ3ZzY29kZS1qc29ucnBjJztcclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgU3ltYm9sS2luZCxcclxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgU3ltYm9sSW5mb3JtYXRpb24sXHJcbiAgRG9jdW1lbnRTeW1ib2wsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQge1xyXG4gIFBvaW50LFxyXG4gIFRleHRFZGl0b3IsXHJcbn0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgZG9jdW1lbnRTeW1ib2xQcm92aWRlciBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHRoZSBPdXRsaW5lIFZpZXdcclxuLy8gc3VwcGxpZWQgYnkgQXRvbSBJREUgVUkuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dGxpbmVWaWV3QWRhcHRlciB7XHJcblxyXG4gIHByaXZhdGUgX2NhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIENhbmNlbGxhdGlvblRva2VuU291cmNlPiA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGRvY3VtZW50U3ltYm9sUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRTeW1ib2xQcm92aWRlciA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSBPdXRsaW5lIGZvciBkb2N1bWVudCB2aWEgdGhlIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IGFzIGlkZW50aWZpZWRcclxuICAvLyBieSB0aGUge1RleHRFZGl0b3J9LlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXHJcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBvdXRsaW5lLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIE91dGxpbmUgc2hvdWxkIHJlcHJlc2VudC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge091dGxpbmV9IG9mIHRoaXMgZG9jdW1lbnQuXHJcbiAgcHVibGljIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IFRleHRFZGl0b3IpOiBQcm9taXNlPGF0b21JZGUuT3V0bGluZSB8IG51bGw+IHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBVdGlscy5kb1dpdGhDYW5jZWxsYXRpb25Ub2tlbihjb25uZWN0aW9uLCB0aGlzLl9jYW5jZWxsYXRpb25Ub2tlbnMsIChjYW5jZWxsYXRpb25Ub2tlbikgPT5cclxuICAgICAgY29ubmVjdGlvbi5kb2N1bWVudFN5bWJvbCh7dGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpfSwgY2FuY2VsbGF0aW9uVG9rZW4pLFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBvdXRsaW5lVHJlZXM6IFtdLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgocmVzdWx0c1swXSBhcyBEb2N1bWVudFN5bWJvbCkuc2VsZWN0aW9uUmFuZ2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBJZiB0aGUgc2VydmVyIGlzIGdpdmluZyBiYWNrIHRoZSBuZXdlciBEb2N1bWVudFN5bWJvbCBmb3JtYXQuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgb3V0bGluZVRyZWVzOiBPdXRsaW5lVmlld0FkYXB0ZXIuY3JlYXRlSGllcmFyY2hpY2FsT3V0bGluZVRyZWVzKFxyXG4gICAgICAgICAgcmVzdWx0cyBhcyBEb2N1bWVudFN5bWJvbFtdKSxcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgaXMgZ2l2aW5nIGJhY2sgdGhlIG9yaWdpbmFsIFN5bWJvbEluZm9ybWF0aW9uIGZvcm1hdC5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBvdXRsaW5lVHJlZXM6IE91dGxpbmVWaWV3QWRhcHRlci5jcmVhdGVPdXRsaW5lVHJlZXMoXHJcbiAgICAgICAgICByZXN1bHRzIGFzIFN5bWJvbEluZm9ybWF0aW9uW10pLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9cyBmcm9tIHRoZSBBcnJheSBvZiB7RG9jdW1lbnRTeW1ib2x9IHJlY2lldmVkXHJcbiAgLy8gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGluY2x1ZGVzIGNvbnZlcnRpbmcgYWxsIHRoZSBjaGlsZHJlbiBub2RlcyBpbiB0aGUgZW50aXJlXHJcbiAgLy8gaGllcmFyY2h5LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sc2AgQW4ge0FycmF5fSBvZiB7RG9jdW1lbnRTeW1ib2x9cyByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdFxyXG4gIC8vICAgICAgICAgICAgIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtPdXRsaW5lVHJlZX0gY29udGFpbmluZyB0aGUgZ2l2ZW4gc3ltYm9scyB0aGF0IHRoZSBPdXRsaW5lIFZpZXcgY2FuIGRpc3BsYXkuXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVIaWVyYXJjaGljYWxPdXRsaW5lVHJlZXMoc3ltYm9sczogRG9jdW1lbnRTeW1ib2xbXSk6IGF0b21JZGUuT3V0bGluZVRyZWVbXSB7XHJcbiAgICAvLyBTb3J0IGFsbCB0aGUgaW5jb21pbmcgc3ltYm9sc1xyXG4gICAgc3ltYm9scy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIGlmIChhLnJhbmdlLnN0YXJ0LmxpbmUgIT09IGIucmFuZ2Uuc3RhcnQubGluZSkge1xyXG4gICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAhPT0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIpIHtcclxuICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEucmFuZ2UuZW5kLmxpbmUgIT09IGIucmFuZ2UuZW5kLmxpbmUpIHtcclxuICAgICAgICByZXR1cm4gYS5yYW5nZS5lbmQubGluZSAtIGIucmFuZ2UuZW5kLmxpbmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhLnJhbmdlLmVuZC5jaGFyYWN0ZXIgLSBiLnJhbmdlLmVuZC5jaGFyYWN0ZXI7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gc3ltYm9scy5tYXAoKHN5bWJvbCkgPT4ge1xyXG4gICAgICBjb25zdCB0cmVlID0gT3V0bGluZVZpZXdBZGFwdGVyLmhpZXJhcmNoaWNhbFN5bWJvbFRvT3V0bGluZShzeW1ib2wpO1xyXG5cclxuICAgICAgaWYgKHN5bWJvbC5jaGlsZHJlbiAhPSBudWxsKSB7XHJcbiAgICAgICAgdHJlZS5jaGlsZHJlbiA9IE91dGxpbmVWaWV3QWRhcHRlci5jcmVhdGVIaWVyYXJjaGljYWxPdXRsaW5lVHJlZXMoXHJcbiAgICAgICAgICBzeW1ib2wuY2hpbGRyZW4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJlZTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9cyBmcm9tIHRoZSBBcnJheSBvZiB7U3ltYm9sSW5mb3JtYXRpb259IHJlY2lldmVkXHJcbiAgLy8gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGluY2x1ZGVzIGRldGVybWluaW5nIHRoZSBhcHByb3ByaWF0ZSBjaGlsZCBhbmQgcGFyZW50XHJcbiAgLy8gcmVsYXRpb25zaGlwcyBmb3IgdGhlIGhpZXJhcmNoeS5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbHNgIEFuIHtBcnJheX0gb2Yge1N5bWJvbEluZm9ybWF0aW9ufXMgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXRcclxuICAvLyAgICAgICAgICAgICBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIHtPdXRsaW5lVHJlZX0uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtPdXRsaW5lVHJlZX0gY29udGFpbmluZyB0aGUgZ2l2ZW4gc3ltYm9scyB0aGF0IHRoZSBPdXRsaW5lIFZpZXcgY2FuIGRpc3BsYXkuXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVPdXRsaW5lVHJlZXMoc3ltYm9sczogU3ltYm9sSW5mb3JtYXRpb25bXSk6IGF0b21JZGUuT3V0bGluZVRyZWVbXSB7XHJcbiAgICBzeW1ib2xzLnNvcnQoXHJcbiAgICAgIChhLCBiKSA9PlxyXG4gICAgICAgIChhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUgPT09IGIubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZVxyXG4gICAgICAgICAgPyBhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIubG9jYXRpb24ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyXHJcbiAgICAgICAgICA6IGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZSAtIGIubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZSksXHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRlbXBvcmFyaWx5IGtlZXAgY29udGFpbmVyTmFtZSB0aHJvdWdoIHRoZSBjb252ZXJzaW9uIHByb2Nlc3NcclxuICAgIC8vIEFsc28gZmlsdGVyIG91dCBzeW1ib2xzIHdpdGhvdXQgYSBuYW1lIC0gaXQncyBwYXJ0IG9mIHRoZSBzcGVjIGJ1dCBzb21lIGRvbid0IGluY2x1ZGUgaXRcclxuICAgIGNvbnN0IGFsbEl0ZW1zID0gc3ltYm9scy5maWx0ZXIoKHN5bWJvbCkgPT4gc3ltYm9sLm5hbWUpLm1hcCgoc3ltYm9sKSA9PiAoe1xyXG4gICAgICBjb250YWluZXJOYW1lOiBzeW1ib2wuY29udGFpbmVyTmFtZSxcclxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxyXG4gICAgY29uc3QgY29udGFpbmVycyA9IGFsbEl0ZW1zLnJlZHVjZSgobWFwLCBpdGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLm91dGxpbmUucmVwcmVzZW50YXRpdmVOYW1lO1xyXG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250YWluZXIucHVzaChpdGVtLm91dGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuXHJcbiAgICBjb25zdCByb290czogYXRvbUlkZS5PdXRsaW5lVHJlZVtdID0gW107XHJcblxyXG4gICAgLy8gUHV0IGVhY2ggaXRlbSB3aXRoaW4gaXRzIHBhcmVudCBhbmQgZXh0cmFjdCBvdXQgdGhlIHJvb3RzXHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWxsSXRlbXMpIHtcclxuICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGl0ZW0uY29udGFpbmVyTmFtZTtcclxuICAgICAgY29uc3QgY2hpbGQgPSBpdGVtLm91dGxpbmU7XHJcbiAgICAgIGlmIChjb250YWluZXJOYW1lID09IG51bGwgfHwgY29udGFpbmVyTmFtZSA9PT0gJycpIHtcclxuICAgICAgICByb290cy5wdXNoKGl0ZW0ub3V0bGluZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcG9zc2libGVQYXJlbnRzID0gY29udGFpbmVycy5nZXQoY29udGFpbmVyTmFtZSk7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RQYXJlbnQgPSBPdXRsaW5lVmlld0FkYXB0ZXIuX2dldENsb3Nlc3RQYXJlbnQocG9zc2libGVQYXJlbnRzLCBjaGlsZCk7XHJcbiAgICAgICAgaWYgKGNsb3Nlc3RQYXJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgY2xvc2VzdFBhcmVudCA9IHtcclxuICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IGNvbnRhaW5lck5hbWUsXHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246IG5ldyBQb2ludCgwLCAwKSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgcm9vdHMucHVzaChjbG9zZXN0UGFyZW50KTtcclxuICAgICAgICAgIGlmIChwb3NzaWJsZVBhcmVudHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250YWluZXJzLnNldChjb250YWluZXJOYW1lLCBbY2xvc2VzdFBhcmVudF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zc2libGVQYXJlbnRzLnB1c2goY2xvc2VzdFBhcmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvb3RzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgX2dldENsb3Nlc3RQYXJlbnQoXHJcbiAgICBjYW5kaWRhdGVzOiBhdG9tSWRlLk91dGxpbmVUcmVlW10gfCBudWxsLFxyXG4gICAgY2hpbGQ6IGF0b21JZGUuT3V0bGluZVRyZWUsXHJcbiAgKTogYXRvbUlkZS5PdXRsaW5lVHJlZSB8IG51bGwge1xyXG4gICAgaWYgKGNhbmRpZGF0ZXMgPT0gbnVsbCB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGFyZW50OiBhdG9tSWRlLk91dGxpbmVUcmVlIHwgdW5kZWZpbmVkO1xyXG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY2FuZGlkYXRlICE9PSBjaGlsZCAmJlxyXG4gICAgICAgIGNhbmRpZGF0ZS5zdGFydFBvc2l0aW9uLmlzTGVzc1RoYW5PckVxdWFsKGNoaWxkLnN0YXJ0UG9zaXRpb24pICYmXHJcbiAgICAgICAgKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAoY2hpbGQuZW5kUG9zaXRpb24gJiYgY2FuZGlkYXRlLmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNoaWxkLmVuZFBvc2l0aW9uKSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAocGFyZW50LnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24pIHx8XHJcbiAgICAgICAgICAgIChwYXJlbnQuZW5kUG9zaXRpb24gIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgIGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiAmJlxyXG4gICAgICAgICAgICAgIHBhcmVudC5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjYW5kaWRhdGUuZW5kUG9zaXRpb24pKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHBhcmVudCA9IGNhbmRpZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50IHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gaW5kaXZpZHVhbCB7RG9jdW1lbnRTeW1ib2x9IGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIHRvIGFuIHtPdXRsaW5lVHJlZX0gZm9yIHVzZSBieSB0aGUgT3V0bGluZSBWaWV3LiBJdCBkb2VzIE5PVCByZWN1cnNpdmVseVxyXG4gIC8vIHByb2Nlc3MgdGhlIGdpdmVuIHN5bWJvbCdzIGNoaWxkcmVuIChpZiBhbnkpLlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUge0RvY3VtZW50U3ltYm9sfSB0byBjb252ZXJ0IHRvIGFuIHtPdXRsaW5lVHJlZX0uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSB7T3V0bGluZVRyZWV9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHtEb2N1bWVudFN5bWJvbH0uXHJcbiAgcHVibGljIHN0YXRpYyBoaWVyYXJjaGljYWxTeW1ib2xUb091dGxpbmUoc3ltYm9sOiBEb2N1bWVudFN5bWJvbCk6IGF0b21JZGUuT3V0bGluZVRyZWUge1xyXG4gICAgY29uc3QgaWNvbiA9IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbC5raW5kKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b2tlbml6ZWRUZXh0OiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAga2luZDogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2wua2luZCksXHJcbiAgICAgICAgICB2YWx1ZTogc3ltYm9sLm5hbWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgaWNvbjogaWNvbiAhPSBudWxsID8gaWNvbiA6IHVuZGVmaW5lZCxcclxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcclxuICAgICAgc3RhcnRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLnNlbGVjdGlvblJhbmdlLnN0YXJ0KSxcclxuICAgICAgZW5kUG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5zZWxlY3Rpb25SYW5nZS5lbmQpLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIGluZGl2aWR1YWwge1N5bWJvbEluZm9ybWF0aW9ufSBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyB0byBhbiB7T3V0bGluZVRyZWV9IGZvciB1c2UgYnkgdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIHtTeW1ib2xJbmZvcm1hdGlvbn0gdG8gY29udmVydCB0byBhbiB7T3V0bGluZVRyZWV9LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUge091dGxpbmVUcmVlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7U3ltYm9sSW5mb3JtYXRpb259LlxyXG4gIHB1YmxpYyBzdGF0aWMgc3ltYm9sVG9PdXRsaW5lKHN5bWJvbDogU3ltYm9sSW5mb3JtYXRpb24pOiBhdG9tSWRlLk91dGxpbmVUcmVlIHtcclxuICAgIGNvbnN0IGljb24gPSBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2wua2luZCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0b2tlbml6ZWRUZXh0OiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAga2luZDogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb1Rva2VuS2luZChzeW1ib2wua2luZCksXHJcbiAgICAgICAgICB2YWx1ZTogc3ltYm9sLm5hbWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgaWNvbjogaWNvbiAhPSBudWxsID8gaWNvbiA6IHVuZGVmaW5lZCxcclxuICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBzeW1ib2wubmFtZSxcclxuICAgICAgc3RhcnRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLnN0YXJ0KSxcclxuICAgICAgZW5kUG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5lbmQpLFxyXG4gICAgICBjaGlsZHJlbjogW10sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgc3ltYm9sIGtpbmQgaW50byBhbiBvdXRsaW5lIGVudGl0eSBraW5kIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAgLy8gdGhlIHN0eWxpbmcgc3VjaCBhcyB0aGUgYXBwcm9wcmlhdGUgaWNvbiBpbiB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBPdXRsaW5lVmlldyBlbnRpdHkga2luZC5cclxuICBwdWJsaWMgc3RhdGljIHN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sOiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcclxuICAgIHN3aXRjaCAoc3ltYm9sKSB7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5BcnJheTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtYXJyYXknO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQm9vbGVhbjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtYm9vbGVhbic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY2xhc3MnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RhbnQ6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0YW50JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdHJ1Y3Rvcic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5FbnVtOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1lbnVtJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpZWxkOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1maWVsZCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GaWxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1maWxlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1mdW5jdGlvbic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5JbnRlcmZhY2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWludGVyZmFjZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5NZXRob2Q6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW1ldGhvZCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Nb2R1bGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW1vZHVsZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5OYW1lc3BhY2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW5hbWVzcGFjZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5OdW1iZXI6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW51bWJlcic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5QYWNrYWdlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1wYWNrYWdlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlByb3BlcnR5OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1wcm9wZXJ0eSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5TdHJpbmc6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXN0cmluZyc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5WYXJpYWJsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtdmFyaWFibGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RydWN0OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jbGFzcyc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5FbnVtTWVtYmVyOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdGFudCc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCB0byB0aGUgYXBwcm9wcmlhdGUgdG9rZW4ga2luZCB1c2VkIHRvIHN5bnRheFxyXG4gIC8vIGhpZ2hsaWdodCB0aGUgc3ltYm9sIG5hbWUgaW4gdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgc3ludGF4IHRva2VuIGtpbmQuXHJcbiAgcHVibGljIHN0YXRpYyBzeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sOiBudW1iZXIpOiBhdG9tSWRlLlRva2VuS2luZCB7XHJcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxyXG4gICAgICAgIHJldHVybiAnY29uc3RydWN0b3InO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgcmV0dXJuICdtZXRob2QnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxyXG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gJ3BsYWluJztcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19