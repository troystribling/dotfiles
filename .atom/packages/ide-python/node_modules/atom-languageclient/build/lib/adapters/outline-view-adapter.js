Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
let OutlineViewAdapter = class OutlineViewAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  getOutline(connection, editor) {
    return _asyncToGenerator(function* () {
      const results = yield connection.documentSymbol({
        textDocument: _convert2.default.editorToTextDocumentIdentifier(editor)
      });
      results.sort(function (a, b) {
        return a.location.range.start.line === b.location.range.start.line ? a.location.range.start.character - b.location.range.start.character : a.location.range.start.line - b.location.range.start.line;
      });
      return {
        outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
      };
    })();
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    // Temporarily keep containerName through the conversion process
    const allItems = symbols.map(symbol => ({
      containerName: symbol.containerName,
      outline: OutlineViewAdapter.symbolToOutline(symbol)
    }));

    // Create a map of containers by name with all items that have that name
    const containers = allItems.reduce((map, item) => {
      const name = item.outline.representativeName;
      if (name != null) {
        const container = map.get(name);
        if (container == null) {
          map.set(name, [item.outline]);
        } else {
          container.push(item.outline);
        }
      }
      return map;
    }, new Map());

    const roots = [];

    // Put each item within its parent and extract out the roots
    for (const item of allItems) {
      const containerName = item.containerName;
      const child = item.outline;
      if (containerName == null || containerName === '') {
        roots.push(item.outline);
      } else {
        const possibleParents = containers.get(containerName);
        let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
        if (closestParent == null) {
          closestParent = {
            plainText: containerName,
            representativeName: containerName,
            startPosition: new _atom.Point(0, 0),
            children: [child]
          };
          roots.push(closestParent);
          if (possibleParents == null) {
            containers.set(containerName, [closestParent]);
          } else {
            possibleParents.push(closestParent);
          }
        } else {
          closestParent.children.push(child);
        }
      }
    }

    return roots;
  }

  static _getClosestParent(candidates, child) {
    if (candidates == null || candidates.length === 0) {
      return null;
    }

    let parent = null;
    for (const candidate of candidates) {
      if (candidate !== child && candidate.startPosition.isLessThanOrEqual(child.startPosition) && (candidate.endPosition == null || candidate.endPosition.isGreaterThanOrEqual(child.endPosition))) {
        if (parent == null || parent.startPosition.isLessThanOrEqual(candidate.startPosition) || parent.endPosition != null && parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)) {
          parent = candidate;
        }
      }
    }

    return parent;
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
};
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRvY3VtZW50U3ltYm9sUHJvdmlkZXIiLCJnZXRPdXRsaW5lIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInJlc3VsdHMiLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInNvcnQiLCJhIiwiYiIsImxvY2F0aW9uIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJvdXRsaW5lVHJlZXMiLCJjcmVhdGVPdXRsaW5lVHJlZXMiLCJzeW1ib2xzIiwiYWxsSXRlbXMiLCJtYXAiLCJzeW1ib2wiLCJjb250YWluZXJOYW1lIiwib3V0bGluZSIsInN5bWJvbFRvT3V0bGluZSIsImNvbnRhaW5lcnMiLCJyZWR1Y2UiLCJpdGVtIiwibmFtZSIsInJlcHJlc2VudGF0aXZlTmFtZSIsImNvbnRhaW5lciIsImdldCIsInNldCIsInB1c2giLCJNYXAiLCJyb290cyIsImNoaWxkIiwicG9zc2libGVQYXJlbnRzIiwiY2xvc2VzdFBhcmVudCIsIl9nZXRDbG9zZXN0UGFyZW50IiwicGxhaW5UZXh0Iiwic3RhcnRQb3NpdGlvbiIsImNoaWxkcmVuIiwiY2FuZGlkYXRlcyIsImxlbmd0aCIsInBhcmVudCIsImNhbmRpZGF0ZSIsImlzTGVzc1RoYW5PckVxdWFsIiwiZW5kUG9zaXRpb24iLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbCIsImljb24iLCJzeW1ib2xLaW5kVG9FbnRpdHlLaW5kIiwia2luZCIsInRva2VuaXplZFRleHQiLCJzeW1ib2xLaW5kVG9Ub2tlbktpbmQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInBvc2l0aW9uVG9Qb2ludCIsImVuZCIsIkFycmF5IiwiQm9vbGVhbiIsIkNsYXNzIiwiQ29uc3RhbnQiLCJDb25zdHJ1Y3RvciIsIkVudW0iLCJGaWVsZCIsIkZpbGUiLCJGdW5jdGlvbiIsIkludGVyZmFjZSIsIk1ldGhvZCIsIk1vZHVsZSIsIk5hbWVzcGFjZSIsIk51bWJlciIsIlBhY2thZ2UiLCJQcm9wZXJ0eSIsIlN0cmluZyIsIlZhcmlhYmxlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7SUFDcUJBLGtCLEdBQU4sTUFBTUEsa0JBQU4sQ0FBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxzQkFBbkIsS0FBOEMsSUFBckQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ01DLFlBQU4sQ0FBaUJDLFVBQWpCLEVBQXVEQyxNQUF2RCxFQUEyRztBQUFBO0FBQ3pHLFlBQU1DLFVBQVUsTUFBTUYsV0FBV0csY0FBWCxDQUEwQjtBQUM5Q0Msc0JBQWMsa0JBQVFDLDhCQUFSLENBQXVDSixNQUF2QztBQURnQyxPQUExQixDQUF0QjtBQUdBQyxjQUFRSSxJQUFSLENBQ0UsVUFBQ0MsQ0FBRCxFQUFJQyxDQUFKO0FBQUEsZUFDRUQsRUFBRUUsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFBdkIsS0FBZ0NKLEVBQUVDLFFBQUYsQ0FBV0MsS0FBWCxDQUFpQkMsS0FBakIsQ0FBdUJDLElBQXZELEdBQ0lMLEVBQUVFLFFBQUYsQ0FBV0MsS0FBWCxDQUFpQkMsS0FBakIsQ0FBdUJFLFNBQXZCLEdBQW1DTCxFQUFFQyxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCRSxTQUQ5RCxHQUVJTixFQUFFRSxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCQyxJQUF2QixHQUE4QkosRUFBRUMsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixD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UUFBUDtBQUNGO0FBQ0UsZUFBTyxPQUFQO0FBWEo7QUFhRDtBQXROcUMsQztrQkFBbkI5RSxrQiIsImZpbGUiOiJvdXRsaW5lLXZpZXctYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgU3ltYm9sS2luZCwgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsIHR5cGUgU3ltYm9sSW5mb3JtYXRpb259IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcbmltcG9ydCB7UG9pbnR9IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGRvY3VtZW50U3ltYm9sUHJvdmlkZXIgb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byB0aGUgT3V0bGluZSBWaWV3XHJcbi8vIHN1cHBsaWVkIGJ5IEF0b20gSURFIFVJLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRsaW5lVmlld0FkYXB0ZXIge1xyXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGRvY3VtZW50U3ltYm9sUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIE91dGxpbmUgZm9yIGRvY3VtZW50IHZpYSB0aGUge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gYXMgaWRlbnRpZmllZFxyXG4gIC8vIGJ5IHRoZSB7VGV4dEVkaXRvcn0uXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcclxuICAvLyAgICAgICAgICAgICAgICBmb3IgdGhlIG91dGxpbmUuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgT3V0bGluZSBzaG91bGQgcmVwcmVzZW50LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIHRoZSB7T3V0bGluZX0gb2YgdGhpcyBkb2N1bWVudC5cclxuICBhc3luYyBnZXRPdXRsaW5lKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiBQcm9taXNlPD9hdG9tSWRlJE91dGxpbmU+IHtcclxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50U3ltYm9sKHtcclxuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxyXG4gICAgfSk7XHJcbiAgICByZXN1bHRzLnNvcnQoXHJcbiAgICAgIChhLCBiKSA9PlxyXG4gICAgICAgIGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZSA9PT0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lXHJcbiAgICAgICAgICA/IGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXJcclxuICAgICAgICAgIDogYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lLFxyXG4gICAgKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG91dGxpbmVUcmVlczogT3V0bGluZVZpZXdBZGFwdGVyLmNyZWF0ZU91dGxpbmVUcmVlcyhyZXN1bHRzKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhbiB7QXJyYXl9IG9mIHtPdXRsaW5lVHJlZX1zIGZyb20gdGhlIEFycmF5IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn0gcmVjaWV2ZWRcclxuICAvLyBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaW5jbHVkZXMgZGV0ZXJtaW5pbmcgdGhlIGFwcHJvcHJpYXRlIGNoaWxkIGFuZCBwYXJlbnRcclxuICAvLyByZWxhdGlvbnNoaXBzIGZvciB0aGUgaGllcmFyY2h5LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sc2AgQW4ge0FycmF5fSBvZiB7U3ltYm9sSW5mb3JtYXRpb259cyByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdFxyXG4gIC8vICAgICAgICAgICAgIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4ge091dGxpbmVUcmVlfS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYW4ge091dGxpbmVUcmVlfSBjb250YWluaW5nIHRoZSBnaXZlbiBzeW1ib2xzIHRoYXQgdGhlIE91dGxpbmUgVmlldyBjYW4gZGlzcGxheS5cclxuICBzdGF0aWMgY3JlYXRlT3V0bGluZVRyZWVzKHN5bWJvbHM6IEFycmF5PFN5bWJvbEluZm9ybWF0aW9uPik6IEFycmF5PGF0b21JZGUkT3V0bGluZVRyZWU+IHtcclxuICAgIC8vIFRlbXBvcmFyaWx5IGtlZXAgY29udGFpbmVyTmFtZSB0aHJvdWdoIHRoZSBjb252ZXJzaW9uIHByb2Nlc3NcclxuICAgIGNvbnN0IGFsbEl0ZW1zID0gc3ltYm9scy5tYXAoc3ltYm9sID0+ICh7XHJcbiAgICAgIGNvbnRhaW5lck5hbWU6IHN5bWJvbC5jb250YWluZXJOYW1lLFxyXG4gICAgICBvdXRsaW5lOiBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sVG9PdXRsaW5lKHN5bWJvbCksXHJcbiAgICB9KSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGNvbnRhaW5lcnMgYnkgbmFtZSB3aXRoIGFsbCBpdGVtcyB0aGF0IGhhdmUgdGhhdCBuYW1lXHJcbiAgICBjb25zdCBjb250YWluZXJzID0gYWxsSXRlbXMucmVkdWNlKChtYXAsIGl0ZW0pID0+IHtcclxuICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ub3V0bGluZS5yZXByZXNlbnRhdGl2ZU5hbWU7XHJcbiAgICAgIGlmIChuYW1lICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBtYXAuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgbWFwLnNldChuYW1lLCBbaXRlbS5vdXRsaW5lXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGl0ZW0ub3V0bGluZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9LCBuZXcgTWFwKCkpO1xyXG5cclxuICAgIGNvbnN0IHJvb3RzOiBBcnJheTxhdG9tSWRlJE91dGxpbmVUcmVlPiA9IFtdO1xyXG5cclxuICAgIC8vIFB1dCBlYWNoIGl0ZW0gd2l0aGluIGl0cyBwYXJlbnQgYW5kIGV4dHJhY3Qgb3V0IHRoZSByb290c1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFsbEl0ZW1zKSB7XHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lck5hbWUgPSBpdGVtLmNvbnRhaW5lck5hbWU7XHJcbiAgICAgIGNvbnN0IGNoaWxkID0gaXRlbS5vdXRsaW5lO1xyXG4gICAgICBpZiAoY29udGFpbmVyTmFtZSA9PSBudWxsIHx8IGNvbnRhaW5lck5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgcm9vdHMucHVzaChpdGVtLm91dGxpbmUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHBvc3NpYmxlUGFyZW50cyA9IGNvbnRhaW5lcnMuZ2V0KGNvbnRhaW5lck5hbWUpO1xyXG4gICAgICAgIGxldCBjbG9zZXN0UGFyZW50ID0gT3V0bGluZVZpZXdBZGFwdGVyLl9nZXRDbG9zZXN0UGFyZW50KHBvc3NpYmxlUGFyZW50cywgY2hpbGQpO1xyXG4gICAgICAgIGlmIChjbG9zZXN0UGFyZW50ID09IG51bGwpIHtcclxuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQgPSB7XHJcbiAgICAgICAgICAgIHBsYWluVGV4dDogY29udGFpbmVyTmFtZSxcclxuICAgICAgICAgICAgcmVwcmVzZW50YXRpdmVOYW1lOiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uOiBuZXcgUG9pbnQoMCwgMCksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbY2hpbGRdLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHJvb3RzLnB1c2goY2xvc2VzdFBhcmVudCk7XHJcbiAgICAgICAgICBpZiAocG9zc2libGVQYXJlbnRzID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29udGFpbmVycy5zZXQoY29udGFpbmVyTmFtZSwgW2Nsb3Nlc3RQYXJlbnRdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBvc3NpYmxlUGFyZW50cy5wdXNoKGNsb3Nlc3RQYXJlbnQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjbG9zZXN0UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb290cztcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfZ2V0Q2xvc2VzdFBhcmVudChjYW5kaWRhdGVzOiA/QXJyYXk8YXRvbUlkZSRPdXRsaW5lVHJlZT4sIGNoaWxkOiBhdG9tSWRlJE91dGxpbmVUcmVlKTogP2F0b21JZGUkT3V0bGluZVRyZWUge1xyXG4gICAgaWYgKGNhbmRpZGF0ZXMgPT0gbnVsbCB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGFyZW50ID0gbnVsbDtcclxuICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIGNhbmRpZGF0ZXMpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGNhbmRpZGF0ZSAhPT0gY2hpbGQgJiZcclxuICAgICAgICBjYW5kaWRhdGUuc3RhcnRQb3NpdGlvbi5pc0xlc3NUaGFuT3JFcXVhbChjaGlsZC5zdGFydFBvc2l0aW9uKSAmJlxyXG4gICAgICAgIChjYW5kaWRhdGUuZW5kUG9zaXRpb24gPT0gbnVsbCB8fCBjYW5kaWRhdGUuZW5kUG9zaXRpb24uaXNHcmVhdGVyVGhhbk9yRXF1YWwoY2hpbGQuZW5kUG9zaXRpb24pKVxyXG4gICAgICApIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBwYXJlbnQgPT0gbnVsbCB8fFxyXG4gICAgICAgICAgKHBhcmVudC5zdGFydFBvc2l0aW9uLmlzTGVzc1RoYW5PckVxdWFsKGNhbmRpZGF0ZS5zdGFydFBvc2l0aW9uKSB8fFxyXG4gICAgICAgICAgICAocGFyZW50LmVuZFBvc2l0aW9uICE9IG51bGwgJiYgcGFyZW50LmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbikpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcGFyZW50ID0gY2FuZGlkYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gaW5kaXZpZHVhbCB7U3ltYm9sSW5mb3JtYXRpb259IGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIHRvIGFuIHtPdXRsaW5lVHJlZX0gZm9yIHVzZSBieSB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUge1N5bWJvbEluZm9ybWF0aW9ufSB0byBjb252ZXJ0IHRvIGFuIHtPdXRsaW5lVHJlZX0uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSB7T3V0bGluZVRyZWV9IGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHtTeW1ib2xJbmZvcm1hdGlvbn0uXHJcbiAgc3RhdGljIHN5bWJvbFRvT3V0bGluZShzeW1ib2w6IFN5bWJvbEluZm9ybWF0aW9uKTogYXRvbUlkZSRPdXRsaW5lVHJlZSB7XHJcbiAgICBjb25zdCBpY29uID0gT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sLmtpbmQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9rZW5pemVkVGV4dDogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGtpbmQ6IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sLmtpbmQpLFxyXG4gICAgICAgICAgdmFsdWU6IHN5bWJvbC5uYW1lLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIGljb246IGljb24gIT0gbnVsbCA/IGljb24gOiB1bmRlZmluZWQsXHJcbiAgICAgIHJlcHJlc2VudGF0aXZlTmFtZTogc3ltYm9sLm5hbWUsXHJcbiAgICAgIHN0YXJ0UG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5zdGFydCksXHJcbiAgICAgIGVuZFBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChzeW1ib2wubG9jYXRpb24ucmFuZ2UuZW5kKSxcclxuICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIGludG8gYW4gb3V0bGluZSBlbnRpdHkga2luZCB1c2VkIHRvIGRldGVybWluZVxyXG4gIC8vIHRoZSBzdHlsaW5nIHN1Y2ggYXMgdGhlIGFwcHJvcHJpYXRlIGljb24gaW4gdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgT3V0bGluZVZpZXcgZW50aXR5IGtpbmQuXHJcbiAgc3RhdGljIHN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sOiBudW1iZXIpOiA/c3RyaW5nIHtcclxuICAgIHN3aXRjaCAoc3ltYm9sKSB7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5BcnJheTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtYXJyYXknO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQm9vbGVhbjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtYm9vbGVhbic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY2xhc3MnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RhbnQ6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0YW50JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdHJ1Y3Rvcic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5FbnVtOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1lbnVtJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpZWxkOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1maWVsZCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GaWxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1maWxlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1mdW5jdGlvbic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5JbnRlcmZhY2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWludGVyZmFjZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5NZXRob2Q6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW1ldGhvZCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Nb2R1bGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW1vZHVsZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5OYW1lc3BhY2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW5hbWVzcGFjZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5OdW1iZXI6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLW51bWJlcic7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5QYWNrYWdlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1wYWNrYWdlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlByb3BlcnR5OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1wcm9wZXJ0eSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5TdHJpbmc6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXN0cmluZyc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5WYXJpYWJsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtdmFyaWFibGUnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgc3ltYm9sIGtpbmQgdG8gdGhlIGFwcHJvcHJpYXRlIHRva2VuIGtpbmQgdXNlZCB0byBzeW50YXhcclxuICAvLyBoaWdobGlnaHQgdGhlIHN5bWJvbCBuYW1lIGluIHRoZSBPdXRsaW5lIFZpZXcuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xgIFRoZSBudW1lcmljIHN5bWJvbCBraW5kIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcXVpdmFsZW50IHN5bnRheCB0b2tlbiBraW5kLlxyXG4gIHN0YXRpYyBzeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sOiBudW1iZXIpOiBhdG9tSWRlJFRva2VuS2luZCB7XHJcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxyXG4gICAgICAgIHJldHVybiAnY29uc3RydWN0b3InO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgcmV0dXJuICdtZXRob2QnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxyXG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gJ3BsYWluJztcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19