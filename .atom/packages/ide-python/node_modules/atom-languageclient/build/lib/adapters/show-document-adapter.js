"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.showDocument = exports.attach = void 0;
const electron_1 = require("electron");
const atom_1 = require("atom");
const convert_1 = require("../convert");
/** Public: Adapts the window/showDocument command to Atom's text editors or external programs. */
const ShowDocumentAdapter = {
    /** {@inheritDoc attach} */
    attach,
    /** {@inheritDoc showDocument} */
    showDocument,
};
// for consistency with other adapters
exports.default = ShowDocumentAdapter;
/** Public: Attach to a {LanguageClientConnection} to recieve requests to show documents. */
function attach(connection) {
    connection.onShowDocument(showDocument);
}
exports.attach = attach;
/**
 * Public: show documents inside Atom text editor or in external programs
 *
 * @param params The {ShowDocumentParams} received from the language server indicating the document to be displayed as
 *   well as other metadata.
 * @returns {Promise<ShowDocumentResult>} With a `success: boolean` property specifying if the operation was sucessful
 *   {@inheritDoc ShowDocumentParams}
 */
function showDocument(params) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (!params.external) {
                // open using atom.workspace
                const view = yield atom.workspace.open(convert_1.default.uriToPath(params.uri), {
                    activateItem: params.takeFocus,
                    activatePane: params.takeFocus,
                    pending: true,
                    initialLine: (_b = (_a = params.selection) === null || _a === void 0 ? void 0 : _a.start.line) !== null && _b !== void 0 ? _b : 0,
                    initialColumn: (_d = (_c = params.selection) === null || _c === void 0 ? void 0 : _c.start.character) !== null && _d !== void 0 ? _d : 0,
                });
                if (!view) {
                    return { success: false };
                }
                if (view instanceof atom_1.TextEditor && params.selection !== undefined) {
                    view.selectToBufferPosition(convert_1.default.positionToPoint(params.selection.end));
                }
            }
            else {
                // open using Electron
                electron_1.shell.openExternal(params.uri, { activate: params.takeFocus });
            }
            return { success: true };
        }
        catch (e) {
            atom.notifications.addError(e);
            return { success: false };
        }
    });
}
exports.showDocument = showDocument;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hvdy1kb2N1bWVudC1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbGliL2FkYXB0ZXJzL3Nob3ctZG9jdW1lbnQtYWRhcHRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx1Q0FBZ0M7QUFFaEMsK0JBQWlDO0FBQ2pDLHdDQUFnQztBQUVoQyxrR0FBa0c7QUFDbEcsTUFBTSxtQkFBbUIsR0FBRztJQUMxQiwyQkFBMkI7SUFDM0IsTUFBTTtJQUNOLGlDQUFpQztJQUNqQyxZQUFZO0NBQ2IsQ0FBQTtBQUNELHNDQUFzQztBQUN0QyxrQkFBZSxtQkFBbUIsQ0FBQTtBQUVsQyw0RkFBNEY7QUFDNUYsU0FBZ0IsTUFBTSxDQUFDLFVBQW9DO0lBQ3pELFVBQVUsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQUE7QUFDekMsQ0FBQztBQUZELHdCQUVDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQXNCLFlBQVksQ0FBQyxNQUEwQjs7O1FBQzNELElBQUk7WUFDRixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtnQkFDcEIsNEJBQTRCO2dCQUM1QixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtvQkFDcEUsWUFBWSxFQUFFLE1BQU0sQ0FBQyxTQUFTO29CQUM5QixZQUFZLEVBQUUsTUFBTSxDQUFDLFNBQVM7b0JBQzlCLE9BQU8sRUFBRSxJQUFJO29CQUNiLFdBQVcsRUFBRSxNQUFBLE1BQUEsTUFBTSxDQUFDLFNBQVMsMENBQUUsS0FBSyxDQUFDLElBQUksbUNBQUksQ0FBQztvQkFDOUMsYUFBYSxFQUFFLE1BQUEsTUFBQSxNQUFNLENBQUMsU0FBUywwQ0FBRSxLQUFLLENBQUMsU0FBUyxtQ0FBSSxDQUFDO2lCQUN0RCxDQUFDLENBQUE7Z0JBQ0YsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDVCxPQUFPLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFBO2lCQUMxQjtnQkFDRCxJQUFJLElBQUksWUFBWSxpQkFBVSxJQUFJLE1BQU0sQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFO29CQUNoRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsaUJBQU8sQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO2lCQUMzRTthQUNGO2lCQUFNO2dCQUNMLHNCQUFzQjtnQkFDdEIsZ0JBQUssQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQTthQUMvRDtZQUNELE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUE7U0FDekI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBQzlCLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLENBQUE7U0FDMUI7O0NBQ0Y7QUExQkQsb0NBMEJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hlbGwgfSBmcm9tIFwiZWxlY3Ryb25cIlxuaW1wb3J0IHsgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBTaG93RG9jdW1lbnRQYXJhbXMsIFNob3dEb2N1bWVudFJlc3VsdCB9IGZyb20gXCIuLi9sYW5ndWFnZWNsaWVudFwiXG5pbXBvcnQgeyBUZXh0RWRpdG9yIH0gZnJvbSBcImF0b21cIlxuaW1wb3J0IENvbnZlcnQgZnJvbSBcIi4uL2NvbnZlcnRcIlxuXG4vKiogUHVibGljOiBBZGFwdHMgdGhlIHdpbmRvdy9zaG93RG9jdW1lbnQgY29tbWFuZCB0byBBdG9tJ3MgdGV4dCBlZGl0b3JzIG9yIGV4dGVybmFsIHByb2dyYW1zLiAqL1xuY29uc3QgU2hvd0RvY3VtZW50QWRhcHRlciA9IHtcbiAgLyoqIHtAaW5oZXJpdERvYyBhdHRhY2h9ICovXG4gIGF0dGFjaCxcbiAgLyoqIHtAaW5oZXJpdERvYyBzaG93RG9jdW1lbnR9ICovXG4gIHNob3dEb2N1bWVudCxcbn1cbi8vIGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGFkYXB0ZXJzXG5leHBvcnQgZGVmYXVsdCBTaG93RG9jdW1lbnRBZGFwdGVyXG5cbi8qKiBQdWJsaWM6IEF0dGFjaCB0byBhIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHJlY2lldmUgcmVxdWVzdHMgdG8gc2hvdyBkb2N1bWVudHMuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbik6IHZvaWQge1xuICBjb25uZWN0aW9uLm9uU2hvd0RvY3VtZW50KHNob3dEb2N1bWVudClcbn1cblxuLyoqXG4gKiBQdWJsaWM6IHNob3cgZG9jdW1lbnRzIGluc2lkZSBBdG9tIHRleHQgZWRpdG9yIG9yIGluIGV4dGVybmFsIHByb2dyYW1zXG4gKlxuICogQHBhcmFtIHBhcmFtcyBUaGUge1Nob3dEb2N1bWVudFBhcmFtc30gcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGluZGljYXRpbmcgdGhlIGRvY3VtZW50IHRvIGJlIGRpc3BsYXllZCBhc1xuICogICB3ZWxsIGFzIG90aGVyIG1ldGFkYXRhLlxuICogQHJldHVybnMge1Byb21pc2U8U2hvd0RvY3VtZW50UmVzdWx0Pn0gV2l0aCBhIGBzdWNjZXNzOiBib29sZWFuYCBwcm9wZXJ0eSBzcGVjaWZ5aW5nIGlmIHRoZSBvcGVyYXRpb24gd2FzIHN1Y2Vzc2Z1bFxuICogICB7QGluaGVyaXREb2MgU2hvd0RvY3VtZW50UGFyYW1zfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2hvd0RvY3VtZW50KHBhcmFtczogU2hvd0RvY3VtZW50UGFyYW1zKTogUHJvbWlzZTxTaG93RG9jdW1lbnRSZXN1bHQ+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXBhcmFtcy5leHRlcm5hbCkge1xuICAgICAgLy8gb3BlbiB1c2luZyBhdG9tLndvcmtzcGFjZVxuICAgICAgY29uc3QgdmlldyA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oQ29udmVydC51cmlUb1BhdGgocGFyYW1zLnVyaSksIHtcbiAgICAgICAgYWN0aXZhdGVJdGVtOiBwYXJhbXMudGFrZUZvY3VzLFxuICAgICAgICBhY3RpdmF0ZVBhbmU6IHBhcmFtcy50YWtlRm9jdXMsXG4gICAgICAgIHBlbmRpbmc6IHRydWUsXG4gICAgICAgIGluaXRpYWxMaW5lOiBwYXJhbXMuc2VsZWN0aW9uPy5zdGFydC5saW5lID8/IDAsXG4gICAgICAgIGluaXRpYWxDb2x1bW46IHBhcmFtcy5zZWxlY3Rpb24/LnN0YXJ0LmNoYXJhY3RlciA/PyAwLFxuICAgICAgfSlcbiAgICAgIGlmICghdmlldykge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSB9XG4gICAgICB9XG4gICAgICBpZiAodmlldyBpbnN0YW5jZW9mIFRleHRFZGl0b3IgJiYgcGFyYW1zLnNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZpZXcuc2VsZWN0VG9CdWZmZXJQb3NpdGlvbihDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChwYXJhbXMuc2VsZWN0aW9uLmVuZCkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9wZW4gdXNpbmcgRWxlY3Ryb25cbiAgICAgIHNoZWxsLm9wZW5FeHRlcm5hbChwYXJhbXMudXJpLCB7IGFjdGl2YXRlOiBwYXJhbXMudGFrZUZvY3VzIH0pXG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZEVycm9yKGUpXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfVxuICB9XG59XG4iXX0=