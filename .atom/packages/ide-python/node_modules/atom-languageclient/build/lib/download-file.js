"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
/**
 * Public: Download a file and store it on a file system using streaming with appropriate progress callback.
 *
 * @param sourceUrl Url to download from.
 * @param targetFile File path to save to.
 * @param progressCallback Callback function that will be given a {ByteProgressCallback} object containing both
 *   bytesDone and percent.
 * @param length File length in bytes if you want percentage progress indication and the server is unable to provide a
 *   Content-Length header and whitelist CORS access via a `Access-Control-Expose-Headers "content-length"` header.
 * @returns A {Promise} that will accept when complete.
 */
exports.default = (function downloadFile(sourceUrl, targetFile, progressCallback, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new Request(sourceUrl, {
            headers: new Headers({ "Content-Type": "application/octet-stream" }),
        });
        const response = yield fetch(request);
        if (!response.ok) {
            throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
        }
        const body = response.body;
        if (body == null) {
            throw Error("No response body");
        }
        const finalLength = length || parseInt(response.headers.get("Content-Length") || "0", 10);
        const reader = body.getReader();
        const writer = fs.createWriteStream(targetFile);
        yield streamWithProgress(finalLength, reader, writer, progressCallback);
        writer.end();
    });
});
/**
 * Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
 *
 * @param length File length in bytes.
 * @param reader A {ReadableStreamReader} to read from.
 * @param writer A {WriteStream} to write to.
 * @param progressCallback Callback function that will be given a {ByteProgressCallback} object containing both
 *   bytesDone and percent.
 * @returns A {Promise} that will accept when complete.
 */
function streamWithProgress(length, reader, writer, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        let bytesDone = 0;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // TODO use Promise.all
            // eslint-disable-next-line no-await-in-loop
            const result = yield reader.read();
            if (result.done) {
                if (progressCallback != null) {
                    progressCallback(length, 100);
                }
                return;
            }
            const chunk = result.value;
            if (chunk == null) {
                throw Error("Empty chunk received during download");
            }
            else {
                writer.write(Buffer.from(chunk));
                if (progressCallback != null) {
                    bytesDone += chunk.byteLength;
                    const percent = length === 0 ? undefined : Math.floor((bytesDone / length) * 100);
                    progressCallback(bytesDone, percent);
                }
            }
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG93bmxvYWQtZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEseUJBQXdCO0FBRXhCOzs7Ozs7Ozs7O0dBVUc7QUFDSCxrQkFBZSxDQUFDLFNBQWUsWUFBWSxDQUN6QyxTQUFpQixFQUNqQixVQUFrQixFQUNsQixnQkFBdUMsRUFDdkMsTUFBZTs7UUFFZixNQUFNLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDckMsT0FBTyxFQUFFLElBQUksT0FBTyxDQUFDLEVBQUUsY0FBYyxFQUFFLDBCQUEwQixFQUFFLENBQUM7U0FDckUsQ0FBQyxDQUFBO1FBRUYsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUE7UUFDckMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxLQUFLLENBQUMsdUNBQXVDLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUE7U0FDN0Y7UUFFRCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFBO1FBQzFCLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNoQixNQUFNLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO1NBQ2hDO1FBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUN6RixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUE7UUFDL0IsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFBO1FBRS9DLE1BQU0sa0JBQWtCLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQTtRQUN2RSxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUE7SUFDZCxDQUFDO0NBQUEsQ0FBQyxDQUFBO0FBRUY7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZSxrQkFBa0IsQ0FDL0IsTUFBYyxFQUNkLE1BQXdDLEVBQ3hDLE1BQXNCLEVBQ3RCLGdCQUF1Qzs7UUFFdkMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFBO1FBRWpCLGlEQUFpRDtRQUNqRCxPQUFPLElBQUksRUFBRTtZQUNYLHVCQUF1QjtZQUN2Qiw0Q0FBNEM7WUFDNUMsTUFBTSxNQUFNLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUE7WUFDbEMsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO2dCQUNmLElBQUksZ0JBQWdCLElBQUksSUFBSSxFQUFFO29CQUM1QixnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUE7aUJBQzlCO2dCQUNELE9BQU07YUFDUDtZQUVELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUE7WUFDMUIsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO2dCQUNqQixNQUFNLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFBO2FBQ3BEO2lCQUFNO2dCQUNMLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFBO2dCQUNoQyxJQUFJLGdCQUFnQixJQUFJLElBQUksRUFBRTtvQkFDNUIsU0FBUyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUE7b0JBQzdCLE1BQU0sT0FBTyxHQUF1QixNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUE7b0JBQ3JHLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQTtpQkFDckM7YUFDRjtTQUNGO0lBQ0gsQ0FBQztDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCJcblxuLyoqXG4gKiBQdWJsaWM6IERvd25sb2FkIGEgZmlsZSBhbmQgc3RvcmUgaXQgb24gYSBmaWxlIHN5c3RlbSB1c2luZyBzdHJlYW1pbmcgd2l0aCBhcHByb3ByaWF0ZSBwcm9ncmVzcyBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0gc291cmNlVXJsIFVybCB0byBkb3dubG9hZCBmcm9tLlxuICogQHBhcmFtIHRhcmdldEZpbGUgRmlsZSBwYXRoIHRvIHNhdmUgdG8uXG4gKiBAcGFyYW0gcHJvZ3Jlc3NDYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZ2l2ZW4gYSB7Qnl0ZVByb2dyZXNzQ2FsbGJhY2t9IG9iamVjdCBjb250YWluaW5nIGJvdGhcbiAqICAgYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxuICogQHBhcmFtIGxlbmd0aCBGaWxlIGxlbmd0aCBpbiBieXRlcyBpZiB5b3Ugd2FudCBwZXJjZW50YWdlIHByb2dyZXNzIGluZGljYXRpb24gYW5kIHRoZSBzZXJ2ZXIgaXMgdW5hYmxlIHRvIHByb3ZpZGUgYVxuICogICBDb250ZW50LUxlbmd0aCBoZWFkZXIgYW5kIHdoaXRlbGlzdCBDT1JTIGFjY2VzcyB2aWEgYSBgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMgXCJjb250ZW50LWxlbmd0aFwiYCBoZWFkZXIuXG4gKiBAcmV0dXJucyBBIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoXG4gIHNvdXJjZVVybDogc3RyaW5nLFxuICB0YXJnZXRGaWxlOiBzdHJpbmcsXG4gIHByb2dyZXNzQ2FsbGJhY2s/OiBCeXRlUHJvZ3Jlc3NDYWxsYmFjayxcbiAgbGVuZ3RoPzogbnVtYmVyXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHNvdXJjZVVybCwge1xuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9KSxcbiAgfSlcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRvd25sb2FkLCBzZXJ2ZXIgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuICB9XG5cbiAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHlcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKFwiTm8gcmVzcG9uc2UgYm9keVwiKVxuICB9XG5cbiAgY29uc3QgZmluYWxMZW5ndGggPSBsZW5ndGggfHwgcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSB8fCBcIjBcIiwgMTApXG4gIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKClcbiAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0odGFyZ2V0RmlsZSlcblxuICBhd2FpdCBzdHJlYW1XaXRoUHJvZ3Jlc3MoZmluYWxMZW5ndGgsIHJlYWRlciwgd3JpdGVyLCBwcm9ncmVzc0NhbGxiYWNrKVxuICB3cml0ZXIuZW5kKClcbn0pXG5cbi8qKlxuICogU3RyZWFtIGZyb20gYSB7UmVhZGFibGVTdHJlYW1SZWFkZXJ9IHRvIGEge1dyaXRlU3RyZWFtfSB3aXRoIHByb2dyZXNzIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSBsZW5ndGggRmlsZSBsZW5ndGggaW4gYnl0ZXMuXG4gKiBAcGFyYW0gcmVhZGVyIEEge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byByZWFkIGZyb20uXG4gKiBAcGFyYW0gd3JpdGVyIEEge1dyaXRlU3RyZWFtfSB0byB3cml0ZSB0by5cbiAqIEBwYXJhbSBwcm9ncmVzc0NhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmcgYm90aFxuICogICBieXRlc0RvbmUgYW5kIHBlcmNlbnQuXG4gKiBAcmV0dXJucyBBIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVdpdGhQcm9ncmVzcyhcbiAgbGVuZ3RoOiBudW1iZXIsXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXI8VWludDhBcnJheT4sXG4gIHdyaXRlcjogZnMuV3JpdGVTdHJlYW0sXG4gIHByb2dyZXNzQ2FsbGJhY2s/OiBCeXRlUHJvZ3Jlc3NDYWxsYmFja1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGxldCBieXRlc0RvbmUgPSAwXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRPRE8gdXNlIFByb21pc2UuYWxsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3BcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2sobGVuZ3RoLCAxMDApXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjaHVuayA9IHJlc3VsdC52YWx1ZVxuICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkVtcHR5IGNodW5rIHJlY2VpdmVkIGR1cmluZyBkb3dubG9hZFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZXIud3JpdGUoQnVmZmVyLmZyb20oY2h1bmspKVxuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBieXRlc0RvbmUgKz0gY2h1bmsuYnl0ZUxlbmd0aFxuICAgICAgICBjb25zdCBwZXJjZW50OiBudW1iZXIgfCB1bmRlZmluZWQgPSBsZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBNYXRoLmZsb29yKChieXRlc0RvbmUgLyBsZW5ndGgpICogMTAwKVxuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGJ5dGVzRG9uZSwgcGVyY2VudClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIFB1YmxpYzogUHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24gc2lnbmF0dXJlIGluZGljYXRpbmcgdGhlIGJ5dGVzRG9uZSBhbmQgb3B0aW9uYWwgcGVyY2VudGFnZSB3aGVuIGxlbmd0aCBpcyBrbm93bi4gKi9cbmV4cG9ydCB0eXBlIEJ5dGVQcm9ncmVzc0NhbGxiYWNrID0gKGJ5dGVzRG9uZTogbnVtYmVyLCBwZXJjZW50PzogbnVtYmVyKSA9PiB2b2lkXG4iXX0=