Object.defineProperty(exports, "__esModule", {
  value: true
});

// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `targwriteretFile` {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.
let streamWithProgress = (() => {
  var _ref2 = _asyncToGenerator(function* (length, reader, writer, progressCallback) {
    let bytesDone = 0;

    while (true) {
      const result = yield reader.read();
      if (result.done) {
        if (progressCallback != null) {
          progressCallback(length, 100);
        }
        return;
      }

      const chunk = result.value;
      if (chunk == null) {
        throw Error('Empty chunk received during download');
      } else {
        writer.write(Buffer.from(chunk));
        if (progressCallback != null) {
          bytesDone += chunk.byteLength;
          const percent = length === 0 ? null : Math.floor(bytesDone / length * 100);
          progressCallback(bytesDone, percent);
        }
      }
    }
  });

  return function streamWithProgress(_x5, _x6, _x7, _x8) {
    return _ref2.apply(this, arguments);
  };
})();

// Public: Progress callback function signature indicating the bytesDone and
// optional percentage when length is known.


var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           Optional file length in bytes for cases where the server will not supply the
//                      Content-Length header but the value is known in advance. Without either the
//                      percentage on the callback can not be determined.
//
// Returns a {Promise} that will accept when complete.
exports.default = (() => {
  var _ref = _asyncToGenerator(function* (sourceUrl, targetFile, progressCallback, length) {
    const request = new Request(sourceUrl, {
      headers: new Headers({ 'Content-Type': 'application/octet-stream' })
    });

    const response = yield fetch(request);
    if (!response.ok) {
      throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
    }

    const body = response.body;
    if (body == null) {
      throw Error('No response body');
    }

    const finalLength = length || parseInt(response.headers.get('Content-Length' || '0'), 10);
    const reader = body.getReader();
    const writer = _fs2.default.createWriteStream(targetFile);

    yield streamWithProgress(finalLength, reader, writer, progressCallback);
    writer.end();
  });

  function downloadFile(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  }

  return downloadFile;
})();

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLmpzIl0sIm5hbWVzIjpbImxlbmd0aCIsInJlYWRlciIsIndyaXRlciIsInByb2dyZXNzQ2FsbGJhY2siLCJieXRlc0RvbmUiLCJyZXN1bHQiLCJyZWFkIiwiZG9uZSIsImNodW5rIiwidmFsdWUiLCJFcnJvciIsIndyaXRlIiwiQnVmZmVyIiwiZnJvbSIsImJ5dGVMZW5ndGgiLCJwZXJjZW50IiwiTWF0aCIsImZsb29yIiwic3RyZWFtV2l0aFByb2dyZXNzIiwic291cmNlVXJsIiwidGFyZ2V0RmlsZSIsInJlcXVlc3QiLCJSZXF1ZXN0IiwiaGVhZGVycyIsIkhlYWRlcnMiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiYm9keSIsImZpbmFsTGVuZ3RoIiwicGFyc2VJbnQiLCJnZXQiLCJnZXRSZWFkZXIiLCJjcmVhdGVXcml0ZVN0cmVhbSIsImVuZCIsImRvd25sb2FkRmlsZSJdLCJtYXBwaW5ncyI6Ijs7OztBQTJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dDQUNBLFdBQ0VBLE1BREYsRUFFRUMsTUFGRixFQUdFQyxNQUhGLEVBSUVDLGdCQUpGLEVBS2lCO0FBQ2YsUUFBSUMsWUFBWSxDQUFoQjs7QUFFQSxXQUFPLElBQVAsRUFBYTtBQUNYLFlBQU1DLFNBQVMsTUFBTUosT0FBT0ssSUFBUCxFQUFyQjtBQUNBLFVBQUlELE9BQU9FLElBQVgsRUFBaUI7QUFDZixZQUFJSixvQkFBb0IsSUFBeEIsRUFBOEI7QUFDNUJBLDJCQUFpQkgsTUFBakIsRUFBeUIsR0FBekI7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsWUFBTVEsUUFBUUgsT0FBT0ksS0FBckI7QUFDQSxVQUFJRCxTQUFTLElBQWIsRUFBbUI7QUFDakIsY0FBTUUsTUFBTSxzQ0FBTixDQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0xSLGVBQU9TLEtBQVAsQ0FBYUMsT0FBT0MsSUFBUCxDQUFZTCxLQUFaLENBQWI7QUFDQSxZQUFJTCxvQkFBb0IsSUFBeEIsRUFBOEI7QUFDNUJDLHVCQUFhSSxNQUFNTSxVQUFuQjtBQUNBLGdCQUFNQyxVQUFtQmYsV0FBVyxDQUFYLEdBQWUsSUFBZixHQUFzQmdCLEtBQUtDLEtBQUwsQ0FBV2IsWUFBWUosTUFBWixHQUFxQixHQUFoQyxDQUEvQztBQUNBRywyQkFBaUJDLFNBQWpCLEVBQTRCVyxPQUE1QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEc7O2tCQTdCY0csa0I7Ozs7O0FBK0JmO0FBQ0E7OztBQWxGQTs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrQkFDZ0IsV0FDZEMsU0FEYyxFQUVkQyxVQUZjLEVBR2RqQixnQkFIYyxFQUlkSCxNQUpjLEVBS0M7QUFDZixVQUFNcUIsVUFBVSxJQUFJQyxPQUFKLENBQVlILFNBQVosRUFBdUI7QUFDckNJLGVBQVMsSUFBSUMsT0FBSixDQUFZLEVBQUMsZ0JBQWdCLDBCQUFqQixFQUFaO0FBRDRCLEtBQXZCLENBQWhCOztBQUlBLFVBQU1DLFdBQVcsTUFBTUMsTUFBTUwsT0FBTixDQUF2QjtBQUNBLFFBQUksQ0FBQ0ksU0FBU0UsRUFBZCxFQUFrQjtBQUNoQixZQUFNakIsTUFBTyx1Q0FBc0NlLFNBQVNHLE1BQU8sSUFBR0gsU0FBU0ksVUFBVyxFQUFwRixDQUFOO0FBQ0Q7O0FBRUQsVUFBTUMsT0FBT0wsU0FBU0ssSUFBdEI7QUFDQSxRQUFJQSxRQUFRLElBQVosRUFBa0I7QUFDaEIsWUFBTXBCLE1BQU0sa0JBQU4sQ0FBTjtBQUNEOztBQUVELFVBQU1xQixjQUFjL0IsVUFBVWdDLFNBQVNQLFNBQVNGLE9BQVQsQ0FBaUJVLEdBQWpCLENBQXFCLG9CQUFvQixHQUF6QyxDQUFULEVBQXdELEVBQXhELENBQTlCO0FBQ0EsVUFBTWhDLFNBQVM2QixLQUFLSSxTQUFMLEVBQWY7QUFDQSxVQUFNaEMsU0FBUyxhQUFHaUMsaUJBQUgsQ0FBcUJmLFVBQXJCLENBQWY7O0FBRUEsVUFBTUYsbUJBQW1CYSxXQUFuQixFQUFnQzlCLE1BQWhDLEVBQXdDQyxNQUF4QyxFQUFnREMsZ0JBQWhELENBQU47QUFDQUQsV0FBT2tDLEdBQVA7QUFDRCxHOztXQTFCOEJDLFk7Ozs7U0FBQUEsWSIsImZpbGUiOiJkb3dubG9hZC1maWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCBmcyBmcm9tICdmcyc7XHJcblxyXG4vLyBQdWJsaWM6IERvd25sb2FkIGEgZmlsZSBhbmQgc3RvcmUgaXQgb24gYSBmaWxlIHN5c3RlbSB1c2luZyBzdHJlYW1pbmcgd2l0aCBhcHByb3ByaWF0ZSBwcm9ncmVzcyBjYWxsYmFjay5cclxuLy9cclxuLy8gKiBgc291cmNlVXJsYCAgICAgICAgVXJsIHRvIGRvd25sb2FkIGZyb20uXHJcbi8vICogYHRhcmdldEZpbGVgICAgICAgIEZpbGUgcGF0aCB0byBzYXZlIHRvLlxyXG4vLyAqIGBwcm9ncmVzc0NhbGxiYWNrYCBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZ2l2ZW4gYSB7Qnl0ZVByb2dyZXNzQ2FsbGJhY2t9IG9iamVjdCBjb250YWluaW5nXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxyXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBPcHRpb25hbCBmaWxlIGxlbmd0aCBpbiBieXRlcyBmb3IgY2FzZXMgd2hlcmUgdGhlIHNlcnZlciB3aWxsIG5vdCBzdXBwbHkgdGhlXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBidXQgdGhlIHZhbHVlIGlzIGtub3duIGluIGFkdmFuY2UuIFdpdGhvdXQgZWl0aGVyIHRoZVxyXG4vLyAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlIG9uIHRoZSBjYWxsYmFjayBjYW4gbm90IGJlIGRldGVybWluZWQuXHJcbi8vXHJcbi8vIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCB3aWxsIGFjY2VwdCB3aGVuIGNvbXBsZXRlLlxyXG5leHBvcnQgZGVmYXVsdCAoYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlKFxyXG4gIHNvdXJjZVVybDogc3RyaW5nLFxyXG4gIHRhcmdldEZpbGU6IHN0cmluZyxcclxuICBwcm9ncmVzc0NhbGxiYWNrOiA/Qnl0ZVByb2dyZXNzQ2FsbGJhY2ssXHJcbiAgbGVuZ3RoOiA/bnVtYmVyLFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qoc291cmNlVXJsLCB7XHJcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nfSksXHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkb3dubG9hZCwgc2VydmVyIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcclxuICBpZiAoYm9keSA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZmluYWxMZW5ndGggPSBsZW5ndGggfHwgcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyB8fCAnMCcpLCAxMCk7XHJcbiAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcclxuICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbSh0YXJnZXRGaWxlKTtcclxuXHJcbiAgYXdhaXQgc3RyZWFtV2l0aFByb2dyZXNzKGZpbmFsTGVuZ3RoLCByZWFkZXIsIHdyaXRlciwgcHJvZ3Jlc3NDYWxsYmFjayk7XHJcbiAgd3JpdGVyLmVuZCgpO1xyXG59KTtcclxuXHJcbi8vIFN0cmVhbSBmcm9tIGEge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byBhIHtXcml0ZVN0cmVhbX0gd2l0aCBwcm9ncmVzcyBjYWxsYmFjay5cclxuLy9cclxuLy8gKiBgbGVuZ3RoYCAgICAgICAgICAgRmlsZSBsZW5ndGggaW4gYnl0ZXMuXHJcbi8vICogYHJlYWRlcmAgICAgICAgICAgIHtSZWFkYWJsZVN0cmVhbVJlYWRlcn0gdG8gcmVhZCBmcm9tLlxyXG4vLyAqIGB0YXJnd3JpdGVyZXRGaWxlYCB7V3JpdGVTdHJlYW19IHRvIHdyaXRlIHRvLlxyXG4vLyAqIGBwcm9ncmVzc0NhbGxiYWNrYCBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZ2l2ZW4gYSB7Qnl0ZVByb2dyZXNzQ2FsbGJhY2t9IG9iamVjdCBjb250YWluaW5nXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxyXG4vL1xyXG4vLyBSZXR1cm5zIGEge1Byb21pc2V9IHRoYXQgd2lsbCBhY2NlcHQgd2hlbiBjb21wbGV0ZS5cclxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtV2l0aFByb2dyZXNzKFxyXG4gIGxlbmd0aDogbnVtYmVyLFxyXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXIsXHJcbiAgd3JpdGVyOiBmcy5Xcml0ZVN0cmVhbSxcclxuICBwcm9ncmVzc0NhbGxiYWNrOiA/Qnl0ZVByb2dyZXNzQ2FsbGJhY2ssXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGxldCBieXRlc0RvbmUgPSAwO1xyXG5cclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcclxuICAgIGlmIChyZXN1bHQuZG9uZSkge1xyXG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhsZW5ndGgsIDEwMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNodW5rID0gcmVzdWx0LnZhbHVlO1xyXG4gICAgaWYgKGNodW5rID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ0VtcHR5IGNodW5rIHJlY2VpdmVkIGR1cmluZyBkb3dubG9hZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3JpdGVyLndyaXRlKEJ1ZmZlci5mcm9tKGNodW5rKSk7XHJcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICBieXRlc0RvbmUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBwZXJjZW50OiA/bnVtYmVyID0gbGVuZ3RoID09PSAwID8gbnVsbCA6IE1hdGguZmxvb3IoYnl0ZXNEb25lIC8gbGVuZ3RoICogMTAwKTtcclxuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGJ5dGVzRG9uZSwgcGVyY2VudCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIFB1YmxpYzogUHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24gc2lnbmF0dXJlIGluZGljYXRpbmcgdGhlIGJ5dGVzRG9uZSBhbmRcclxuLy8gb3B0aW9uYWwgcGVyY2VudGFnZSB3aGVuIGxlbmd0aCBpcyBrbm93bi5cclxuZXhwb3J0IHR5cGUgQnl0ZVByb2dyZXNzQ2FsbGJhY2sgPSAoYnl0ZXNEb25lOiBudW1iZXIsIHBlcmNlbnQ6ID9udW1iZXIpID0+IHt9O1xyXG4iXX0=