"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           File length in bytes if you want percentage progress indication and the server is
//                      unable to provide a Content-Length header and whitelist CORS access via a
//                      `Access-Control-Expose-Headers "content-length"` header.
//
// Returns a {Promise} that will accept when complete.
exports.default = (function downloadFile(sourceUrl, targetFile, progressCallback, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new Request(sourceUrl, {
            headers: new Headers({ 'Content-Type': 'application/octet-stream' }),
        });
        const response = yield fetch(request);
        if (!response.ok) {
            throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
        }
        const body = response.body;
        if (body == null) {
            throw Error('No response body');
        }
        const finalLength = length || parseInt(response.headers.get('Content-Length') || '0', 10);
        const reader = body.getReader();
        const writer = fs.createWriteStream(targetFile);
        yield streamWithProgress(finalLength, reader, writer, progressCallback);
        writer.end();
    });
});
// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `writer`           {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.
function streamWithProgress(length, reader, writer, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        let bytesDone = 0;
        while (true) {
            const result = yield reader.read();
            if (result.done) {
                if (progressCallback != null) {
                    progressCallback(length, 100);
                }
                return;
            }
            const chunk = result.value;
            if (chunk == null) {
                throw Error('Empty chunk received during download');
            }
            else {
                writer.write(Buffer.from(chunk));
                if (progressCallback != null) {
                    bytesDone += chunk.byteLength;
                    const percent = length === 0 ? undefined : Math.floor(bytesDone / length * 100);
                    progressCallback(bytesDone, percent);
                }
            }
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG93bmxvYWQtZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFFekIsNEdBQTRHO0FBQzVHLEVBQUU7QUFDRiw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLHVHQUF1RztBQUN2RyxtREFBbUQ7QUFDbkQseUdBQXlHO0FBQ3pHLGlHQUFpRztBQUNqRyxnRkFBZ0Y7QUFDaEYsRUFBRTtBQUNGLHNEQUFzRDtBQUN0RCxrQkFBZSxDQUFDLFNBQWUsWUFBWSxDQUN6QyxTQUFpQixFQUNqQixVQUFrQixFQUNsQixnQkFBdUMsRUFDdkMsTUFBZTs7UUFFZixNQUFNLE9BQU8sR0FBRyxJQUFJLE9BQU8sQ0FBQyxTQUFTLEVBQUU7WUFDckMsT0FBTyxFQUFFLElBQUksT0FBTyxDQUFDLEVBQUMsY0FBYyxFQUFFLDBCQUEwQixFQUFDLENBQUM7U0FDbkUsQ0FBQyxDQUFDO1FBRUgsTUFBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxLQUFLLENBQUMsdUNBQXVDLFFBQVEsQ0FBQyxNQUFNLElBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUM7U0FDOUY7UUFFRCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQzNCLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtZQUNoQixNQUFNLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1NBQ2pDO1FBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMxRixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDaEMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWhELE1BQU0sa0JBQWtCLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUN4RSxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDZixDQUFDO0NBQUEsQ0FBQyxDQUFDO0FBRUgsa0ZBQWtGO0FBQ2xGLEVBQUU7QUFDRiw2Q0FBNkM7QUFDN0MsNERBQTREO0FBQzVELGtEQUFrRDtBQUNsRCx1R0FBdUc7QUFDdkcsbURBQW1EO0FBQ25ELEVBQUU7QUFDRixzREFBc0Q7QUFDdEQsU0FBZSxrQkFBa0IsQ0FDL0IsTUFBYyxFQUNkLE1BQTRCLEVBQzVCLE1BQXNCLEVBQ3RCLGdCQUF1Qzs7UUFFdkMsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLE9BQU8sSUFBSSxFQUFFO1lBQ1gsTUFBTSxNQUFNLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbkMsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO2dCQUNmLElBQUksZ0JBQWdCLElBQUksSUFBSSxFQUFFO29CQUM1QixnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQy9CO2dCQUNELE9BQU87YUFDUjtZQUVELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7WUFDM0IsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO2dCQUNqQixNQUFNLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO2FBQ3JEO2lCQUFNO2dCQUNMLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUNqQyxJQUFJLGdCQUFnQixJQUFJLElBQUksRUFBRTtvQkFDNUIsU0FBUyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUM7b0JBQzlCLE1BQU0sT0FBTyxHQUF1QixNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLE1BQU0sR0FBRyxHQUFHLENBQUMsQ0FBQztvQkFDcEcsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2lCQUN0QzthQUNGO1NBQ0Y7SUFDSCxDQUFDO0NBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XHJcblxyXG4vLyBQdWJsaWM6IERvd25sb2FkIGEgZmlsZSBhbmQgc3RvcmUgaXQgb24gYSBmaWxlIHN5c3RlbSB1c2luZyBzdHJlYW1pbmcgd2l0aCBhcHByb3ByaWF0ZSBwcm9ncmVzcyBjYWxsYmFjay5cclxuLy9cclxuLy8gKiBgc291cmNlVXJsYCAgICAgICAgVXJsIHRvIGRvd25sb2FkIGZyb20uXHJcbi8vICogYHRhcmdldEZpbGVgICAgICAgIEZpbGUgcGF0aCB0byBzYXZlIHRvLlxyXG4vLyAqIGBwcm9ncmVzc0NhbGxiYWNrYCBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZ2l2ZW4gYSB7Qnl0ZVByb2dyZXNzQ2FsbGJhY2t9IG9iamVjdCBjb250YWluaW5nXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxyXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBGaWxlIGxlbmd0aCBpbiBieXRlcyBpZiB5b3Ugd2FudCBwZXJjZW50YWdlIHByb2dyZXNzIGluZGljYXRpb24gYW5kIHRoZSBzZXJ2ZXIgaXNcclxuLy8gICAgICAgICAgICAgICAgICAgICAgdW5hYmxlIHRvIHByb3ZpZGUgYSBDb250ZW50LUxlbmd0aCBoZWFkZXIgYW5kIHdoaXRlbGlzdCBDT1JTIGFjY2VzcyB2aWEgYVxyXG4vLyAgICAgICAgICAgICAgICAgICAgICBgQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnMgXCJjb250ZW50LWxlbmd0aFwiYCBoZWFkZXIuXHJcbi8vXHJcbi8vIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCB3aWxsIGFjY2VwdCB3aGVuIGNvbXBsZXRlLlxyXG5leHBvcnQgZGVmYXVsdCAoYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlKFxyXG4gIHNvdXJjZVVybDogc3RyaW5nLFxyXG4gIHRhcmdldEZpbGU6IHN0cmluZyxcclxuICBwcm9ncmVzc0NhbGxiYWNrPzogQnl0ZVByb2dyZXNzQ2FsbGJhY2ssXHJcbiAgbGVuZ3RoPzogbnVtYmVyLFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qoc291cmNlVXJsLCB7XHJcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nfSksXHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBkb3dubG9hZCwgc2VydmVyIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgfVxyXG5cclxuICBjb25zdCBib2R5ID0gcmVzcG9uc2UuYm9keTtcclxuICBpZiAoYm9keSA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgZmluYWxMZW5ndGggPSBsZW5ndGggfHwgcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJykgfHwgJzAnLCAxMCk7XHJcbiAgY29uc3QgcmVhZGVyID0gYm9keS5nZXRSZWFkZXIoKTtcclxuICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbSh0YXJnZXRGaWxlKTtcclxuXHJcbiAgYXdhaXQgc3RyZWFtV2l0aFByb2dyZXNzKGZpbmFsTGVuZ3RoLCByZWFkZXIsIHdyaXRlciwgcHJvZ3Jlc3NDYWxsYmFjayk7XHJcbiAgd3JpdGVyLmVuZCgpO1xyXG59KTtcclxuXHJcbi8vIFN0cmVhbSBmcm9tIGEge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byBhIHtXcml0ZVN0cmVhbX0gd2l0aCBwcm9ncmVzcyBjYWxsYmFjay5cclxuLy9cclxuLy8gKiBgbGVuZ3RoYCAgICAgICAgICAgRmlsZSBsZW5ndGggaW4gYnl0ZXMuXHJcbi8vICogYHJlYWRlcmAgICAgICAgICAgIHtSZWFkYWJsZVN0cmVhbVJlYWRlcn0gdG8gcmVhZCBmcm9tLlxyXG4vLyAqIGB3cml0ZXJgICAgICAgICAgICB7V3JpdGVTdHJlYW19IHRvIHdyaXRlIHRvLlxyXG4vLyAqIGBwcm9ncmVzc0NhbGxiYWNrYCBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZ2l2ZW4gYSB7Qnl0ZVByb2dyZXNzQ2FsbGJhY2t9IG9iamVjdCBjb250YWluaW5nXHJcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxyXG4vL1xyXG4vLyBSZXR1cm5zIGEge1Byb21pc2V9IHRoYXQgd2lsbCBhY2NlcHQgd2hlbiBjb21wbGV0ZS5cclxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtV2l0aFByb2dyZXNzKFxyXG4gIGxlbmd0aDogbnVtYmVyLFxyXG4gIHJlYWRlcjogUmVhZGFibGVTdHJlYW1SZWFkZXIsXHJcbiAgd3JpdGVyOiBmcy5Xcml0ZVN0cmVhbSxcclxuICBwcm9ncmVzc0NhbGxiYWNrPzogQnl0ZVByb2dyZXNzQ2FsbGJhY2ssXHJcbik6IFByb21pc2U8dm9pZD4ge1xyXG4gIGxldCBieXRlc0RvbmUgPSAwO1xyXG5cclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcclxuICAgIGlmIChyZXN1bHQuZG9uZSkge1xyXG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhsZW5ndGgsIDEwMCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNodW5rID0gcmVzdWx0LnZhbHVlO1xyXG4gICAgaWYgKGNodW5rID09IG51bGwpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoJ0VtcHR5IGNodW5rIHJlY2VpdmVkIGR1cmluZyBkb3dubG9hZCcpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3JpdGVyLndyaXRlKEJ1ZmZlci5mcm9tKGNodW5rKSk7XHJcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICBieXRlc0RvbmUgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBwZXJjZW50OiBudW1iZXIgfCB1bmRlZmluZWQgPSBsZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiBNYXRoLmZsb29yKGJ5dGVzRG9uZSAvIGxlbmd0aCAqIDEwMCk7XHJcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhieXRlc0RvbmUsIHBlcmNlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQdWJsaWM6IFByb2dyZXNzIGNhbGxiYWNrIGZ1bmN0aW9uIHNpZ25hdHVyZSBpbmRpY2F0aW5nIHRoZSBieXRlc0RvbmUgYW5kXHJcbi8vIG9wdGlvbmFsIHBlcmNlbnRhZ2Ugd2hlbiBsZW5ndGggaXMga25vd24uXHJcbmV4cG9ydCB0eXBlIEJ5dGVQcm9ncmVzc0NhbGxiYWNrID0gKGJ5dGVzRG9uZTogbnVtYmVyLCBwZXJjZW50PzogbnVtYmVyKSA9PiB2b2lkO1xyXG4iXX0=