/// <reference types="node" />
import * as ls from "./languageclient";
import { ChildProcess } from "child_process";
import { Logger } from "./logger";
import { CompositeDisposable, FilesystemChangeEvent, TextEditor } from "atom";
import { ReportBusyWhile } from "./utils";
export declare type MinimalLanguageServerProcess = Pick<ChildProcess, "stdin" | "stdout" | "stderr" | "pid" | "kill" | "on">;
/**
 * Public: Defines a language server process which is either a ChildProcess, or it is a minimal object that resembles a
 * ChildProcess. `MinimalLanguageServerProcess` is used so that language packages with alternative language server
 * process hosting strategies can return something compatible with `AutoLanguageClient.startServerProcess`.
 */
export declare type LanguageServerProcess = ChildProcess | MinimalLanguageServerProcess;
/** The necessary elements for a server that has started or is starting. */
export interface ActiveServer {
    disposable: CompositeDisposable;
    projectPath: string;
    process: LanguageServerProcess;
    connection: ls.LanguageClientConnection;
    capabilities: ls.ServerCapabilities;
    /** Out of project directories that this server can also support. */
    additionalPaths?: Set<string>;
}
/** Manages the language server lifecycles and their associated objects necessary for adapting them to Atom IDE. */
export declare class ServerManager {
    private _startServer;
    private _logger;
    private _startForEditor;
    private _changeWatchedFileFilter;
    private _reportBusyWhile;
    private _languageServerName;
    private _determineProjectPath;
    private shutdownGracefully;
    private _activeServers;
    private _startingServerPromises;
    private _restartCounterPerProject;
    private _stoppingServers;
    private _disposable;
    private _editorToServer;
    private _normalizedProjectPaths;
    private _previousNormalizedProjectPaths;
    private _isStarted;
    constructor(_startServer: (projectPath: string) => Promise<ActiveServer>, _logger: Logger, _startForEditor: (editor: TextEditor) => boolean, _changeWatchedFileFilter: (filePath: string) => boolean, _reportBusyWhile: ReportBusyWhile, _languageServerName: string, _determineProjectPath: (textEditor: TextEditor) => string | null, shutdownGracefully: boolean);
    startListening(): void;
    stopListening(): void;
    private observeTextEditors;
    private _handleTextEditor;
    private _handleGrammarChange;
    getActiveServers(): Readonly<ActiveServer[]>;
    getServer(textEditor: TextEditor, { shouldStart }?: {
        shouldStart?: boolean;
    }): Promise<ActiveServer | null>;
    startServer(projectPath: string): Promise<ActiveServer>;
    stopUnusedServers(): Promise<void>;
    stopAllServers(): Promise<void>;
    restartAllServers(): Promise<void>;
    hasServerReachedRestartLimit(server: ActiveServer): boolean;
    stopServer(server: ActiveServer): Promise<void>;
    exitServer(server: ActiveServer): void;
    terminate(): void;
    updateNormalizedProjectPaths(): void;
    getNormalizedProjectPaths(): Readonly<string[]>;
    /**
     * Public: fetch the current open list of workspace folders
     *
     * @returns A {Promise} containing an {Array} of {lsp.WorkspaceFolder[]} or {null} if only a single file is open in the tool.
     */
    getWorkspaceFolders(): Promise<ls.WorkspaceFolder[] | null>;
    projectPathsChanged(projectPaths: string[]): Promise<void>;
    projectFilesChanged(fileEvents: FilesystemChangeEvent): void;
    /** @deprecated Use the exported `normalizePath` function */
    normalizePath: typeof normalizePath;
}
export declare function projectPathToWorkspaceFolder(projectPath: string): ls.WorkspaceFolder;
export declare function normalizedProjectPathToWorkspaceFolder(normalizedProjectPath: string): ls.WorkspaceFolder;
export declare function normalizePath(projectPath: string): string;
/** Considers a path for inclusion in `additionalPaths`. */
export declare function considerAdditionalPath(server: ActiveServer & {
    additionalPaths: Set<string>;
}, additionalPath: string): void;
