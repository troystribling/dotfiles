Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerManager = undefined;

require('./logger');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _convert = require('./convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Manages the language server lifecycles and their associated objects necessary
// for adapting them to Atom IDE.


// The necessary elements for a server that has started or is starting.
class ServerManager {

  constructor(startServer, logger, startForEditor, changeWatchedFileFilter) {
    this._activeServers = [];
    this._startingServerPromises = new Map();
    this._stoppingServers = [];
    this._disposable = new _atom.CompositeDisposable();
    this._editorToServer = new Map();
    this._normalizedProjectPaths = [];

    this._startServer = startServer;
    this._logger = logger;
    this._startForEditor = startForEditor;
    this.updateNormalizedProjectPaths();
    this._changeWatchedFileFilter = changeWatchedFileFilter;
  }

  startListening() {
    this._disposable.add(atom.textEditors.observe(this.observeTextEditors.bind(this)));
    this._disposable.add(atom.project.onDidChangePaths(this.projectPathsChanged.bind(this)));
    if (atom.project.onDidChangeFiles) {
      this._disposable.add(atom.project.onDidChangeFiles(this.projectFilesChanged.bind(this)));
    }
  }

  stopListening() {
    this._disposable.dispose();
  }

  observeTextEditors(editor) {
    // Track grammar changes for opened editors
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => listener.dispose()));
    // Try to see if editor can have LS connected to it
    this._handleTextEditor(editor);
  }

  async _handleTextEditor(editor) {
    if (!this._editorToServer.has(editor)) {
      // editor hasn't been processed yet, so process it by allocating LS for it if necessary
      const server = await this.getServer(editor, { shouldStart: true });
      if (server != null) {
        // There LS for the editor (either started now and already running)
        this._editorToServer.set(editor, server);
        this._disposable.add(editor.onDidDestroy(() => {
          this._editorToServer.delete(editor);
          this.stopUnusedServers();
        }));
      }
    }
  }

  _handleGrammarChange(editor) {
    if (this._startForEditor(editor)) {
      // If editor is interesting for LS process the editor further to attempt to start LS if needed
      this._handleTextEditor(editor);
    } else {
      // Editor is not supported by the LS
      const server = this._editorToServer.get(editor);
      // If LS is running for the unsupported editor then disconnect the editor from LS and shut down LS if necessary
      if (server) {
        // LS is up for unsupported server
        if (server.docSyncAdapter) {
          const syncAdapter = server.docSyncAdapter.getEditorSyncAdapter(editor);
          if (syncAdapter) {
            // Immitate editor close to disconnect LS from the editor
            syncAdapter.didClose();
          }
        }
        // Remove editor from the cache
        this._editorToServer.delete(editor);
        // Shut down LS if it's used by any other editor
        this.stopUnusedServers();
      }
    }
  }

  getActiveServers() {
    return this._activeServers.slice();
  }

  async getServer(textEditor, { shouldStart } = { shouldStart: false }) {
    const finalProjectPath = this.determineProjectPath(textEditor);
    if (finalProjectPath == null) {
      // Files not yet saved have no path
      return null;
    }

    const foundActiveServer = this._activeServers.find(s => finalProjectPath === s.projectPath);
    if (foundActiveServer) {
      return foundActiveServer;
    }

    const startingPromise = this._startingServerPromises.get(finalProjectPath);
    if (startingPromise) {
      return startingPromise;
    }

    return shouldStart && this._startForEditor(textEditor) ? await this.startServer(finalProjectPath) : null;
  }

  async startServer(projectPath) {
    this._logger.debug(`Server starting "${projectPath}"`);
    const startingPromise = this._startServer(projectPath);
    this._startingServerPromises.set(projectPath, startingPromise);
    const startedActiveServer = await startingPromise;
    this._activeServers.push(startedActiveServer);
    this._startingServerPromises.delete(projectPath);
    this._logger.debug(`Server started "${projectPath}" (pid ${startedActiveServer.process.pid})`);
    return startedActiveServer;
  }

  async stopUnusedServers() {
    const usedServers = new Set(this._editorToServer.values());
    const unusedServers = this._activeServers.filter(s => !usedServers.has(s));
    if (unusedServers.length > 0) {
      this._logger.debug(`Stopping ${unusedServers.length} unused servers`);
      await Promise.all(unusedServers.map(s => this.stopServer(s)));
    }
  }

  async stopAllServers() {
    await Promise.all(this._activeServers.map(s => this.stopServer(s)));
  }

  async stopServer(server) {
    this._logger.debug(`Server stopping "${server.projectPath}"`);
    // Immediately remove the server to prevent further usage.
    // If we re-open the file after this point, we'll get a new server.
    this._activeServers.splice(this._activeServers.indexOf(server), 1);
    this._stoppingServers.push(server);
    server.disposable.dispose();
    await server.connection.shutdown();

    if (server.linterPushV2 != null) {
      server.linterPushV2.detachAll();
    }

    if (server.signatureHelpAdapter != null) {
      server.signatureHelpAdapter.dispose();
    }

    this.exitServer(server);
    this._stoppingServers.splice(this._stoppingServers.indexOf(server), 1);
  }

  exitServer(server) {
    const pid = server.process.pid;
    try {
      server.connection.exit();
    } finally {
      server.process.kill();
    }
    this._logger.debug(`Server stopped "${server.projectPath}" (pid ${pid})`);
  }

  terminate() {
    this._stoppingServers.forEach(server => {
      this._logger.debug(`Server terminating "${server.projectPath}"`);
      this.exitServer(server);
    });
  }

  determineProjectPath(textEditor) {
    const filePath = textEditor.getPath();
    if (filePath == null) {
      return null;
    }
    return this._normalizedProjectPaths.find(d => filePath.startsWith(d));
  }

  updateNormalizedProjectPaths() {
    this._normalizedProjectPaths = atom.project.getDirectories().map(d => this.normalizePath(d.getPath()));
  }

  normalizePath(projectPath) {
    return !projectPath.endsWith(_path2.default.sep) ? _path2.default.join(projectPath, _path2.default.sep) : projectPath;
  }

  projectPathsChanged(projectPaths) {
    const pathsSet = new Set(projectPaths.map(this.normalizePath));
    const serversToStop = this._activeServers.filter(s => !pathsSet.has(s.projectPath));
    Promise.all(serversToStop.map(s => this.stopServer(s)));
    this.updateNormalizedProjectPaths();
  }

  projectFilesChanged(fileEvents) {
    if (this._activeServers.length === 0) {
      return;
    }

    for (const activeServer of this._activeServers) {
      const changes = [];
      for (const fileEvent of fileEvents) {
        if (fileEvent.path.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.path)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[0]);
        }
        if (fileEvent.oldPath && fileEvent.oldPath.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.oldPath)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[1]);
        }
      }
      if (changes.length > 0) {
        activeServer.connection.didChangeWatchedFiles({ changes });
      }
    }
  }
}
exports.ServerManager = ServerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9zZXJ2ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJscyIsIlNlcnZlck1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0U2VydmVyIiwibG9nZ2VyIiwic3RhcnRGb3JFZGl0b3IiLCJjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlciIsIl9hY3RpdmVTZXJ2ZXJzIiwiX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMiLCJNYXAiLCJfc3RvcHBpbmdTZXJ2ZXJzIiwiX2Rpc3Bvc2FibGUiLCJfZWRpdG9yVG9TZXJ2ZXIiLCJfbm9ybWFsaXplZFByb2plY3RQYXRocyIsIl9zdGFydFNlcnZlciIsIl9sb2dnZXIiLCJfc3RhcnRGb3JFZGl0b3IiLCJ1cGRhdGVOb3JtYWxpemVkUHJvamVjdFBhdGhzIiwiX2NoYW5nZVdhdGNoZWRGaWxlRmlsdGVyIiwic3RhcnRMaXN0ZW5pbmciLCJhZGQiLCJhdG9tIiwidGV4dEVkaXRvcnMiLCJvYnNlcnZlIiwib2JzZXJ2ZVRleHRFZGl0b3JzIiwiYmluZCIsInByb2plY3QiLCJvbkRpZENoYW5nZVBhdGhzIiwicHJvamVjdFBhdGhzQ2hhbmdlZCIsIm9uRGlkQ2hhbmdlRmlsZXMiLCJwcm9qZWN0RmlsZXNDaGFuZ2VkIiwic3RvcExpc3RlbmluZyIsImRpc3Bvc2UiLCJlZGl0b3IiLCJsaXN0ZW5lciIsIm9ic2VydmVHcmFtbWFyIiwiZ3JhbW1hciIsIl9oYW5kbGVHcmFtbWFyQ2hhbmdlIiwib25EaWREZXN0cm95IiwiX2hhbmRsZVRleHRFZGl0b3IiLCJoYXMiLCJzZXJ2ZXIiLCJnZXRTZXJ2ZXIiLCJzaG91bGRTdGFydCIsInNldCIsImRlbGV0ZSIsInN0b3BVbnVzZWRTZXJ2ZXJzIiwiZ2V0IiwiZG9jU3luY0FkYXB0ZXIiLCJzeW5jQWRhcHRlciIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwiZGlkQ2xvc2UiLCJnZXRBY3RpdmVTZXJ2ZXJzIiwic2xpY2UiLCJ0ZXh0RWRpdG9yIiwiZmluYWxQcm9qZWN0UGF0aCIsImRldGVybWluZVByb2plY3RQYXRoIiwiZm91bmRBY3RpdmVTZXJ2ZXIiLCJmaW5kIiwicyIsInByb2plY3RQYXRoIiwic3RhcnRpbmdQcm9taXNlIiwiZGVidWciLCJzdGFydGVkQWN0aXZlU2VydmVyIiwicHVzaCIsInByb2Nlc3MiLCJwaWQiLCJ1c2VkU2VydmVycyIsIlNldCIsInZhbHVlcyIsInVudXNlZFNlcnZlcnMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwic3RvcFNlcnZlciIsInN0b3BBbGxTZXJ2ZXJzIiwic3BsaWNlIiwiaW5kZXhPZiIsImRpc3Bvc2FibGUiLCJjb25uZWN0aW9uIiwic2h1dGRvd24iLCJsaW50ZXJQdXNoVjIiLCJkZXRhY2hBbGwiLCJzaWduYXR1cmVIZWxwQWRhcHRlciIsImV4aXRTZXJ2ZXIiLCJleGl0Iiwia2lsbCIsInRlcm1pbmF0ZSIsImZvckVhY2giLCJmaWxlUGF0aCIsImdldFBhdGgiLCJkIiwic3RhcnRzV2l0aCIsImdldERpcmVjdG9yaWVzIiwibm9ybWFsaXplUGF0aCIsImVuZHNXaXRoIiwic2VwIiwiam9pbiIsInByb2plY3RQYXRocyIsInBhdGhzU2V0Iiwic2VydmVyc1RvU3RvcCIsImZpbGVFdmVudHMiLCJhY3RpdmVTZXJ2ZXIiLCJjaGFuZ2VzIiwiZmlsZUV2ZW50IiwicGF0aCIsImF0b21GaWxlRXZlbnRUb0xTRmlsZUV2ZW50cyIsIm9sZFBhdGgiLCJkaWRDaGFuZ2VXYXRjaGVkRmlsZXMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBS0E7Ozs7QUFDQTs7SUFBWUEsRTs7QUFDWjs7OztBQUNBOzs7Ozs7QUFjQTtBQUNBOzs7QUFiQTtBQWNPLE1BQU1DLGFBQU4sQ0FBb0I7O0FBWXpCQyxjQUNFQyxXQURGLEVBRUVDLE1BRkYsRUFHRUMsY0FIRixFQUlFQyx1QkFKRixFQUtFO0FBQUEsU0FoQkZDLGNBZ0JFLEdBaEJvQyxFQWdCcEM7QUFBQSxTQWZGQyx1QkFlRSxHQWY0RCxJQUFJQyxHQUFKLEVB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QWdEO0FBQzlDLFlBQU1rRyxVQUFVLEVBQWhCO0FBQ0EsV0FBSyxNQUFNQyxTQUFYLElBQXdCSCxVQUF4QixFQUFvQztBQUNsQyxZQUFJRyxVQUFVQyxJQUFWLENBQWViLFVBQWYsQ0FBMEJVLGFBQWE1QyxXQUF2QyxLQUF1RCxLQUFLMUMsd0JBQUwsQ0FBOEJ3RixVQUFVQyxJQUF4QyxDQUEzRCxFQUEwRztBQUN4R0Ysa0JBQVF6QyxJQUFSLENBQWEsa0JBQVE0QywyQkFBUixDQUFvQ0YsU0FBcEMsRUFBK0MsQ0FBL0MsQ0FBYjtBQUNEO0FBQ0QsWUFDRUEsVUFBVUcsT0FBVixJQUNBSCxVQUFVRyxPQUFWLENBQWtCZixVQUFsQixDQUE2QlUsYUFBYTVDLFdBQTFDLENBREEsSUFFQSxLQUFLMUMsd0JBQUwsQ0FBOEJ3RixVQUFVRyxPQUF4QyxDQUhGLEVBSUU7QUFDQUosa0JBQVF6QyxJQUFSLENBQWEsa0JBQVE0QywyQkFBUixDQUFvQ0YsU0FBcEMsRUFBK0MsQ0FBL0MsQ0FBYjtBQUNEO0FBQ0Y7QUFDRCxVQUFJRCxRQUFRakMsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUN0QmdDLHFCQUFhdkIsVUFBYixDQUF3QjZCLHFCQUF4QixDQUE4QyxFQUFDTCxPQUFELEVBQTlDO0FBQ0Q7QUFDRjtBQUNGO0FBOU53QjtRQUFkeEcsYSxHQUFBQSxhIiwiZmlsZSI6InNlcnZlci1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7dHlwZSBMb2dnZXJ9IGZyb20gJy4vbG9nZ2VyJztcclxuaW1wb3J0IHR5cGUgTGludGVyUHVzaFYyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2xpbnRlci1wdXNoLXYyLWFkYXB0ZXInO1xyXG5pbXBvcnQgdHlwZSBEb2N1bWVudFN5bmNBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvZG9jdW1lbnQtc3luYy1hZGFwdGVyJztcclxuaW1wb3J0IHR5cGUgU2lnbmF0dXJlSGVscEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9zaWduYXR1cmUtaGVscC1hZGFwdGVyJztcclxuXHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgKiBhcyBscyBmcm9tICcuL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi9jb252ZXJ0JztcclxuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFRoZSBuZWNlc3NhcnkgZWxlbWVudHMgZm9yIGEgc2VydmVyIHRoYXQgaGFzIHN0YXJ0ZWQgb3IgaXMgc3RhcnRpbmcuXHJcbmV4cG9ydCB0eXBlIEFjdGl2ZVNlcnZlciA9IHtcclxuICBkaXNwb3NhYmxlOiBDb21wb3NpdGVEaXNwb3NhYmxlLFxyXG4gIHByb2plY3RQYXRoOiBzdHJpbmcsXHJcbiAgcHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXHJcbiAgY29ubmVjdGlvbjogbHMuTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIGNhcGFiaWxpdGllczogbHMuU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG4gIGxpbnRlclB1c2hWMj86IExpbnRlclB1c2hWMkFkYXB0ZXIsXHJcbiAgZG9jU3luY0FkYXB0ZXI/OiBEb2N1bWVudFN5bmNBZGFwdGVyLFxyXG4gIHNpZ25hdHVyZUhlbHBBZGFwdGVyPzogU2lnbmF0dXJlSGVscEFkYXB0ZXIsXHJcbn07XHJcblxyXG4vLyBNYW5hZ2VzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgbGlmZWN5Y2xlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBvYmplY3RzIG5lY2Vzc2FyeVxyXG4vLyBmb3IgYWRhcHRpbmcgdGhlbSB0byBBdG9tIElERS5cclxuZXhwb3J0IGNsYXNzIFNlcnZlck1hbmFnZXIge1xyXG4gIF9hY3RpdmVTZXJ2ZXJzOiBBcnJheTxBY3RpdmVTZXJ2ZXI+ID0gW107XHJcbiAgX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXM6IE1hcDxzdHJpbmcsIFByb21pc2U8QWN0aXZlU2VydmVyPj4gPSBuZXcgTWFwKCk7XHJcbiAgX3N0b3BwaW5nU2VydmVyczogQXJyYXk8QWN0aXZlU2VydmVyPiA9IFtdO1xyXG4gIF9kaXNwb3NhYmxlOiBDb21wb3NpdGVEaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICBfZWRpdG9yVG9TZXJ2ZXI6IE1hcDxhdG9tJFRleHRFZGl0b3IsIEFjdGl2ZVNlcnZlcj4gPSBuZXcgTWFwKCk7XHJcbiAgX2xvZ2dlcjogTG9nZ2VyO1xyXG4gIF9ub3JtYWxpemVkUHJvamVjdFBhdGhzOiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgX3N0YXJ0Rm9yRWRpdG9yOiAoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpID0+IGJvb2xlYW47XHJcbiAgX3N0YXJ0U2VydmVyOiAocHJvamVjdFBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+O1xyXG4gIF9jaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcjogKGZpbGVQYXRoOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgc3RhcnRTZXJ2ZXI6IChwcm9qZWN0UGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPEFjdGl2ZVNlcnZlcj4sXHJcbiAgICBsb2dnZXI6IExvZ2dlcixcclxuICAgIHN0YXJ0Rm9yRWRpdG9yOiAoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpID0+IGJvb2xlYW4sXHJcbiAgICBjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcjogKGZpbGVQYXRoOiBzdHJpbmcpID0+IGJvb2xlYW4sXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9zdGFydFNlcnZlciA9IHN0YXJ0U2VydmVyO1xyXG4gICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgdGhpcy5fc3RhcnRGb3JFZGl0b3IgPSBzdGFydEZvckVkaXRvcjtcclxuICAgIHRoaXMudXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpO1xyXG4gICAgdGhpcy5fY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIgPSBjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcjtcclxuICB9XHJcblxyXG4gIHN0YXJ0TGlzdGVuaW5nKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS50ZXh0RWRpdG9ycy5vYnNlcnZlKHRoaXMub2JzZXJ2ZVRleHRFZGl0b3JzLmJpbmQodGhpcykpKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20ucHJvamVjdC5vbkRpZENoYW5nZVBhdGhzKHRoaXMucHJvamVjdFBhdGhzQ2hhbmdlZC5iaW5kKHRoaXMpKSk7XHJcbiAgICBpZiAoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlRmlsZXMpIHtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlRmlsZXModGhpcy5wcm9qZWN0RmlsZXNDaGFuZ2VkLmJpbmQodGhpcykpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0b3BMaXN0ZW5pbmcoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICB9XHJcblxyXG4gIG9ic2VydmVUZXh0RWRpdG9ycyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IHZvaWQge1xyXG4gICAgLy8gVHJhY2sgZ3JhbW1hciBjaGFuZ2VzIGZvciBvcGVuZWQgZWRpdG9yc1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBlZGl0b3Iub2JzZXJ2ZUdyYW1tYXIoZ3JhbW1hciA9PiB0aGlzLl9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcikpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiBsaXN0ZW5lci5kaXNwb3NlKCkpKTtcclxuICAgIC8vIFRyeSB0byBzZWUgaWYgZWRpdG9yIGNhbiBoYXZlIExTIGNvbm5lY3RlZCB0byBpdFxyXG4gICAgdGhpcy5faGFuZGxlVGV4dEVkaXRvcihlZGl0b3IpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2hhbmRsZVRleHRFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuaGFzKGVkaXRvcikpIHtcclxuICAgICAgLy8gZWRpdG9yIGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQsIHNvIHByb2Nlc3MgaXQgYnkgYWxsb2NhdGluZyBMUyBmb3IgaXQgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuZ2V0U2VydmVyKGVkaXRvciwge3Nob3VsZFN0YXJ0OiB0cnVlfSk7XHJcbiAgICAgIGlmIChzZXJ2ZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoZXJlIExTIGZvciB0aGUgZWRpdG9yIChlaXRoZXIgc3RhcnRlZCBub3cgYW5kIGFscmVhZHkgcnVubmluZylcclxuICAgICAgICB0aGlzLl9lZGl0b3JUb1NlcnZlci5zZXQoZWRpdG9yLCBzZXJ2ZXIpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICAgICAgZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikge1xyXG4gICAgaWYgKHRoaXMuX3N0YXJ0Rm9yRWRpdG9yKGVkaXRvcikpIHtcclxuICAgICAgLy8gSWYgZWRpdG9yIGlzIGludGVyZXN0aW5nIGZvciBMUyBwcm9jZXNzIHRoZSBlZGl0b3IgZnVydGhlciB0byBhdHRlbXB0IHRvIHN0YXJ0IExTIGlmIG5lZWRlZFxyXG4gICAgICB0aGlzLl9oYW5kbGVUZXh0RWRpdG9yKGVkaXRvcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBFZGl0b3IgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgTFNcclxuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZ2V0KGVkaXRvcik7XHJcbiAgICAgIC8vIElmIExTIGlzIHJ1bm5pbmcgZm9yIHRoZSB1bnN1cHBvcnRlZCBlZGl0b3IgdGhlbiBkaXNjb25uZWN0IHRoZSBlZGl0b3IgZnJvbSBMUyBhbmQgc2h1dCBkb3duIExTIGlmIG5lY2Vzc2FyeVxyXG4gICAgICBpZiAoc2VydmVyKSB7XHJcbiAgICAgICAgLy8gTFMgaXMgdXAgZm9yIHVuc3VwcG9ydGVkIHNlcnZlclxyXG4gICAgICAgIGlmIChzZXJ2ZXIuZG9jU3luY0FkYXB0ZXIpIHtcclxuICAgICAgICAgIGNvbnN0IHN5bmNBZGFwdGVyID0gc2VydmVyLmRvY1N5bmNBZGFwdGVyLmdldEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvcik7XHJcbiAgICAgICAgICBpZiAoc3luY0FkYXB0ZXIpIHtcclxuICAgICAgICAgICAgLy8gSW1taXRhdGUgZWRpdG9yIGNsb3NlIHRvIGRpc2Nvbm5lY3QgTFMgZnJvbSB0aGUgZWRpdG9yXHJcbiAgICAgICAgICAgIHN5bmNBZGFwdGVyLmRpZENsb3NlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlZGl0b3IgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICB0aGlzLl9lZGl0b3JUb1NlcnZlci5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgICAvLyBTaHV0IGRvd24gTFMgaWYgaXQncyB1c2VkIGJ5IGFueSBvdGhlciBlZGl0b3JcclxuICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEFjdGl2ZVNlcnZlcnMoKTogQXJyYXk8QWN0aXZlU2VydmVyPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlU2VydmVycy5zbGljZSgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U2VydmVyKFxyXG4gICAgdGV4dEVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gICAge3Nob3VsZFN0YXJ0fToge3Nob3VsZFN0YXJ0PzogYm9vbGVhbn0gPSB7c2hvdWxkU3RhcnQ6IGZhbHNlfSxcclxuICApOiBQcm9taXNlPD9BY3RpdmVTZXJ2ZXI+IHtcclxuICAgIGNvbnN0IGZpbmFsUHJvamVjdFBhdGggPSB0aGlzLmRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3IpO1xyXG4gICAgaWYgKGZpbmFsUHJvamVjdFBhdGggPT0gbnVsbCkge1xyXG4gICAgICAvLyBGaWxlcyBub3QgeWV0IHNhdmVkIGhhdmUgbm8gcGF0aFxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3VuZEFjdGl2ZVNlcnZlciA9IHRoaXMuX2FjdGl2ZVNlcnZlcnMuZmluZChzID0+IGZpbmFsUHJvamVjdFBhdGggPT09IHMucHJvamVjdFBhdGgpO1xyXG4gICAgaWYgKGZvdW5kQWN0aXZlU2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBmb3VuZEFjdGl2ZVNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmdldChmaW5hbFByb2plY3RQYXRoKTtcclxuICAgIGlmIChzdGFydGluZ1Byb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHN0YXJ0aW5nUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2hvdWxkU3RhcnQgJiYgdGhpcy5fc3RhcnRGb3JFZGl0b3IodGV4dEVkaXRvcikgPyBhd2FpdCB0aGlzLnN0YXJ0U2VydmVyKGZpbmFsUHJvamVjdFBhdGgpIDogbnVsbDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0YXJ0U2VydmVyKHByb2plY3RQYXRoOiBzdHJpbmcpOiBQcm9taXNlPEFjdGl2ZVNlcnZlcj4ge1xyXG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RhcnRpbmcgXCIke3Byb2plY3RQYXRofVwiYCk7XHJcbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydFNlcnZlcihwcm9qZWN0UGF0aCk7XHJcbiAgICB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLnNldChwcm9qZWN0UGF0aCwgc3RhcnRpbmdQcm9taXNlKTtcclxuICAgIGNvbnN0IHN0YXJ0ZWRBY3RpdmVTZXJ2ZXIgPSBhd2FpdCBzdGFydGluZ1Byb21pc2U7XHJcbiAgICB0aGlzLl9hY3RpdmVTZXJ2ZXJzLnB1c2goc3RhcnRlZEFjdGl2ZVNlcnZlcik7XHJcbiAgICB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmRlbGV0ZShwcm9qZWN0UGF0aCk7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdGFydGVkIFwiJHtwcm9qZWN0UGF0aH1cIiAocGlkICR7c3RhcnRlZEFjdGl2ZVNlcnZlci5wcm9jZXNzLnBpZH0pYCk7XHJcbiAgICByZXR1cm4gc3RhcnRlZEFjdGl2ZVNlcnZlcjtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0b3BVbnVzZWRTZXJ2ZXJzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdXNlZFNlcnZlcnMgPSBuZXcgU2V0KHRoaXMuX2VkaXRvclRvU2VydmVyLnZhbHVlcygpKTtcclxuICAgIGNvbnN0IHVudXNlZFNlcnZlcnMgPSB0aGlzLl9hY3RpdmVTZXJ2ZXJzLmZpbHRlcihzID0+ICF1c2VkU2VydmVycy5oYXMocykpO1xyXG4gICAgaWYgKHVudXNlZFNlcnZlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFN0b3BwaW5nICR7dW51c2VkU2VydmVycy5sZW5ndGh9IHVudXNlZCBzZXJ2ZXJzYCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHVudXNlZFNlcnZlcnMubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wQWxsU2VydmVycygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX2FjdGl2ZVNlcnZlcnMubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wU2VydmVyKHNlcnZlcjogQWN0aXZlU2VydmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdG9wcGluZyBcIiR7c2VydmVyLnByb2plY3RQYXRofVwiYCk7XHJcbiAgICAvLyBJbW1lZGlhdGVseSByZW1vdmUgdGhlIHNlcnZlciB0byBwcmV2ZW50IGZ1cnRoZXIgdXNhZ2UuXHJcbiAgICAvLyBJZiB3ZSByZS1vcGVuIHRoZSBmaWxlIGFmdGVyIHRoaXMgcG9pbnQsIHdlJ2xsIGdldCBhIG5ldyBzZXJ2ZXIuXHJcbiAgICB0aGlzLl9hY3RpdmVTZXJ2ZXJzLnNwbGljZSh0aGlzLl9hY3RpdmVTZXJ2ZXJzLmluZGV4T2Yoc2VydmVyKSwgMSk7XHJcbiAgICB0aGlzLl9zdG9wcGluZ1NlcnZlcnMucHVzaChzZXJ2ZXIpO1xyXG4gICAgc2VydmVyLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgYXdhaXQgc2VydmVyLmNvbm5lY3Rpb24uc2h1dGRvd24oKTtcclxuXHJcbiAgICBpZiAoc2VydmVyLmxpbnRlclB1c2hWMiAhPSBudWxsKSB7XHJcbiAgICAgIHNlcnZlci5saW50ZXJQdXNoVjIuZGV0YWNoQWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlcnZlci5zaWduYXR1cmVIZWxwQWRhcHRlciAhPSBudWxsKSB7XHJcbiAgICAgIHNlcnZlci5zaWduYXR1cmVIZWxwQWRhcHRlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5leGl0U2VydmVyKHNlcnZlcik7XHJcbiAgICB0aGlzLl9zdG9wcGluZ1NlcnZlcnMuc3BsaWNlKHRoaXMuX3N0b3BwaW5nU2VydmVycy5pbmRleE9mKHNlcnZlciksIDEpO1xyXG4gIH1cclxuXHJcbiAgZXhpdFNlcnZlcihzZXJ2ZXI6IEFjdGl2ZVNlcnZlcik6IHZvaWQge1xyXG4gICAgY29uc3QgcGlkID0gc2VydmVyLnByb2Nlc3MucGlkO1xyXG4gICAgdHJ5IHtcclxuICAgICAgc2VydmVyLmNvbm5lY3Rpb24uZXhpdCgpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2VydmVyLnByb2Nlc3Mua2lsbCgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RvcHBlZCBcIiR7c2VydmVyLnByb2plY3RQYXRofVwiIChwaWQgJHtwaWR9KWApO1xyXG4gIH1cclxuXHJcbiAgdGVybWluYXRlKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fc3RvcHBpbmdTZXJ2ZXJzLmZvckVhY2goc2VydmVyID0+IHtcclxuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgdGVybWluYXRpbmcgXCIke3NlcnZlci5wcm9qZWN0UGF0aH1cImApO1xyXG4gICAgICB0aGlzLmV4aXRTZXJ2ZXIoc2VydmVyKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZGV0ZXJtaW5lUHJvamVjdFBhdGgodGV4dEVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogP3N0cmluZyB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IHRleHRFZGl0b3IuZ2V0UGF0aCgpO1xyXG4gICAgaWYgKGZpbGVQYXRoID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplZFByb2plY3RQYXRocy5maW5kKGQgPT4gZmlsZVBhdGguc3RhcnRzV2l0aChkKSk7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVOb3JtYWxpemVkUHJvamVjdFBhdGhzKCk6IHZvaWQge1xyXG4gICAgdGhpcy5fbm9ybWFsaXplZFByb2plY3RQYXRocyA9IGF0b20ucHJvamVjdC5nZXREaXJlY3RvcmllcygpLm1hcChkID0+IHRoaXMubm9ybWFsaXplUGF0aChkLmdldFBhdGgoKSkpO1xyXG4gIH1cclxuXHJcbiAgbm9ybWFsaXplUGF0aChwcm9qZWN0UGF0aDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIHJldHVybiAhcHJvamVjdFBhdGguZW5kc1dpdGgocGF0aC5zZXApID8gcGF0aC5qb2luKHByb2plY3RQYXRoLCBwYXRoLnNlcCkgOiBwcm9qZWN0UGF0aDtcclxuICB9XHJcblxyXG4gIHByb2plY3RQYXRoc0NoYW5nZWQocHJvamVjdFBhdGhzOiBBcnJheTxzdHJpbmc+KTogdm9pZCB7XHJcbiAgICBjb25zdCBwYXRoc1NldCA9IG5ldyBTZXQocHJvamVjdFBhdGhzLm1hcCh0aGlzLm5vcm1hbGl6ZVBhdGgpKTtcclxuICAgIGNvbnN0IHNlcnZlcnNUb1N0b3AgPSB0aGlzLl9hY3RpdmVTZXJ2ZXJzLmZpbHRlcihzID0+ICFwYXRoc1NldC5oYXMocy5wcm9qZWN0UGF0aCkpO1xyXG4gICAgUHJvbWlzZS5hbGwoc2VydmVyc1RvU3RvcC5tYXAocyA9PiB0aGlzLnN0b3BTZXJ2ZXIocykpKTtcclxuICAgIHRoaXMudXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpO1xyXG4gIH1cclxuXHJcbiAgcHJvamVjdEZpbGVzQ2hhbmdlZChmaWxlRXZlbnRzOiBBcnJheTxhdG9tJFByb2plY3RGaWxlRXZlbnQ+KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fYWN0aXZlU2VydmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgYWN0aXZlU2VydmVyIG9mIHRoaXMuX2FjdGl2ZVNlcnZlcnMpIHtcclxuICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xyXG4gICAgICBmb3IgKGNvbnN0IGZpbGVFdmVudCBvZiBmaWxlRXZlbnRzKSB7XHJcbiAgICAgICAgaWYgKGZpbGVFdmVudC5wYXRoLnN0YXJ0c1dpdGgoYWN0aXZlU2VydmVyLnByb2plY3RQYXRoKSAmJiB0aGlzLl9jaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcihmaWxlRXZlbnQucGF0aCkpIHtcclxuICAgICAgICAgIGNoYW5nZXMucHVzaChDb252ZXJ0LmF0b21GaWxlRXZlbnRUb0xTRmlsZUV2ZW50cyhmaWxlRXZlbnQpWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgZmlsZUV2ZW50Lm9sZFBhdGggJiZcclxuICAgICAgICAgIGZpbGVFdmVudC5vbGRQYXRoLnN0YXJ0c1dpdGgoYWN0aXZlU2VydmVyLnByb2plY3RQYXRoKSAmJlxyXG4gICAgICAgICAgdGhpcy5fY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIoZmlsZUV2ZW50Lm9sZFBhdGgpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goQ29udmVydC5hdG9tRmlsZUV2ZW50VG9MU0ZpbGVFdmVudHMoZmlsZUV2ZW50KVsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBhY3RpdmVTZXJ2ZXIuY29ubmVjdGlvbi5kaWRDaGFuZ2VXYXRjaGVkRmlsZXMoe2NoYW5nZXN9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=