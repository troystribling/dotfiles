Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerManager = undefined;

require('./logger');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _convert = require('./convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Manages the language server lifecycles and their associated objects necessary
// for adapting them to Atom IDE.


// The necessary elements for a server that has started or is starting.
let ServerManager = exports.ServerManager = class ServerManager {

  constructor(startServer, logger, startForEditor) {
    this._activeServers = [];
    this._startingServerPromises = new Map();
    this._stoppingServers = [];
    this._disposable = new _atom.CompositeDisposable();
    this._editorToServer = new Map();
    this._normalizedProjectPaths = [];

    this._startServer = startServer;
    this._logger = logger;
    this._startForEditor = startForEditor;
    this.updateNormalizedProjectPaths();
  }

  startListening() {
    this._disposable.add(atom.textEditors.observe(this.observeTextEditors.bind(this)));
    this._disposable.add(atom.project.onDidChangePaths(this.projectPathsChanged.bind(this)));
    if (atom.project.onDidChangeFiles) {
      this._disposable.add(atom.project.onDidChangeFiles(this.projectFilesChanged.bind(this)));
    }
  }

  stopListening() {
    this._disposable.dispose();
  }

  observeTextEditors(editor) {
    // Track grammar changes for opened editors
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => listener.dispose()));
    // Try to see if editor can have LS connected to it
    this._handleTextEditor(editor);
  }

  _handleTextEditor(editor) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (!_this._editorToServer.has(editor)) {
        // editor hasn't been processed yet, so process it by allocating LS for it if necessary
        const server = yield _this.getServer(editor, { shouldStart: true });
        if (server != null) {
          // There LS for the editor (either started now and already running)
          _this._editorToServer.set(editor, server);
          _this._disposable.add(editor.onDidDestroy(function () {
            _this._editorToServer.delete(editor);
            _this.stopUnusedServers();
          }));
        }
      }
    })();
  }

  _handleGrammarChange(editor) {
    if (this._startForEditor(editor)) {
      // If editor is interesting for LS process the editor further to attempt to start LS if needed
      this._handleTextEditor(editor);
    } else {
      // Editor is not supported by the LS
      const server = this._editorToServer.get(editor);
      // If LS is running for the unsupported editor then disconnect the editor from LS and shut down LS if necessary
      if (server) {
        // LS is up for unsupported server
        if (server.docSyncAdapter) {
          const syncAdapter = server.docSyncAdapter.getEditorSyncAdapter(editor);
          if (syncAdapter) {
            // Immitate editor close to disconnect LS from the editor
            syncAdapter.didClose();
          }
        }
        // Remove editor from the cache
        this._editorToServer.delete(editor);
        // Shut down LS if it's used by any other editor
        this.stopUnusedServers();
      }
    }
  }

  getActiveServers() {
    return this._activeServers.slice();
  }

  getServer(textEditor, { shouldStart } = { shouldStart: false }) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const finalProjectPath = _this2.determineProjectPath(textEditor);
      if (finalProjectPath == null) {
        // Files not yet saved have no path
        return null;
      }

      const foundActiveServer = _this2._activeServers.find(function (s) {
        return finalProjectPath === s.projectPath;
      });
      if (foundActiveServer) {
        return foundActiveServer;
      }

      const startingPromise = _this2._startingServerPromises.get(finalProjectPath);
      if (startingPromise) {
        return startingPromise;
      }

      return shouldStart && _this2._startForEditor(textEditor) ? yield _this2.startServer(finalProjectPath) : null;
    })();
  }

  startServer(projectPath) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      _this3._logger.debug(`Server starting "${projectPath}"`);
      const startingPromise = _this3._startServer(projectPath);
      _this3._startingServerPromises.set(projectPath, startingPromise);
      const startedActiveServer = yield startingPromise;
      _this3._activeServers.push(startedActiveServer);
      _this3._startingServerPromises.delete(projectPath);
      _this3._logger.debug(`Server started "${projectPath}" (pid ${startedActiveServer.process.pid})`);
      return startedActiveServer;
    })();
  }

  stopUnusedServers() {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const usedServers = new Set(_this4._editorToServer.values());
      const unusedServers = _this4._activeServers.filter(function (s) {
        return !usedServers.has(s);
      });
      if (unusedServers.length > 0) {
        _this4._logger.debug(`Stopping ${unusedServers.length} unused servers`);
        yield Promise.all(unusedServers.map(function (s) {
          return _this4.stopServer(s);
        }));
      }
    })();
  }

  stopAllServers() {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      yield Promise.all(_this5._activeServers.map(function (s) {
        return _this5.stopServer(s);
      }));
    })();
  }

  stopServer(server) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      _this6._logger.debug(`Server stopping "${server.projectPath}"`);
      // Immediately remove the server to prevent further usage.
      // If we re-open the file after this point, we'll get a new server.
      _this6._activeServers.splice(_this6._activeServers.indexOf(server), 1);
      _this6._stoppingServers.push(server);
      server.disposable.dispose();
      yield server.connection.shutdown();

      if (server.linterPushV2 != null) {
        server.linterPushV2.detachAll();
      }

      _this6.exitServer(server);
      _this6._stoppingServers.splice(_this6._stoppingServers.indexOf(server), 1);
    })();
  }

  exitServer(server) {
    const pid = server.process.pid;
    try {
      server.connection.exit();
    } finally {
      server.process.kill();
    }
    this._logger.debug(`Server stopped "${server.projectPath}" (pid ${pid})`);
  }

  terminate() {
    this._stoppingServers.forEach(server => {
      this._logger.debug(`Server terminating "${server.projectPath}"`);
      this.exitServer(server);
    });
  }

  determineProjectPath(textEditor) {
    const filePath = textEditor.getPath();
    if (filePath == null) {
      return null;
    }
    return this._normalizedProjectPaths.find(d => filePath.startsWith(d));
  }

  updateNormalizedProjectPaths() {
    this._normalizedProjectPaths = atom.project.getDirectories().map(d => this.normalizePath(d.getPath()));
  }

  normalizePath(projectPath) {
    return !projectPath.endsWith(_path2.default.sep) ? _path2.default.join(projectPath, _path2.default.sep) : projectPath;
  }

  projectPathsChanged(projectPaths) {
    const pathsSet = new Set(projectPaths.map(this.normalizePath));
    const serversToStop = this._activeServers.filter(s => !pathsSet.has(s.projectPath));
    Promise.all(serversToStop.map(s => this.stopServer(s)));
    this.updateNormalizedProjectPaths();
  }

  projectFilesChanged(fileEvents) {
    if (this._activeServers.length === 0) {
      return;
    }

    for (const activeServer of this._activeServers) {
      const changes = [];
      for (const fileEvent of fileEvents) {
        if (fileEvent.path.startsWith(activeServer.projectPath)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[0]);
        }
        if (fileEvent.oldPath && fileEvent.oldPath.startsWith(activeServer.projectPath)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[1]);
        }
      }
      if (changes.length > 0) {
        activeServer.connection.didChangeWatchedFiles({ changes });
      }
    }
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9zZXJ2ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJscyIsIlNlcnZlck1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0U2VydmVyIiwibG9nZ2VyIiwic3RhcnRGb3JFZGl0b3IiLCJfYWN0aXZlU2VydmVycyIsIl9zdGFydGluZ1NlcnZlclByb21pc2VzIiwiTWFwIiwiX3N0b3BwaW5nU2VydmVycyIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvclRvU2VydmVyIiwiX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMiLCJfc3RhcnRTZXJ2ZXIiLCJfbG9nZ2VyIiwiX3N0YXJ0Rm9yRWRpdG9yIiwidXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocyIsInN0YXJ0TGlzdGVuaW5nIiwiYWRkIiwiYXRvbSIsInRleHRFZGl0b3JzIiwib2JzZXJ2ZSIsIm9ic2VydmVUZXh0RWRpdG9ycyIsImJpbmQiLCJwcm9qZWN0Iiwib25EaWRDaGFuZ2VQYXRocyIsInByb2plY3RQYXRoc0NoYW5nZWQiLCJvbkRpZENoYW5nZUZpbGVzIiwicHJvamVjdEZpbGVzQ2hhbmdlZCIsInN0b3BMaXN0ZW5pbmciLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsIl9oYW5kbGVUZXh0RWRpdG9yIiwiaGFzIiwic2VydmVyIiwiZ2V0U2VydmVyIiwic2hvdWxkU3RhcnQiLCJzZXQiLCJkZWxldGUiLCJzdG9wVW51c2VkU2VydmVycyIsImdldCIsImRvY1N5bmNBZGFwdGVyIiwic3luY0FkYXB0ZXIiLCJnZXRFZGl0b3JTeW5jQWRhcHRlciIsImRpZENsb3NlIiwiZ2V0QWN0aXZlU2VydmVycyIsInNsaWNlIiwidGV4dEVkaXRvciIsImZpbmFsUHJvamVjdFBhdGgiLCJkZXRlcm1pbmVQcm9qZWN0UGF0aCIsImZvdW5kQWN0aXZlU2VydmVyIiwiZmluZCIsInMiLCJwcm9qZWN0UGF0aCIsInN0YXJ0aW5nUHJvbWlzZSIsImRlYnVnIiwic3RhcnRlZEFjdGl2ZVNlcnZlciIsInB1c2giLCJwcm9jZXNzIiwicGlkIiwidXNlZFNlcnZlcnMiLCJTZXQiLCJ2YWx1ZXMiLCJ1bnVzZWRTZXJ2ZXJzIiwiZmlsdGVyIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInN0b3BTZXJ2ZXIiLCJzdG9wQWxsU2VydmVycyIsInNwbGljZSIsImluZGV4T2YiLCJkaXNwb3NhYmxlIiwiY29ubmVjdGlvbiIsInNodXRkb3duIiwibGludGVyUHVzaFYyIiwiZGV0YWNoQWxsIiwiZXhpdFNlcnZlciIsImV4aXQiLCJraWxsIiwidGVybWluYXRlIiwiZm9yRWFjaCIsImZpbGVQYXRoIiwiZ2V0UGF0aCIsImQiLCJzdGFydHNXaXRoIiwiZ2V0RGlyZWN0b3JpZXMiLCJub3JtYWxpemVQYXRoIiwiZW5kc1dpdGgiLCJzZXAiLCJqb2luIiwicHJvamVjdFBhdGhzIiwicGF0aHNTZXQiLCJzZXJ2ZXJzVG9TdG9wIiwiZmlsZUV2ZW50cyIsImFjdGl2ZVNlcnZlciIsImNoYW5nZXMiLCJmaWxlRXZlbnQiLCJwYXRoIiwiYXRvbUZpbGVFdmVudFRvTFNGaWxlRXZlbnRzIiwib2xkUGF0aCIsImRpZENoYW5nZVdhdGNoZWRGaWxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7QUFJQTs7OztBQUNBOztJQUFZQSxFOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7O0FBYUE7QUFDQTs7O0FBWkE7SUFhYUMsYSxXQUFBQSxhLEdBQU4sTUFBTUEsYUFBTixDQUFvQjs7QUFXekJDLGNBQ0VDLFdBREYsRUFFRUMsTUFGRixFQUdFQyxjQUhGLEVBSUU7QUFBQSxTQWRGQyxjQWNFLEdBZG9DLEVBY3BDO0FBQUEsU0FiRkMsdUJBYUUsR0FiNEQsSUFBSUMsR0FBSixFQWE1RDtBQUFBLFNBWkZDLGdCQVlFLEdBWnNDLEVBWXRDO0FBQUEsU0FYRkMsV0FXRSxHQVhpQywrQkFXakM7QUFBQSxTQVZGQyxl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QXdCSCxVQUF4QixFQUFvQztBQUNsQyxZQUFJRyxVQUFVQyxJQUFWLENBQWViLFVBQWYsQ0FBMEJVLGFBQWEzQyxXQUF2QyxDQUFKLEVBQXlEO0FBQ3ZENEMsa0JBQVF4QyxJQUFSLENBQWEsa0JBQVEyQywyQkFBUixDQUFvQ0YsU0FBcEMsRUFBK0MsQ0FBL0MsQ0FBYjtBQUNEO0FBQ0QsWUFBSUEsVUFBVUcsT0FBVixJQUFxQkgsVUFBVUcsT0FBVixDQUFrQmYsVUFBbEIsQ0FBNkJVLGFBQWEzQyxXQUExQyxDQUF6QixFQUFpRjtBQUMvRTRDLGtCQUFReEMsSUFBUixDQUFhLGtCQUFRMkMsMkJBQVIsQ0FBb0NGLFNBQXBDLEVBQStDLENBQS9DLENBQWI7QUFDRDtBQUNGO0FBQ0QsVUFBSUQsUUFBUWhDLE1BQVIsR0FBaUIsQ0FBckIsRUFBd0I7QUFDdEIrQixxQkFBYXRCLFVBQWIsQ0FBd0I0QixxQkFBeEIsQ0FBOEMsRUFBQ0wsT0FBRCxFQUE5QztBQUNEO0FBQ0Y7QUFDRjtBQW5Od0IsQyIsImZpbGUiOiJzZXJ2ZXItbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQge3R5cGUgTG9nZ2VyfSBmcm9tICcuL2xvZ2dlcic7XHJcbmltcG9ydCB0eXBlIExpbnRlclB1c2hWMkFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9saW50ZXItcHVzaC12Mi1hZGFwdGVyJztcclxuaW1wb3J0IHR5cGUgRG9jdW1lbnRTeW5jQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2RvY3VtZW50LXN5bmMtYWRhcHRlcic7XHJcblxyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0ICogYXMgbHMgZnJvbSAnLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4vY29udmVydCc7XHJcbmltcG9ydCB7Q29tcG9zaXRlRGlzcG9zYWJsZX0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBUaGUgbmVjZXNzYXJ5IGVsZW1lbnRzIGZvciBhIHNlcnZlciB0aGF0IGhhcyBzdGFydGVkIG9yIGlzIHN0YXJ0aW5nLlxyXG5leHBvcnQgdHlwZSBBY3RpdmVTZXJ2ZXIgPSB7XHJcbiAgZGlzcG9zYWJsZTogQ29tcG9zaXRlRGlzcG9zYWJsZSxcclxuICBwcm9qZWN0UGF0aDogc3RyaW5nLFxyXG4gIHByb2Nlc3M6IGNoaWxkX3Byb2Nlc3MkQ2hpbGRQcm9jZXNzLFxyXG4gIGNvbm5lY3Rpb246IGxzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBjYXBhYmlsaXRpZXM6IGxzLlNlcnZlckNhcGFiaWxpdGllcyxcclxuICBsaW50ZXJQdXNoVjI/OiBMaW50ZXJQdXNoVjJBZGFwdGVyLFxyXG4gIGRvY1N5bmNBZGFwdGVyPzogRG9jdW1lbnRTeW5jQWRhcHRlcixcclxufTtcclxuXHJcbi8vIE1hbmFnZXMgdGhlIGxhbmd1YWdlIHNlcnZlciBsaWZlY3ljbGVzIGFuZCB0aGVpciBhc3NvY2lhdGVkIG9iamVjdHMgbmVjZXNzYXJ5XHJcbi8vIGZvciBhZGFwdGluZyB0aGVtIHRvIEF0b20gSURFLlxyXG5leHBvcnQgY2xhc3MgU2VydmVyTWFuYWdlciB7XHJcbiAgX2FjdGl2ZVNlcnZlcnM6IEFycmF5PEFjdGl2ZVNlcnZlcj4gPSBbXTtcclxuICBfc3RhcnRpbmdTZXJ2ZXJQcm9taXNlczogTWFwPHN0cmluZywgUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+PiA9IG5ldyBNYXAoKTtcclxuICBfc3RvcHBpbmdTZXJ2ZXJzOiBBcnJheTxBY3RpdmVTZXJ2ZXI+ID0gW107XHJcbiAgX2Rpc3Bvc2FibGU6IENvbXBvc2l0ZURpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIF9lZGl0b3JUb1NlcnZlcjogTWFwPGF0b20kVGV4dEVkaXRvciwgQWN0aXZlU2VydmVyPiA9IG5ldyBNYXAoKTtcclxuICBfbG9nZ2VyOiBMb2dnZXI7XHJcbiAgX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHM6IEFycmF5PHN0cmluZz4gPSBbXTtcclxuICBfc3RhcnRGb3JFZGl0b3I6IChlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikgPT4gYm9vbGVhbjtcclxuICBfc3RhcnRTZXJ2ZXI6IChwcm9qZWN0UGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPEFjdGl2ZVNlcnZlcj47XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgc3RhcnRTZXJ2ZXI6IChwcm9qZWN0UGF0aDogc3RyaW5nKSA9PiBQcm9taXNlPEFjdGl2ZVNlcnZlcj4sXHJcbiAgICBsb2dnZXI6IExvZ2dlcixcclxuICAgIHN0YXJ0Rm9yRWRpdG9yOiAoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpID0+IGJvb2xlYW4sXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9zdGFydFNlcnZlciA9IHN0YXJ0U2VydmVyO1xyXG4gICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgdGhpcy5fc3RhcnRGb3JFZGl0b3IgPSBzdGFydEZvckVkaXRvcjtcclxuICAgIHRoaXMudXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnRMaXN0ZW5pbmcoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnRleHRFZGl0b3JzLm9ic2VydmUodGhpcy5vYnNlcnZlVGV4dEVkaXRvcnMuYmluZCh0aGlzKSkpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlUGF0aHModGhpcy5wcm9qZWN0UGF0aHNDaGFuZ2VkLmJpbmQodGhpcykpKTtcclxuICAgIGlmIChhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VGaWxlcykge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VGaWxlcyh0aGlzLnByb2plY3RGaWxlc0NoYW5nZWQuYmluZCh0aGlzKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RvcExpc3RlbmluZygpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgb2JzZXJ2ZVRleHRFZGl0b3JzKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICAvLyBUcmFjayBncmFtbWFyIGNoYW5nZXMgZm9yIG9wZW5lZCBlZGl0b3JzXHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IGVkaXRvci5vYnNlcnZlR3JhbW1hcihncmFtbWFyID0+IHRoaXMuX2hhbmRsZUdyYW1tYXJDaGFuZ2UoZWRpdG9yKSk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IGxpc3RlbmVyLmRpc3Bvc2UoKSkpO1xyXG4gICAgLy8gVHJ5IHRvIHNlZSBpZiBlZGl0b3IgY2FuIGhhdmUgTFMgY29ubmVjdGVkIHRvIGl0XHJcbiAgICB0aGlzLl9oYW5kbGVUZXh0RWRpdG9yKGVkaXRvcik7XHJcbiAgfVxyXG5cclxuICBhc3luYyBfaGFuZGxlVGV4dEVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgaWYgKCF0aGlzLl9lZGl0b3JUb1NlcnZlci5oYXMoZWRpdG9yKSkge1xyXG4gICAgICAvLyBlZGl0b3IgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldCwgc28gcHJvY2VzcyBpdCBieSBhbGxvY2F0aW5nIExTIGZvciBpdCBpZiBuZWNlc3NhcnlcclxuICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXIoZWRpdG9yLCB7c2hvdWxkU3RhcnQ6IHRydWV9KTtcclxuICAgICAgaWYgKHNlcnZlciAhPSBudWxsKSB7XHJcbiAgICAgICAgLy8gVGhlcmUgTFMgZm9yIHRoZSBlZGl0b3IgKGVpdGhlciBzdGFydGVkIG5vdyBhbmQgYWxyZWFkeSBydW5uaW5nKVxyXG4gICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLnNldChlZGl0b3IsIHNlcnZlcik7XHJcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZGVsZXRlKGVkaXRvcik7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcFVudXNlZFNlcnZlcnMoKTtcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKSB7XHJcbiAgICBpZiAodGhpcy5fc3RhcnRGb3JFZGl0b3IoZWRpdG9yKSkge1xyXG4gICAgICAvLyBJZiBlZGl0b3IgaXMgaW50ZXJlc3RpbmcgZm9yIExTIHByb2Nlc3MgdGhlIGVkaXRvciBmdXJ0aGVyIHRvIGF0dGVtcHQgdG8gc3RhcnQgTFMgaWYgbmVlZGVkXHJcbiAgICAgIHRoaXMuX2hhbmRsZVRleHRFZGl0b3IoZWRpdG9yKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEVkaXRvciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBMU1xyXG4gICAgICBjb25zdCBzZXJ2ZXIgPSB0aGlzLl9lZGl0b3JUb1NlcnZlci5nZXQoZWRpdG9yKTtcclxuICAgICAgLy8gSWYgTFMgaXMgcnVubmluZyBmb3IgdGhlIHVuc3VwcG9ydGVkIGVkaXRvciB0aGVuIGRpc2Nvbm5lY3QgdGhlIGVkaXRvciBmcm9tIExTIGFuZCBzaHV0IGRvd24gTFMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGlmIChzZXJ2ZXIpIHtcclxuICAgICAgICAvLyBMUyBpcyB1cCBmb3IgdW5zdXBwb3J0ZWQgc2VydmVyXHJcbiAgICAgICAgaWYgKHNlcnZlci5kb2NTeW5jQWRhcHRlcikge1xyXG4gICAgICAgICAgY29uc3Qgc3luY0FkYXB0ZXIgPSBzZXJ2ZXIuZG9jU3luY0FkYXB0ZXIuZ2V0RWRpdG9yU3luY0FkYXB0ZXIoZWRpdG9yKTtcclxuICAgICAgICAgIGlmIChzeW5jQWRhcHRlcikge1xyXG4gICAgICAgICAgICAvLyBJbW1pdGF0ZSBlZGl0b3IgY2xvc2UgdG8gZGlzY29ubmVjdCBMUyBmcm9tIHRoZSBlZGl0b3JcclxuICAgICAgICAgICAgc3luY0FkYXB0ZXIuZGlkQ2xvc2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIGVkaXRvciBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgIC8vIFNodXQgZG93biBMUyBpZiBpdCdzIHVzZWQgYnkgYW55IG90aGVyIGVkaXRvclxyXG4gICAgICAgIHRoaXMuc3RvcFVudXNlZFNlcnZlcnMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0QWN0aXZlU2VydmVycygpOiBBcnJheTxBY3RpdmVTZXJ2ZXI+IHtcclxuICAgIHJldHVybiB0aGlzLl9hY3RpdmVTZXJ2ZXJzLnNsaWNlKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRTZXJ2ZXIoXHJcbiAgICB0ZXh0RWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgICB7c2hvdWxkU3RhcnR9OiB7c2hvdWxkU3RhcnQ/OiBib29sZWFufSA9IHtzaG91bGRTdGFydDogZmFsc2V9LFxyXG4gICk6IFByb21pc2U8P0FjdGl2ZVNlcnZlcj4ge1xyXG4gICAgY29uc3QgZmluYWxQcm9qZWN0UGF0aCA9IHRoaXMuZGV0ZXJtaW5lUHJvamVjdFBhdGgodGV4dEVkaXRvcik7XHJcbiAgICBpZiAoZmluYWxQcm9qZWN0UGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIC8vIEZpbGVzIG5vdCB5ZXQgc2F2ZWQgaGF2ZSBubyBwYXRoXHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZvdW5kQWN0aXZlU2VydmVyID0gdGhpcy5fYWN0aXZlU2VydmVycy5maW5kKHMgPT4gZmluYWxQcm9qZWN0UGF0aCA9PT0gcy5wcm9qZWN0UGF0aCk7XHJcbiAgICBpZiAoZm91bmRBY3RpdmVTZXJ2ZXIpIHtcclxuICAgICAgcmV0dXJuIGZvdW5kQWN0aXZlU2VydmVyO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXJ0aW5nUHJvbWlzZSA9IHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuZ2V0KGZpbmFsUHJvamVjdFBhdGgpO1xyXG4gICAgaWYgKHN0YXJ0aW5nUHJvbWlzZSkge1xyXG4gICAgICByZXR1cm4gc3RhcnRpbmdQcm9taXNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaG91bGRTdGFydCAmJiB0aGlzLl9zdGFydEZvckVkaXRvcih0ZXh0RWRpdG9yKSA/IGF3YWl0IHRoaXMuc3RhcnRTZXJ2ZXIoZmluYWxQcm9qZWN0UGF0aCkgOiBudWxsO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RhcnRTZXJ2ZXIocHJvamVjdFBhdGg6IHN0cmluZyk6IFByb21pc2U8QWN0aXZlU2VydmVyPiB7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdGFydGluZyBcIiR7cHJvamVjdFBhdGh9XCJgKTtcclxuICAgIGNvbnN0IHN0YXJ0aW5nUHJvbWlzZSA9IHRoaXMuX3N0YXJ0U2VydmVyKHByb2plY3RQYXRoKTtcclxuICAgIHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuc2V0KHByb2plY3RQYXRoLCBzdGFydGluZ1Byb21pc2UpO1xyXG4gICAgY29uc3Qgc3RhcnRlZEFjdGl2ZVNlcnZlciA9IGF3YWl0IHN0YXJ0aW5nUHJvbWlzZTtcclxuICAgIHRoaXMuX2FjdGl2ZVNlcnZlcnMucHVzaChzdGFydGVkQWN0aXZlU2VydmVyKTtcclxuICAgIHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuZGVsZXRlKHByb2plY3RQYXRoKTtcclxuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0YXJ0ZWQgXCIke3Byb2plY3RQYXRofVwiIChwaWQgJHtzdGFydGVkQWN0aXZlU2VydmVyLnByb2Nlc3MucGlkfSlgKTtcclxuICAgIHJldHVybiBzdGFydGVkQWN0aXZlU2VydmVyO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgc3RvcFVudXNlZFNlcnZlcnMoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCB1c2VkU2VydmVycyA9IG5ldyBTZXQodGhpcy5fZWRpdG9yVG9TZXJ2ZXIudmFsdWVzKCkpO1xyXG4gICAgY29uc3QgdW51c2VkU2VydmVycyA9IHRoaXMuX2FjdGl2ZVNlcnZlcnMuZmlsdGVyKHMgPT4gIXVzZWRTZXJ2ZXJzLmhhcyhzKSk7XHJcbiAgICBpZiAodW51c2VkU2VydmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU3RvcHBpbmcgJHt1bnVzZWRTZXJ2ZXJzLmxlbmd0aH0gdW51c2VkIHNlcnZlcnNgKTtcclxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodW51c2VkU2VydmVycy5tYXAocyA9PiB0aGlzLnN0b3BTZXJ2ZXIocykpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIHN0b3BBbGxTZXJ2ZXJzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5fYWN0aXZlU2VydmVycy5tYXAocyA9PiB0aGlzLnN0b3BTZXJ2ZXIocykpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0b3BTZXJ2ZXIoc2VydmVyOiBBY3RpdmVTZXJ2ZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0b3BwaW5nIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCJgKTtcclxuICAgIC8vIEltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgc2VydmVyIHRvIHByZXZlbnQgZnVydGhlciB1c2FnZS5cclxuICAgIC8vIElmIHdlIHJlLW9wZW4gdGhlIGZpbGUgYWZ0ZXIgdGhpcyBwb2ludCwgd2UnbGwgZ2V0IGEgbmV3IHNlcnZlci5cclxuICAgIHRoaXMuX2FjdGl2ZVNlcnZlcnMuc3BsaWNlKHRoaXMuX2FjdGl2ZVNlcnZlcnMuaW5kZXhPZihzZXJ2ZXIpLCAxKTtcclxuICAgIHRoaXMuX3N0b3BwaW5nU2VydmVycy5wdXNoKHNlcnZlcik7XHJcbiAgICBzZXJ2ZXIuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5zaHV0ZG93bigpO1xyXG5cclxuICAgIGlmIChzZXJ2ZXIubGludGVyUHVzaFYyICE9IG51bGwpIHtcclxuICAgICAgc2VydmVyLmxpbnRlclB1c2hWMi5kZXRhY2hBbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmV4aXRTZXJ2ZXIoc2VydmVyKTtcclxuICAgIHRoaXMuX3N0b3BwaW5nU2VydmVycy5zcGxpY2UodGhpcy5fc3RvcHBpbmdTZXJ2ZXJzLmluZGV4T2Yoc2VydmVyKSwgMSk7XHJcbiAgfVxyXG5cclxuICBleGl0U2VydmVyKHNlcnZlcjogQWN0aXZlU2VydmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBwaWQgPSBzZXJ2ZXIucHJvY2Vzcy5waWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZXJ2ZXIuY29ubmVjdGlvbi5leGl0KCk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXJ2ZXIucHJvY2Vzcy5raWxsKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdG9wcGVkIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCIgKHBpZCAke3BpZH0pYCk7XHJcbiAgfVxyXG5cclxuICB0ZXJtaW5hdGUoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9zdG9wcGluZ1NlcnZlcnMuZm9yRWFjaChzZXJ2ZXIgPT4ge1xyXG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciB0ZXJtaW5hdGluZyBcIiR7c2VydmVyLnByb2plY3RQYXRofVwiYCk7XHJcbiAgICAgIHRoaXMuZXhpdFNlcnZlcihzZXJ2ZXIpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBkZXRlcm1pbmVQcm9qZWN0UGF0aCh0ZXh0RWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiA/c3RyaW5nIHtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gdGV4dEVkaXRvci5nZXRQYXRoKCk7XHJcbiAgICBpZiAoZmlsZVBhdGggPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkUHJvamVjdFBhdGhzLmZpbmQoZCA9PiBmaWxlUGF0aC5zdGFydHNXaXRoKGQpKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9ub3JtYWxpemVkUHJvamVjdFBhdGhzID0gYXRvbS5wcm9qZWN0LmdldERpcmVjdG9yaWVzKCkubWFwKGQgPT4gdGhpcy5ub3JtYWxpemVQYXRoKGQuZ2V0UGF0aCgpKSk7XHJcbiAgfVxyXG5cclxuICBub3JtYWxpemVQYXRoKHByb2plY3RQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICFwcm9qZWN0UGF0aC5lbmRzV2l0aChwYXRoLnNlcCkgPyBwYXRoLmpvaW4ocHJvamVjdFBhdGgsIHBhdGguc2VwKSA6IHByb2plY3RQYXRoO1xyXG4gIH1cclxuXHJcbiAgcHJvamVjdFBhdGhzQ2hhbmdlZChwcm9qZWN0UGF0aHM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcclxuICAgIGNvbnN0IHBhdGhzU2V0ID0gbmV3IFNldChwcm9qZWN0UGF0aHMubWFwKHRoaXMubm9ybWFsaXplUGF0aCkpO1xyXG4gICAgY29uc3Qgc2VydmVyc1RvU3RvcCA9IHRoaXMuX2FjdGl2ZVNlcnZlcnMuZmlsdGVyKHMgPT4gIXBhdGhzU2V0LmhhcyhzLnByb2plY3RQYXRoKSk7XHJcbiAgICBQcm9taXNlLmFsbChzZXJ2ZXJzVG9TdG9wLm1hcChzID0+IHRoaXMuc3RvcFNlcnZlcihzKSkpO1xyXG4gICAgdGhpcy51cGRhdGVOb3JtYWxpemVkUHJvamVjdFBhdGhzKCk7XHJcbiAgfVxyXG5cclxuICBwcm9qZWN0RmlsZXNDaGFuZ2VkKGZpbGVFdmVudHM6IEFycmF5PGF0b20kUHJvamVjdEZpbGVFdmVudD4pOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9hY3RpdmVTZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBhY3RpdmVTZXJ2ZXIgb2YgdGhpcy5fYWN0aXZlU2VydmVycykge1xyXG4gICAgICBjb25zdCBjaGFuZ2VzID0gW107XHJcbiAgICAgIGZvciAoY29uc3QgZmlsZUV2ZW50IG9mIGZpbGVFdmVudHMpIHtcclxuICAgICAgICBpZiAoZmlsZUV2ZW50LnBhdGguc3RhcnRzV2l0aChhY3RpdmVTZXJ2ZXIucHJvamVjdFBhdGgpKSB7XHJcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goQ29udmVydC5hdG9tRmlsZUV2ZW50VG9MU0ZpbGVFdmVudHMoZmlsZUV2ZW50KVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWxlRXZlbnQub2xkUGF0aCAmJiBmaWxlRXZlbnQub2xkUGF0aC5zdGFydHNXaXRoKGFjdGl2ZVNlcnZlci5wcm9qZWN0UGF0aCkpIHtcclxuICAgICAgICAgIGNoYW5nZXMucHVzaChDb252ZXJ0LmF0b21GaWxlRXZlbnRUb0xTRmlsZUV2ZW50cyhmaWxlRXZlbnQpWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGFjdGl2ZVNlcnZlci5jb25uZWN0aW9uLmRpZENoYW5nZVdhdGNoZWRGaWxlcyh7Y2hhbmdlc30pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==