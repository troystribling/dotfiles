"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
class Utils {
    /**
     * Obtain the range of the word at the given editor position.
     * Uses the non-word characters from the position's grammar scope.
     */
    static getWordAtPosition(editor, position) {
        const scopeDescriptor = editor.scopeDescriptorForBufferPosition(position);
        const nonWordCharacters = Utils.escapeRegExp(editor.getNonWordCharacters(scopeDescriptor));
        const range = Utils._getRegexpRangeAtPosition(editor.getBuffer(), position, new RegExp(`^[\t ]*$|[^\\s${nonWordCharacters}]+`, 'g'));
        if (range == null) {
            return new atom_1.Range(position, position);
        }
        return range;
    }
    static escapeRegExp(string) {
        // From atom/underscore-plus.
        return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    static _getRegexpRangeAtPosition(buffer, position, wordRegex) {
        const { row, column } = position;
        const rowRange = buffer.rangeForRow(row, false);
        let matchData;
        // Extract the expression from the row text.
        buffer.scanInRange(wordRegex, rowRange, (data) => {
            const { range } = data;
            if (position.isGreaterThanOrEqual(range.start) &&
                // Range endpoints are exclusive.
                position.isLessThan(range.end)) {
                matchData = data;
                data.stop();
                return;
            }
            // Stop the scan if the scanner has passed our position.
            if (range.end.column > column) {
                data.stop();
            }
        });
        return matchData == null ? null : matchData.range;
    }
    /**
     * For the given connection and cancellationTokens map, cancel the existing
     * CancellationToken for that connection then create and store a new
     * CancellationToken to be used for the current request.
     */
    static cancelAndRefreshCancellationToken(key, cancellationTokens) {
        let cancellationToken = cancellationTokens.get(key);
        if (cancellationToken !== undefined && !cancellationToken.token.isCancellationRequested) {
            cancellationToken.cancel();
        }
        cancellationToken = new vscode_jsonrpc_1.CancellationTokenSource();
        cancellationTokens.set(key, cancellationToken);
        return cancellationToken.token;
    }
    static doWithCancellationToken(key, cancellationTokens, work) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = Utils.cancelAndRefreshCancellationToken(key, cancellationTokens);
            const result = yield work(token);
            cancellationTokens.delete(key);
            return result;
        });
    }
    static assertUnreachable(_) {
        return _;
    }
}
exports.default = Utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9saWIvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLCtCQU1jO0FBQ2QsbURBR3dCO0FBRXhCO0lBQ0U7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLGlCQUFpQixDQUFDLE1BQWtCLEVBQUUsUUFBZTtRQUNqRSxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsZ0NBQWdDLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDMUUsTUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO1FBQzNGLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyx5QkFBeUIsQ0FDM0MsTUFBTSxDQUFDLFNBQVMsRUFBRSxFQUNsQixRQUFRLEVBQ1IsSUFBSSxNQUFNLENBQUMsaUJBQWlCLGlCQUFpQixJQUFJLEVBQUUsR0FBRyxDQUFDLENBQ3hELENBQUM7UUFDRixFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNsQixNQUFNLENBQUMsSUFBSSxZQUFLLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ3ZDLENBQUM7UUFDRCxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVNLE1BQU0sQ0FBQyxZQUFZLENBQUMsTUFBYztRQUN2Qyw2QkFBNkI7UUFDN0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVPLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxNQUFrQixFQUFFLFFBQWUsRUFBRSxTQUFpQjtRQUM3RixNQUFNLEVBQUMsR0FBRyxFQUFFLE1BQU0sRUFBQyxHQUFHLFFBQVEsQ0FBQztRQUMvQixNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNoRCxJQUFJLFNBQThDLENBQUM7UUFDbkQsNENBQTRDO1FBQzVDLE1BQU0sQ0FBQyxXQUFXLENBQUMsU0FBUyxFQUFFLFFBQVEsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO1lBQy9DLE1BQU0sRUFBQyxLQUFLLEVBQUMsR0FBRyxJQUFJLENBQUM7WUFDckIsRUFBRSxDQUFDLENBQ0QsUUFBUSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7Z0JBQzFDLGlDQUFpQztnQkFDakMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUMvQixDQUFDLENBQUMsQ0FBQztnQkFDRCxTQUFTLEdBQUcsSUFBSSxDQUFDO2dCQUNqQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ1osTUFBTSxDQUFDO1lBQ1QsQ0FBQztZQUNELHdEQUF3RDtZQUN4RCxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUM5QixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDZCxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxNQUFNLENBQUMsU0FBUyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLGlDQUFpQyxDQUM3QyxHQUFNLEVBQ04sa0JBQXVEO1FBRXZELElBQUksaUJBQWlCLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3BELEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixLQUFLLFNBQVMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLENBQUM7WUFDeEYsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDN0IsQ0FBQztRQUVELGlCQUFpQixHQUFHLElBQUksd0NBQXVCLEVBQUUsQ0FBQztRQUNsRCxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGlCQUFpQixDQUFDLENBQUM7UUFDL0MsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQztJQUNqQyxDQUFDO0lBRU0sTUFBTSxDQUFPLHVCQUF1QixDQUN6QyxHQUFPLEVBQ1Asa0JBQXdELEVBQ3hELElBQStDOztZQUUvQyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsaUNBQWlDLENBQUMsR0FBRyxFQUFFLGtCQUFrQixDQUFDLENBQUM7WUFDL0UsTUFBTSxNQUFNLEdBQU8sTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDaEIsQ0FBQztLQUFBO0lBRU0sTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQVE7UUFDdEMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7Q0FDRjtBQWpGRCx3QkFpRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIFBvaW50LFxyXG4gIFRleHRCdWZmZXIsXHJcbiAgVGV4dEVkaXRvcixcclxuICBSYW5nZSxcclxuICBCdWZmZXJTY2FuUmVzdWx0LFxyXG59IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQge1xyXG4gIENhbmNlbGxhdGlvblRva2VuLFxyXG4gIENhbmNlbGxhdGlvblRva2VuU291cmNlLFxyXG59IGZyb20gJ3ZzY29kZS1qc29ucnBjJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFV0aWxzIHtcclxuICAvKipcclxuICAgKiBPYnRhaW4gdGhlIHJhbmdlIG9mIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBlZGl0b3IgcG9zaXRpb24uXHJcbiAgICogVXNlcyB0aGUgbm9uLXdvcmQgY2hhcmFjdGVycyBmcm9tIHRoZSBwb3NpdGlvbidzIGdyYW1tYXIgc2NvcGUuXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBnZXRXb3JkQXRQb3NpdGlvbihlZGl0b3I6IFRleHRFZGl0b3IsIHBvc2l0aW9uOiBQb2ludCk6IFJhbmdlIHtcclxuICAgIGNvbnN0IHNjb3BlRGVzY3JpcHRvciA9IGVkaXRvci5zY29wZURlc2NyaXB0b3JGb3JCdWZmZXJQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgICBjb25zdCBub25Xb3JkQ2hhcmFjdGVycyA9IFV0aWxzLmVzY2FwZVJlZ0V4cChlZGl0b3IuZ2V0Tm9uV29yZENoYXJhY3RlcnMoc2NvcGVEZXNjcmlwdG9yKSk7XHJcbiAgICBjb25zdCByYW5nZSA9IFV0aWxzLl9nZXRSZWdleHBSYW5nZUF0UG9zaXRpb24oXHJcbiAgICAgIGVkaXRvci5nZXRCdWZmZXIoKSxcclxuICAgICAgcG9zaXRpb24sXHJcbiAgICAgIG5ldyBSZWdFeHAoYF5bXFx0IF0qJHxbXlxcXFxzJHtub25Xb3JkQ2hhcmFjdGVyc31dK2AsICdnJyksXHJcbiAgICApO1xyXG4gICAgaWYgKHJhbmdlID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbiwgcG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJhbmdlO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBlc2NhcGVSZWdFeHAoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgLy8gRnJvbSBhdG9tL3VuZGVyc2NvcmUtcGx1cy5cclxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgX2dldFJlZ2V4cFJhbmdlQXRQb3NpdGlvbihidWZmZXI6IFRleHRCdWZmZXIsIHBvc2l0aW9uOiBQb2ludCwgd29yZFJlZ2V4OiBSZWdFeHApOiBSYW5nZSB8IG51bGwge1xyXG4gICAgY29uc3Qge3JvdywgY29sdW1ufSA9IHBvc2l0aW9uO1xyXG4gICAgY29uc3Qgcm93UmFuZ2UgPSBidWZmZXIucmFuZ2VGb3JSb3cocm93LCBmYWxzZSk7XHJcbiAgICBsZXQgbWF0Y2hEYXRhOiBCdWZmZXJTY2FuUmVzdWx0IHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIC8vIEV4dHJhY3QgdGhlIGV4cHJlc3Npb24gZnJvbSB0aGUgcm93IHRleHQuXHJcbiAgICBidWZmZXIuc2NhbkluUmFuZ2Uod29yZFJlZ2V4LCByb3dSYW5nZSwgKGRhdGEpID0+IHtcclxuICAgICAgY29uc3Qge3JhbmdlfSA9IGRhdGE7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBwb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChyYW5nZS5zdGFydCkgJiZcclxuICAgICAgICAvLyBSYW5nZSBlbmRwb2ludHMgYXJlIGV4Y2x1c2l2ZS5cclxuICAgICAgICBwb3NpdGlvbi5pc0xlc3NUaGFuKHJhbmdlLmVuZClcclxuICAgICAgKSB7XHJcbiAgICAgICAgbWF0Y2hEYXRhID0gZGF0YTtcclxuICAgICAgICBkYXRhLnN0b3AoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgLy8gU3RvcCB0aGUgc2NhbiBpZiB0aGUgc2Nhbm5lciBoYXMgcGFzc2VkIG91ciBwb3NpdGlvbi5cclxuICAgICAgaWYgKHJhbmdlLmVuZC5jb2x1bW4gPiBjb2x1bW4pIHtcclxuICAgICAgICBkYXRhLnN0b3AoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbWF0Y2hEYXRhID09IG51bGwgPyBudWxsIDogbWF0Y2hEYXRhLnJhbmdlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9yIHRoZSBnaXZlbiBjb25uZWN0aW9uIGFuZCBjYW5jZWxsYXRpb25Ub2tlbnMgbWFwLCBjYW5jZWwgdGhlIGV4aXN0aW5nXHJcbiAgICogQ2FuY2VsbGF0aW9uVG9rZW4gZm9yIHRoYXQgY29ubmVjdGlvbiB0aGVuIGNyZWF0ZSBhbmQgc3RvcmUgYSBuZXdcclxuICAgKiBDYW5jZWxsYXRpb25Ub2tlbiB0byBiZSB1c2VkIGZvciB0aGUgY3VycmVudCByZXF1ZXN0LlxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdGF0aWMgY2FuY2VsQW5kUmVmcmVzaENhbmNlbGxhdGlvblRva2VuPFQgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gICAga2V5OiBULFxyXG4gICAgY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPFQsIENhbmNlbGxhdGlvblRva2VuU291cmNlPik6IENhbmNlbGxhdGlvblRva2VuIHtcclxuXHJcbiAgICBsZXQgY2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25Ub2tlbnMuZ2V0KGtleSk7XHJcbiAgICBpZiAoY2FuY2VsbGF0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCAmJiAhY2FuY2VsbGF0aW9uVG9rZW4udG9rZW4uaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpIHtcclxuICAgICAgY2FuY2VsbGF0aW9uVG9rZW4uY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FuY2VsbGF0aW9uVG9rZW4gPSBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcclxuICAgIGNhbmNlbGxhdGlvblRva2Vucy5zZXQoa2V5LCBjYW5jZWxsYXRpb25Ub2tlbik7XHJcbiAgICByZXR1cm4gY2FuY2VsbGF0aW9uVG9rZW4udG9rZW47XHJcbiAgfVxyXG5cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGRvV2l0aENhbmNlbGxhdGlvblRva2VuPFQxIGV4dGVuZHMgb2JqZWN0LCBUMj4oXHJcbiAgICBrZXk6IFQxLFxyXG4gICAgY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPFQxLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4sXHJcbiAgICB3b3JrOiAodG9rZW46IENhbmNlbGxhdGlvblRva2VuKSA9PiBQcm9taXNlPFQyPixcclxuICApOiBQcm9taXNlPFQyPiB7XHJcbiAgICBjb25zdCB0b2tlbiA9IFV0aWxzLmNhbmNlbEFuZFJlZnJlc2hDYW5jZWxsYXRpb25Ub2tlbihrZXksIGNhbmNlbGxhdGlvblRva2Vucyk7XHJcbiAgICBjb25zdCByZXN1bHQ6IFQyID0gYXdhaXQgd29yayh0b2tlbik7XHJcbiAgICBjYW5jZWxsYXRpb25Ub2tlbnMuZGVsZXRlKGtleSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgcHVibGljIHN0YXRpYyBhc3NlcnRVbnJlYWNoYWJsZShfOiBuZXZlcik6IG5ldmVyIHtcclxuICAgIHJldHVybiBfO1xyXG4gIH1cclxufVxyXG4iXX0=