"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const path = require("path");
const sinon = require("sinon");
const apply_edit_adapter_1 = require("../../lib/adapters/apply-edit-adapter");
const convert_1 = require("../../lib/convert");
const TEST_PATH1 = normalizeDriveLetterName(path.join(__dirname, 'test.txt'));
const TEST_PATH2 = normalizeDriveLetterName(path.join(__dirname, 'test2.txt'));
const TEST_PATH3 = normalizeDriveLetterName(path.join(__dirname, 'test3.txt'));
const TEST_PATH4 = normalizeDriveLetterName(path.join(__dirname, 'test4.txt'));
function normalizeDriveLetterName(filePath) {
    if (process.platform === 'win32') {
        return filePath.replace(/^([a-z]):/, ([driveLetter]) => driveLetter.toUpperCase() + ':');
    }
    else {
        return filePath;
    }
}
describe('ApplyEditAdapter', () => {
    describe('onApplyEdit', () => {
        beforeEach(() => {
            sinon.spy(atom.notifications, 'addError');
        });
        afterEach(() => {
            atom.notifications.addError.restore();
        });
        it('works for open files', () => __awaiter(this, void 0, void 0, function* () {
            const editor = yield atom.workspace.open(TEST_PATH1);
            editor.setText('abc\ndef\n');
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [convert_1.default.pathToUri(TEST_PATH1)]: [
                            {
                                range: {
                                    start: { line: 0, character: 0 },
                                    end: { line: 0, character: 3 },
                                },
                                newText: 'def',
                            },
                            {
                                range: {
                                    start: { line: 1, character: 0 },
                                    end: { line: 1, character: 3 },
                                },
                                newText: 'ghi',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(true);
            chai_1.expect(editor.getText()).to.equal('def\nghi\n');
            // Undo should be atomic.
            editor.getBuffer().undo();
            chai_1.expect(editor.getText()).to.equal('abc\ndef\n');
        }));
        it('works with TextDocumentEdits', () => __awaiter(this, void 0, void 0, function* () {
            const editor = yield atom.workspace.open(TEST_PATH1);
            editor.setText('abc\ndef\n');
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    documentChanges: [{
                            textDocument: {
                                version: 1,
                                uri: convert_1.default.pathToUri(TEST_PATH1),
                            },
                            edits: [
                                {
                                    range: {
                                        start: { line: 0, character: 0 },
                                        end: { line: 0, character: 3 },
                                    },
                                    newText: 'def',
                                },
                                {
                                    range: {
                                        start: { line: 1, character: 0 },
                                        end: { line: 1, character: 3 },
                                    },
                                    newText: 'ghi',
                                },
                            ],
                        }],
                },
            });
            chai_1.expect(result.applied).to.equal(true);
            chai_1.expect(editor.getText()).to.equal('def\nghi\n');
            // Undo should be atomic.
            editor.getBuffer().undo();
            chai_1.expect(editor.getText()).to.equal('abc\ndef\n');
        }));
        it('opens files that are not already open', () => __awaiter(this, void 0, void 0, function* () {
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [TEST_PATH2]: [
                            {
                                range: {
                                    start: { line: 0, character: 0 },
                                    end: { line: 0, character: 0 },
                                },
                                newText: 'abc',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(true);
            const editor = yield atom.workspace.open(TEST_PATH2);
            chai_1.expect(editor.getText()).to.equal('abc');
        }));
        it('fails with overlapping edits', () => __awaiter(this, void 0, void 0, function* () {
            const editor = yield atom.workspace.open(TEST_PATH3);
            editor.setText('abcdef\n');
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [TEST_PATH3]: [
                            {
                                range: {
                                    start: { line: 0, character: 0 },
                                    end: { line: 0, character: 3 },
                                },
                                newText: 'def',
                            },
                            {
                                range: {
                                    start: { line: 0, character: 2 },
                                    end: { line: 0, character: 4 },
                                },
                                newText: 'ghi',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(false);
            chai_1.expect(atom.notifications.addError.calledWith('workspace/applyEdits failed', {
                description: 'Failed to apply edits.',
                detail: `Found overlapping edit ranges in ${TEST_PATH3}`,
            })).to.equal(true);
            // No changes.
            chai_1.expect(editor.getText()).to.equal('abcdef\n');
        }));
        it('fails with out-of-range edits', () => __awaiter(this, void 0, void 0, function* () {
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [TEST_PATH4]: [
                            {
                                range: {
                                    start: { line: 0, character: 1 },
                                    end: { line: 0, character: 2 },
                                },
                                newText: 'def',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(false);
            const errorCalls = atom.notifications.addError.getCalls();
            chai_1.expect(errorCalls.length).to.equal(1);
            chai_1.expect(errorCalls[0].args[1].detail).to.equal(`Out of range edit on ${TEST_PATH4}:1:2`);
        }));
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi90ZXN0L2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlci50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSwrQkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiw4RUFBcUU7QUFDckUsK0NBQXdDO0FBR3hDLE1BQU0sVUFBVSxHQUFHLHdCQUF3QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDOUUsTUFBTSxVQUFVLEdBQUcsd0JBQXdCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUMvRSxNQUFNLFVBQVUsR0FBRyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQy9FLE1BQU0sVUFBVSxHQUFHLHdCQUF3QixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFFL0UsU0FBUyx3QkFBd0IsQ0FBQyxRQUFnQjtJQUNoRCxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO1FBQ2hDLE9BQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsV0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7S0FDMUY7U0FBTTtRQUNMLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO0FBQ0gsQ0FBQztBQUVELFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7SUFDaEMsUUFBUSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7UUFDM0IsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLEtBQUss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QUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLHdCQUF3QixVQUFVLE1BQU0sQ0FBQyxDQUFDO1FBQzFGLENBQUMsQ0FBQSxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnY2hhaSc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIHNpbm9uIGZyb20gJ3Npbm9uJztcclxuaW1wb3J0IEFwcGx5RWRpdEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlcic7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uLy4uL2xpYi9jb252ZXJ0JztcclxuaW1wb3J0IHsgVGV4dEVkaXRvciB9IGZyb20gJ2F0b20nO1xyXG5cclxuY29uc3QgVEVTVF9QQVRIMSA9IG5vcm1hbGl6ZURyaXZlTGV0dGVyTmFtZShwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC50eHQnKSk7XHJcbmNvbnN0IFRFU1RfUEFUSDIgPSBub3JtYWxpemVEcml2ZUxldHRlck5hbWUocGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3QyLnR4dCcpKTtcclxuY29uc3QgVEVTVF9QQVRIMyA9IG5vcm1hbGl6ZURyaXZlTGV0dGVyTmFtZShwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdDMudHh0JykpO1xyXG5jb25zdCBURVNUX1BBVEg0ID0gbm9ybWFsaXplRHJpdmVMZXR0ZXJOYW1lKHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0NC50eHQnKSk7XHJcblxyXG5mdW5jdGlvbiBub3JtYWxpemVEcml2ZUxldHRlck5hbWUoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcclxuICAgIHJldHVybiBmaWxlUGF0aC5yZXBsYWNlKC9eKFthLXpdKTovLCAoW2RyaXZlTGV0dGVyXSkgPT4gZHJpdmVMZXR0ZXIudG9VcHBlckNhc2UoKSArICc6Jyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBmaWxlUGF0aDtcclxuICB9XHJcbn1cclxuXHJcbmRlc2NyaWJlKCdBcHBseUVkaXRBZGFwdGVyJywgKCkgPT4ge1xyXG4gIGRlc2NyaWJlKCdvbkFwcGx5RWRpdCcsICgpID0+IHtcclxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgICBzaW5vbi5zcHkoYXRvbS5ub3RpZmljYXRpb25zLCAnYWRkRXJyb3InKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XHJcbiAgICAgIChhdG9tIGFzIGFueSkubm90aWZpY2F0aW9ucy5hZGRFcnJvci5yZXN0b3JlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnd29ya3MgZm9yIG9wZW4gZmlsZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oVEVTVF9QQVRIMSkgYXMgVGV4dEVkaXRvcjtcclxuICAgICAgZWRpdG9yLnNldFRleHQoJ2FiY1xcbmRlZlxcbicpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XHJcbiAgICAgICAgZWRpdDoge1xyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICBbQ29udmVydC5wYXRoVG9VcmkoVEVTVF9QQVRIMSldOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDN9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdkZWYnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAxLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAxLCBjaGFyYWN0ZXI6IDN9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdnaGknLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkKS50by5lcXVhbCh0cnVlKTtcclxuICAgICAgZXhwZWN0KGVkaXRvci5nZXRUZXh0KCkpLnRvLmVxdWFsKCdkZWZcXG5naGlcXG4nKTtcclxuXHJcbiAgICAgIC8vIFVuZG8gc2hvdWxkIGJlIGF0b21pYy5cclxuICAgICAgZWRpdG9yLmdldEJ1ZmZlcigpLnVuZG8oKTtcclxuICAgICAgZXhwZWN0KGVkaXRvci5nZXRUZXh0KCkpLnRvLmVxdWFsKCdhYmNcXG5kZWZcXG4nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCd3b3JrcyB3aXRoIFRleHREb2N1bWVudEVkaXRzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBhdG9tLndvcmtzcGFjZS5vcGVuKFRFU1RfUEFUSDEpIGFzIFRleHRFZGl0b3I7XHJcbiAgICAgIGVkaXRvci5zZXRUZXh0KCdhYmNcXG5kZWZcXG4nKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQoe1xyXG4gICAgICAgIGVkaXQ6IHtcclxuICAgICAgICAgIGRvY3VtZW50Q2hhbmdlczogW3tcclxuICAgICAgICAgICAgdGV4dERvY3VtZW50OiB7XHJcbiAgICAgICAgICAgICAgdmVyc2lvbjogMSxcclxuICAgICAgICAgICAgICB1cmk6IENvbnZlcnQucGF0aFRvVXJpKFRFU1RfUEFUSDEpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlZGl0czogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMCwgY2hhcmFjdGVyOiAzfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMSwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMSwgY2hhcmFjdGVyOiAzfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZ2hpJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgfV0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKHRydWUpO1xyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2RlZlxcbmdoaVxcbicpO1xyXG5cclxuICAgICAgLy8gVW5kbyBzaG91bGQgYmUgYXRvbWljLlxyXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkudW5kbygpO1xyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2FiY1xcbmRlZlxcbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ29wZW5zIGZpbGVzIHRoYXQgYXJlIG5vdCBhbHJlYWR5IG9wZW4nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQoe1xyXG4gICAgICAgIGVkaXQ6IHtcclxuICAgICAgICAgIGNoYW5nZXM6IHtcclxuICAgICAgICAgICAgW1RFU1RfUEFUSDJdOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdhYmMnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkKS50by5lcXVhbCh0cnVlKTtcclxuICAgICAgY29uc3QgZWRpdG9yID0gYXdhaXQgYXRvbS53b3Jrc3BhY2Uub3BlbihURVNUX1BBVEgyKSBhcyBUZXh0RWRpdG9yO1xyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2FiYycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2ZhaWxzIHdpdGggb3ZlcmxhcHBpbmcgZWRpdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oVEVTVF9QQVRIMykgYXMgVGV4dEVkaXRvcjtcclxuICAgICAgZWRpdG9yLnNldFRleHQoJ2FiY2RlZlxcbicpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XHJcbiAgICAgICAgZWRpdDoge1xyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICBbVEVTVF9QQVRIM106IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogM30sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2RlZicsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogNH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2doaScsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKGZhbHNlKTtcclxuICAgICAgZXhwZWN0KFxyXG4gICAgICAgIChhdG9tIGFzIGFueSkubm90aWZpY2F0aW9ucy5hZGRFcnJvci5jYWxsZWRXaXRoKCd3b3Jrc3BhY2UvYXBwbHlFZGl0cyBmYWlsZWQnLCB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhaWxlZCB0byBhcHBseSBlZGl0cy4nLFxyXG4gICAgICAgICAgZGV0YWlsOiBgRm91bmQgb3ZlcmxhcHBpbmcgZWRpdCByYW5nZXMgaW4gJHtURVNUX1BBVEgzfWAsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICkudG8uZXF1YWwodHJ1ZSk7XHJcbiAgICAgIC8vIE5vIGNoYW5nZXMuXHJcbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnYWJjZGVmXFxuJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZmFpbHMgd2l0aCBvdXQtb2YtcmFuZ2UgZWRpdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQoe1xyXG4gICAgICAgIGVkaXQ6IHtcclxuICAgICAgICAgIGNoYW5nZXM6IHtcclxuICAgICAgICAgICAgW1RFU1RfUEFUSDRdOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDF9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDJ9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdkZWYnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkKS50by5lcXVhbChmYWxzZSk7XHJcbiAgICAgIGNvbnN0IGVycm9yQ2FsbHMgPSAoYXRvbSBhcyBhbnkpLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IuZ2V0Q2FsbHMoKTtcclxuICAgICAgZXhwZWN0KGVycm9yQ2FsbHMubGVuZ3RoKS50by5lcXVhbCgxKTtcclxuICAgICAgZXhwZWN0KGVycm9yQ2FsbHNbMF0uYXJnc1sxXS5kZXRhaWwpLnRvLmVxdWFsKGBPdXQgb2YgcmFuZ2UgZWRpdCBvbiAke1RFU1RfUEFUSDR9OjE6MmApO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXX0=