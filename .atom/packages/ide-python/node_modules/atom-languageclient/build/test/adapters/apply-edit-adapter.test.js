var _chai = require('chai');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _applyEditAdapter = require('../../lib/adapters/apply-edit-adapter');

var _applyEditAdapter2 = _interopRequireDefault(_applyEditAdapter);

var _convert = require('../../lib/convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const TEST_PATH1 = _path2.default.join(__dirname, 'test.txt');
const TEST_PATH2 = _path2.default.join(__dirname, 'test2.txt');
const TEST_PATH3 = _path2.default.join(__dirname, 'test3.txt');
const TEST_PATH4 = _path2.default.join(__dirname, 'test4.txt');

describe('ApplyEditAdapter', () => {
  describe('onApplyEdit', () => {
    beforeEach(() => {
      _sinon2.default.spy(atom.notifications, 'addError');
    });

    afterEach(() => {
      atom.notifications.addError.restore();
    });

    it('works for open files', _asyncToGenerator(function* () {
      const editor = yield atom.workspace.open(TEST_PATH1);
      editor.setText('abc\ndef\n');

      const result = yield _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [_convert2.default.pathToUri(TEST_PATH1)]: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 3 }
              },
              newText: 'def'
            }, {
              range: {
                start: { line: 1, character: 0 },
                end: { line: 1, character: 3 }
              },
              newText: 'ghi'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(true);
      (0, _chai.expect)(editor.getText()).to.equal('def\nghi\n');

      // Undo should be atomic.
      editor.getBuffer().undo();
      (0, _chai.expect)(editor.getText()).to.equal('abc\ndef\n');
    }));

    it('opens files that are not already open', _asyncToGenerator(function* () {
      const result = yield _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [TEST_PATH2]: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 0 }
              },
              newText: 'abc'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(true);
      const editor = yield atom.workspace.open(TEST_PATH2);
      (0, _chai.expect)(editor.getText()).to.equal('abc');
    }));

    it('fails with overlapping edits', _asyncToGenerator(function* () {
      const editor = yield atom.workspace.open(TEST_PATH3);
      editor.setText('abcdef\n');

      const result = yield _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [TEST_PATH3]: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 3 }
              },
              newText: 'def'
            }, {
              range: {
                start: { line: 0, character: 2 },
                end: { line: 0, character: 4 }
              },
              newText: 'ghi'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(false);
      (0, _chai.expect)(atom.notifications.addError.calledWith('workspace/applyEdits failed', {
        description: 'Failed to apply edits.',
        detail: `Found overlapping edit ranges in ${TEST_PATH3}`
      })).to.equal(true);
      // No changes.
      (0, _chai.expect)(editor.getText()).to.equal('abcdef\n');
    }));

    it('fails with out-of-range edits', _asyncToGenerator(function* () {
      const result = yield _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [TEST_PATH4]: [{
              range: {
                start: { line: 0, character: 1 },
                end: { line: 0, character: 2 }
              },
              newText: 'def'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(false);
      const errorCalls = atom.notifications.addError.getCalls();
      (0, _chai.expect)(errorCalls.length).to.equal(1);
      (0, _chai.expect)(errorCalls[0].args[1].detail).to.equal(`Out of range edit on ${TEST_PATH4}:1:2`);
    }));
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvYXBwbHktZWRpdC1hZGFwdGVyLnRlc3QuanMiXSwibmFtZXMiOlsiVEVTVF9QQVRIMSIsImpvaW4iLCJfX2Rpcm5hbWUiLCJURVNUX1BBVEgyIiwiVEVTVF9QQVRIMyIsIlRFU1RfUEFUSDQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJzcHkiLCJhdG9tIiwibm90aWZpY2F0aW9ucyIsImFmdGVyRWFjaCIsImFkZEVycm9yIiwicmVzdG9yZSIsIml0IiwiZWRpdG9yIiwid29ya3NwYWNlIiwib3BlbiIsInNldFRleHQiLCJyZXN1bHQiLCJvbkFwcGx5RWRpdCIsImVkaXQiLCJjaGFuZ2VzIiwicGF0aFRvVXJpIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJlbmQiLCJuZXdUZXh0IiwiYXBwbGllZCIsInRvIiwiZXF1YWwiLCJnZXRUZXh0IiwiZ2V0QnVmZmVyIiwidW5kbyIsImNhbGxlZFdpdGgiLCJkZXNjcmlwdGlvbiIsImRldGFpbCIsImVycm9yQ2FsbHMiLCJnZXRDYWxscyIsImxlbmd0aCIsImFyZ3MiXSwibWFwcGluZ3MiOiJBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBLE1BQU1BLGFBQWEsZUFBS0MsSUFBTCxDQUFVQyxTQUFWLEVBQXFCLFVBQXJCLENBQW5CO0FBQ0EsTUFBTUMsYUFBYSxlQUFLRixJQUFMLENBQVVDLFNBQVYsRUFBcUIsV0FBckIsQ0FBbkI7QUFDQSxNQUFNRSxhQUFhLGVBQUtILElBQUwsQ0FBVUMsU0FBVixFQUFxQixXQUFyQixDQUFuQjtBQUNBLE1BQU1HLGFBQWEsZUFBS0osSUFBTCxDQUFVQyxTQUFWLEVBQXFCLFdBQXJCLENBQW5COztBQUVBSSxTQUFTLGtCQUFULEVBQTZCLE1BQU07QUFDakNBLFdBQVMsYUFBVCxFQUF3QixNQUFNO0FBQzVCQyxlQUFXLE1BQU07QUFDZixzQkFBTUMsR0FBTixDQUFVQyxLQUFLQyxh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QyxLQUE3QixDQUFtQyxDQUFuQztBQUNBLHdCQUFPTyxXQUFXLENBQVgsRUFBY0csSUFBZCxDQUFtQixDQUFuQixFQUFzQkosTUFBN0IsRUFBcUNQLEVBQXJDLENBQXdDQyxLQUF4QyxDQUErQyx3QkFBdUIzQixVQUFXLE1BQWpGO0FBQ0QsS0FyQkQ7QUFzQkQsR0E5SEQ7QUErSEQsQ0FoSUQiLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLnRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtleHBlY3R9IGZyb20gJ2NoYWknO1xyXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcclxuaW1wb3J0IHNpbm9uIGZyb20gJ3Npbm9uJztcclxuaW1wb3J0IEFwcGx5RWRpdEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlcic7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uLy4uL2xpYi9jb252ZXJ0JztcclxuXHJcbmNvbnN0IFRFU1RfUEFUSDEgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC50eHQnKTtcclxuY29uc3QgVEVTVF9QQVRIMiA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0Mi50eHQnKTtcclxuY29uc3QgVEVTVF9QQVRIMyA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0My50eHQnKTtcclxuY29uc3QgVEVTVF9QQVRINCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0NC50eHQnKTtcclxuXHJcbmRlc2NyaWJlKCdBcHBseUVkaXRBZGFwdGVyJywgKCkgPT4ge1xyXG4gIGRlc2NyaWJlKCdvbkFwcGx5RWRpdCcsICgpID0+IHtcclxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgICBzaW5vbi5zcHkoYXRvbS5ub3RpZmljYXRpb25zLCAnYWRkRXJyb3InKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XHJcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvci5yZXN0b3JlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnd29ya3MgZm9yIG9wZW4gZmlsZXMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oVEVTVF9QQVRIMSk7XHJcbiAgICAgIGVkaXRvci5zZXRUZXh0KCdhYmNcXG5kZWZcXG4nKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQoe1xyXG4gICAgICAgIGVkaXQ6IHtcclxuICAgICAgICAgIGNoYW5nZXM6IHtcclxuICAgICAgICAgICAgW0NvbnZlcnQucGF0aFRvVXJpKFRFU1RfUEFUSDEpXTogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMCwgY2hhcmFjdGVyOiAzfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMSwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMSwgY2hhcmFjdGVyOiAzfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZ2hpJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZCkudG8uZXF1YWwodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnZGVmXFxuZ2hpXFxuJyk7XHJcblxyXG4gICAgICAvLyBVbmRvIHNob3VsZCBiZSBhdG9taWMuXHJcbiAgICAgIGVkaXRvci5nZXRCdWZmZXIoKS51bmRvKCk7XHJcbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnYWJjXFxuZGVmXFxuJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnb3BlbnMgZmlsZXMgdGhhdCBhcmUgbm90IGFscmVhZHkgb3BlbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XHJcbiAgICAgICAgZWRpdDoge1xyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICBbVEVTVF9QQVRIMl06IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2FiYycsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKHRydWUpO1xyXG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBhdG9tLndvcmtzcGFjZS5vcGVuKFRFU1RfUEFUSDIpO1xyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2FiYycpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2ZhaWxzIHdpdGggb3ZlcmxhcHBpbmcgZWRpdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oVEVTVF9QQVRIMyk7XHJcbiAgICAgIGVkaXRvci5zZXRUZXh0KCdhYmNkZWZcXG4nKTtcclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IEFwcGx5RWRpdEFkYXB0ZXIub25BcHBseUVkaXQoe1xyXG4gICAgICAgIGVkaXQ6IHtcclxuICAgICAgICAgIGNoYW5nZXM6IHtcclxuICAgICAgICAgICAgW1RFU1RfUEFUSDNdOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDN9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdkZWYnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDJ9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDR9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdnaGknLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkKS50by5lcXVhbChmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChcclxuICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IuY2FsbGVkV2l0aCgnd29ya3NwYWNlL2FwcGx5RWRpdHMgZmFpbGVkJywge1xyXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdGYWlsZWQgdG8gYXBwbHkgZWRpdHMuJyxcclxuICAgICAgICAgIGRldGFpbDogYEZvdW5kIG92ZXJsYXBwaW5nIGVkaXQgcmFuZ2VzIGluICR7VEVTVF9QQVRIM31gLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICApLnRvLmVxdWFsKHRydWUpO1xyXG4gICAgICAvLyBObyBjaGFuZ2VzLlxyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2FiY2RlZlxcbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2ZhaWxzIHdpdGggb3V0LW9mLXJhbmdlIGVkaXRzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KHtcclxuICAgICAgICBlZGl0OiB7XHJcbiAgICAgICAgICBjaGFuZ2VzOiB7XHJcbiAgICAgICAgICAgIFtURVNUX1BBVEg0XTogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAxfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMCwgY2hhcmFjdGVyOiAyfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZCkudG8uZXF1YWwoZmFsc2UpO1xyXG4gICAgICBjb25zdCBlcnJvckNhbGxzID0gYXRvbS5ub3RpZmljYXRpb25zLmFkZEVycm9yLmdldENhbGxzKCk7XHJcbiAgICAgIGV4cGVjdChlcnJvckNhbGxzLmxlbmd0aCkudG8uZXF1YWwoMSk7XHJcbiAgICAgIGV4cGVjdChlcnJvckNhbGxzWzBdLmFyZ3NbMV0uZGV0YWlsKS50by5lcXVhbChgT3V0IG9mIHJhbmdlIGVkaXQgb24gJHtURVNUX1BBVEg0fToxOjJgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl19