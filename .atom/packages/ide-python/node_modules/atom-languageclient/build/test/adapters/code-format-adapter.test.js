var _atom = require('atom');

var _chai = require('chai');

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _convert = require('../../lib/convert');

var _convert2 = _interopRequireDefault(_convert);

var _languageclient = require('../../lib/languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _codeFormatAdapter = require('../../lib/adapters/code-format-adapter');

var _codeFormatAdapter2 = _interopRequireDefault(_codeFormatAdapter);

var _helpers = require('../helpers.js');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

describe('CodeFormatAdapter', () => {
  let fakeEditor;
  let connection;
  let range;

  beforeEach(() => {
    connection = new ls.LanguageClientConnection((0, _helpers.createSpyConnection)());
    fakeEditor = (0, _helpers.createFakeEditor)();
    range = new _atom.Range([0, 0], [100, 100]);
  });

  describe('canAdapt', () => {
    it('returns true if range formatting is supported', () => {
      const result = _codeFormatAdapter2.default.canAdapt({
        documentRangeFormattingProvider: true
      });
      (0, _chai.expect)(result).to.be.true;
    });

    it('returns true if document formatting is supported', () => {
      const result = _codeFormatAdapter2.default.canAdapt({
        documentFormattingProvider: true
      });
      (0, _chai.expect)(result).to.be.true;
    });

    it('returns false it no formatting supported', () => {
      const result = _codeFormatAdapter2.default.canAdapt({});
      (0, _chai.expect)(result).to.be.false;
    });
  });

  describe('format', () => {
    it('prefers range formatting if available', () => {
      const rangeStub = _sinon2.default.spy(connection, 'documentRangeFormatting');
      const docStub = _sinon2.default.spy(connection, 'documentFormatting');
      _codeFormatAdapter2.default.format(connection, {
        documentRangeFormattingProvider: true,
        documentFormattingProvider: true
      }, fakeEditor, range);
      (0, _chai.expect)(rangeStub.called).to.be.true;
      (0, _chai.expect)(docStub.called).to.be.false;
    });

    it('falls back to document formatting if range formatting not available', () => {
      const rangeStub = _sinon2.default.spy(connection, 'documentRangeFormatting');
      const docStub = _sinon2.default.spy(connection, 'documentFormatting');
      _codeFormatAdapter2.default.format(connection, { documentFormattingProvider: true }, fakeEditor, range);
      (0, _chai.expect)(rangeStub.called).to.be.false;
      (0, _chai.expect)(docStub.called).to.be.true;
    });

    it('throws if neither range or document formatting are supported', () => {
      (0, _chai.expect)(() => _codeFormatAdapter2.default.format(connection, {}, fakeEditor, range)).to.throw('');
    });
  });

  describe('formatDocument', () => {
    it('converts the results from the connection', _asyncToGenerator(function* () {
      _sinon2.default.stub(connection, 'documentFormatting').resolves([{
        range: {
          start: { line: 0, character: 1 },
          end: { line: 0, character: 2 }
        },
        newText: 'abc'
      }, {
        range: {
          start: { line: 5, character: 10 },
          end: { line: 15, character: 20 }
        },
        newText: 'def'
      }]);
      const actual = yield _codeFormatAdapter2.default.formatDocument(connection, fakeEditor);
      (0, _chai.expect)(actual.length).to.equal(2);
      (0, _chai.expect)(actual[0].newText).to.equal('abc');
      (0, _chai.expect)(actual[1].oldRange.start.row).to.equal(5);
      (0, _chai.expect)(actual[1].oldRange.start.column).to.equal(10);
      (0, _chai.expect)(actual[1].oldRange.end.row).to.equal(15);
      (0, _chai.expect)(actual[1].oldRange.end.column).to.equal(20);
      (0, _chai.expect)(actual[1].newText).to.equal('def');
    }));
  });

  describe('createDocumentFormattingParams', () => {
    it('returns the tab size from the editor', () => {
      _sinon2.default.stub(fakeEditor, 'getPath').returns('/a/b/c/d.txt');
      _sinon2.default.stub(fakeEditor, 'getTabLength').returns(1);
      _sinon2.default.stub(fakeEditor, 'getSoftTabs').returns(false);

      const actual = _codeFormatAdapter2.default.createDocumentFormattingParams(fakeEditor);

      (0, _chai.expect)(actual.textDocument).to.eql({ uri: 'file:///a/b/c/d.txt' });
      (0, _chai.expect)(actual.options.tabSize).to.equal(1);
      (0, _chai.expect)(actual.options.insertSpaces).to.equal(false);
    });
  });

  describe('formatRange', () => {
    it('converts the results from the connection', _asyncToGenerator(function* () {
      _sinon2.default.stub(connection, 'documentRangeFormatting').resolves([{
        range: {
          start: { line: 0, character: 1 },
          end: { line: 0, character: 2 }
        },
        newText: 'abc'
      }, {
        range: {
          start: { line: 5, character: 10 },
          end: { line: 15, character: 20 }
        },
        newText: 'def'
      }]);
      const actual = yield _codeFormatAdapter2.default.formatRange(connection, fakeEditor, new _atom.Range([0, 0], [1, 1]));
      (0, _chai.expect)(actual.length).to.equal(2);
      (0, _chai.expect)(actual[0].newText).to.equal('abc');
      (0, _chai.expect)(actual[1].oldRange.start.row).to.equal(5);
      (0, _chai.expect)(actual[1].oldRange.start.column).to.equal(10);
      (0, _chai.expect)(actual[1].oldRange.end.row).to.equal(15);
      (0, _chai.expect)(actual[1].oldRange.end.column).to.equal(20);
      (0, _chai.expect)(actual[1].newText).to.equal('def');
    }));
  });

  describe('createDocumentRangeFormattingParams', () => {
    it('returns the tab size from the editor', () => {
      _sinon2.default.stub(fakeEditor, 'getPath').returns('/a/b/c/d.txt');
      _sinon2.default.stub(fakeEditor, 'getTabLength').returns(1);
      _sinon2.default.stub(fakeEditor, 'getSoftTabs').returns(false);

      const actual = _codeFormatAdapter2.default.createDocumentRangeFormattingParams(fakeEditor, new _atom.Range([1, 0], [2, 3]));

      (0, _chai.expect)(actual.textDocument).to.eql({ uri: 'file:///a/b/c/d.txt' });
      (0, _chai.expect)(actual.range).to.eql({
        start: { line: 1, character: 0 },
        end: { line: 2, character: 3 }
      });
      (0, _chai.expect)(actual.options.tabSize).to.equal(1);
      (0, _chai.expect)(actual.options.insertSpaces).to.equal(false);
    });
  });

  describe('getFormatOptions', () => {
    it('returns the tab size from the editor', () => {
      _sinon2.default.stub(fakeEditor, 'getTabLength').returns(17);
      const options = _codeFormatAdapter2.default.getFormatOptions(fakeEditor);
      (0, _chai.expect)(options.tabSize).to.equal(17);
    });

    it('returns the soft tab setting from the editor', () => {
      _sinon2.default.stub(fakeEditor, 'getSoftTabs').returns(true);
      const options = _codeFormatAdapter2.default.getFormatOptions(fakeEditor);
      (0, _chai.expect)(options.insertSpaces).to.be.true;
    });
  });

  describe('convertLsTextEdit', () => {
    it('returns oldRange and newText from a textEdit', () => {
      const textEdit = {
        range: {
          start: { line: 1, character: 0 },
          end: { line: 2, character: 3 }
        },
        newText: 'abc-def'
      };
      const actual = _convert2.default.convertLsTextEdit(textEdit);
      (0, _chai.expect)(actual.oldRange).to.eql(new _atom.Range([1, 0], [2, 3]));
      (0, _chai.expect)(actual.newText).to.equal('abc-def');
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvY29kZS1mb3JtYXQtYWRhcHRlci50ZXN0LmpzIl0sIm5hbWVzIjpbImxzIiwiZGVzY3JpYmUiLCJmYWtlRWRpdG9yIiwiY29ubmVjdGlvbiIsInJhbmdlIiwiYmVmb3JlRWFjaCIsIkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiIsIml0IiwicmVzdWx0IiwiY2FuQWRhcHQiLCJkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyIiwidG8iLCJiZSIsInRydWUiLCJkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciIsImZhbHNlIiwicmFuZ2VTdHViIiwic3B5IiwiZG9jU3R1YiIsImZvcm1hdCIsImNhbGxlZCIsInRocm93Iiwic3R1YiIsInJlc29sdmVzIiwic3RhcnQiLCJsaW5lIiwiY2hhcmFjdGVyIiwiZW5kIiwibmV3VGV4dCIsImFjdHVhbCIsImZvcm1hdERvY3VtZW50IiwibGVuZ3RoIiwiZXF1YWwiLCJvbGRSYW5nZSIsInJvdyIsImNvbHVtbiIsInJldHVybnMiLCJjcmVhdGVEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMiLCJ0ZXh0RG9jdW1lbnQiLCJlcWwiLCJ1cmkiLCJvcHRpb25zIiwidGFiU2l6ZSIsImluc2VydFNwYWNlcyIsImZvcm1hdFJhbmdlIiwiY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMiLCJnZXRGb3JtYXRPcHRpb25zIiwidGV4dEVkaXQiLCJjb252ZXJ0THNUZXh0RWRpdCJdLCJtYXBwaW5ncyI6IkFBRUE7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztJQUFZQSxFOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7O0FBRUFDLFNBQVMsbUJBQVQsRUFBOEIsTUFBTTtBQUNsQyxNQUFJQyxVQUFKO0FBQ0EsTUFBSUMsVUFBSjtBQUNBLE1BQUlDLEtBQUo7O0FBRUFDLGFBQVcsTUFBTTtBQUNmRixpQkFBYSxJQUFJSCxHQUFHTSx3QkFBUCxDQUFnQyxtQ0FBaEMsQ0FBYjtB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NEJBQWtCSyxnQkFBbEIsQ0FBbUM1QyxVQUFuQyxDQUFoQjtBQUNBLHdCQUFPdUMsUUFBUUMsT0FBZixFQUF3Qi9CLEVBQXhCLENBQTJCcUIsS0FBM0IsQ0FBaUMsRUFBakM7QUFDRCxLQUpEOztBQU1BekIsT0FBRyw4Q0FBSCxFQUFtRCxNQUFNO0FBQ3ZELHNCQUFNZSxJQUFOLENBQVdwQixVQUFYLEVBQXVCLGFBQXZCLEVBQXNDa0MsT0FBdEMsQ0FBOEMsSUFBOUM7QUFDQSxZQUFNSyxVQUFVLDRCQUFrQkssZ0JBQWxCLENBQW1DNUMsVUFBbkMsQ0FBaEI7QUFDQSx3QkFBT3VDLFFBQVFFLFlBQWYsRUFBNkJoQyxFQUE3QixDQUFnQ0MsRUFBaEMsQ0FBbUNDLElBQW5DO0FBQ0QsS0FKRDtBQUtELEdBWkQ7O0FBY0FaLFdBQVMsbUJBQVQsRUFBOEIsTUFBTTtBQUNsQ00sT0FBRyw4Q0FBSCxFQUFtRCxNQUFNO0FBQ3ZELFlBQU13QyxXQUFXO0FBQ2YzQyxlQUFPO0FBQ0xvQixpQkFBTyxFQUFDQyxNQUFNLENBQVAsRUFBVUMsV0FBVyxDQUFyQixFQURGO0FBRUxDLGVBQUssRUFBQ0YsTUFBTSxDQUFQLEVBQVVDLFdBQVcsQ0FBckI7QUFGQSxTQURRO0FBS2ZFLGlCQUFTO0FBTE0sT0FBakI7QUFPQSxZQUFNQyxTQUFTLGtCQUFRbUIsaUJBQVIsQ0FBMEJELFFBQTFCLENBQWY7QUFDQSx3QkFBT2xCLE9BQU9JLFFBQWQsRUFBd0J0QixFQUF4QixDQUEyQjRCLEdBQTNCLENBQStCLGdCQUFVLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBVixFQUFrQixDQUFDLENBQUQsRUFBSSxDQUFKLENBQWxCLENBQS9CO0FBQ0Esd0JBQU9WLE9BQU9ELE9BQWQsRUFBdUJqQixFQUF2QixDQUEwQnFCLEtBQTFCLENBQWdDLFNBQWhDO0FBQ0QsS0FYRDtBQVlELEdBYkQ7QUFjRCxDQXBMRCIsImZpbGUiOiJjb2RlLWZvcm1hdC1hZGFwdGVyLnRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtSYW5nZX0gZnJvbSAnYXRvbSc7XHJcbmltcG9ydCB7ZXhwZWN0fSBmcm9tICdjaGFpJztcclxuaW1wb3J0IHNpbm9uIGZyb20gJ3Npbm9uJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vLi4vbGliL2NvbnZlcnQnO1xyXG5pbXBvcnQgKiBhcyBscyBmcm9tICcuLi8uLi9saWIvbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29kZUZvcm1hdEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL2NvZGUtZm9ybWF0LWFkYXB0ZXInO1xyXG5pbXBvcnQge2NyZWF0ZVNweUNvbm5lY3Rpb24sIGNyZWF0ZUZha2VFZGl0b3J9IGZyb20gJy4uL2hlbHBlcnMuanMnO1xyXG5cclxuZGVzY3JpYmUoJ0NvZGVGb3JtYXRBZGFwdGVyJywgKCkgPT4ge1xyXG4gIGxldCBmYWtlRWRpdG9yO1xyXG4gIGxldCBjb25uZWN0aW9uO1xyXG4gIGxldCByYW5nZTtcclxuXHJcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICBjb25uZWN0aW9uID0gbmV3IGxzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbihjcmVhdGVTcHlDb25uZWN0aW9uKCkpO1xyXG4gICAgZmFrZUVkaXRvciA9IGNyZWF0ZUZha2VFZGl0b3IoKTtcclxuICAgIHJhbmdlID0gbmV3IFJhbmdlKFswLCAwXSwgWzEwMCwgMTAwXSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdjYW5BZGFwdCcsICgpID0+IHtcclxuICAgIGl0KCdyZXR1cm5zIHRydWUgaWYgcmFuZ2UgZm9ybWF0dGluZyBpcyBzdXBwb3J0ZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IENvZGVGb3JtYXRBZGFwdGVyLmNhbkFkYXB0KHtcclxuICAgICAgICBkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyOiB0cnVlLFxyXG4gICAgICB9KTtcclxuICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUudHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdyZXR1cm5zIHRydWUgaWYgZG9jdW1lbnQgZm9ybWF0dGluZyBpcyBzdXBwb3J0ZWQnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IENvZGVGb3JtYXRBZGFwdGVyLmNhbkFkYXB0KHtcclxuICAgICAgICBkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcjogdHJ1ZSxcclxuICAgICAgfSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLnRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgncmV0dXJucyBmYWxzZSBpdCBubyBmb3JtYXR0aW5nIHN1cHBvcnRlZCcsICgpID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gQ29kZUZvcm1hdEFkYXB0ZXIuY2FuQWRhcHQoe30pO1xyXG4gICAgICBleHBlY3QocmVzdWx0KS50by5iZS5mYWxzZTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnZm9ybWF0JywgKCkgPT4ge1xyXG4gICAgaXQoJ3ByZWZlcnMgcmFuZ2UgZm9ybWF0dGluZyBpZiBhdmFpbGFibGUnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJhbmdlU3R1YiA9IHNpbm9uLnNweShjb25uZWN0aW9uLCAnZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmcnKTtcclxuICAgICAgY29uc3QgZG9jU3R1YiA9IHNpbm9uLnNweShjb25uZWN0aW9uLCAnZG9jdW1lbnRGb3JtYXR0aW5nJyk7XHJcbiAgICAgIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdChcclxuICAgICAgICBjb25uZWN0aW9uLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXI6IHRydWUsXHJcbiAgICAgICAgICBkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcjogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZha2VFZGl0b3IsXHJcbiAgICAgICAgcmFuZ2UsXHJcbiAgICAgICk7XHJcbiAgICAgIGV4cGVjdChyYW5nZVN0dWIuY2FsbGVkKS50by5iZS50cnVlO1xyXG4gICAgICBleHBlY3QoZG9jU3R1Yi5jYWxsZWQpLnRvLmJlLmZhbHNlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ2ZhbGxzIGJhY2sgdG8gZG9jdW1lbnQgZm9ybWF0dGluZyBpZiByYW5nZSBmb3JtYXR0aW5nIG5vdCBhdmFpbGFibGUnLCAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJhbmdlU3R1YiA9IHNpbm9uLnNweShjb25uZWN0aW9uLCAnZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmcnKTtcclxuICAgICAgY29uc3QgZG9jU3R1YiA9IHNpbm9uLnNweShjb25uZWN0aW9uLCAnZG9jdW1lbnRGb3JtYXR0aW5nJyk7XHJcbiAgICAgIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdChjb25uZWN0aW9uLCB7ZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXI6IHRydWV9LCBmYWtlRWRpdG9yLCByYW5nZSk7XHJcbiAgICAgIGV4cGVjdChyYW5nZVN0dWIuY2FsbGVkKS50by5iZS5mYWxzZTtcclxuICAgICAgZXhwZWN0KGRvY1N0dWIuY2FsbGVkKS50by5iZS50cnVlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Rocm93cyBpZiBuZWl0aGVyIHJhbmdlIG9yIGRvY3VtZW50IGZvcm1hdHRpbmcgYXJlIHN1cHBvcnRlZCcsICgpID0+IHtcclxuICAgICAgZXhwZWN0KCgpID0+IENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdChjb25uZWN0aW9uLCB7fSwgZmFrZUVkaXRvciwgcmFuZ2UpKS50by50aHJvdygnJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2Zvcm1hdERvY3VtZW50JywgKCkgPT4ge1xyXG4gICAgaXQoJ2NvbnZlcnRzIHRoZSByZXN1bHRzIGZyb20gdGhlIGNvbm5lY3Rpb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIHNpbm9uLnN0dWIoY29ubmVjdGlvbiwgJ2RvY3VtZW50Rm9ybWF0dGluZycpLnJlc29sdmVzKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMX0sXHJcbiAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbmV3VGV4dDogJ2FiYycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICBzdGFydDoge2xpbmU6IDUsIGNoYXJhY3RlcjogMTB9LFxyXG4gICAgICAgICAgICBlbmQ6IHtsaW5lOiAxNSwgY2hhcmFjdGVyOiAyMH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbmV3VGV4dDogJ2RlZicsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSk7XHJcbiAgICAgIGNvbnN0IGFjdHVhbCA9IGF3YWl0IENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdERvY3VtZW50KGNvbm5lY3Rpb24sIGZha2VFZGl0b3IpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsLmxlbmd0aCkudG8uZXF1YWwoMik7XHJcbiAgICAgIGV4cGVjdChhY3R1YWxbMF0ubmV3VGV4dCkudG8uZXF1YWwoJ2FiYycpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsWzFdLm9sZFJhbmdlLnN0YXJ0LnJvdykudG8uZXF1YWwoNSk7XHJcbiAgICAgIGV4cGVjdChhY3R1YWxbMV0ub2xkUmFuZ2Uuc3RhcnQuY29sdW1uKS50by5lcXVhbCgxMCk7XHJcbiAgICAgIGV4cGVjdChhY3R1YWxbMV0ub2xkUmFuZ2UuZW5kLnJvdykudG8uZXF1YWwoMTUpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsWzFdLm9sZFJhbmdlLmVuZC5jb2x1bW4pLnRvLmVxdWFsKDIwKTtcclxuICAgICAgZXhwZWN0KGFjdHVhbFsxXS5uZXdUZXh0KS50by5lcXVhbCgnZGVmJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2NyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcycsICgpID0+IHtcclxuICAgIGl0KCdyZXR1cm5zIHRoZSB0YWIgc2l6ZSBmcm9tIHRoZSBlZGl0b3InLCAoKSA9PiB7XHJcbiAgICAgIHNpbm9uLnN0dWIoZmFrZUVkaXRvciwgJ2dldFBhdGgnKS5yZXR1cm5zKCcvYS9iL2MvZC50eHQnKTtcclxuICAgICAgc2lub24uc3R1YihmYWtlRWRpdG9yLCAnZ2V0VGFiTGVuZ3RoJykucmV0dXJucygxKTtcclxuICAgICAgc2lub24uc3R1YihmYWtlRWRpdG9yLCAnZ2V0U29mdFRhYnMnKS5yZXR1cm5zKGZhbHNlKTtcclxuXHJcbiAgICAgIGNvbnN0IGFjdHVhbCA9IENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyhmYWtlRWRpdG9yKTtcclxuXHJcbiAgICAgIGV4cGVjdChhY3R1YWwudGV4dERvY3VtZW50KS50by5lcWwoe3VyaTogJ2ZpbGU6Ly8vYS9iL2MvZC50eHQnfSk7XHJcbiAgICAgIGV4cGVjdChhY3R1YWwub3B0aW9ucy50YWJTaXplKS50by5lcXVhbCgxKTtcclxuICAgICAgZXhwZWN0KGFjdHVhbC5vcHRpb25zLmluc2VydFNwYWNlcykudG8uZXF1YWwoZmFsc2UpO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdmb3JtYXRSYW5nZScsICgpID0+IHtcclxuICAgIGl0KCdjb252ZXJ0cyB0aGUgcmVzdWx0cyBmcm9tIHRoZSBjb25uZWN0aW9uJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBzaW5vbi5zdHViKGNvbm5lY3Rpb24sICdkb2N1bWVudFJhbmdlRm9ybWF0dGluZycpLnJlc29sdmVzKFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMX0sXHJcbiAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbmV3VGV4dDogJ2FiYycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICBzdGFydDoge2xpbmU6IDUsIGNoYXJhY3RlcjogMTB9LFxyXG4gICAgICAgICAgICBlbmQ6IHtsaW5lOiAxNSwgY2hhcmFjdGVyOiAyMH0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbmV3VGV4dDogJ2RlZicsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSk7XHJcbiAgICAgIGNvbnN0IGFjdHVhbCA9IGF3YWl0IENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdFJhbmdlKGNvbm5lY3Rpb24sIGZha2VFZGl0b3IsIG5ldyBSYW5nZShbMCwgMF0sIFsxLCAxXSkpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsLmxlbmd0aCkudG8uZXF1YWwoMik7XHJcbiAgICAgIGV4cGVjdChhY3R1YWxbMF0ubmV3VGV4dCkudG8uZXF1YWwoJ2FiYycpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsWzFdLm9sZFJhbmdlLnN0YXJ0LnJvdykudG8uZXF1YWwoNSk7XHJcbiAgICAgIGV4cGVjdChhY3R1YWxbMV0ub2xkUmFuZ2Uuc3RhcnQuY29sdW1uKS50by5lcXVhbCgxMCk7XHJcbiAgICAgIGV4cGVjdChhY3R1YWxbMV0ub2xkUmFuZ2UuZW5kLnJvdykudG8uZXF1YWwoMTUpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsWzFdLm9sZFJhbmdlLmVuZC5jb2x1bW4pLnRvLmVxdWFsKDIwKTtcclxuICAgICAgZXhwZWN0KGFjdHVhbFsxXS5uZXdUZXh0KS50by5lcXVhbCgnZGVmJyk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2NyZWF0ZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zJywgKCkgPT4ge1xyXG4gICAgaXQoJ3JldHVybnMgdGhlIHRhYiBzaXplIGZyb20gdGhlIGVkaXRvcicsICgpID0+IHtcclxuICAgICAgc2lub24uc3R1YihmYWtlRWRpdG9yLCAnZ2V0UGF0aCcpLnJldHVybnMoJy9hL2IvYy9kLnR4dCcpO1xyXG4gICAgICBzaW5vbi5zdHViKGZha2VFZGl0b3IsICdnZXRUYWJMZW5ndGgnKS5yZXR1cm5zKDEpO1xyXG4gICAgICBzaW5vbi5zdHViKGZha2VFZGl0b3IsICdnZXRTb2Z0VGFicycpLnJldHVybnMoZmFsc2UpO1xyXG5cclxuICAgICAgY29uc3QgYWN0dWFsID0gQ29kZUZvcm1hdEFkYXB0ZXIuY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMoZmFrZUVkaXRvciwgbmV3IFJhbmdlKFsxLCAwXSwgWzIsIDNdKSk7XHJcblxyXG4gICAgICBleHBlY3QoYWN0dWFsLnRleHREb2N1bWVudCkudG8uZXFsKHt1cmk6ICdmaWxlOi8vL2EvYi9jL2QudHh0J30pO1xyXG4gICAgICBleHBlY3QoYWN0dWFsLnJhbmdlKS50by5lcWwoe1xyXG4gICAgICAgIHN0YXJ0OiB7bGluZTogMSwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICBlbmQ6IHtsaW5lOiAyLCBjaGFyYWN0ZXI6IDN9LFxyXG4gICAgICB9KTtcclxuICAgICAgZXhwZWN0KGFjdHVhbC5vcHRpb25zLnRhYlNpemUpLnRvLmVxdWFsKDEpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsLm9wdGlvbnMuaW5zZXJ0U3BhY2VzKS50by5lcXVhbChmYWxzZSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgZGVzY3JpYmUoJ2dldEZvcm1hdE9wdGlvbnMnLCAoKSA9PiB7XHJcbiAgICBpdCgncmV0dXJucyB0aGUgdGFiIHNpemUgZnJvbSB0aGUgZWRpdG9yJywgKCkgPT4ge1xyXG4gICAgICBzaW5vbi5zdHViKGZha2VFZGl0b3IsICdnZXRUYWJMZW5ndGgnKS5yZXR1cm5zKDE3KTtcclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZmFrZUVkaXRvcik7XHJcbiAgICAgIGV4cGVjdChvcHRpb25zLnRhYlNpemUpLnRvLmVxdWFsKDE3KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdyZXR1cm5zIHRoZSBzb2Z0IHRhYiBzZXR0aW5nIGZyb20gdGhlIGVkaXRvcicsICgpID0+IHtcclxuICAgICAgc2lub24uc3R1YihmYWtlRWRpdG9yLCAnZ2V0U29mdFRhYnMnKS5yZXR1cm5zKHRydWUpO1xyXG4gICAgICBjb25zdCBvcHRpb25zID0gQ29kZUZvcm1hdEFkYXB0ZXIuZ2V0Rm9ybWF0T3B0aW9ucyhmYWtlRWRpdG9yKTtcclxuICAgICAgZXhwZWN0KG9wdGlvbnMuaW5zZXJ0U3BhY2VzKS50by5iZS50cnVlO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcblxyXG4gIGRlc2NyaWJlKCdjb252ZXJ0THNUZXh0RWRpdCcsICgpID0+IHtcclxuICAgIGl0KCdyZXR1cm5zIG9sZFJhbmdlIGFuZCBuZXdUZXh0IGZyb20gYSB0ZXh0RWRpdCcsICgpID0+IHtcclxuICAgICAgY29uc3QgdGV4dEVkaXQgPSB7XHJcbiAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgIHN0YXJ0OiB7bGluZTogMSwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICAgIGVuZDoge2xpbmU6IDIsIGNoYXJhY3RlcjogM30sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXdUZXh0OiAnYWJjLWRlZicsXHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IGFjdHVhbCA9IENvbnZlcnQuY29udmVydExzVGV4dEVkaXQodGV4dEVkaXQpO1xyXG4gICAgICBleHBlY3QoYWN0dWFsLm9sZFJhbmdlKS50by5lcWwobmV3IFJhbmdlKFsxLCAwXSwgWzIsIDNdKSk7XHJcbiAgICAgIGV4cGVjdChhY3R1YWwubmV3VGV4dCkudG8uZXF1YWwoJ2FiYy1kZWYnKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59KTtcclxuIl19