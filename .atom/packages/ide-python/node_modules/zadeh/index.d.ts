import * as Binding from "./binding";
declare type stringWithLength1 = string;
export interface IOptions {
    /** @default false */
    allowErrors?: boolean;
    /** @default true */
    usePathScoring?: boolean;
    /** @default false */
    useExtensionBonus?: boolean;
    /**
     * A path separator which is a string with length 1. Such as "/" or "". By default, this is chosen based on the
     * operating system.
     */
    pathSeparator?: "/" | "\\" | stringWithLength1;
    /** @deprecated: there is no major benefit by precomputing something just for the query. */
    preparedQuery?: {};
}
export declare type StringArrayFilterOptions = IOptions & {
    /** The maximum numbers of results to return */
    maxResults?: number;
};
export declare type ObjectArrayFilterOptions = StringArrayFilterOptions;
export declare type TreeFilterOptions = StringArrayFilterOptions;
/** @deprecated The key to use when candidates is an object Deprecated option. */
export declare type DeprecatedFilterOptions<T extends StringOrObjectArray> = IOptions & {
    key?: T extends string ? never : keyof T;
};
/** An object that stores its `dataKey` in `DataKey` */
export declare type ObjectWithKey<DataKey extends string | number = string | number> = {
    [dk in DataKey]: string;
} & Record<string | number, string>;
export declare type StringOrObjectArray = string | ObjectWithKey;
/** StringArrayFilterer is a class that performs filtering on an array of strings */
export declare class StringArrayFilterer {
    obj: Binding.Zadeh;
    private candidates;
    /**
     * Make a `StringArrayFilterer` for the candidates that are going to be filtered.
     *
     * @param candidates An array of strings.
     */
    constructor(candidates?: Array<string>);
    /**
     * The method to set the candidates that are going to be filtered
     *
     * @param candidates An array of strings.
     */
    setCandidates(candidates: Array<string>): boolean;
    /**
     * Filter the already set array of strings
     *
     * @param query A string query to match each candidate against.
     * @param options Options
     * @returns Returns an array of candidates sorted by best match against the query.
     */
    filter(query: string, options?: StringArrayFilterOptions): Array<string>;
    /**
     * Filter the already set array of strings and get the indices of the chosen candidate
     *
     * @param query A string query to match each candidate against.
     * @param options Options
     * @returns Returns an array of numbers indicating the index of the chosen candidate sorted by best match against the query.
     */
    filterIndices(query: string, options?: StringArrayFilterOptions): Array<number>;
}
/**
 * ObjectArrayFilterer is a class that performs filtering on an array of objects based on a string stored in the given
 * `dataKey` for each object
 */
export declare class ObjectArrayFilterer<DataKey extends string | number = string> {
    obj: Binding.Zadeh;
    private candidates;
    /**
     * Make a `ObjectArrayFilterer` for the candidates that are going to be filtered.
     *
     * @param candidates An array of objects.
     * @param dataKey The key which is indexed for each object, and filtering is done based on the resulting string
     */
    constructor(candidates?: ObjectWithKey<DataKey>[], dataKey?: DataKey);
    /**
     * Allows to set the candidates (if changed or not set in the constructor).
     *
     * @param candidates An array of objects.
     * @param dataKey The key which is indexed for each object, and filtering is done based on the resulting string
     */
    setCandidates(candidates: ObjectWithKey<DataKey>[], dataKey: DataKey): void;
    /**
     * Filter the already set objects
     *
     * @param query A string query to match the dataKey of each candidate against.
     * @param options Options
     * @returns Returns an array of objects sorted by best match against the query.
     */
    filter(query: string, options?: ObjectArrayFilterOptions): ObjectWithKey<DataKey>[];
    /**
     * Filter the already set array of objects and get the indices of the chosen candidate
     *
     * @param query A string query to match the dataKey of each candidate against.
     * @param options Options
     * @returns Returns an array of numbers indicating the index of the chosen candidate sorted by best match against the query.
     */
    filterIndices(query: string, options?: StringArrayFilterOptions): Array<number>;
}
/** @deprecated */
declare type DeprecatedFilterReturn<T> = T extends string ? string[] : ObjectWithKey[];
/**
 * @deprecated Use `StringArrayFilterer` or `ObjectArrayFilterer` instead Sort and filter the given candidates by
 *   matching them against the given query.
 * @param candidates An array of strings or objects.
 * @param query A string query to match each candidate against.
 * @param options Options
 * @returns Returns an array of candidates sorted by best match against the query.
 */
export declare function filter<T extends StringOrObjectArray>(candidates: T[], query: string, options?: DeprecatedFilterOptions<T>): DeprecatedFilterReturn<T>;
export interface TreeFilterIndicesResult {
    data: string;
    index: number;
    parent_indices: Array<number>;
}
/**
 * TreeFilterer is a filters the given query in the nodes of the given array of trees, and returns an array of filtered
 * tree. A tree object is an object in which each entry stores the data in its dataKey and it has (may have) some
 * children (with a similar structure) in its childrenKey
 */
export declare class TreeFilterer<DataKey extends string = string, ChildrenKey extends string = string> {
    obj: Binding.Zadeh;
    private candidates;
    /**
     * The method to set an array of trees that are going to be filtered
     *
     * @param candidates An array of tree objects.
     * @param dataKey The key of the object (and its children) which holds the data (defaults to `"data"`)
     * @param childrenKey The key of the object (and its children) which hold the children (defaults to `"children"`)
     */
    constructor(candidates?: Tree<DataKey, ChildrenKey>[], dataKey?: DataKey, childrenKey?: ChildrenKey);
    /**
     * The method to set an array of trees that are going to be filtered
     *
     * @param candidates An array of tree objects.
     * @param dataKey The key of the object (and its children) which holds the data (defaults to `"data"`)
     * @param childrenKey The key of the object (and its children) which hold the children (defaults to `"children"`)
     */
    setCandidates(candidates: Tree<DataKey, ChildrenKey>[], dataKey?: DataKey, childrenKey?: ChildrenKey): boolean;
    /**
     * Filter the already set trees
     *
     * @param query A string query to match the dataKey of each candidate against.
     * @param options Options
     * @returns {Tree[]} An array of filtered trees. In a tree, the filtered data is at the last level (if it has
     *   children, they are not included in the filered tree)
     */
    filter(query: string, options?: TreeFilterOptions): Tree<DataKey, ChildrenKey>[];
    /**
     * The method to perform the filtering on the already set candidates
     *
     * @param query A string query to match the dataKey of each candidate against.
     * @param options Options
     * @returns {TreeFilterIndicesResult[]} An array candidate objects in form of `{data, index, parentIndices}` sorted by
     *   best match against the query. Each objects has the address of the object in the tree using `index` and `parent_indices`
     */
    filterIndices(query: string, options?: TreeFilterOptions): TreeFilterIndicesResult[];
}
export declare type TreeDataProperty<DataKey extends string> = {
    [dk in DataKey]: string;
};
export declare type TreeChildrenProperty<ChildrenKey extends string> = {
    [ck in ChildrenKey]?: string[];
};
/**
 * A {Tree} object is an object in which each entry stores the data in its dataKey and it has (may have) some children
 * (with a similar structure) in its childrenKey
 */
export declare type Tree<DataKey extends string = string, ChildrenKey extends string = string> = TreeDataProperty<DataKey> & TreeChildrenProperty<ChildrenKey>;
/**
 * Score the given string against the given query.
 *
 * @param candidate The string the score.
 * @param query The query to score the string against.
 * @param options Options
 */
export declare function score(candidate: string, query: string, options?: IOptions): number;
/** Gives an array of indices at which the query matches the given string */
export declare function match(str: string, query: string, options?: IOptions): number[];
/** Gives an HTML/Markdown string that highlights the range for which the match happens */
export declare function wrap(str: string, query: string, options?: IOptions): string;
/** @deprecated: there is no major benefit by precomputing something just for the query. */
export declare function prepareQuery(query: string, options?: IOptions): {};
export {};
