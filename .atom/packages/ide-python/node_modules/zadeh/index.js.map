{"version":3,"file":"index.js","sources":["src/binding/binding.ts","src/binding/index.ts"],"sourcesContent":["import type { Tree, TreeFilterIndicesResult } from \"./index\"\n\nexport declare class Zadeh {\n  constructor()\n\n  filter(query: string, maxResult: number, usePathScoring: boolean, useExtensionBonus: boolean): Array<string>\n  filterIndices(query: string, maxResult: number, usePathScoring: boolean, useExtensionBonus: boolean): Array<number>\n\n  setArrayFiltererCandidates(candidateStrings: Array<string>): boolean\n\n  filterTree(query: string, maxResult: number, usePathScoring: boolean, useExtensionBonus: boolean): Array<Tree>\n\n  filterIndicesTree(\n    query: string,\n    maxResult: number,\n    usePathScoring: boolean,\n    useExtensionBonus: boolean\n  ): Array<TreeFilterIndicesResult>\n\n  // TODO use generic Tree type\n  setTreeFiltererCandidates(candidateTrees: Array<Tree>, dataKey: string, childrenKey: string): boolean\n}\n\nexport declare function score(\n  candidate: string,\n  query: string,\n  usePathScoring: boolean,\n  useExtensionBonus: boolean\n): number\n\nexport declare function match(str: string, query: string, pathSeparator: string): Array<number>\n\nexport declare function wrap(str: string, query: string, pathSeparator: string): string\n\n// Argument validators\n\nexport function validate_filter(...args: Parameters<Zadeh[\"filter\"]>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"number\" &&\n      typeof args[2] === \"boolean\" &&\n      typeof args[3] === \"boolean\"\n    )\n  ) {\n    throw new Error(`Invalid arguments for filter: ${args}`)\n  }\n}\n\nexport function validate_setArrayFiltererCandidates(...args: Parameters<Zadeh[\"setArrayFiltererCandidates\"]>) {\n  if (!Array.isArray(args[0])) {\n    throw new Error(`Invalid arguments for setArrayFiltererCandidates: ${args}`)\n  }\n}\n\nexport function validate_filterTree(...args: Parameters<Zadeh[\"filterIndicesTree\"]>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"number\" &&\n      typeof args[2] === \"boolean\" &&\n      typeof args[3] === \"boolean\"\n    )\n  ) {\n    throw new Error(`Invalid arguments for filterTree: ${args}`)\n  }\n}\n\nexport function validate_setTreeFiltererCandidates(...args: Parameters<Zadeh[\"setTreeFiltererCandidates\"]>) {\n  if (!(Array.isArray(args[0]) && typeof args[1] === \"string\" && typeof args[2] === \"string\")) {\n    throw new Error(`Invalid arguments for setTreeFiltererCandidates: ${args}`)\n  }\n}\n\nexport function validate_score(...args: Parameters<typeof score>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"string\" &&\n      typeof args[2] === \"boolean\" &&\n      typeof args[3] === \"boolean\"\n    )\n  ) {\n    throw new Error(`Invalid arguments for score: ${args}`)\n  }\n}\n\nexport function validate_match(...args: Parameters<typeof match>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"string\" &&\n      typeof args[2] === \"string\" &&\n      /** PathSeparator */ args[2].length === 1\n    )\n  ) {\n    throw new Error(`Invalid arguments for match: ${args}`)\n  }\n}\n\nexport function validate_wrap(...args: Parameters<typeof wrap>) {\n  if (\n    !(\n      typeof args[0] === \"string\" &&\n      typeof args[1] === \"string\" &&\n      typeof args[2] === \"string\" &&\n      /** PathSeparator */ args[2].length === 1\n    )\n  ) {\n    throw new Error(`Invalid arguments for wrap: ${args}`)\n  }\n}\n","// @ts-ignore\nimport nodeGypBuld from \"node-gyp-build\"\n\nimport * as Binding from \"./binding\"\nconst binding = nodeGypBuld(__dirname) as typeof Binding // __dirname relies on Parcel to bundle this file in the root of the package, so __dirname becomes correct\n\n/*\n ██████  ██████  ████████ ██  ██████  ███    ██ ███████\n██    ██ ██   ██    ██    ██ ██    ██ ████   ██ ██\n██    ██ ██████     ██    ██ ██    ██ ██ ██  ██ ███████\n██    ██ ██         ██    ██ ██    ██ ██  ██ ██      ██\n ██████  ██         ██    ██  ██████  ██   ████ ███████\n*/\n\ntype stringWithLength1 = string\n\nexport interface IOptions {\n  /** @default false */\n  allowErrors?: boolean\n\n  /** @default true */\n  usePathScoring?: boolean\n\n  /** @default false */\n  useExtensionBonus?: boolean\n\n  /**\n   * A path separator which is a string with length 1. Such as \"/\" or \"\". By default, this is chosen based on the\n   * operating system.\n   */\n  pathSeparator?: \"/\" | \"\\\\\" | stringWithLength1\n\n  // TODO not implemented?\n  // optCharRegEx?: RegExp\n\n  // TODO not implemented?\n  // wrap?: { tagOpen?: string; tagClass?: string; tagClose?: string }\n\n  /** @deprecated: there is no major benefit by precomputing something just for the query. */\n  preparedQuery?: {}\n}\n\nexport type StringArrayFilterOptions = IOptions & {\n  /** The maximum numbers of results to return */\n  maxResults?: number\n\n  // TODO not implemented\n  // maxInners?: number\n}\n\nexport type ObjectArrayFilterOptions = StringArrayFilterOptions\nexport type TreeFilterOptions = StringArrayFilterOptions\n\n/** @deprecated The key to use when candidates is an object Deprecated option. */\nexport type DeprecatedFilterOptions<T extends StringOrObjectArray> = IOptions & {\n  key?: T extends string ? never : keyof T\n}\n\nconst defaultPathSeparator = process.platform === \"win32\" ? \"\\\\\" : \"/\"\n\nfunction parseOptions(options: IOptions) {\n  // options.allowErrors ? = false\n  if (options.usePathScoring === undefined || options.usePathScoring === null) {\n    options.usePathScoring = true\n  }\n  // options.useExtensionBonus ? = false\n  if (!options.pathSeparator) {\n    options.pathSeparator = defaultPathSeparator\n  }\n}\n\nfunction parseFilterOptions(filterOptions: StringArrayFilterOptions | ObjectArrayFilterOptions | TreeFilterOptions) {\n  // options.optCharRegEx ? = null\n  // options.wrap ? = null\n  if (!filterOptions.maxResults) {\n    filterOptions.maxResults = 0\n  }\n  // parse common options\n  parseOptions(filterOptions)\n}\n\n/*\n █████  ██████  ██████   █████  ██    ██     ███████ ██ ██   ████████ ███████ ██████\n██   ██ ██   ██ ██   ██ ██   ██  ██  ██      ██      ██ ██      ██    ██      ██   ██\n███████ ██████  ██████  ███████   ████       █████   ██ ██      ██    █████   ██████\n██   ██ ██   ██ ██   ██ ██   ██    ██        ██      ██ ██      ██    ██      ██   ██\n██   ██ ██   ██ ██   ██ ██   ██    ██        ██      ██ ███████ ██    ███████ ██   ██\n*/\n\n/** An object that stores its `dataKey` in `DataKey` */\nexport type ObjectWithKey<DataKey extends string | number = string | number> = {\n  [dk in DataKey]: string\n} &\n  Record<string | number, string>\n\nexport type StringOrObjectArray = string | ObjectWithKey\n\n/** StringArrayFilterer is a class that performs filtering on an array of strings */\nexport class StringArrayFilterer {\n  obj = new binding.Zadeh()\n  // typescript cannot detect that candidates is definitely assigned\n  // @ts-ignore\n  private candidates: Array<string>\n\n  /**\n   * Make a `StringArrayFilterer` for the candidates that are going to be filtered.\n   *\n   * @param candidates An array of strings.\n   */\n  constructor(candidates?: Array<string>) {\n    if (candidates !== undefined) {\n      this.setCandidates(candidates)\n    } else {\n      this.candidates = []\n    }\n  }\n\n  /**\n   * The method to set the candidates that are going to be filtered\n   *\n   * @param candidates An array of strings.\n   */\n  setCandidates(candidates: Array<string>) {\n    this.candidates = candidates\n\n    Binding.validate_setArrayFiltererCandidates(candidates)\n    return this.obj.setArrayFiltererCandidates(candidates)\n  }\n\n  /**\n   * Filter the already set array of strings\n   *\n   * @param query A string query to match each candidate against.\n   * @param options Options\n   * @returns Returns an array of candidates sorted by best match against the query.\n   */\n  filter(query: string, options: StringArrayFilterOptions = {}): Array<string> {\n    return this.filterIndices(query, options).map((ind: number) => this.candidates[ind])\n  }\n\n  /**\n   * Filter the already set array of strings and get the indices of the chosen candidate\n   *\n   * @param query A string query to match each candidate against.\n   * @param options Options\n   * @returns Returns an array of numbers indicating the index of the chosen candidate sorted by best match against the query.\n   */\n  filterIndices(query: string, options: StringArrayFilterOptions = {}): Array<number> {\n    parseFilterOptions(options)\n\n    const maxResult = options.maxResults as number /* numberified by parseFilterOptions */\n    const usePathScoring = Boolean(options.usePathScoring)\n    const useExtensionBonus = Boolean(options.useExtensionBonus)\n\n    Binding.validate_filter(query, maxResult, usePathScoring, useExtensionBonus)\n    // NOTE calling obj.filter is slower than (obj.filterIndices then map) due to the interop overhead\n    return this.obj.filterIndices(query, maxResult, usePathScoring, useExtensionBonus)\n  }\n}\n\n/**\n * ObjectArrayFilterer is a class that performs filtering on an array of objects based on a string stored in the given\n * `dataKey` for each object\n */\nexport class ObjectArrayFilterer<DataKey extends string | number = string> {\n  obj = new binding.Zadeh()\n  // typescript cannot detect that candidates is definitely assigned\n  // @ts-ignore\n  private candidates: ObjectWithKey<DataKey>[]\n\n  /**\n   * Make a `ObjectArrayFilterer` for the candidates that are going to be filtered.\n   *\n   * @param candidates An array of objects.\n   * @param dataKey The key which is indexed for each object, and filtering is done based on the resulting string\n   */\n  constructor(candidates?: ObjectWithKey<DataKey>[], dataKey?: DataKey) {\n    if (candidates !== undefined && dataKey !== undefined) {\n      this.setCandidates(candidates, dataKey)\n    } else {\n      this.candidates = []\n    }\n  }\n\n  /**\n   * Allows to set the candidates (if changed or not set in the constructor).\n   *\n   * @param candidates An array of objects.\n   * @param dataKey The key which is indexed for each object, and filtering is done based on the resulting string\n   */\n  setCandidates(candidates: ObjectWithKey<DataKey>[], dataKey: DataKey) {\n    this.candidates = candidates\n    const candidatesKeys = candidates.map((item) => item[dataKey])\n\n    Binding.validate_setArrayFiltererCandidates(candidatesKeys)\n    this.obj.setArrayFiltererCandidates(candidatesKeys)\n  }\n\n  /**\n   * Filter the already set objects\n   *\n   * @param query A string query to match the dataKey of each candidate against.\n   * @param options Options\n   * @returns Returns an array of objects sorted by best match against the query.\n   */\n  filter(query: string, options: ObjectArrayFilterOptions = {}): ObjectWithKey<DataKey>[] {\n    return this.filterIndices(query, options).map((ind: number) => this.candidates[ind])\n  }\n\n  /**\n   * Filter the already set array of objects and get the indices of the chosen candidate\n   *\n   * @param query A string query to match the dataKey of each candidate against.\n   * @param options Options\n   * @returns Returns an array of numbers indicating the index of the chosen candidate sorted by best match against the query.\n   */\n  filterIndices(query: string, options: StringArrayFilterOptions = {}): Array<number> {\n    parseFilterOptions(options)\n\n    const maxResult = options.maxResults as number /* numberified by parseFilterOptions */\n    const usePathScoring = Boolean(options.usePathScoring)\n    const useExtensionBonus = Boolean(options.useExtensionBonus)\n\n    Binding.validate_filter(query, maxResult, usePathScoring, useExtensionBonus)\n    if (query.length === 0) {\n      // optimization for query === \"\"\n      return []\n    }\n    // NOTE calling obj.filter is slower than (obj.filterIndices then map) due to the interop overhead\n    return this.obj.filterIndices(query, maxResult, usePathScoring, useExtensionBonus)\n  }\n}\n\n/** @deprecated */\ntype DeprecatedFilterReturn<T> = T extends string ? string[] : ObjectWithKey[]\n\nlet warnStringArrayFilterer = true\nlet warnfilterObjectArrayFilterer = true\n\n/**\n * @deprecated Use `StringArrayFilterer` or `ObjectArrayFilterer` instead Sort and filter the given candidates by\n *   matching them against the given query.\n * @param candidates An array of strings or objects.\n * @param query A string query to match each candidate against.\n * @param options Options\n * @returns Returns an array of candidates sorted by best match against the query.\n */\nexport function filter<T extends StringOrObjectArray>(\n  candidates: T[],\n  query: string,\n  options: DeprecatedFilterOptions<T> = {}\n): DeprecatedFilterReturn<T> {\n  if (!candidates || !query) {\n    console.warn(`Zadeh: bad input to filter candidates: ${candidates}, query: ${query}`)\n    // @ts-ignore: bad input guard which doesn't meet the types\n    return []\n  }\n\n  if (typeof candidates[0] === \"object\" && options.key) {\n    // an object (options) containing the key\n    if (warnfilterObjectArrayFilterer) {\n      console.warn(`Zadeh: deprecated function. Use 'ObjectArrayFilterer' instead`)\n      warnfilterObjectArrayFilterer = false\n    }\n    const dataKey = options.key\n    const objectArrayFilterer = new ObjectArrayFilterer(\n      candidates as ObjectWithKey<T extends string ? never : keyof T>[],\n      dataKey\n    )\n    return objectArrayFilterer.filter(query, options) as DeprecatedFilterReturn<T>\n  } else if (typeof candidates[0] === \"string\") {\n    // string array\n    if (warnStringArrayFilterer) {\n      console.warn(`Zadeh: deprecated function. Use 'StringArrayFilterer' instead`)\n      warnStringArrayFilterer = false\n    }\n    const stringArrayFilterer = new StringArrayFilterer(candidates as string[])\n    return stringArrayFilterer.filter(query, options) as DeprecatedFilterReturn<T>\n  } else {\n    throw new Error(`Zadeh: bad input to filter candidates: ${candidates}, query: ${query}, options: ${options}`)\n  }\n}\n\n/*\n████████ ██████  ███████ ███████     ███████ ██ ██   ████████ ███████ ██████\n   ██    ██   ██ ██      ██          ██      ██ ██      ██    ██      ██   ██\n   ██    ██████  █████   █████       █████   ██ ██      ██    █████   ██████\n   ██    ██   ██ ██      ██          ██      ██ ██      ██    ██      ██   ██\n   ██    ██   ██ ███████ ███████     ██      ██ ███████ ██    ███████ ██   ██\n*/\n\n// The object (an element of the array) returned from filtering trees. It has the address of the object in the tree using `index` and `parent_indices`.\nexport interface TreeFilterIndicesResult {\n  data: string\n  index: number\n  parent_indices: Array<number>\n}\n\n/**\n * TreeFilterer is a filters the given query in the nodes of the given array of trees, and returns an array of filtered\n * tree. A tree object is an object in which each entry stores the data in its dataKey and it has (may have) some\n * children (with a similar structure) in its childrenKey\n */\nexport class TreeFilterer<DataKey extends string = string, ChildrenKey extends string = string> {\n  obj = new binding.Zadeh()\n  // typescript cannot detect that candidates is definitely assigned\n  // @ts-ignore\n  private candidates: Tree<DataKey, ChildrenKey>[]\n\n  /**\n   * The method to set an array of trees that are going to be filtered\n   *\n   * @param candidates An array of tree objects.\n   * @param dataKey The key of the object (and its children) which holds the data (defaults to `\"data\"`)\n   * @param childrenKey The key of the object (and its children) which hold the children (defaults to `\"children\"`)\n   */\n  constructor(\n    candidates?: Tree<DataKey, ChildrenKey>[],\n    dataKey: DataKey = \"data\" as DataKey,\n    childrenKey: ChildrenKey = \"children\" as ChildrenKey\n  ) {\n    if (candidates) {\n      this.setCandidates(candidates, dataKey, childrenKey)\n    } else {\n      this.candidates = []\n    }\n  }\n\n  /**\n   * The method to set an array of trees that are going to be filtered\n   *\n   * @param candidates An array of tree objects.\n   * @param dataKey The key of the object (and its children) which holds the data (defaults to `\"data\"`)\n   * @param childrenKey The key of the object (and its children) which hold the children (defaults to `\"children\"`)\n   */\n  setCandidates(\n    candidates: Tree<DataKey, ChildrenKey>[],\n    dataKey: DataKey = \"data\" as DataKey,\n    childrenKey: ChildrenKey = \"children\" as ChildrenKey\n  ) {\n    this.candidates = candidates\n\n    Binding.validate_setTreeFiltererCandidates(candidates, dataKey, childrenKey)\n    return this.obj.setTreeFiltererCandidates(candidates, dataKey, childrenKey)\n  }\n\n  /**\n   * Filter the already set trees\n   *\n   * @param query A string query to match the dataKey of each candidate against.\n   * @param options Options\n   * @returns {Tree[]} An array of filtered trees. In a tree, the filtered data is at the last level (if it has\n   *   children, they are not included in the filered tree)\n   */\n  filter(query: string, options: TreeFilterOptions = {}): Tree<DataKey, ChildrenKey>[] {\n    parseFilterOptions(options)\n\n    const maxResult = options.maxResults as number /* numberified by parseFilterOptions */\n    const usePathScoring = Boolean(options.usePathScoring)\n    const useExtensionBonus = Boolean(options.useExtensionBonus)\n\n    Binding.validate_filterTree(query, maxResult, usePathScoring, useExtensionBonus)\n    if (query.length === 0) {\n      // optimization for query === \"\"\n      return []\n    }\n    return this.obj.filterTree(query, maxResult, usePathScoring, useExtensionBonus)\n  }\n\n  /**\n   * The method to perform the filtering on the already set candidates\n   *\n   * @param query A string query to match the dataKey of each candidate against.\n   * @param options Options\n   * @returns {TreeFilterIndicesResult[]} An array candidate objects in form of `{data, index, parentIndices}` sorted by\n   *   best match against the query. Each objects has the address of the object in the tree using `index` and `parent_indices`\n   */\n  filterIndices(query: string, options: TreeFilterOptions = {}): TreeFilterIndicesResult[] {\n    parseOptions(options)\n    if (query.length === 0) {\n      // optimization for query === \"\"\n      return []\n    }\n    return this.obj.filterIndicesTree(\n      query,\n      options.maxResults ?? 0,\n      Boolean(options.usePathScoring),\n      Boolean(options.useExtensionBonus)\n    )\n  }\n}\n\nexport type TreeDataProperty<DataKey extends string> = {\n  [dk in DataKey]: string\n}\nexport type TreeChildrenProperty<ChildrenKey extends string> = {\n  [ck in ChildrenKey]?: string[] // children is either an array or not provided\n}\n/**\n * A {Tree} object is an object in which each entry stores the data in its dataKey and it has (may have) some children\n * (with a similar structure) in its childrenKey\n */\nexport type Tree<DataKey extends string = string, ChildrenKey extends string = string> = TreeDataProperty<DataKey> &\n  TreeChildrenProperty<ChildrenKey>\n\n/*\n███████  ██████  ██████  ██████  ███████\n██      ██      ██    ██ ██   ██ ██\n███████ ██      ██    ██ ██████  █████\n     ██ ██      ██    ██ ██   ██ ██\n███████  ██████  ██████  ██   ██ ███████\n*/\n\n/**\n * Score the given string against the given query.\n *\n * @param candidate The string the score.\n * @param query The query to score the string against.\n * @param options Options\n */\nexport function score(candidate: string, query: string, options: IOptions = {}): number {\n  if (!candidate || !query) {\n    console.warn(`Zadeh: bad input to score candidates: ${candidate}, query: ${query}`)\n    return 0\n  }\n  parseOptions(options)\n\n  const usePathScoring = Boolean(options.usePathScoring)\n  const useExtensionBonus = Boolean(options.useExtensionBonus)\n\n  Binding.validate_score(candidate, query, usePathScoring, useExtensionBonus)\n  return binding.score(candidate, query, usePathScoring, useExtensionBonus)\n}\n\n/*\n███    ███  █████  ████████  ██████ ██   ██\n████  ████ ██   ██    ██    ██      ██   ██\n██ ████ ██ ███████    ██    ██      ███████\n██  ██  ██ ██   ██    ██    ██      ██   ██\n██      ██ ██   ██    ██     ██████ ██   ██\n*/\n\n/** Gives an array of indices at which the query matches the given string */\nexport function match(str: string, query: string, options: IOptions = {}): number[] {\n  if (!str || !query) {\n    console.warn(`Zadeh: bad input to match str: ${str}, query: ${query}`)\n    return []\n  }\n  if (str === query) {\n    return Array.from(Array(str.length).keys())\n  }\n  parseOptions(options)\n\n  const pathSeparator = options.pathSeparator as string /* stringified by parseOption */\n\n  Binding.validate_match(str, query, pathSeparator)\n  return binding.match(str, query, pathSeparator)\n}\n\n/*\n██     ██ ██████   █████  ██████\n██     ██ ██   ██ ██   ██ ██   ██\n██  █  ██ ██████  ███████ ██████\n██ ███ ██ ██   ██ ██   ██ ██\n ███ ███  ██   ██ ██   ██ ██\n*/\n\n/** Gives an HTML/Markdown string that highlights the range for which the match happens */\nexport function wrap(str: string, query: string, options: IOptions = {}): string {\n  if (!str || !query) {\n    console.warn(`Zadeh: bad input to wrap str: ${str}, query: ${query}`)\n    // @ts-ignore\n    return []\n  }\n  parseOptions(options)\n\n  const pathSeparator = options.pathSeparator as string /* stringified by parseOption */\n\n  Binding.validate_wrap(str, query, pathSeparator)\n  return binding.wrap(str, query, pathSeparator)\n}\n\n/*\n ██████  ████████ ██   ██ ███████ ██████\n██    ██    ██    ██   ██ ██      ██   ██\n██    ██    ██    ███████ █████   ██████\n██    ██    ██    ██   ██ ██      ██   ██\n ██████     ██    ██   ██ ███████ ██   ██\n*/\n\n/** @deprecated: there is no major benefit by precomputing something just for the query. */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// @ts-ignore\nexport function prepareQuery(query: string, options: IOptions = {}): {} {\n  console.warn(\n    \"Zadeh: prepareQuery is deprecated. There is no major benefit by precomputing something just for the query. \"\n  )\n  // This is no - op since there is no major benefit by precomputing something\n  // just for the query.\n  return {}\n}\n"],"names":["validate_filter","_i","args","Error","validate_setArrayFiltererCandidates","Array","isArray","binding","__dirname","defaultPathSeparator","process","platform","parseOptions","options","undefined","usePathScoring","pathSeparator","parseFilterOptions","filterOptions","maxResults","candidates","this","Zadeh","setCandidates","StringArrayFilterer","Binding.validate_setArrayFiltererCandidates","obj","setArrayFiltererCandidates","query","filterIndices","map","ind","_this","maxResult","Boolean","useExtensionBonus","Binding.validate_filter","dataKey","ObjectArrayFilterer","candidatesKeys","item","length","warnStringArrayFilterer","warnfilterObjectArrayFilterer","childrenKey","TreeFilterer","Binding.validate_setTreeFiltererCandidates","setTreeFiltererCandidates","Binding.validate_filterTree","filterTree","filterIndicesTree","console","warn","key","filter","str","from","keys","Binding.validate_match","match","candidate","Binding.validate_score","score","Binding.validate_wrap","wrap"],"mappings":"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"}