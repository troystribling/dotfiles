Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts workspace/applyEdit commands to editors.
class ApplyEditAdapter {
  // Public: Attach to a {LanguageClientConnection} to receive edit events.
  static attach(connection) {
    connection.onApplyEdit(m => ApplyEditAdapter.onApplyEdit(m));
  }

  static async onApplyEdit(params) {
    // TODO(protocol v3.0): Handle versioned documentChanges
    const { changes } = params.edit;
    const uris = Object.keys(changes);
    const paths = uris.map(_convert2.default.uriToPath);
    const editors = await Promise.all(paths.map(path => {
      return atom.workspace.open(path, {
        searchAllPanes: true,
        // Open new editors in the background.
        activatePane: false,
        activateItem: false
      });
    }));

    const checkpoints = [];
    try {
      for (let i = 0; i < editors.length; i++) {
        const editor = editors[i];
        const uri = uris[i];
        // Get an existing editor for the file, or open a new one if it doesn't exist.
        const edits = _convert2.default.convertLsTextEdits(changes[uri]);
        // Sort edits in reverse order to prevent edit conflicts.
        edits.sort((edit1, edit2) => -edit1.oldRange.compare(edit2.oldRange));
        const buffer = editor.getBuffer();
        const checkpoint = buffer.createCheckpoint();
        checkpoints.push({ buffer, checkpoint });
        let prevEdit = null;
        for (const edit of edits) {
          ApplyEditAdapter.validateEdit(buffer, edit, prevEdit);
          buffer.setTextInRange(edit.oldRange, edit.newText);
          prevEdit = edit;
        }
        buffer.groupChangesSinceCheckpoint(checkpoint);
      }
      return { applied: true };
    } catch (e) {
      atom.notifications.addError('workspace/applyEdits failed', {
        description: 'Failed to apply edits.',
        detail: e.message
      });
      checkpoints.forEach(({ buffer, checkpoint }) => {
        buffer.revertToCheckpoint(checkpoint);
      });
      return { applied: false };
    }
  }

  // Private: Do some basic sanity checking on the edit ranges.
  static validateEdit(buffer, edit, prevEdit) {
    const path = buffer.getPath() || '';
    if (prevEdit != null && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
      throw Error(`Found overlapping edit ranges in ${path}`);
    }
    const startRow = edit.oldRange.start.row;
    const startCol = edit.oldRange.start.column;
    const lineLength = buffer.lineLengthForRow(startRow);
    if (lineLength == null || startCol > lineLength) {
      throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
    }
  }
}
exports.default = ApplyEditAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9hcHBseS1lZGl0LWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiQXBwbHlFZGl0QWRhcHRlciIsImF0dGFjaCIsImNvbm5lY3Rpb24iLCJvbkFwcGx5RWRpdCIsIm0iLCJwYXJhbXMiLCJjaGFuZ2VzIiwiZWRpdCIsInVyaXMiLCJPYmplY3QiLCJrZXlzIiwicGF0aHMiLCJtYXAiLCJ1cmlUb1BhdGgiLCJlZGl0b3JzIiwiUHJvbWlzZSIsImFsbCIsInBhdGgiLCJhdG9tIiwid29ya3NwYWNlIiwib3BlbiIsInNlYXJjaEFsbFBhbmVzIiwiYWN0aXZhdGVQYW5lIiwiYWN0aXZhdGVJdGVtIiwiY2hlY2twb2ludHMiLCJpIiwibGVuZ3RoIiwiZWRpdG9yIiwidXJpIiwiZWRpdHMiLCJjb252ZXJ0THNUZXh0RWRpdHMiLCJzb3J0IiwiZWRpdDEiLCJlZGl0MiIsIm9sZFJhbmdlIiwiY29tcGFyZSIsImJ1ZmZlciIsImdldEJ1ZmZlciIsImNoZWNrcG9pbnQiLCJjcmVhdGVDaGVja3BvaW50IiwicHVzaCIsInByZXZFZGl0IiwidmFsaWRhdGVFZGl0Iiwic2V0VGV4dEluUmFuZ2UiLCJuZXdUZXh0IiwiZ3JvdXBDaGFuZ2VzU2luY2VDaGVja3BvaW50IiwiYXBwbGllZCIsImUiLCJub3RpZmljYXRpb25zIiwiYWRkRXJyb3IiLCJkZXNjcmlwdGlvbiIsImRldGFpbCIsIm1lc3NhZ2UiLCJmb3JFYWNoIiwicmV2ZXJ0VG9DaGVja3BvaW50IiwiZ2V0UGF0aCIsImVuZCIsInN0YXJ0IiwiRXJyb3IiLCJzdGFydFJvdyIsInJvdyIsInN0YXJ0Q29sIiwiY29sdW1uIiwibGluZUxlbmd0aCIsImxpbmVMZW5ndGhGb3JSb3ciXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFLQTs7Ozs7O0FBRUE7QUFDZSxNQUFNQSxnQkFBTixDQUF1QjtBQUNwQztBQUNBLFNBQU9DLE1BQVAsQ0FBY0MsVUFBZCxFQUFvRDtBQUNsREEsZUFBV0MsV0FB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ckM7QUFDQSxVQUFNQyxXQUFXdEQsS0FBSzJCLFFBQUwsQ0FBY3VCLEtBQWQsQ0FBb0JLLE1BQXJDO0FBQ0EsVUFBTUMsYUFBYTNCLE9BQU80QixnQkFBUCxDQUF3QkwsUUFBeEIsQ0FBbkI7QUFDQSxRQUFJSSxjQUFjLElBQWQsSUFBc0JGLFdBQVdFLFVBQXJDLEVBQWlEO0FBQy9DLFlBQU1MLE1BQU8sd0JBQXVCekMsSUFBSyxJQUFHMEMsV0FBVyxDQUFFLElBQUdFLFdBQVcsQ0FBRSxFQUFuRSxDQUFOO0FBQ0Q7QUFDRjtBQW5FbUM7a0JBQWpCN0QsZ0IiLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7XHJcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIHR5cGUgQXBwbHlXb3Jrc3BhY2VFZGl0UGFyYW1zLFxyXG4gIHR5cGUgQXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2UsXHJcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHdvcmtzcGFjZS9hcHBseUVkaXQgY29tbWFuZHMgdG8gZWRpdG9ycy5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwbHlFZGl0QWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBBdHRhY2ggdG8gYSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byByZWNlaXZlIGVkaXQgZXZlbnRzLlxyXG4gIHN0YXRpYyBhdHRhY2goY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uKSB7XHJcbiAgICBjb25uZWN0aW9uLm9uQXBwbHlFZGl0KG0gPT4gQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdChtKSk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgb25BcHBseUVkaXQocGFyYW1zOiBBcHBseVdvcmtzcGFjZUVkaXRQYXJhbXMpOiBQcm9taXNlPEFwcGx5V29ya3NwYWNlRWRpdFJlc3BvbnNlPiB7XHJcbiAgICAvLyBUT0RPKHByb3RvY29sIHYzLjApOiBIYW5kbGUgdmVyc2lvbmVkIGRvY3VtZW50Q2hhbmdlc1xyXG4gICAgY29uc3Qge2NoYW5nZXN9ID0gcGFyYW1zLmVkaXQ7XHJcbiAgICBjb25zdCB1cmlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XHJcbiAgICBjb25zdCBwYXRocyA9IHVyaXMubWFwKENvbnZlcnQudXJpVG9QYXRoKTtcclxuICAgIGNvbnN0IGVkaXRvcnMgPSBhd2FpdCBQcm9taXNlLmFsbChcclxuICAgICAgcGF0aHMubWFwKHBhdGggPT4ge1xyXG4gICAgICAgIHJldHVybiBhdG9tLndvcmtzcGFjZS5vcGVuKHBhdGgsIHtcclxuICAgICAgICAgIHNlYXJjaEFsbFBhbmVzOiB0cnVlLFxyXG4gICAgICAgICAgLy8gT3BlbiBuZXcgZWRpdG9ycyBpbiB0aGUgYmFja2dyb3VuZC5cclxuICAgICAgICAgIGFjdGl2YXRlUGFuZTogZmFsc2UsXHJcbiAgICAgICAgICBhY3RpdmF0ZUl0ZW06IGZhbHNlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgY2hlY2twb2ludHMgPSBbXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9ycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGVkaXRvcnNbaV07XHJcbiAgICAgICAgY29uc3QgdXJpID0gdXJpc1tpXTtcclxuICAgICAgICAvLyBHZXQgYW4gZXhpc3RpbmcgZWRpdG9yIGZvciB0aGUgZmlsZSwgb3Igb3BlbiBhIG5ldyBvbmUgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICAgICAgICBjb25zdCBlZGl0cyA9IENvbnZlcnQuY29udmVydExzVGV4dEVkaXRzKGNoYW5nZXNbdXJpXSk7XHJcbiAgICAgICAgLy8gU29ydCBlZGl0cyBpbiByZXZlcnNlIG9yZGVyIHRvIHByZXZlbnQgZWRpdCBjb25mbGljdHMuXHJcbiAgICAgICAgZWRpdHMuc29ydCgoZWRpdDEsIGVkaXQyKSA9PiAtZWRpdDEub2xkUmFuZ2UuY29tcGFyZShlZGl0Mi5vbGRSYW5nZSkpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVkaXRvci5nZXRCdWZmZXIoKTtcclxuICAgICAgICBjb25zdCBjaGVja3BvaW50ID0gYnVmZmVyLmNyZWF0ZUNoZWNrcG9pbnQoKTtcclxuICAgICAgICBjaGVja3BvaW50cy5wdXNoKHtidWZmZXIsIGNoZWNrcG9pbnR9KTtcclxuICAgICAgICBsZXQgcHJldkVkaXQgPSBudWxsO1xyXG4gICAgICAgIGZvciAoY29uc3QgZWRpdCBvZiBlZGl0cykge1xyXG4gICAgICAgICAgQXBwbHlFZGl0QWRhcHRlci52YWxpZGF0ZUVkaXQoYnVmZmVyLCBlZGl0LCBwcmV2RWRpdCk7XHJcbiAgICAgICAgICBidWZmZXIuc2V0VGV4dEluUmFuZ2UoZWRpdC5vbGRSYW5nZSwgZWRpdC5uZXdUZXh0KTtcclxuICAgICAgICAgIHByZXZFZGl0ID0gZWRpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVmZmVyLmdyb3VwQ2hhbmdlc1NpbmNlQ2hlY2twb2ludChjaGVja3BvaW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge2FwcGxpZWQ6IHRydWV9O1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IoJ3dvcmtzcGFjZS9hcHBseUVkaXRzIGZhaWxlZCcsIHtcclxuICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhaWxlZCB0byBhcHBseSBlZGl0cy4nLFxyXG4gICAgICAgIGRldGFpbDogZS5tZXNzYWdlLFxyXG4gICAgICB9KTtcclxuICAgICAgY2hlY2twb2ludHMuZm9yRWFjaCgoe2J1ZmZlciwgY2hlY2twb2ludH0pID0+IHtcclxuICAgICAgICBidWZmZXIucmV2ZXJ0VG9DaGVja3BvaW50KGNoZWNrcG9pbnQpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHthcHBsaWVkOiBmYWxzZX07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQcml2YXRlOiBEbyBzb21lIGJhc2ljIHNhbml0eSBjaGVja2luZyBvbiB0aGUgZWRpdCByYW5nZXMuXHJcbiAgc3RhdGljIHZhbGlkYXRlRWRpdChidWZmZXI6IGF0b20kVGV4dEJ1ZmZlciwgZWRpdDogYXRvbUlkZSRUZXh0RWRpdCwgcHJldkVkaXQ6ID9hdG9tSWRlJFRleHRFZGl0KTogdm9pZCB7XHJcbiAgICBjb25zdCBwYXRoID0gYnVmZmVyLmdldFBhdGgoKSB8fCAnJztcclxuICAgIGlmIChwcmV2RWRpdCAhPSBudWxsICYmIGVkaXQub2xkUmFuZ2UuZW5kLmNvbXBhcmUocHJldkVkaXQub2xkUmFuZ2Uuc3RhcnQpID4gMCkge1xyXG4gICAgICB0aHJvdyBFcnJvcihgRm91bmQgb3ZlcmxhcHBpbmcgZWRpdCByYW5nZXMgaW4gJHtwYXRofWApO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3RhcnRSb3cgPSBlZGl0Lm9sZFJhbmdlLnN0YXJ0LnJvdztcclxuICAgIGNvbnN0IHN0YXJ0Q29sID0gZWRpdC5vbGRSYW5nZS5zdGFydC5jb2x1bW47XHJcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gYnVmZmVyLmxpbmVMZW5ndGhGb3JSb3coc3RhcnRSb3cpO1xyXG4gICAgaWYgKGxpbmVMZW5ndGggPT0gbnVsbCB8fCBzdGFydENvbCA+IGxpbmVMZW5ndGgpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoYE91dCBvZiByYW5nZSBlZGl0IG9uICR7cGF0aH06JHtzdGFydFJvdyArIDF9OiR7c3RhcnRDb2wgKyAxfWApO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=