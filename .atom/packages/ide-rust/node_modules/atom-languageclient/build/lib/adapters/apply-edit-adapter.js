Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts workspace/applyEdit commands to editors.
class ApplyEditAdapter {
  // Public: Attach to a {LanguageClientConnection} to receive edit events.
  static attach(connection) {
    connection.onApplyEdit(m => ApplyEditAdapter.onApplyEdit(m));
  }

  static async onApplyEdit(params) {

    let changes = params.edit.changes || {};

    if (params.edit.documentChanges) {
      changes = {};
      params.edit.documentChanges.forEach(change => {
        if (change && change.textDocument) {
          changes[change.textDocument.uri] = change.edits;
        }
      });
    }

    const uris = Object.keys(changes);
    const paths = uris.map(_convert2.default.uriToPath);
    const editors = await Promise.all(paths.map(path => {
      return atom.workspace.open(path, {
        searchAllPanes: true,
        // Open new editors in the background.
        activatePane: false,
        activateItem: false
      });
    }));

    const checkpoints = [];
    try {
      for (let i = 0; i < editors.length; i++) {
        const editor = editors[i];
        const uri = uris[i];
        // Get an existing editor for the file, or open a new one if it doesn't exist.
        const edits = _convert2.default.convertLsTextEdits(changes[uri]);
        // Sort edits in reverse order to prevent edit conflicts.
        edits.sort((edit1, edit2) => -edit1.oldRange.compare(edit2.oldRange));
        const buffer = editor.getBuffer();
        const checkpoint = buffer.createCheckpoint();
        checkpoints.push({ buffer, checkpoint });
        let prevEdit = null;
        for (const edit of edits) {
          ApplyEditAdapter.validateEdit(buffer, edit, prevEdit);
          buffer.setTextInRange(edit.oldRange, edit.newText);
          prevEdit = edit;
        }
        buffer.groupChangesSinceCheckpoint(checkpoint);
      }
      return { applied: true };
    } catch (e) {
      atom.notifications.addError('workspace/applyEdits failed', {
        description: 'Failed to apply edits.',
        detail: e.message
      });
      checkpoints.forEach(({ buffer, checkpoint }) => {
        buffer.revertToCheckpoint(checkpoint);
      });
      return { applied: false };
    }
  }

  // Private: Do some basic sanity checking on the edit ranges.
  static validateEdit(buffer, edit, prevEdit) {
    const path = buffer.getPath() || '';
    if (prevEdit != null && edit.oldRange.end.compare(prevEdit.oldRange.start) > 0) {
      throw Error(`Found overlapping edit ranges in ${path}`);
    }
    const startRow = edit.oldRange.start.row;
    const startCol = edit.oldRange.start.column;
    const lineLength = buffer.lineLengthForRow(startRow);
    if (lineLength == null || startCol > lineLength) {
      throw Error(`Out of range edit on ${path}:${startRow + 1}:${startCol + 1}`);
    }
  }
}
exports.default = ApplyEditAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9hcHBseS1lZGl0LWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiQXBwbHlFZGl0QWRhcHRlciIsImF0dGFjaCIsImNvbm5lY3Rpb24iLCJvbkFwcGx5RWRpdCIsIm0iLCJwYXJhbXMiLCJjaGFuZ2VzIiwiZWRpdCIsImRvY3VtZW50Q2hhbmdlcyIsImZvckVhY2giLCJjaGFuZ2UiLCJ0ZXh0RG9jdW1lbnQiLCJ1cmkiLCJlZGl0cyIsInVyaXMiLCJPYmplY3QiLCJrZXlzIiwicGF0aHMiLCJtYXAiLCJ1cmlUb1BhdGgiLCJlZGl0b3JzIiwiUHJvbWlzZSIsImFsbCIsInBhdGgiLCJhdG9tIiwid29ya3NwYWNlIiwib3BlbiIsInNlYXJjaEFsbFBhbmVzIiwiYWN0aXZhdGVQYW5lIiwiYWN0aXZhdGVJdGVtIiwiY2hlY2twb2ludHMiLCJpIiwibGVuZ3RoIiwiZWRpdG9yIiwiY29udmVydExzVGV4dEVkaXRzIiwic29ydCIsImVkaXQxIiwiZWRpdDIiLCJvbGRSYW5nZSIsImNvbXBhcmUiLCJidWZmZXIiLCJnZXRCdWZmZXIiLCJjaGVja3BvaW50IiwiY3JlYXRlQ2hlY2twb2ludCIsInB1c2giLCJwcmV2RWRpdCIsInZhbGlkYXRlRWRpdCIsInNldFRleHRJblJhbmdlIiwibmV3VGV4dCIsImdyb3VwQ2hhbmdlc1NpbmNlQ2hlY2twb2ludCIsImFwcGxpZWQiLCJlIiwibm90aWZpY2F0aW9ucyIsImFkZEVycm9yIiwiZGVzY3JpcHRpb24iLCJkZXRhaWwiLCJtZXNzYWdlIiwicmV2ZXJ0VG9DaGVja3BvaW50IiwiZ2V0UGF0aCIsImVuZCIsInN0YXJ0IiwiRXJyb3IiLCJzdGFydFJvdyIsInJvdyIsInN0YXJ0Q29sIiwiY29sdW1uIiwibGluZUxlbmd0aCIsImxpbmVMZW5ndGhGb3JSb3ciXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFLQTs7Ozs7O0FBRUE7QUFDZSxNQUFNQSxnQkFBTixDQUF1QjtBQUNwQztBQUNBLFNB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LFFBQXJFLEVBQXdHO0FBQ3RHLFVBQU10QixPQUFPaUIsT0FBT2tCLE9BQVAsTUFBb0IsRUFBakM7QUFDQSxRQUFJYixZQUFZLElBQVosSUFBb0J0QyxLQUFLK0IsUUFBTCxDQUFjcUIsR0FBZCxDQUFrQnBCLE9BQWxCLENBQTBCTSxTQUFTUCxRQUFULENBQWtCc0IsS0FBNUMsSUFBcUQsQ0FBN0UsRUFBZ0Y7QUFDOUUsWUFBTUMsTUFBTyxvQ0FBbUN0QyxJQUFLLEVBQS9DLENBQU47QUFDRDtBQUNELFVBQU11QyxXQUFXdkQsS0FBSytCLFFBQUwsQ0FBY3NCLEtBQWQsQ0FBb0JHLEdBQXJDO0FBQ0EsVUFBTUMsV0FBV3pELEtBQUsrQixRQUFMLENBQWNzQixLQUFkLENBQW9CSyxNQUFyQztBQUNBLFVBQU1DLGFBQWExQixPQUFPMkIsZ0JBQVAsQ0FBd0JMLFFBQXhCLENBQW5CO0FBQ0EsUUFBSUksY0FBYyxJQUFkLElBQXNCRixXQUFXRSxVQUFyQyxFQUFpRDtBQUMvQyxZQUFNTCxNQUFPLHdCQUF1QnRDLElBQUssSUFBR3VDLFdBQVcsQ0FBRSxJQUFHRSxXQUFXLENBQUUsRUFBbkUsQ0FBTjtBQUNEO0FBQ0Y7QUE3RW1DO2tCQUFqQmhFLGdCIiwiZmlsZSI6ImFwcGx5LWVkaXQtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgdHlwZSBBcHBseVdvcmtzcGFjZUVkaXRQYXJhbXMsXG4gIHR5cGUgQXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2UsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB3b3Jrc3BhY2UvYXBwbHlFZGl0IGNvbW1hbmRzIHRvIGVkaXRvcnMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHBseUVkaXRBZGFwdGVyIHtcbiAgLy8gUHVibGljOiBBdHRhY2ggdG8gYSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byByZWNlaXZlIGVkaXQgZXZlbnRzLlxuICBzdGF0aWMgYXR0YWNoKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbikge1xuICAgIGNvbm5lY3Rpb24ub25BcHBseUVkaXQobSA9PiBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KG0pKTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBvbkFwcGx5RWRpdChwYXJhbXM6IEFwcGx5V29ya3NwYWNlRWRpdFBhcmFtcyk6IFByb21pc2U8QXBwbHlXb3Jrc3BhY2VFZGl0UmVzcG9uc2U+IHtcblxuICAgIGxldCBjaGFuZ2VzID0gcGFyYW1zLmVkaXQuY2hhbmdlcyB8fCB7fTtcblxuICAgIGlmIChwYXJhbXMuZWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgIGNoYW5nZXMgPSB7fTtcbiAgICAgIHBhcmFtcy5lZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XG4gICAgICAgIGlmIChjaGFuZ2UgJiYgY2hhbmdlLnRleHREb2N1bWVudCkge1xuICAgICAgICAgIGNoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gY2hhbmdlLmVkaXRzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmlzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgY29uc3QgcGF0aHMgPSB1cmlzLm1hcChDb252ZXJ0LnVyaVRvUGF0aCk7XG4gICAgY29uc3QgZWRpdG9ycyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgcGF0aHMubWFwKHBhdGggPT4ge1xuICAgICAgICByZXR1cm4gYXRvbS53b3Jrc3BhY2Uub3BlbihwYXRoLCB7XG4gICAgICAgICAgc2VhcmNoQWxsUGFuZXM6IHRydWUsXG4gICAgICAgICAgLy8gT3BlbiBuZXcgZWRpdG9ycyBpbiB0aGUgYmFja2dyb3VuZC5cbiAgICAgICAgICBhY3RpdmF0ZVBhbmU6IGZhbHNlLFxuICAgICAgICAgIGFjdGl2YXRlSXRlbTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgKTtcblxuICAgIGNvbnN0IGNoZWNrcG9pbnRzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBlZGl0b3JzW2ldO1xuICAgICAgICBjb25zdCB1cmkgPSB1cmlzW2ldO1xuICAgICAgICAvLyBHZXQgYW4gZXhpc3RpbmcgZWRpdG9yIGZvciB0aGUgZmlsZSwgb3Igb3BlbiBhIG5ldyBvbmUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgY29uc3QgZWRpdHMgPSBDb252ZXJ0LmNvbnZlcnRMc1RleHRFZGl0cyhjaGFuZ2VzW3VyaV0pO1xuICAgICAgICAvLyBTb3J0IGVkaXRzIGluIHJldmVyc2Ugb3JkZXIgdG8gcHJldmVudCBlZGl0IGNvbmZsaWN0cy5cbiAgICAgICAgZWRpdHMuc29ydCgoZWRpdDEsIGVkaXQyKSA9PiAtZWRpdDEub2xkUmFuZ2UuY29tcGFyZShlZGl0Mi5vbGRSYW5nZSkpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBlZGl0b3IuZ2V0QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBidWZmZXIuY3JlYXRlQ2hlY2twb2ludCgpO1xuICAgICAgICBjaGVja3BvaW50cy5wdXNoKHtidWZmZXIsIGNoZWNrcG9pbnR9KTtcbiAgICAgICAgbGV0IHByZXZFZGl0ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0IG9mIGVkaXRzKSB7XG4gICAgICAgICAgQXBwbHlFZGl0QWRhcHRlci52YWxpZGF0ZUVkaXQoYnVmZmVyLCBlZGl0LCBwcmV2RWRpdCk7XG4gICAgICAgICAgYnVmZmVyLnNldFRleHRJblJhbmdlKGVkaXQub2xkUmFuZ2UsIGVkaXQubmV3VGV4dCk7XG4gICAgICAgICAgcHJldkVkaXQgPSBlZGl0O1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5ncm91cENoYW5nZXNTaW5jZUNoZWNrcG9pbnQoY2hlY2twb2ludCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge2FwcGxpZWQ6IHRydWV9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvcignd29ya3NwYWNlL2FwcGx5RWRpdHMgZmFpbGVkJywge1xuICAgICAgICBkZXNjcmlwdGlvbjogJ0ZhaWxlZCB0byBhcHBseSBlZGl0cy4nLFxuICAgICAgICBkZXRhaWw6IGUubWVzc2FnZSxcbiAgICAgIH0pO1xuICAgICAgY2hlY2twb2ludHMuZm9yRWFjaCgoe2J1ZmZlciwgY2hlY2twb2ludH0pID0+IHtcbiAgICAgICAgYnVmZmVyLnJldmVydFRvQ2hlY2twb2ludChjaGVja3BvaW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHthcHBsaWVkOiBmYWxzZX07XG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZTogRG8gc29tZSBiYXNpYyBzYW5pdHkgY2hlY2tpbmcgb24gdGhlIGVkaXQgcmFuZ2VzLlxuICBzdGF0aWMgdmFsaWRhdGVFZGl0KGJ1ZmZlcjogYXRvbSRUZXh0QnVmZmVyLCBlZGl0OiBhdG9tSWRlJFRleHRFZGl0LCBwcmV2RWRpdDogP2F0b21JZGUkVGV4dEVkaXQpOiB2b2lkIHtcbiAgICBjb25zdCBwYXRoID0gYnVmZmVyLmdldFBhdGgoKSB8fCAnJztcbiAgICBpZiAocHJldkVkaXQgIT0gbnVsbCAmJiBlZGl0Lm9sZFJhbmdlLmVuZC5jb21wYXJlKHByZXZFZGl0Lm9sZFJhbmdlLnN0YXJ0KSA+IDApIHtcbiAgICAgIHRocm93IEVycm9yKGBGb3VuZCBvdmVybGFwcGluZyBlZGl0IHJhbmdlcyBpbiAke3BhdGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0Um93ID0gZWRpdC5vbGRSYW5nZS5zdGFydC5yb3c7XG4gICAgY29uc3Qgc3RhcnRDb2wgPSBlZGl0Lm9sZFJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gYnVmZmVyLmxpbmVMZW5ndGhGb3JSb3coc3RhcnRSb3cpO1xuICAgIGlmIChsaW5lTGVuZ3RoID09IG51bGwgfHwgc3RhcnRDb2wgPiBsaW5lTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihgT3V0IG9mIHJhbmdlIGVkaXQgb24gJHtwYXRofToke3N0YXJ0Um93ICsgMX06JHtzdGFydENvbCArIDF9YCk7XG4gICAgfVxuICB9XG59XG4iXX0=