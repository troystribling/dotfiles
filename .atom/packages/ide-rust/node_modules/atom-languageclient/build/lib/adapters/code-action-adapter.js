"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const convert_1 = require("../convert");
class CodeActionAdapter {
    // Returns a {Boolean} indicating this adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.codeActionProvider === true;
    }
    // Public: Retrieves code actions for a given editor, range, and context (diagnostics).
    // Throws an error if codeActionProvider is not a registered capability.
    //
    // * `connection` A {LanguageClientConnection} to the language server that provides highlights.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `editor` The Atom {TextEditor} containing the diagnostics.
    // * `range` The Atom {Range} to fetch code actions for.
    // * `diagnostics` An {Array<atomIde$Diagnostic>} to fetch code actions for.
    //                 This is typically a list of diagnostics intersecting `range`.
    //
    // Returns a {Promise} of an {Array} of {atomIde$CodeAction}s to display.
    static getCodeActions(connection, serverCapabilities, linterAdapter, editor, range, diagnostics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (linterAdapter == null) {
                return [];
            }
            assert(serverCapabilities.codeActionProvider, 'Must have the textDocument/codeAction capability');
            const commands = yield connection.codeAction({
                textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
                range: convert_1.default.atomRangeToLSRange(range),
                context: {
                    diagnostics: diagnostics.map((diagnostic) => {
                        // Retrieve the stored diagnostic code if it exists.
                        // Until the Linter API provides a place to store the code,
                        // there's no real way for the code actions API to give it back to us.
                        const converted = convert_1.default.atomIdeDiagnosticToLSDiagnostic(diagnostic);
                        if (diagnostic.range != null && diagnostic.text != null) {
                            const code = linterAdapter.getDiagnosticCode(editor, diagnostic.range, diagnostic.text);
                            if (code != null) {
                                converted.code = code;
                            }
                        }
                        return converted;
                    }),
                },
            });
            return commands.map((command) => ({
                apply() {
                    return __awaiter(this, void 0, void 0, function* () {
                        yield connection.executeCommand({
                            command: command.command,
                            arguments: command.arguments,
                        });
                    });
                },
                getTitle() {
                    return Promise.resolve(command.title);
                },
                // tslint:disable-next-line:no-empty
                dispose() { },
            }));
        });
    }
}
exports.default = CodeActionAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1hY3Rpb24tYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWFjdGlvbi1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFQSxpQ0FBa0M7QUFDbEMsd0NBQWlDO0FBVWpDO0lBQ0UsZ0ZBQWdGO0lBQ2hGLDRCQUE0QjtJQUNyQixNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxNQUFNLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLEtBQUssSUFBSSxDQUFDO0lBQ3hELENBQUM7SUFFRCx1RkFBdUY7SUFDdkYsd0VBQXdFO0lBQ3hFLEVBQUU7SUFDRiwrRkFBK0Y7SUFDL0YsNEZBQTRGO0lBQzVGLCtEQUErRDtJQUMvRCx3REFBd0Q7SUFDeEQsNEVBQTRFO0lBQzVFLGdGQUFnRjtJQUNoRixFQUFFO0lBQ0YseUVBQXlFO0lBQ2xFLE1BQU0sQ0FBTyxjQUFjLENBQ2hDLFVBQW9DLEVBQ3BDLGtCQUFzQyxFQUN0QyxhQUE4QyxFQUM5QyxNQUFrQixFQUNsQixLQUFZLEVBQ1osV0FBaUM7O1lBRWpDLEVBQUUsQ0FBQyxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUMxQixNQUFNLENBQUMsRUFBRSxDQUFDO1lBQ1osQ0FBQztZQUNELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsRUFBRSxrREFBa0QsQ0FBQyxDQUFDO1lBQ2xHLE1BQU0sUUFBUSxHQUFHLE1BQU0sVUFBVSxDQUFDLFVBQVUsQ0FBQztnQkFDM0MsWUFBWSxFQUFFLGlCQUFPLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDO2dCQUM1RCxLQUFLLEVBQUUsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUM7Z0JBQ3hDLE9BQU8sRUFBRTtvQkFDUCxXQUFXLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsRUFBRSxFQUFFO3dCQUMxQyxvREFBb0Q7d0JBQ3BELDJEQUEyRDt3QkFDM0Qsc0VBQXNFO3dCQUN0RSxNQUFNLFNBQVMsR0FBRyxpQkFBTyxDQUFDLCtCQUErQixDQUFDLFVBQVUsQ0FBQyxDQUFDO3dCQUN0RSxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7NEJBQ3hELE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQ3hGLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dDQUNqQixTQUFTLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs0QkFDeEIsQ0FBQzt3QkFDSCxDQUFDO3dCQUNELE1BQU0sQ0FBQyxTQUFTLENBQUM7b0JBQ25CLENBQUMsQ0FBQztpQkFDSDthQUNGLENBQUMsQ0FBQztZQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2dCQUMxQixLQUFLOzt3QkFDVCxNQUFNLFVBQVUsQ0FBQyxjQUFjLENBQUM7NEJBQzlCLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTzs0QkFDeEIsU0FBUyxFQUFFLE9BQU8sQ0FBQyxTQUFTO3lCQUM3QixDQUFDLENBQUM7b0JBQ0wsQ0FBQztpQkFBQTtnQkFDRCxRQUFRO29CQUNOLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDeEMsQ0FBQztnQkFDRCxvQ0FBb0M7Z0JBQ3BDLE9BQU8sS0FBSSxDQUFDO2FBQ2IsQ0FBQyxDQUFDLENBQUM7UUFDTixDQUFDO0tBQUE7Q0FDRjtBQS9ERCxvQ0ErREMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IExpbnRlclB1c2hWMkFkYXB0ZXIgZnJvbSAnLi9saW50ZXItcHVzaC12Mi1hZGFwdGVyJztcclxuaW1wb3J0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IHtcclxuICBUZXh0RWRpdG9yLFxyXG4gIFJhbmdlLFxyXG59IGZyb20gJ2F0b20nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29kZUFjdGlvbkFkYXB0ZXIge1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyB0aGlzIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHB1YmxpYyBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuY29kZUFjdGlvblByb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBSZXRyaWV2ZXMgY29kZSBhY3Rpb25zIGZvciBhIGdpdmVuIGVkaXRvciwgcmFuZ2UsIGFuZCBjb250ZXh0IChkaWFnbm9zdGljcykuXHJcbiAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGNvZGVBY3Rpb25Qcm92aWRlciBpcyBub3QgYSByZWdpc3RlcmVkIGNhcGFiaWxpdHkuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCBwcm92aWRlcyBoaWdobGlnaHRzLlxyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHVzZWQuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZGlhZ25vc3RpY3MuXHJcbiAgLy8gKiBgcmFuZ2VgIFRoZSBBdG9tIHtSYW5nZX0gdG8gZmV0Y2ggY29kZSBhY3Rpb25zIGZvci5cclxuICAvLyAqIGBkaWFnbm9zdGljc2AgQW4ge0FycmF5PGF0b21JZGUkRGlhZ25vc3RpYz59IHRvIGZldGNoIGNvZGUgYWN0aW9ucyBmb3IuXHJcbiAgLy8gICAgICAgICAgICAgICAgIFRoaXMgaXMgdHlwaWNhbGx5IGEgbGlzdCBvZiBkaWFnbm9zdGljcyBpbnRlcnNlY3RpbmcgYHJhbmdlYC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7YXRvbUlkZSRDb2RlQWN0aW9ufXMgdG8gZGlzcGxheS5cclxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGdldENvZGVBY3Rpb25zKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgICBsaW50ZXJBZGFwdGVyOiBMaW50ZXJQdXNoVjJBZGFwdGVyIHwgdW5kZWZpbmVkICxcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHJhbmdlOiBSYW5nZSxcclxuICAgIGRpYWdub3N0aWNzOiBhdG9tSWRlLkRpYWdub3N0aWNbXSxcclxuICApOiBQcm9taXNlPGF0b21JZGUuQ29kZUFjdGlvbltdPiB7XHJcbiAgICBpZiAobGludGVyQWRhcHRlciA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGFzc2VydChzZXJ2ZXJDYXBhYmlsaXRpZXMuY29kZUFjdGlvblByb3ZpZGVyLCAnTXVzdCBoYXZlIHRoZSB0ZXh0RG9jdW1lbnQvY29kZUFjdGlvbiBjYXBhYmlsaXR5Jyk7XHJcbiAgICBjb25zdCBjb21tYW5kcyA9IGF3YWl0IGNvbm5lY3Rpb24uY29kZUFjdGlvbih7XHJcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcclxuICAgICAgcmFuZ2U6IENvbnZlcnQuYXRvbVJhbmdlVG9MU1JhbmdlKHJhbmdlKSxcclxuICAgICAgY29udGV4dDoge1xyXG4gICAgICAgIGRpYWdub3N0aWNzOiBkaWFnbm9zdGljcy5tYXAoKGRpYWdub3N0aWMpID0+IHtcclxuICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBzdG9yZWQgZGlhZ25vc3RpYyBjb2RlIGlmIGl0IGV4aXN0cy5cclxuICAgICAgICAgIC8vIFVudGlsIHRoZSBMaW50ZXIgQVBJIHByb3ZpZGVzIGEgcGxhY2UgdG8gc3RvcmUgdGhlIGNvZGUsXHJcbiAgICAgICAgICAvLyB0aGVyZSdzIG5vIHJlYWwgd2F5IGZvciB0aGUgY29kZSBhY3Rpb25zIEFQSSB0byBnaXZlIGl0IGJhY2sgdG8gdXMuXHJcbiAgICAgICAgICBjb25zdCBjb252ZXJ0ZWQgPSBDb252ZXJ0LmF0b21JZGVEaWFnbm9zdGljVG9MU0RpYWdub3N0aWMoZGlhZ25vc3RpYyk7XHJcbiAgICAgICAgICBpZiAoZGlhZ25vc3RpYy5yYW5nZSAhPSBudWxsICYmIGRpYWdub3N0aWMudGV4dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBsaW50ZXJBZGFwdGVyLmdldERpYWdub3N0aWNDb2RlKGVkaXRvciwgZGlhZ25vc3RpYy5yYW5nZSwgZGlhZ25vc3RpYy50ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIGNvbnZlcnRlZC5jb2RlID0gY29kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRlZDtcclxuICAgICAgICB9KSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNvbW1hbmRzLm1hcCgoY29tbWFuZCkgPT4gKHtcclxuICAgICAgYXN5bmMgYXBwbHkoKSB7XHJcbiAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5leGVjdXRlQ29tbWFuZCh7XHJcbiAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLmNvbW1hbmQsXHJcbiAgICAgICAgICBhcmd1bWVudHM6IGNvbW1hbmQuYXJndW1lbnRzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRUaXRsZSgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbW1hbmQudGl0bGUpO1xyXG4gICAgICB9LFxyXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcclxuICAgICAgZGlzcG9zZSgpIHt9LFxyXG4gICAgfSkpO1xyXG4gIH1cclxufVxyXG4iXX0=