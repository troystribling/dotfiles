Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class CodeActionAdapter {
  // Returns a {Boolean} indicating this adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.codeActionProvider === true;
  }

  // Public: Retrieves code actions for a given editor, range, and context (diagnostics).
  // Throws an error if codeActionProvider is not a registered capability.
  //
  // * `connection` A {LanguageClientConnection} to the language server that provides highlights.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `editor` The Atom {TextEditor} containing the diagnostics.
  // * `range` The Atom {Range} to fetch code actions for.
  // * `diagnostics` An {Array<atomIde$Diagnostic>} to fetch code actions for.
  //                 This is typically a list of diagnostics intersecting `range`.
  //
  // Returns a {Promise} of an {Array} of {atomIde$CodeAction}s to display.
  static async getCodeActions(connection, serverCapabilities, linterAdapter, editor, range, diagnostics) {
    if (linterAdapter == null) {
      return [];
    }
    (0, _assert2.default)(serverCapabilities.codeActionProvider, 'Must have the textDocument/codeAction capability');
    const commands = await connection.codeAction({
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      range: _convert2.default.atomRangeToLSRange(range),
      context: {
        diagnostics: diagnostics.map(diagnostic => {
          // Retrieve the stored diagnostic code if it exists.
          // Until the Linter API provides a place to store the code,
          // there's no real way for the code actions API to give it back to us.
          const converted = _convert2.default.atomIdeDiagnosticToLSDiagnostic(diagnostic);
          if (diagnostic.range != null && diagnostic.text != null) {
            const code = linterAdapter.getDiagnosticCode(editor, diagnostic.range, diagnostic.text);
            if (code != null) {
              converted.code = code;
            }
          }
          return converted;
        })
      }
    });
    return commands.map(command => ({
      async apply() {
        await connection.executeCommand({
          command: command.command,
          arguments: command.arguments
        });
      },
      getTitle() {
        return Promise.resolve(command.title);
      },
      dispose() {}
    }));
  }
}
exports.default = CodeActionAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWFjdGlvbi1hZGFwdGVyLmpzIl0sIm5hbWVzIjpbIkNvZGVBY3Rpb25BZGFwdGVyIiwiY2FuQWRhcHQiLCJzZXJ2ZXJDYXBhYmlsaXRpZXMiLCJjb2RlQWN0aW9uUHJvdmlkZXIiLCJnZXRDb2RlQWN0aW9ucyIsImNvbm5lY3Rpb24iLCJsaW50ZXJBZGFwdGVyIiwiZWRpdG9yIiwicmFuZ2UiLCJkaWFnbm9zdGljcyIsImNvbW1hbmRzIiwiY29kZUFjdGlvbiIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsImF0b21SYW5nZVRvTFNSYW5nZSIsImNvbnRleHQiLCJtYXAiLCJkaWFnbm9zdGljIiwiY29udmVydGVkIiwiYXRvbUlkZURpYWdub3N0aWNUb0xTRGlhZ25vc3RpYyIsInRleHQiLCJjb2RlIiwiZ2V0RGlhZ25vc3RpY0NvZGUiLCJjb21tYW5kIiwiYXBwbHkiLCJleGVjdXRlQ29tbWFuZCIsImFyZ3VtZW50cyIsImdldFRpdGxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aXRsZSIsImRpc3Bvc2UiXSwibWFwcGluZ3MiOiI7Ozs7QUFJQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFFZSxNQUFNQSxpQkFBTixDQUF3QjtBQUNyQztBQUNBO0FBQ0EsU0FBT0MsUUFBUCxDQUFnQkMsa0JBQWhCLEVBQWlFO0FBQy9ELFdBQU9BLG1CQUFtQkMsa0JBQW5CLEtBQTBDLElBQWpEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWFDLGNBQWIsQ0FDRUMsVUFERixFQUVFSCxrQkFGRixFQUdFSSxhQUhGLEVBSUVDLE1BSkYsRUFLRUMsS0FMRixFQU1FQyxXQU5GLEVBT3NDO0FBQ3BDLFFBQUlILGlCQUFpQixJQUFyQixFQUEyQjtBQUN6QixhQUFPLEVBQVA7QUFDRDtBQUNELDBCQUFVSixtQkFBbUJDLGtCQUE3QixFQUFpRCxrREFBakQ7QUFDQSxVQUFNTyxXQUFXLE1BQU1MLFdBQVdNLFVBQVgsQ0FBc0I7QUFDM0NDLG9CQUFjLGtCQUFRQyw4QkFBUixDQUF1Q04sTUFBdkMsQ0FENkI7QUFFM0NDLGFBQU8sa0JBQVFNLGtCQUFSLENBQTJCTixLQUEzQixDQUZvQztBQUczQ08sZUFBUztBQUNQTixxQkFBYUEsWUFBWU8sR0FBWixDQUFnQkMsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBTUMsWUFBWSxrQkFBUUMsK0JBQVIsQ0FBd0NGLFVBQXhDLENBQWxCO0FBQ0EsY0FBSUEsV0FBV1QsS0FBWCxJQUFvQixJQUFwQixJQUE0QlMsV0FBV0csSUFBWCxJQUFtQixJQUFuRCxFQUF5RDtBQUN2RCxrQkFBTUMsT0FBT2YsY0FBY2dCLGlCQUFkLENBQWdDZixNQUFoQyxFQUF3Q1UsV0FBV1QsS0FBbkQsRUFBMERTLFdBQVdHLElBQXJFLENBQWI7QUFDQSxnQkFBSUMsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCSCx3QkFBVUcsSUFBVixHQUFpQkEsSUFBakI7QUFDRDtBQUNGO0FBQ0QsaUJBQU9ILFNBQVA7QUFDRCxTQVpZO0FBRE47QUFIa0MsS0FBdEIsQ0FBdkI7QUFtQkEsV0FBT1IsU0FBU00sR0FBVCxDQUFhTyxZQUFZO0FBQzlCLFlBQU1DLEtBQU4sR0FBYztBQUNaLGNBQU1uQixXQUFXb0IsY0FBWCxDQUEwQjtBQUM5QkYsbUJBQVNBLFFBQVFBLE9BRGE7QUFFOUJHLHFCQUFXSCxRQUFRRztBQUZXLFNBQTFCLENBQU47QUFJRCxPQU42QjtBQU85QkMsaUJBQVc7QUFDVCxlQUFPQyxRQUFRQyxPQUFSLENBQWdCTixRQUFRTyxLQUF4QixDQUFQO0FBQ0QsT0FUNkI7QUFVOUJDLGdCQUFVLENBQUU7QUFWa0IsS0FBWixDQUFiLENBQVA7QUFZRDtBQTdEb0M7a0JBQWxCL0IsaUIiLCJmaWxlIjoiY29kZS1hY3Rpb24tYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XHJcblxyXG5pbXBvcnQgdHlwZSBMaW50ZXJQdXNoVjJBZGFwdGVyIGZyb20gJy4vbGludGVyLXB1c2gtdjItYWRhcHRlcic7XHJcblxyXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XHJcbmltcG9ydCB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCB0eXBlIFNlcnZlckNhcGFiaWxpdGllc30gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvZGVBY3Rpb25BZGFwdGVyIHtcclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgdGhpcyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuY29kZUFjdGlvblByb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBSZXRyaWV2ZXMgY29kZSBhY3Rpb25zIGZvciBhIGdpdmVuIGVkaXRvciwgcmFuZ2UsIGFuZCBjb250ZXh0IChkaWFnbm9zdGljcykuXHJcbiAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIGNvZGVBY3Rpb25Qcm92aWRlciBpcyBub3QgYSByZWdpc3RlcmVkIGNhcGFiaWxpdHkuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCBwcm92aWRlcyBoaWdobGlnaHRzLlxyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHVzZWQuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZGlhZ25vc3RpY3MuXHJcbiAgLy8gKiBgcmFuZ2VgIFRoZSBBdG9tIHtSYW5nZX0gdG8gZmV0Y2ggY29kZSBhY3Rpb25zIGZvci5cclxuICAvLyAqIGBkaWFnbm9zdGljc2AgQW4ge0FycmF5PGF0b21JZGUkRGlhZ25vc3RpYz59IHRvIGZldGNoIGNvZGUgYWN0aW9ucyBmb3IuXHJcbiAgLy8gICAgICAgICAgICAgICAgIFRoaXMgaXMgdHlwaWNhbGx5IGEgbGlzdCBvZiBkaWFnbm9zdGljcyBpbnRlcnNlY3RpbmcgYHJhbmdlYC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7YXRvbUlkZSRDb2RlQWN0aW9ufXMgdG8gZGlzcGxheS5cclxuICBzdGF0aWMgYXN5bmMgZ2V0Q29kZUFjdGlvbnMoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcclxuICAgIGxpbnRlckFkYXB0ZXI6ID9MaW50ZXJQdXNoVjJBZGFwdGVyLFxyXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXHJcbiAgICByYW5nZTogYXRvbSRSYW5nZSxcclxuICAgIGRpYWdub3N0aWNzOiBBcnJheTxhdG9tSWRlJERpYWdub3N0aWM+LFxyXG4gICk6IFByb21pc2U8QXJyYXk8YXRvbUlkZSRDb2RlQWN0aW9uPj4ge1xyXG4gICAgaWYgKGxpbnRlckFkYXB0ZXIgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICBpbnZhcmlhbnQoc2VydmVyQ2FwYWJpbGl0aWVzLmNvZGVBY3Rpb25Qcm92aWRlciwgJ011c3QgaGF2ZSB0aGUgdGV4dERvY3VtZW50L2NvZGVBY3Rpb24gY2FwYWJpbGl0eScpO1xyXG4gICAgY29uc3QgY29tbWFuZHMgPSBhd2FpdCBjb25uZWN0aW9uLmNvZGVBY3Rpb24oe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICAgIHJhbmdlOiBDb252ZXJ0LmF0b21SYW5nZVRvTFNSYW5nZShyYW5nZSksXHJcbiAgICAgIGNvbnRleHQ6IHtcclxuICAgICAgICBkaWFnbm9zdGljczogZGlhZ25vc3RpY3MubWFwKGRpYWdub3N0aWMgPT4ge1xyXG4gICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHN0b3JlZCBkaWFnbm9zdGljIGNvZGUgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICAgLy8gVW50aWwgdGhlIExpbnRlciBBUEkgcHJvdmlkZXMgYSBwbGFjZSB0byBzdG9yZSB0aGUgY29kZSxcclxuICAgICAgICAgIC8vIHRoZXJlJ3Mgbm8gcmVhbCB3YXkgZm9yIHRoZSBjb2RlIGFjdGlvbnMgQVBJIHRvIGdpdmUgaXQgYmFjayB0byB1cy5cclxuICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZCA9IENvbnZlcnQuYXRvbUlkZURpYWdub3N0aWNUb0xTRGlhZ25vc3RpYyhkaWFnbm9zdGljKTtcclxuICAgICAgICAgIGlmIChkaWFnbm9zdGljLnJhbmdlICE9IG51bGwgJiYgZGlhZ25vc3RpYy50ZXh0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGxpbnRlckFkYXB0ZXIuZ2V0RGlhZ25vc3RpY0NvZGUoZWRpdG9yLCBkaWFnbm9zdGljLnJhbmdlLCBkaWFnbm9zdGljLnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoY29kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgY29udmVydGVkLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gY29udmVydGVkO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29tbWFuZHMubWFwKGNvbW1hbmQgPT4gKHtcclxuICAgICAgYXN5bmMgYXBwbHkoKSB7XHJcbiAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5leGVjdXRlQ29tbWFuZCh7XHJcbiAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLmNvbW1hbmQsXHJcbiAgICAgICAgICBhcmd1bWVudHM6IGNvbW1hbmQuYXJndW1lbnRzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBnZXRUaXRsZSgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbW1hbmQudGl0bGUpO1xyXG4gICAgICB9LFxyXG4gICAgICBkaXNwb3NlKCkge30sXHJcbiAgICB9KSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==