Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the language server protocol "textDocument/completion" to the
// Atom IDE UI Code-format package.
let CodeFormatAdapter = class CodeFormatAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing either a documentFormattingProvider
  // or a documentRangeFormattingProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating this adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentRangeFormattingProvider === true || serverCapabilities.documentFormattingProvider === true;
  }

  // Public: Format text in the editor using the given language server connection and an optional range.
  // If the server does not support range formatting then range will be ignored and the entire document formatted.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will format the text.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `editor` The Atom {TextEditor} containing the text that will be formatted.
  // * `range` The optional Atom {Range} containing the subset of the text to be formatted.
  //
  // Returns a {Promise} of an {Array} of {Object}s containing the AutoComplete+
  // suggestions to display.
  static format(connection, serverCapabilities, editor, range) {
    if (serverCapabilities.documentRangeFormattingProvider) {
      return CodeFormatAdapter.formatRange(connection, editor, range);
    }

    if (serverCapabilities.documentFormattingProvider) {
      return CodeFormatAdapter.formatDocument(connection, editor);
    }

    throw new Error('Can not format document, language server does not support it');
  }

  // Public: Format the entire document of an Atom {TextEditor} by using a given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will format the text.
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  //
  // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
  // to format the document.
  static formatDocument(connection, editor) {
    return _asyncToGenerator(function* () {
      const edits = yield connection.documentFormatting(CodeFormatAdapter.createDocumentFormattingParams(editor));
      return CodeFormatAdapter.convertLsTextEdits(edits);
    })();
  }

  // Public: Create {DocumentFormattingParams} to be sent to the language server when requesting an
  // entire document is formatted.
  //
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  //
  // Returns {DocumentFormattingParams} containing the identity of the text document as well as
  // options to be used in formatting the document such as tab size and tabs vs spaces.
  static createDocumentFormattingParams(editor) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      options: CodeFormatAdapter.getFormatOptions(editor)
    };
  }

  // Public: Format a range within an Atom {TextEditor} by using a given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will format the text.
  // * `range` The Atom {Range} containing the range of text that should be formatted.
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  //
  // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
  // to format the document.
  static formatRange(connection, editor, range) {
    return _asyncToGenerator(function* () {
      const edits = yield connection.documentRangeFormatting(CodeFormatAdapter.createDocumentRangeFormattingParams(editor, range));
      return CodeFormatAdapter.convertLsTextEdits(edits);
    })();
  }

  // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
  // entire document is formatted.
  //
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  // * `range` The Atom {Range} containing the range of text that should be formatted.
  //
  // Returns {DocumentRangeFormattingParams} containing the identity of the text document, the
  // range of the text to be formatted as well as the options to be used in formatting the
  // document such as tab size and tabs vs spaces.
  static createDocumentRangeFormattingParams(editor, range) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      range: _convert2.default.atomRangeToLSRange(range),
      options: CodeFormatAdapter.getFormatOptions(editor)
    };
  }

  // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
  // entire document is formatted.
  //
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  // * `range` The Atom {Range} containing the range of document that should be formatted.
  //
  // Returns the {FormattingOptions} to be used containing the keys:
  //  * `tabSize` The number of spaces a tab represents.
  //  * `insertSpaces` {True} if spaces should be used, {False} for tab characters.
  static getFormatOptions(editor) {
    return {
      tabSize: editor.getTabLength(),
      insertSpaces: editor.getSoftTabs()
    };
  }

  // Public: Convert an array of language server protocol {TextEdit} objects to an
  // equivalent array of Atom {TextEdit} objects.
  //
  // * `textEdits` The language server protocol {TextEdit} objects to convert.
  //
  // Returns an {Array} of Atom {TextEdit} objects.
  static convertLsTextEdits(textEdits) {
    return textEdits.map(CodeFormatAdapter.convertLsTextEdit);
  }

  // Public: Convert a language server protocol {TextEdit} object to the
  // Atom equivalent {TextEdit}.
  //
  // * `textEdits` The language server protocol {TextEdit} objects to convert.
  //
  // Returns an Atom {TextEdit} object.
  static convertLsTextEdit(textEdit) {
    return {
      oldRange: _convert2.default.lsRangeToAtomRange(textEdit.range),
      newText: textEdit.newText
    };
  }
};
exports.default = CodeFormatAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyLmpzIl0sIm5hbWVzIjpbIkNvZGVGb3JtYXRBZGFwdGVyIiwiY2FuQWRhcHQiLCJzZXJ2ZXJDYXBhYmlsaXRpZXMiLCJkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyIiwiZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIiLCJmb3JtYXQiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicmFuZ2UiLCJmb3JtYXRSYW5nZSIsImZvcm1hdERvY3VtZW50IiwiRXJyb3IiLCJlZGl0cyIsImRvY3VtZW50Rm9ybWF0dGluZyIsImNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyIsImNvbnZlcnRMc1RleHRFZGl0cyIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsIm9wdGlvbnMiLCJnZXRGb3JtYXRPcHRpb25zIiwiZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmciLCJjcmVhdGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtcyIsImF0b21SYW5nZVRvTFNSYW5nZSIsInRhYlNpemUiLCJnZXRUYWJMZW5ndGgiLCJpbnNlcnRTcGFjZXMiLCJnZXRTb2Z0VGFicyIsInRleHRFZGl0cyIsIm1hcCIsImNvbnZlcnRMc1RleHRFZGl0IiwidGV4dEVkaXQiLCJvbGRSYW5nZSIsImxzUmFuZ2VUb0F0b21SYW5nZSIsIm5ld1RleHQiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBUUE7Ozs7Ozs7O0FBRUE7QUFDQTtJQUNxQkEsaUIsR0FBTixNQUFNQSxpQkFBTixDQUF3Qjs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLCtCQUFuQixLQUF1RCxJQUF2RCxJQUErREQsbUJBQW1CRSwwQkFBbkIsS0FBa0QsSUFBeEg7QUFDRDs7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b250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgdHlwZSBEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMsXG4gIHR5cGUgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMsXG4gIHR5cGUgRm9ybWF0dGluZ09wdGlvbnMsXG4gIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzLFxuICB0eXBlIFRleHRFZGl0XG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIFwidGV4dERvY3VtZW50L2NvbXBsZXRpb25cIiB0byB0aGVcbi8vIEF0b20gSURFIFVJIENvZGUtZm9ybWF0IHBhY2thZ2UuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2RlRm9ybWF0QWRhcHRlciB7XG5cbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBlaXRoZXIgYSBkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlclxuICAvLyBvciBhIGRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIuXG4gIC8vXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyB0aGlzIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyID09PSB0cnVlIHx8IHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogRm9ybWF0IHRleHQgaW4gdGhlIGVkaXRvciB1c2luZyB0aGUgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyIGNvbm5lY3Rpb24gYW5kIGFuIG9wdGlvbmFsIHJhbmdlLlxuICAvLyBJZiB0aGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgcmFuZ2UgZm9ybWF0dGluZyB0aGVuIHJhbmdlIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIGVudGlyZSBkb2N1bWVudCBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSB1c2VkLlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoYXQgd2lsbCBiZSBmb3JtYXR0ZWQuXG4gIC8vICogYHJhbmdlYCBUaGUgb3B0aW9uYWwgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHN1YnNldCBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7T2JqZWN0fXMgY29udGFpbmluZyB0aGUgQXV0b0NvbXBsZXRlK1xuICAvLyBzdWdnZXN0aW9ucyB0byBkaXNwbGF5LlxuICBzdGF0aWMgZm9ybWF0KGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMsIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCByYW5nZTogYXRvbSRSYW5nZSk6IFByb21pc2U8QXJyYXk8bnVjbGlkZSRUZXh0RWRpdD4+IHtcbiAgICBpZiAoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBDb2RlRm9ybWF0QWRhcHRlci5mb3JtYXRSYW5nZShjb25uZWN0aW9uLCBlZGl0b3IsIHJhbmdlKTtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50Rm9ybWF0dGluZ1Byb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuZm9ybWF0RG9jdW1lbnQoY29ubmVjdGlvbiwgZWRpdG9yKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZm9ybWF0IGRvY3VtZW50LCBsYW5ndWFnZSBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBpdCcpO1xuICB9XG5cbiAgLy8gUHVibGljOiBGb3JtYXQgdGhlIGVudGlyZSBkb2N1bWVudCBvZiBhbiBBdG9tIHtUZXh0RWRpdG9yfSBieSB1c2luZyBhIGdpdmVuIGxhbmd1YWdlIHNlcnZlci5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBmb3JtYXQgdGhlIHRleHQuXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHtUZXh0RWRpdH0gb2JqZWN0cyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBBdG9tIFRleHRFZGl0b3JcbiAgLy8gdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cbiAgc3RhdGljIGFzeW5jIGZvcm1hdERvY3VtZW50KGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiBQcm9taXNlPEFycmF5PG51Y2xpZGUkVGV4dEVkaXQ+PiB7XG4gICAgY29uc3QgZWRpdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50Rm9ybWF0dGluZyhDb2RlRm9ybWF0QWRhcHRlci5jcmVhdGVEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMoZWRpdG9yKSk7XG4gICAgcmV0dXJuIENvZGVGb3JtYXRBZGFwdGVyLmNvbnZlcnRMc1RleHRFZGl0cyhlZGl0cyk7XG4gIH1cblxuICAvLyBQdWJsaWM6IENyZWF0ZSB7RG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zfSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgd2hlbiByZXF1ZXN0aW5nIGFuXG4gIC8vIGVudGlyZSBkb2N1bWVudCBpcyBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgLy9cbiAgLy8gUmV0dXJucyB7RG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zfSBjb250YWluaW5nIHRoZSBpZGVudGl0eSBvZiB0aGUgdGV4dCBkb2N1bWVudCBhcyB3ZWxsIGFzXG4gIC8vIG9wdGlvbnMgdG8gYmUgdXNlZCBpbiBmb3JtYXR0aW5nIHRoZSBkb2N1bWVudCBzdWNoIGFzIHRhYiBzaXplIGFuZCB0YWJzIHZzIHNwYWNlcy5cbiAgc3RhdGljIGNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IERvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBGb3JtYXQgYSByYW5nZSB3aXRoaW4gYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAvLyAqIGByYW5nZWAgVGhlIEF0b20ge1JhbmdlfSBjb250YWluaW5nIHRoZSByYW5nZSBvZiB0ZXh0IHRoYXQgc2hvdWxkIGJlIGZvcm1hdHRlZC5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IG9mIGFuIHtBcnJheX0gb2Yge1RleHRFZGl0fSBvYmplY3RzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIEF0b20gVGV4dEVkaXRvclxuICAvLyB0byBmb3JtYXQgdGhlIGRvY3VtZW50LlxuICBzdGF0aWMgYXN5bmMgZm9ybWF0UmFuZ2UoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcmFuZ2U6IGF0b20kUmFuZ2UpOiBQcm9taXNlPEFycmF5PG51Y2xpZGUkVGV4dEVkaXQ+PiB7XG4gICAgY29uc3QgZWRpdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nKENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zKGVkaXRvciwgcmFuZ2UpKTtcbiAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuY29udmVydExzVGV4dEVkaXRzKGVkaXRzKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vICogYHJhbmdlYCBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIHRleHQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQsIHRoZVxuICAvLyByYW5nZSBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQgYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyB0byBiZSB1c2VkIGluIGZvcm1hdHRpbmcgdGhlXG4gIC8vIGRvY3VtZW50IHN1Y2ggYXMgdGFiIHNpemUgYW5kIHRhYnMgdnMgc3BhY2VzLlxuICBzdGF0aWMgY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHJhbmdlOiBhdG9tJFJhbmdlKTogRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXG4gICAgICByYW5nZTogQ29udmVydC5hdG9tUmFuZ2VUb0xTUmFuZ2UocmFuZ2UpLFxuICAgICAgb3B0aW9uczogQ29kZUZvcm1hdEFkYXB0ZXIuZ2V0Rm9ybWF0T3B0aW9ucyhlZGl0b3IpLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IENyZWF0ZSB7RG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXN9IHRvIGJlIHNlbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB3aGVuIHJlcXVlc3RpbmcgYW5cbiAgLy8gZW50aXJlIGRvY3VtZW50IGlzIGZvcm1hdHRlZC5cbiAgLy9cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgZG9jdW1lbnQgdG8gYmUgZm9ybWF0dGVkLlxuICAvLyAqIGByYW5nZWAgVGhlIEF0b20ge1JhbmdlfSBjb250YWluaW5nIHRoZSByYW5nZSBvZiBkb2N1bWVudCB0aGF0IHNob3VsZCBiZSBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnMgdGhlIHtGb3JtYXR0aW5nT3B0aW9uc30gdG8gYmUgdXNlZCBjb250YWluaW5nIHRoZSBrZXlzOlxuICAvLyAgKiBgdGFiU2l6ZWAgVGhlIG51bWJlciBvZiBzcGFjZXMgYSB0YWIgcmVwcmVzZW50cy5cbiAgLy8gICogYGluc2VydFNwYWNlc2Age1RydWV9IGlmIHNwYWNlcyBzaG91bGQgYmUgdXNlZCwge0ZhbHNlfSBmb3IgdGFiIGNoYXJhY3RlcnMuXG4gIHN0YXRpYyBnZXRGb3JtYXRPcHRpb25zKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogRm9ybWF0dGluZ09wdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJTaXplOiBlZGl0b3IuZ2V0VGFiTGVuZ3RoKCksXG4gICAgICBpbnNlcnRTcGFjZXM6IGVkaXRvci5nZXRTb2Z0VGFicygpLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gYXJyYXkgb2YgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIHtUZXh0RWRpdH0gb2JqZWN0cyB0byBhblxuICAvLyBlcXVpdmFsZW50IGFycmF5IG9mIEF0b20ge1RleHRFZGl0fSBvYmplY3RzLlxuICAvL1xuICAvLyAqIGB0ZXh0RWRpdHNgIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wge1RleHRFZGl0fSBvYmplY3RzIHRvIGNvbnZlcnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYW4ge0FycmF5fSBvZiBBdG9tIHtUZXh0RWRpdH0gb2JqZWN0cy5cbiAgc3RhdGljIGNvbnZlcnRMc1RleHRFZGl0cyh0ZXh0RWRpdHM6IEFycmF5PFRleHRFZGl0Pik6IEFycmF5PG51Y2xpZGUkVGV4dEVkaXQ+IHtcbiAgICByZXR1cm4gdGV4dEVkaXRzLm1hcChDb2RlRm9ybWF0QWRhcHRlci5jb252ZXJ0THNUZXh0RWRpdCk7XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wge1RleHRFZGl0fSBvYmplY3QgdG8gdGhlXG4gIC8vIEF0b20gZXF1aXZhbGVudCB7VGV4dEVkaXR9LlxuICAvL1xuICAvLyAqIGB0ZXh0RWRpdHNgIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wge1RleHRFZGl0fSBvYmplY3RzIHRvIGNvbnZlcnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYW4gQXRvbSB7VGV4dEVkaXR9IG9iamVjdC5cbiAgc3RhdGljIGNvbnZlcnRMc1RleHRFZGl0KHRleHRFZGl0OiBUZXh0RWRpdCk6IG51Y2xpZGUkVGV4dEVkaXQge1xuICAgIHJldHVybiB7XG4gICAgICBvbGRSYW5nZTogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UodGV4dEVkaXQucmFuZ2UpLFxuICAgICAgbmV3VGV4dDogdGV4dEVkaXQubmV3VGV4dFxuICAgIH1cbiAgfVxufVxuIl19