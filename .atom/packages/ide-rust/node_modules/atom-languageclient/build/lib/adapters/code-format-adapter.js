Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server protocol "textDocument/completion" to the
// Atom IDE UI Code-format package.
class CodeFormatAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing either a documentFormattingProvider
  // or a documentRangeFormattingProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating this adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentRangeFormattingProvider === true || serverCapabilities.documentFormattingProvider === true;
  }

  // Public: Format text in the editor using the given language server connection and an optional range.
  // If the server does not support range formatting then range will be ignored and the entire document formatted.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will format the text.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `editor` The Atom {TextEditor} containing the text that will be formatted.
  // * `range` The optional Atom {Range} containing the subset of the text to be formatted.
  //
  // Returns a {Promise} of an {Array} of {Object}s containing the AutoComplete+
  // suggestions to display.
  static format(connection, serverCapabilities, editor, range) {
    if (serverCapabilities.documentRangeFormattingProvider) {
      return CodeFormatAdapter.formatRange(connection, editor, range);
    }

    if (serverCapabilities.documentFormattingProvider) {
      return CodeFormatAdapter.formatDocument(connection, editor);
    }

    throw new Error('Can not format document, language server does not support it');
  }

  // Public: Format the entire document of an Atom {TextEditor} by using a given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will format the text.
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  //
  // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
  // to format the document.
  static async formatDocument(connection, editor) {
    const edits = await connection.documentFormatting(CodeFormatAdapter.createDocumentFormattingParams(editor));
    return _convert2.default.convertLsTextEdits(edits);
  }

  // Public: Create {DocumentFormattingParams} to be sent to the language server when requesting an
  // entire document is formatted.
  //
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  //
  // Returns {DocumentFormattingParams} containing the identity of the text document as well as
  // options to be used in formatting the document such as tab size and tabs vs spaces.
  static createDocumentFormattingParams(editor) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      options: CodeFormatAdapter.getFormatOptions(editor)
    };
  }

  // Public: Format a range within an Atom {TextEditor} by using a given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will format the text.
  // * `range` The Atom {Range} containing the range of text that should be formatted.
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  //
  // Returns a {Promise} of an {Array} of {TextEdit} objects that can be applied to the Atom TextEditor
  // to format the document.
  static async formatRange(connection, editor, range) {
    const edits = await connection.documentRangeFormatting(CodeFormatAdapter.createDocumentRangeFormattingParams(editor, range));
    return _convert2.default.convertLsTextEdits(edits);
  }

  // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
  // entire document is formatted.
  //
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  // * `range` The Atom {Range} containing the range of text that should be formatted.
  //
  // Returns {DocumentRangeFormattingParams} containing the identity of the text document, the
  // range of the text to be formatted as well as the options to be used in formatting the
  // document such as tab size and tabs vs spaces.
  static createDocumentRangeFormattingParams(editor, range) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      range: _convert2.default.atomRangeToLSRange(range),
      options: CodeFormatAdapter.getFormatOptions(editor)
    };
  }

  // Public: Create {DocumentRangeFormattingParams} to be sent to the language server when requesting an
  // entire document is formatted.
  //
  // * `editor` The Atom {TextEditor} containing the document to be formatted.
  // * `range` The Atom {Range} containing the range of document that should be formatted.
  //
  // Returns the {FormattingOptions} to be used containing the keys:
  //  * `tabSize` The number of spaces a tab represents.
  //  * `insertSpaces` {True} if spaces should be used, {False} for tab characters.
  static getFormatOptions(editor) {
    return {
      tabSize: editor.getTabLength(),
      insertSpaces: editor.getSoftTabs()
    };
  }
}
exports.default = CodeFormatAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyLmpzIl0sIm5hbWVzIjpbIkNvZGVGb3JtYXRBZGFwdGVyIiwiY2FuQWRhcHQiLCJzZXJ2ZXJDYXBhYmlsaXRpZXMiLCJkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyIiwiZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIiLCJmb3JtYXQiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicmFuZ2UiLCJmb3JtYXRSYW5nZSIsImZvcm1hdERvY3VtZW50IiwiRXJyb3IiLCJlZGl0cyIsImRvY3VtZW50Rm9ybWF0dGluZyIsImNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyIsImNvbnZlcnRMc1RleHRFZGl0cyIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsIm9wdGlvbnMiLCJnZXRGb3JtYXRPcHRpb25zIiwiZG9jdW1lbnRSYW5nZUZvcm1hdHRpbmciLCJjcmVhdGVEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtcyIsImF0b21SYW5nZVRvTFNSYW5nZSIsInRhYlNpemUiLCJnZXRUYWJMZW5ndGgiLCJpbnNlcnRTcGFjZXMiLCJnZXRTb2Z0VGFicyJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOztBQU9BOzs7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUEsaUJBQU4sQ0FBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUNFQSxtQkFBbUJDLCtCQUFuQixLQUF1RCxJQUF2RCxJQUNBRCxtQkFBbUJFLDBCQUFuQixLQUFrRCxJQUZwRDtBQUlEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsTUFBUCxDQUNFQyxVQURGLEVBRUVKLGtCQUZGLEVBR0VLLE1BSEYsRUFJRUMsS0FKRixFQUtvQztBQUNsQyxRQUFJTixtQkFBbUJDLCtCQUF2QixFQUF3RDtBQUN0RCxhQUFPSCxrQkFBa0JTLFdBQWxCLENBQThCSCxVQUE5QixFQUEwQ0MsTUFBMUMsRUFBa0RDLEtBQWxELENBQVA7QUFDRDs7QUFFRCxRQUFJTixtQkFBbUJFLDBCQUF2QixFQUFtRDtBQUNqRCxhQUFPSixrQkFBa0JVLGNBQWxCLENBQWlDSixVQUFqQyxFQUE2Q0MsTUFBN0MsQ0FBUDtBQUNEOztBQUVELFVBQU0sSUFBSUksS0FBSixDQUFVLDhEQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWFELGNBQWIsQ0FDRUosVUFERixFQUVFQyxNQUZGLEVBR29DO0FBQ2xDLFVBQU1LLFFBQVEsTUFBTU4sV0FBV08sa0JBQVgsQ0FBOEJiLGtCQUFrQmMsOEJBQWxCLENBQWlEUCxNQUFqRCxDQUE5QixDQUFwQjtBQUNBLFdBQU8sa0JBQVFRLGtCQUFSLENBQTJCSCxLQUEzQixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPRSw4QkFBUCxDQUFzQ1AsTUFBdEMsRUFBeUY7QUFDdkYsV0FBTztBQUNMUyxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNWLE1BQXZDLENBRFQ7QUFFTFcsZUFBU2xCLGtCQUFrQm1CLGdCQUFsQixDQUFtQ1osTUFBbkM7QUFGSixLQUFQO0FBSUQ7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWFFLFdBQWIsQ0FDRUgsVUFERixFQUVFQyxNQUZGLEVBR0VDLEtBSEYsRUFJb0M7QUFDbEMsVUFBTUksUUFBUSxNQUFNTixXQUFXYyx1QkFBWCxDQUNsQnBCLGtCQUFrQnFCLG1DQUFsQixDQUFzRGQsTUFBdEQsRUFBOERDLEtBQTlELENBRGtCLENBQXBCO0FBR0EsV0FBTyxrQkFBUU8sa0JBQVIsQ0FBMkJILEtBQTNCLENBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPUyxtQ0FBUCxDQUNFZCxNQURGLEVBRUVDLEtBRkYsRUFHaUM7QUFDL0IsV0FBTztBQUNMUSxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNWLE1BQXZDLENBRFQ7QUFFTEMsYUFBTyxrQkFBUWMsa0JBQVIsQ0FBMkJkLEtBQTNCLENBRkY7QUFHTFUsZUFBU2xCLGtCQUFrQm1CLGdCQUFsQixDQUFtQ1osTUFBbkM7QUFISixLQUFQO0FBS0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT1ksZ0JBQVAsQ0FBd0JaLE1BQXhCLEVBQW9FO0FBQ2xFLFdBQU87QUFDTGdCLGVBQVNoQixPQUFPaUIsWUFBUCxFQURKO0FBRUxDLG9CQUFjbEIsT0FBT21CLFdBQVA7QUFGVCxLQUFQO0FBSUQ7QUE3SG9DO2tCQUFsQjFCLGlCIiwiZmlsZSI6ImNvZGUtZm9ybWF0LWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIHR5cGUgRG9jdW1lbnRGb3JtYXR0aW5nUGFyYW1zLFxuICB0eXBlIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zLFxuICB0eXBlIEZvcm1hdHRpbmdPcHRpb25zLFxuICB0eXBlIFNlcnZlckNhcGFiaWxpdGllcyxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5cbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvY29tcGxldGlvblwiIHRvIHRoZVxuLy8gQXRvbSBJREUgVUkgQ29kZS1mb3JtYXQgcGFja2FnZS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvZGVGb3JtYXRBZGFwdGVyIHtcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBlaXRoZXIgYSBkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlclxuICAvLyBvciBhIGRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXIuXG4gIC8vXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyB0aGlzIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyID09PSB0cnVlIHx8XG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIgPT09IHRydWVcbiAgICApO1xuICB9XG5cbiAgLy8gUHVibGljOiBGb3JtYXQgdGV4dCBpbiB0aGUgZWRpdG9yIHVzaW5nIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIgY29ubmVjdGlvbiBhbmQgYW4gb3B0aW9uYWwgcmFuZ2UuXG4gIC8vIElmIHRoZSBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCByYW5nZSBmb3JtYXR0aW5nIHRoZW4gcmFuZ2Ugd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgZW50aXJlIGRvY3VtZW50IGZvcm1hdHRlZC5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBmb3JtYXQgdGhlIHRleHQuXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHVzZWQuXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhhdCB3aWxsIGJlIGZvcm1hdHRlZC5cbiAgLy8gKiBgcmFuZ2VgIFRoZSBvcHRpb25hbCBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgc3Vic2V0IG9mIHRoZSB0ZXh0IHRvIGJlIGZvcm1hdHRlZC5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHtPYmplY3R9cyBjb250YWluaW5nIHRoZSBBdXRvQ29tcGxldGUrXG4gIC8vIHN1Z2dlc3Rpb25zIHRvIGRpc3BsYXkuXG4gIHN0YXRpYyBmb3JtYXQoXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzLFxuICAgIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxuICAgIHJhbmdlOiBhdG9tJFJhbmdlLFxuICApOiBQcm9taXNlPEFycmF5PGF0b21JZGUkVGV4dEVkaXQ+PiB7XG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gQ29kZUZvcm1hdEFkYXB0ZXIuZm9ybWF0UmFuZ2UoY29ubmVjdGlvbiwgZWRpdG9yLCByYW5nZSk7XG4gICAgfVxuXG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcikge1xuICAgICAgcmV0dXJuIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdERvY3VtZW50KGNvbm5lY3Rpb24sIGVkaXRvcik7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGZvcm1hdCBkb2N1bWVudCwgbGFuZ3VhZ2Ugc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgaXQnKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogRm9ybWF0IHRoZSBlbnRpcmUgZG9jdW1lbnQgb2YgYW4gQXRvbSB7VGV4dEVkaXRvcn0gYnkgdXNpbmcgYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgZm9ybWF0IHRoZSB0ZXh0LlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gb2YgYW4ge0FycmF5fSBvZiB7VGV4dEVkaXR9IG9iamVjdHMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgQXRvbSBUZXh0RWRpdG9yXG4gIC8vIHRvIGZvcm1hdCB0aGUgZG9jdW1lbnQuXG4gIHN0YXRpYyBhc3luYyBmb3JtYXREb2N1bWVudChcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXG4gICk6IFByb21pc2U8QXJyYXk8YXRvbUlkZSRUZXh0RWRpdD4+IHtcbiAgICBjb25zdCBlZGl0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRGb3JtYXR0aW5nKENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50Rm9ybWF0dGluZ1BhcmFtcyhlZGl0b3IpKTtcbiAgICByZXR1cm4gQ29udmVydC5jb252ZXJ0THNUZXh0RWRpdHMoZWRpdHMpO1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vIFJldHVybnMge0RvY3VtZW50Rm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQgYXMgd2VsbCBhc1xuICAvLyBvcHRpb25zIHRvIGJlIHVzZWQgaW4gZm9ybWF0dGluZyB0aGUgZG9jdW1lbnQgc3VjaCBhcyB0YWIgc2l6ZSBhbmQgdGFicyB2cyBzcGFjZXMuXG4gIHN0YXRpYyBjcmVhdGVEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiBEb2N1bWVudEZvcm1hdHRpbmdQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXG4gICAgICBvcHRpb25zOiBDb2RlRm9ybWF0QWRhcHRlci5nZXRGb3JtYXRPcHRpb25zKGVkaXRvciksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogRm9ybWF0IGEgcmFuZ2Ugd2l0aGluIGFuIEF0b20ge1RleHRFZGl0b3J9IGJ5IHVzaW5nIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGZvcm1hdCB0aGUgdGV4dC5cbiAgLy8gKiBgcmFuZ2VgIFRoZSBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgcmFuZ2Ugb2YgdGV4dCB0aGF0IHNob3VsZCBiZSBmb3JtYXR0ZWQuXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHtUZXh0RWRpdH0gb2JqZWN0cyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBBdG9tIFRleHRFZGl0b3JcbiAgLy8gdG8gZm9ybWF0IHRoZSBkb2N1bWVudC5cbiAgc3RhdGljIGFzeW5jIGZvcm1hdFJhbmdlKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcbiAgICByYW5nZTogYXRvbSRSYW5nZSxcbiAgKTogUHJvbWlzZTxBcnJheTxhdG9tSWRlJFRleHRFZGl0Pj4ge1xuICAgIGNvbnN0IGVkaXRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudFJhbmdlRm9ybWF0dGluZyhcbiAgICAgIENvZGVGb3JtYXRBZGFwdGVyLmNyZWF0ZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zKGVkaXRvciwgcmFuZ2UpLFxuICAgICk7XG4gICAgcmV0dXJuIENvbnZlcnQuY29udmVydExzVGV4dEVkaXRzKGVkaXRzKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gdG8gYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHdoZW4gcmVxdWVzdGluZyBhblxuICAvLyBlbnRpcmUgZG9jdW1lbnQgaXMgZm9ybWF0dGVkLlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSBkb2N1bWVudCB0byBiZSBmb3JtYXR0ZWQuXG4gIC8vICogYHJhbmdlYCBUaGUgQXRvbSB7UmFuZ2V9IGNvbnRhaW5pbmcgdGhlIHJhbmdlIG9mIHRleHQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIHtEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1BhcmFtc30gY29udGFpbmluZyB0aGUgaWRlbnRpdHkgb2YgdGhlIHRleHQgZG9jdW1lbnQsIHRoZVxuICAvLyByYW5nZSBvZiB0aGUgdGV4dCB0byBiZSBmb3JtYXR0ZWQgYXMgd2VsbCBhcyB0aGUgb3B0aW9ucyB0byBiZSB1c2VkIGluIGZvcm1hdHRpbmcgdGhlXG4gIC8vIGRvY3VtZW50IHN1Y2ggYXMgdGFiIHNpemUgYW5kIHRhYnMgdnMgc3BhY2VzLlxuICBzdGF0aWMgY3JlYXRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdQYXJhbXMoXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXG4gICAgcmFuZ2U6IGF0b20kUmFuZ2UsXG4gICk6IERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxuICAgICAgcmFuZ2U6IENvbnZlcnQuYXRvbVJhbmdlVG9MU1JhbmdlKHJhbmdlKSxcbiAgICAgIG9wdGlvbnM6IENvZGVGb3JtYXRBZGFwdGVyLmdldEZvcm1hdE9wdGlvbnMoZWRpdG9yKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUge0RvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUGFyYW1zfSB0byBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgd2hlbiByZXF1ZXN0aW5nIGFuXG4gIC8vIGVudGlyZSBkb2N1bWVudCBpcyBmb3JtYXR0ZWQuXG4gIC8vXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIGRvY3VtZW50IHRvIGJlIGZvcm1hdHRlZC5cbiAgLy8gKiBgcmFuZ2VgIFRoZSBBdG9tIHtSYW5nZX0gY29udGFpbmluZyB0aGUgcmFuZ2Ugb2YgZG9jdW1lbnQgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIHRoZSB7Rm9ybWF0dGluZ09wdGlvbnN9IHRvIGJlIHVzZWQgY29udGFpbmluZyB0aGUga2V5czpcbiAgLy8gICogYHRhYlNpemVgIFRoZSBudW1iZXIgb2Ygc3BhY2VzIGEgdGFiIHJlcHJlc2VudHMuXG4gIC8vICAqIGBpbnNlcnRTcGFjZXNgIHtUcnVlfSBpZiBzcGFjZXMgc2hvdWxkIGJlIHVzZWQsIHtGYWxzZX0gZm9yIHRhYiBjaGFyYWN0ZXJzLlxuICBzdGF0aWMgZ2V0Rm9ybWF0T3B0aW9ucyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IEZvcm1hdHRpbmdPcHRpb25zIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFiU2l6ZTogZWRpdG9yLmdldFRhYkxlbmd0aCgpLFxuICAgICAgaW5zZXJ0U3BhY2VzOiBlZGl0b3IuZ2V0U29mdFRhYnMoKSxcbiAgICB9O1xuICB9XG59XG4iXX0=