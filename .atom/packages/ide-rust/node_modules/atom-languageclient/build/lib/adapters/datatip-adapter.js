Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the language server protocol "textDocument/hover" to the
// Atom IDE UI Datatip package.
let DatatipAdapter = class DatatipAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a hoverProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.hoverProvider === true;
  }

  // Public: Get the Datatip for this {Point} in a {TextEditor} by querying
  // the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the hover text/datatip.
  // * `editor` The Atom {TextEditor} containing the text the Datatip should relate to.
  // * `point` The Atom {Point} containing the point within the text the Datatip should relate to.
  //
  // Returns a {Promise} containing the {Datatip} to display or {null} if no Datatip is available.
  getDatatip(connection, editor, point) {
    return _asyncToGenerator(function* () {
      const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);

      const hover = yield connection.hover(documentPositionParams);
      if (hover == null || hover.contents == null ||
      // This intentionally covers both empty strings and empty arrays.
      hover.contents.length === 0) {
        return null;
      }

      const range = hover.range == null ? _utils2.default.getWordAtPosition(editor, point) : _convert2.default.lsRangeToAtomRange(hover.range);

      const markedStrings = (Array.isArray(hover.contents) ? hover.contents : [hover.contents]).map(function (str) {
        return DatatipAdapter.convertMarkedString(editor, str);
      });

      return { range, markedStrings };
    })();
  }

  static convertMarkedString(editor, markedString) {
    if (typeof markedString === 'object') {
      return {
        type: 'snippet',
        // TODO: find a better mapping from language -> grammar
        grammar: atom.grammars.grammarForScopeName(`source.${markedString.language}`) || editor.getGrammar(),
        value: markedString.value
      };
    }
    return { type: 'markdown', value: markedString };
  }
};
exports.default = DatatipAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kYXRhdGlwLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGF0YXRpcEFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImhvdmVyUHJvdmlkZXIiLCJnZXREYXRhdGlwIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInBvaW50IiwiZG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJob3ZlciIsImNvbnRlbnRzIiwibGVuZ3RoIiwicmFuZ2UiLCJnZXRXb3JkQXRQb3NpdGlvbiIsImxzUmFuZ2VUb0F0b21SYW5nZSIsIm1hcmtlZFN0cmluZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJjb252ZXJ0TWFya2VkU3RyaW5nIiwic3RyIiwibWFya2VkU3RyaW5nIiwidHlwZSIsImdyYW1tYXIiLCJhdG9tIiwiZ3JhbW1hcnMiLCJncmFtbWFyRm9yU2NvcGVOYW1lIiwibGFuZ3VhZ2UiLCJnZXRHcmFtbWFyIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBS0E7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTtBQUNBO0lBQ3FCQSxjLEdBQU4sTUFBTUEsY0FBTixDQUFxQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxhQUFuQixLQUFxQyxJQUE1QztBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNQyxZQUFOLENBQ0VDLFVBREYsRUFFRUMsTUFGRixFQUdFQyxLQUhGLEVBSTZCO0FBQUE7QUFDM0IsWUFBTUMseUJBQXlCLGtCQUFRQyxrQ0FBUixDQUM3QkgsTUFENkIsRUFFN0JDLEtBRjZCLENBQS9COztBQUtBLFlBQU1HLFFBQVEsTUFBTUwsV0FBV0ssS0FBWCxDQUFpQkYsc0JBQWpCLENBQXBCO0FBQ0EsVUFDRUUsU0FBUyxJQUFULElBQ0FBLE1BQU1DLFFBQU4sSUFBa0IsSUFEbEI7QUFFQTtBQUNBRCxZQUFNQyxRQUFOLENBQWVDLE1BQWYsS0FBMEIsQ0FKNUIsRUFLRTtBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELFlBQU1DLFFBQVFILE1BQU1HLEtBQU4sSUFBZSxJQUFmLEdBQ1YsZ0JBQU1DLGlCQUFOLENBQXdCUixNQUF4QixFQUFnQ0MsS0FBaEMsQ0FEVSxHQUVWLGtCQUFRUSxrQkFBUixDQUEyQkwsTUFBTUcsS0FBakMsQ0FGSjs7QUFJQSxZQUFNRyxnQkFBZ0IsQ0FBQ0MsTUFBTUMsT0FBTixDQUFjUixNQUFNQyxRQUFwQixJQUNuQkQsTUFBTUMsUUFEYSxHQUVuQixDQUFDRCxNQUFNQyxRQUFQLENBRmtCLEVBRUFRLEdBRkEsQ0FFSTtBQUFBLGVBQ3hCbkIsZUFBZW9CLG1CQUFmLENBQW1DZCxNQUFuQyxFQUEyQ2UsR0FBM0MsQ0FEd0I7QUFBQSxPQUZKLENBQXRCOztBQU1BLGFBQU8sRUFBQ1IsS0FBRCxFQUFRRyxhQUFSLEVBQVA7QUExQjJCO0FBMkI1Qjs7QUFFRCxTQUFPSSxtQkFBUCxDQUNFZCxNQURGLEVBRUVnQixZQUZGLEVBR3dCO0FBQ3RCLFFBQUksT0FBT0EsWUFBUCxLQUF3QixRQUE1QixFQUFzQztBQUNwQyxhQUFPO0FBQ0xDLGNBQU0sU0FERDtBQUVMO0FBQ0FDLGlCQUFTQyxLQUFLQyxRQUFMLENBQWNDLG1CQUFkLENBQ04sVUFBU0wsYUFBYU0sUUFBUyxFQUR6QixLQUVKdEIsT0FBT3VCLFVBQVAsRUFMQTtBQU1MQyxlQUFPUixhQUFhUTtBQU5mLE9BQVA7QUFRRDtBQUNELFdBQU8sRUFBQ1AsTUFBTSxVQUFQLEVBQW1CTyxPQUFPUixZQUExQixFQUFQO0FBQ0Q7QUF0RWlDLEM7a0JBQWZ0QixjIiwiZmlsZSI6ImRhdGF0aXAtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgdHlwZSBNYXJrZWRTdHJpbmcsXG4gIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzLFxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscyc7XG5cbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvaG92ZXJcIiB0byB0aGVcbi8vIEF0b20gSURFIFVJIERhdGF0aXAgcGFja2FnZS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGF0aXBBZGFwdGVyIHtcblxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgaG92ZXJQcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5ob3ZlclByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gUHVibGljOiBHZXQgdGhlIERhdGF0aXAgZm9yIHRoaXMge1BvaW50fSBpbiBhIHtUZXh0RWRpdG9yfSBieSBxdWVyeWluZ1xuICAvLyB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBob3ZlciB0ZXh0L2RhdGF0aXAuXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIERhdGF0aXAgc2hvdWxkIHJlbGF0ZSB0by5cbiAgLy8gKiBgcG9pbnRgIFRoZSBBdG9tIHtQb2ludH0gY29udGFpbmluZyB0aGUgcG9pbnQgd2l0aGluIHRoZSB0ZXh0IHRoZSBEYXRhdGlwIHNob3VsZCByZWxhdGUgdG8uXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge0RhdGF0aXB9IHRvIGRpc3BsYXkgb3Ige251bGx9IGlmIG5vIERhdGF0aXAgaXMgYXZhaWxhYmxlLlxuICBhc3luYyBnZXREYXRhdGlwKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcbiAgICBwb2ludDogYXRvbSRQb2ludCxcbiAgKTogUHJvbWlzZTw/bnVjbGlkZSREYXRhdGlwPiB7XG4gICAgY29uc3QgZG9jdW1lbnRQb3NpdGlvblBhcmFtcyA9IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhcbiAgICAgIGVkaXRvcixcbiAgICAgIHBvaW50LFxuICAgICk7XG5cbiAgICBjb25zdCBob3ZlciA9IGF3YWl0IGNvbm5lY3Rpb24uaG92ZXIoZG9jdW1lbnRQb3NpdGlvblBhcmFtcyk7XG4gICAgaWYgKFxuICAgICAgaG92ZXIgPT0gbnVsbCB8fFxuICAgICAgaG92ZXIuY29udGVudHMgPT0gbnVsbCB8fFxuICAgICAgLy8gVGhpcyBpbnRlbnRpb25hbGx5IGNvdmVycyBib3RoIGVtcHR5IHN0cmluZ3MgYW5kIGVtcHR5IGFycmF5cy5cbiAgICAgIGhvdmVyLmNvbnRlbnRzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmFuZ2UgPSBob3Zlci5yYW5nZSA9PSBudWxsXG4gICAgICA/IFV0aWxzLmdldFdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpXG4gICAgICA6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGhvdmVyLnJhbmdlKTtcblxuICAgIGNvbnN0IG1hcmtlZFN0cmluZ3MgPSAoQXJyYXkuaXNBcnJheShob3Zlci5jb250ZW50cylcbiAgICAgID8gaG92ZXIuY29udGVudHNcbiAgICAgIDogW2hvdmVyLmNvbnRlbnRzXSkubWFwKHN0ciA9PlxuICAgICAgRGF0YXRpcEFkYXB0ZXIuY29udmVydE1hcmtlZFN0cmluZyhlZGl0b3IsIHN0ciksXG4gICAgKTtcblxuICAgIHJldHVybiB7cmFuZ2UsIG1hcmtlZFN0cmluZ3N9O1xuICB9XG5cbiAgc3RhdGljIGNvbnZlcnRNYXJrZWRTdHJpbmcoXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXG4gICAgbWFya2VkU3RyaW5nOiBNYXJrZWRTdHJpbmcsXG4gICk6IG51Y2xpZGUkTWFya2VkU3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1hcmtlZFN0cmluZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdzbmlwcGV0JyxcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBtYXBwaW5nIGZyb20gbGFuZ3VhZ2UgLT4gZ3JhbW1hclxuICAgICAgICBncmFtbWFyOiBhdG9tLmdyYW1tYXJzLmdyYW1tYXJGb3JTY29wZU5hbWUoXG4gICAgICAgICAgYHNvdXJjZS4ke21hcmtlZFN0cmluZy5sYW5ndWFnZX1gLFxuICAgICAgICApIHx8IGVkaXRvci5nZXRHcmFtbWFyKCksXG4gICAgICAgIHZhbHVlOiBtYXJrZWRTdHJpbmcudmFsdWUsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6ICdtYXJrZG93bicsIHZhbHVlOiBtYXJrZWRTdHJpbmd9O1xuICB9XG59XG4iXX0=