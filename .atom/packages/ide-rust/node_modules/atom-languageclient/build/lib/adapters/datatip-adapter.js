Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server protocol "textDocument/hover" to the
// Atom IDE UI Datatip package.
class DatatipAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a hoverProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.hoverProvider === true;
  }

  // Public: Get the Datatip for this {Point} in a {TextEditor} by querying
  // the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the hover text/datatip.
  // * `editor` The Atom {TextEditor} containing the text the Datatip should relate to.
  // * `point` The Atom {Point} containing the point within the text the Datatip should relate to.
  //
  // Returns a {Promise} containing the {Datatip} to display or {null} if no Datatip is available.
  async getDatatip(connection, editor, point) {
    const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);

    const hover = await connection.hover(documentPositionParams);
    if (hover == null || hover.contents == null ||
    // This intentionally covers both empty strings and empty arrays.
    hover.contents.length === 0) {
      return null;
    }

    const range = hover.range == null ? _utils2.default.getWordAtPosition(editor, point) : _convert2.default.lsRangeToAtomRange(hover.range);

    const markedStrings = (Array.isArray(hover.contents) ? hover.contents : [hover.contents]).map(str => DatatipAdapter.convertMarkedString(editor, str));

    return { range, markedStrings };
  }

  static convertMarkedString(editor, markedString) {
    if (typeof markedString === 'object') {
      return {
        type: 'snippet',
        // TODO: find a better mapping from language -> grammar
        grammar: atom.grammars.grammarForScopeName(`source.${markedString.language}`) || editor.getGrammar(),
        value: markedString.value
      };
    }
    return { type: 'markdown', value: markedString };
  }
}
exports.default = DatatipAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kYXRhdGlwLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGF0YXRpcEFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImhvdmVyUHJvdmlkZXIiLCJnZXREYXRhdGlwIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInBvaW50IiwiZG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJob3ZlciIsImNvbnRlbnRzIiwibGVuZ3RoIiwicmFuZ2UiLCJnZXRXb3JkQXRQb3NpdGlvbiIsImxzUmFuZ2VUb0F0b21SYW5nZSIsIm1hcmtlZFN0cmluZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJzdHIiLCJjb252ZXJ0TWFya2VkU3RyaW5nIiwibWFya2VkU3RyaW5nIiwidHlwZSIsImdyYW1tYXIiLCJhdG9tIiwiZ3JhbW1hcnMiLCJncmFtbWFyRm9yU2NvcGVOYW1lIiwibGFuZ3VhZ2UiLCJnZXRHcmFtbWFyIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUEsY0FBTixDQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLGFBQW5CLEtBQXFDLElBQTVDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsVUFBTixDQUNFQyxVQURGLEVBRUVDLE1BRkYsRUFHRUMsS0FIRixFQUk2QjtBQUMzQixVQUFNQyx5QkFBeUIsa0JBQVFDLGtDQUFSLENBQTJDSCxNQUEzQyxFQUFtREMsS0FBbkQsQ0FBL0I7O0FBRUEsVUFBTUcsUUFBUSxNQUFNTCxXQUFXSyxLQUFYLENBQWlCRixzQkFBakIsQ0FBcEI7QUFDQSxRQUNFRSxTQUFTLElBQVQsSUFDQUEsTUFBTUMsUUFBTixJQUFrQixJQURsQjtBQUVBO0FBQ0FELFVBQU1DLFFBQU4sQ0FBZUMsTUFBZixLQUEwQixDQUo1QixFQUtFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBTUMsUUFDSkgsTUFBTUcsS0FBTixJQUFlLElBQWYsR0FBc0IsZ0JBQU1DLGlCQUFOLENBQXdCUixNQUF4QixFQUFnQ0MsS0FBaEMsQ0FBdEIsR0FBK0Qsa0JBQVFRLGtCQUFSLENBQTJCTCxNQUFNRyxLQUFqQyxDQURqRTs7QUFHQSxVQUFNRyxnQkFBZ0IsQ0FBQ0MsTUFBTUMsT0FBTixDQUFjUixNQUFNQyxRQUFwQixJQUFnQ0QsTUFBTUMsUUFBdEMsR0FBaUQsQ0FBQ0QsTUFBTUMsUUFBUCxDQUFsRCxFQUFvRVEsR0FBcEUsQ0FBd0VDLE9BQzVGcEIsZUFBZXFCLG1CQUFmLENBQW1DZixNQUFuQyxFQUEyQ2MsR0FBM0MsQ0FEb0IsQ0FBdEI7O0FBSUEsV0FBTyxFQUFDUCxLQUFELEVBQVFHLGFBQVIsRUFBUDtBQUNEOztBQUVELFNBQU9LLG1CQUFQLENBQTJCZixNQUEzQixFQUFvRGdCLFlBQXBELEVBQXNHO0FBQ3BHLFFBQUksT0FBT0EsWUFBUCxLQUF3QixRQUE1QixFQUFzQztBQUNwQyxhQUFPO0FBQ0xDLGNBQU0sU0FERDtBQUVMO0FBQ0FDLGlCQUFTQyxLQUFLQyxRQUFMLENBQWNDLG1CQUFkLENBQW1DLFVBQVNMLGFBQWFNLFFBQVMsRUFBbEUsS0FBd0V0QixPQUFPdUIsVUFBUCxFQUg1RTtBQUlMQyxlQUFPUixhQUFhUTtBQUpmLE9BQVA7QUFNRDtBQUNELFdBQU8sRUFBQ1AsTUFBTSxVQUFQLEVBQW1CTyxPQUFPUixZQUExQixFQUFQO0FBQ0Q7QUExRGlDO2tCQUFmdEIsYyIsImZpbGUiOiJkYXRhdGlwLWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgdHlwZSBNYXJrZWRTdHJpbmcsIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzfSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscyc7XG5cbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvaG92ZXJcIiB0byB0aGVcbi8vIEF0b20gSURFIFVJIERhdGF0aXAgcGFja2FnZS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGF0aXBBZGFwdGVyIHtcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGhvdmVyUHJvdmlkZXIuXG4gIC8vXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuaG92ZXJQcm92aWRlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogR2V0IHRoZSBEYXRhdGlwIGZvciB0aGlzIHtQb2ludH0gaW4gYSB7VGV4dEVkaXRvcn0gYnkgcXVlcnlpbmdcbiAgLy8gdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgaG92ZXIgdGV4dC9kYXRhdGlwLlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBEYXRhdGlwIHNob3VsZCByZWxhdGUgdG8uXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgRGF0YXRpcCBzaG91bGQgcmVsYXRlIHRvLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGNvbnRhaW5pbmcgdGhlIHtEYXRhdGlwfSB0byBkaXNwbGF5IG9yIHtudWxsfSBpZiBubyBEYXRhdGlwIGlzIGF2YWlsYWJsZS5cbiAgYXN5bmMgZ2V0RGF0YXRpcChcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IGF0b20kUG9pbnQsXG4gICk6IFByb21pc2U8P2F0b21JZGUkRGF0YXRpcD4ge1xuICAgIGNvbnN0IGRvY3VtZW50UG9zaXRpb25QYXJhbXMgPSBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yLCBwb2ludCk7XG5cbiAgICBjb25zdCBob3ZlciA9IGF3YWl0IGNvbm5lY3Rpb24uaG92ZXIoZG9jdW1lbnRQb3NpdGlvblBhcmFtcyk7XG4gICAgaWYgKFxuICAgICAgaG92ZXIgPT0gbnVsbCB8fFxuICAgICAgaG92ZXIuY29udGVudHMgPT0gbnVsbCB8fFxuICAgICAgLy8gVGhpcyBpbnRlbnRpb25hbGx5IGNvdmVycyBib3RoIGVtcHR5IHN0cmluZ3MgYW5kIGVtcHR5IGFycmF5cy5cbiAgICAgIGhvdmVyLmNvbnRlbnRzLmxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmFuZ2UgPVxuICAgICAgaG92ZXIucmFuZ2UgPT0gbnVsbCA/IFV0aWxzLmdldFdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpIDogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoaG92ZXIucmFuZ2UpO1xuXG4gICAgY29uc3QgbWFya2VkU3RyaW5ncyA9IChBcnJheS5pc0FycmF5KGhvdmVyLmNvbnRlbnRzKSA/IGhvdmVyLmNvbnRlbnRzIDogW2hvdmVyLmNvbnRlbnRzXSkubWFwKHN0ciA9PlxuICAgICAgRGF0YXRpcEFkYXB0ZXIuY29udmVydE1hcmtlZFN0cmluZyhlZGl0b3IsIHN0ciksXG4gICAgKTtcblxuICAgIHJldHVybiB7cmFuZ2UsIG1hcmtlZFN0cmluZ3N9O1xuICB9XG5cbiAgc3RhdGljIGNvbnZlcnRNYXJrZWRTdHJpbmcoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIG1hcmtlZFN0cmluZzogTWFya2VkU3RyaW5nKTogYXRvbUlkZSRNYXJrZWRTdHJpbmcge1xuICAgIGlmICh0eXBlb2YgbWFya2VkU3RyaW5nID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3NuaXBwZXQnLFxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIG1hcHBpbmcgZnJvbSBsYW5ndWFnZSAtPiBncmFtbWFyXG4gICAgICAgIGdyYW1tYXI6IGF0b20uZ3JhbW1hcnMuZ3JhbW1hckZvclNjb3BlTmFtZShgc291cmNlLiR7bWFya2VkU3RyaW5nLmxhbmd1YWdlfWApIHx8IGVkaXRvci5nZXRHcmFtbWFyKCksXG4gICAgICAgIHZhbHVlOiBtYXJrZWRTdHJpbmcudmFsdWUsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge3R5cGU6ICdtYXJrZG93bicsIHZhbHVlOiBtYXJrZWRTdHJpbmd9O1xuICB9XG59XG4iXX0=