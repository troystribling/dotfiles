Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server protocol "textDocument/hover" to the
// Atom IDE UI Datatip package.
class DatatipAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a hoverProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.hoverProvider === true;
  }

  // Public: Get the Datatip for this {Point} in a {TextEditor} by querying
  // the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the hover text/datatip.
  // * `editor` The Atom {TextEditor} containing the text the Datatip should relate to.
  // * `point` The Atom {Point} containing the point within the text the Datatip should relate to.
  //
  // Returns a {Promise} containing the {Datatip} to display or {null} if no Datatip is available.
  async getDatatip(connection, editor, point) {
    const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);

    const hover = await connection.hover(documentPositionParams);
    if (hover == null || hover.contents == null ||
    // This intentionally covers both empty strings and empty arrays.
    hover.contents.length === 0) {
      return null;
    }

    const range = hover.range == null ? _utils2.default.getWordAtPosition(editor, point) : _convert2.default.lsRangeToAtomRange(hover.range);

    const markedStrings = (Array.isArray(hover.contents) ? hover.contents : [hover.contents]).map(str => DatatipAdapter.convertMarkedString(editor, str));

    return { range, markedStrings };
  }

  static convertMarkedString(editor, markedString) {
    if (typeof markedString === 'object') {
      return {
        type: 'snippet',
        // TODO: find a better mapping from language -> grammar
        grammar: atom.grammars.grammarForScopeName(`source.${markedString.language}`) || editor.getGrammar(),
        value: markedString.value
      };
    }
    return { type: 'markdown', value: markedString };
  }
}
exports.default = DatatipAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kYXRhdGlwLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGF0YXRpcEFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImhvdmVyUHJvdmlkZXIiLCJnZXREYXRhdGlwIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInBvaW50IiwiZG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImVkaXRvclRvVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJob3ZlciIsImNvbnRlbnRzIiwibGVuZ3RoIiwicmFuZ2UiLCJnZXRXb3JkQXRQb3NpdGlvbiIsImxzUmFuZ2VUb0F0b21SYW5nZSIsIm1hcmtlZFN0cmluZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJzdHIiLCJjb252ZXJ0TWFya2VkU3RyaW5nIiwibWFya2VkU3RyaW5nIiwidHlwZSIsImdyYW1tYXIiLCJhdG9tIiwiZ3JhbW1hcnMiLCJncmFtbWFyRm9yU2NvcGVOYW1lIiwibGFuZ3VhZ2UiLCJnZXRHcmFtbWFyIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUEsY0FBTixDQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLGFBQW5CLEtBQXFDLElBQTVDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsVUFBTixDQUNFQyxVQURGLEVBRUVDLE1BRkYsRUFHRUMsS0FIRixFQUk2QjtBQUMzQixVQUFNQyx5QkFBeUIsa0JBQVFDLGtDQUFSLENBQTJDSCxNQUEzQyxFQUFtREMsS0FBbkQsQ0FBL0I7O0FBRUEsVUFBTUcsUUFBUSxNQUFNTCxXQUFXSyxLQUFYLENBQWlCRixzQkFBakIsQ0FBcEI7QUFDQSxRQUNFRSxTQUFTLElBQVQsSUFDQUEsTUFBTUMsUUFBTixJQUFrQixJQURsQjtBQUVBO0FBQ0FELFVBQU1DLFFBQU4sQ0FBZUMsTUFBZixLQUEwQixDQUo1QixFQUtFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBTUMsUUFDSkgsTUFBTUcsS0FBTixJQUFlLElBQWYsR0FBc0IsZ0JBQU1DLGlCQUFOLENBQXdCUixNQUF4QixFQUFnQ0MsS0FBaEMsQ0FBdEIsR0FBK0Qsa0JBQVFRLGtCQUFSLENBQTJCTCxNQUFNRyxLQUFqQyxDQURqRTs7QUFHQSxVQUFNRyxnQkFBZ0IsQ0FBQ0MsTUFBTUMsT0FBTixDQUFjUixNQUFNQyxRQUFwQixJQUFnQ0QsTUFBTUMsUUFBdEMsR0FBaUQsQ0FBQ0QsTUFBTUMsUUFBUCxDQUFsRCxFQUFvRVEsR0FBcEUsQ0FBd0VDLE9BQzVGcEIsZUFBZXFCLG1CQUFmLENBQW1DZixNQUFuQyxFQUEyQ2MsR0FBM0MsQ0FEb0IsQ0FBdEI7O0FBSUEsV0FBTyxFQUFDUCxLQUFELEVBQVFHLGFBQVIsRUFBUDtBQUNEOztBQUVELFNBQU9LLG1CQUFQLENBQTJCZixNQUEzQixFQUFvRGdCLFlBQXBELEVBQXNHO0FBQ3BHLFFBQUksT0FBT0EsWUFBUCxLQUF3QixRQUE1QixFQUFzQztBQUNwQyxhQUFPO0FBQ0xDLGNBQU0sU0FERDtBQUVMO0FBQ0FDLGlCQUFTQyxLQUFLQyxRQUFMLENBQWNDLG1CQUFkLENBQW1DLFVBQVNMLGFBQWFNLFFBQVMsRUFBbEUsS0FBd0V0QixPQUFPdUIsVUFBUCxFQUg1RTtBQUlMQyxlQUFPUixhQUFhUTtBQUpmLE9BQVA7QUFNRDtBQUNELFdBQU8sRUFBQ1AsTUFBTSxVQUFQLEVBQW1CTyxPQUFPUixZQUExQixFQUFQO0FBQ0Q7QUExRGlDO2tCQUFmdEIsYyIsImZpbGUiOiJkYXRhdGlwLWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIHR5cGUgTWFya2VkU3RyaW5nLCB0eXBlIFNlcnZlckNhcGFiaWxpdGllc30gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzJztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgXCJ0ZXh0RG9jdW1lbnQvaG92ZXJcIiB0byB0aGVcclxuLy8gQXRvbSBJREUgVUkgRGF0YXRpcCBwYWNrYWdlLlxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhdGlwQWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgaG92ZXJQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmhvdmVyUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCB0aGUgRGF0YXRpcCBmb3IgdGhpcyB7UG9pbnR9IGluIGEge1RleHRFZGl0b3J9IGJ5IHF1ZXJ5aW5nXHJcbiAgLy8gdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZFxyXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgaG92ZXIgdGV4dC9kYXRhdGlwLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIERhdGF0aXAgc2hvdWxkIHJlbGF0ZSB0by5cclxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb2ludCB3aXRoaW4gdGhlIHRleHQgdGhlIERhdGF0aXAgc2hvdWxkIHJlbGF0ZSB0by5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge0RhdGF0aXB9IHRvIGRpc3BsYXkgb3Ige251bGx9IGlmIG5vIERhdGF0aXAgaXMgYXZhaWxhYmxlLlxyXG4gIGFzeW5jIGdldERhdGF0aXAoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICAgIHBvaW50OiBhdG9tJFBvaW50LFxyXG4gICk6IFByb21pc2U8P2F0b21JZGUkRGF0YXRpcD4ge1xyXG4gICAgY29uc3QgZG9jdW1lbnRQb3NpdGlvblBhcmFtcyA9IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvaW50KTtcclxuXHJcbiAgICBjb25zdCBob3ZlciA9IGF3YWl0IGNvbm5lY3Rpb24uaG92ZXIoZG9jdW1lbnRQb3NpdGlvblBhcmFtcyk7XHJcbiAgICBpZiAoXHJcbiAgICAgIGhvdmVyID09IG51bGwgfHxcclxuICAgICAgaG92ZXIuY29udGVudHMgPT0gbnVsbCB8fFxyXG4gICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgY292ZXJzIGJvdGggZW1wdHkgc3RyaW5ncyBhbmQgZW1wdHkgYXJyYXlzLlxyXG4gICAgICBob3Zlci5jb250ZW50cy5sZW5ndGggPT09IDBcclxuICAgICkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByYW5nZSA9XHJcbiAgICAgIGhvdmVyLnJhbmdlID09IG51bGwgPyBVdGlscy5nZXRXb3JkQXRQb3NpdGlvbihlZGl0b3IsIHBvaW50KSA6IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGhvdmVyLnJhbmdlKTtcclxuXHJcbiAgICBjb25zdCBtYXJrZWRTdHJpbmdzID0gKEFycmF5LmlzQXJyYXkoaG92ZXIuY29udGVudHMpID8gaG92ZXIuY29udGVudHMgOiBbaG92ZXIuY29udGVudHNdKS5tYXAoc3RyID0+XHJcbiAgICAgIERhdGF0aXBBZGFwdGVyLmNvbnZlcnRNYXJrZWRTdHJpbmcoZWRpdG9yLCBzdHIpLFxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4ge3JhbmdlLCBtYXJrZWRTdHJpbmdzfTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjb252ZXJ0TWFya2VkU3RyaW5nKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBtYXJrZWRTdHJpbmc6IE1hcmtlZFN0cmluZyk6IGF0b21JZGUkTWFya2VkU3RyaW5nIHtcclxuICAgIGlmICh0eXBlb2YgbWFya2VkU3RyaW5nID09PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6ICdzbmlwcGV0JyxcclxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIG1hcHBpbmcgZnJvbSBsYW5ndWFnZSAtPiBncmFtbWFyXHJcbiAgICAgICAgZ3JhbW1hcjogYXRvbS5ncmFtbWFycy5ncmFtbWFyRm9yU2NvcGVOYW1lKGBzb3VyY2UuJHttYXJrZWRTdHJpbmcubGFuZ3VhZ2V9YCkgfHwgZWRpdG9yLmdldEdyYW1tYXIoKSxcclxuICAgICAgICB2YWx1ZTogbWFya2VkU3RyaW5nLnZhbHVlLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt0eXBlOiAnbWFya2Rvd24nLCB2YWx1ZTogbWFya2VkU3RyaW5nfTtcclxuICB9XHJcbn1cclxuIl19