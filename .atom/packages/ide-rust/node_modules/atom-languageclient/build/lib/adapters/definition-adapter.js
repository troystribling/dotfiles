Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
let DefinitionAdapter = class DefinitionAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a definitionProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.definitionProvider === true;
  }

  // Public: Get the definitions for a symbol at a given {Point} within a
  // {TextEditor} including optionally highlighting all other references
  // within the document if the langauge server also supports highlighting.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `languageName` The name of the programming language.
  // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
  // * `point` The Atom {Point} containing the position of the text that represents the symbol
  //           for which the definition and highlights should be provided.
  //
  // Returns a {Promise} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  getDefinition(connection, serverCapabilities, languageName, editor, point) {
    return _asyncToGenerator(function* () {
      const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);
      const definitionLocations = DefinitionAdapter.normalizeLocations((yield connection.gotoDefinition(documentPositionParams)));
      if (definitionLocations == null || definitionLocations.length === 0) {
        return null;
      }

      let queryRange;
      if (serverCapabilities.documentHighlightProvider) {
        const highlights = yield connection.documentHighlight(documentPositionParams);
        if (highlights != null && highlights.length > 0) {
          queryRange = highlights.map(function (h) {
            return _convert2.default.lsRangeToAtomRange(h.range);
          });
        }
      }

      return {
        queryRange: queryRange || [_utils2.default.getWordAtPosition(editor, point)],
        definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName)
      };
    })();
  }

  // Public: Normalize the locations so a single {Location} becomes an {Array} of just
  // one. The language server protocol return either as the protocol evolved between v1 and v2.
  //
  // * `locationResult` either a single {Location} object or an {Array} of {Locations}
  //
  // Returns an {Array} of {Location}s or {null} if the locationResult was null.
  static normalizeLocations(locationResult) {
    if (locationResult == null) {
      return null;
    }
    return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter(d => d.range.start != null);
  }

  // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
  //
  // * `locations` An {Array} of {Location} objects to be converted.
  // * `languageName` The name of the language these objects are written in.
  //
  // Returns an {Array} of {Definition}s that represented the converted {Location}s.
  static convertLocationsToDefinitions(locations, languageName) {
    return locations.map(d => ({
      path: _convert2.default.uriToPath(d.uri),
      position: _convert2.default.positionToPoint(d.range.start),
      range: _atom.Range.fromObject(_convert2.default.lsRangeToAtomRange(d.range)),
      language: languageName
    }));
  }
};
exports.default = DefinitionAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kZWZpbml0aW9uLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGVmaW5pdGlvbkFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRlZmluaXRpb25Qcm92aWRlciIsImdldERlZmluaXRpb24iLCJjb25uZWN0aW9uIiwibGFuZ3VhZ2VOYW1lIiwiZWRpdG9yIiwicG9pbnQiLCJkb2N1bWVudFBvc2l0aW9uUGFyYW1zIiwiZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImRlZmluaXRpb25Mb2NhdGlvbnMiLCJub3JtYWxpemVMb2NhdGlvbnMiLCJnb3RvRGVmaW5pdGlvbiIsImxlbmd0aCIsInF1ZXJ5UmFuZ2UiLCJkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIiwiaGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0IiwibWFwIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwiaCIsInJhbmdlIiwiZ2V0V29yZEF0UG9zaXRpb24iLCJkZWZpbml0aW9ucyIsImNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zIiwibG9jYXRpb25SZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJkIiwic3RhcnQiLCJsb2NhdGlvbnMiLCJwYXRoIiwidXJpVG9QYXRoIiwidXJpIiwicG9zaXRpb24iLCJwb3NpdGlvblRvUG9pbnQiLCJmcm9tT2JqZWN0IiwibGFuZ3VhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBS0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBO0lBQ3FCQSxpQixHQUFOLE1BQU1BLGlCQUFOLENBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsUUFBUCxDQUFnQkMsa0JBQWhCLEVBQWlFO0FBQy9ELFdBQU9BLG1CQUFtQkMsa0JBQW5CLEtBQTBDLElBQWpEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTUMsZUFBTixDQUNFQyxVQURGLEVBRUVILGtCQUZGLEVBR0VJLFlBSEYsRUFJRUMsTUFKRixFQUtFQyxLQUxGLEVBTTJDO0FBQUE7QUFDekMsWUFBTUMseUJBQXlCLGtCQUFRQyxrQ0FBUixDQUEyQ0gsTUFBM0MsRUFBbURDLEtBQW5ELENBQS9CO0FBQ0EsWUFBTUcsc0JBQXNCWCxrQkFBa0JZLGtCQUFsQixFQUMxQixNQUFNUCxXQUFXUSxjQUFYLENBQTBCSixzQkFBMUIsQ0FEb0IsRUFBNUI7QUFHQSxVQUFJRSx1QkFBdUIsSUFBdkIsSUFBK0JBLG9CQUFvQkcsTUFBcEIsS0FBK0IsQ0FBbEUsRUFBcUU7QUFBRSxlQUFPLElBQVA7QUFBYzs7QUFFckYsVUFBSUMsVUFBSjtBQUNBLFVBQUliLG1CQUFtQmMseUJBQXZCLEVBQWtEO0FBQ2hELGNBQU1DLGFBQWEsTUFBTVosV0FBV2EsaUJBQVgsQ0FBNkJULHNCQUE3QixDQUF6QjtBQUNBLFlBQUlRLGNBQWMsSUFBZCxJQUFzQkEsV0FBV0gsTUFBWCxHQUFvQixDQUE5QyxFQUFpRDtBQUMvQ0MsdUJBQWFFLFdBQVdFLEdBQVgsQ0FBZTtBQUFBLG1CQUFLLGtCQUFRQyxrQkFBUixDQUEyQkMsRUFBRUMsS0FBN0IsQ0FBTDtBQUFBLFdBQWYsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsYUFBTztBQUNMUCxvQkFBWUEsY0FBYyxDQUFDLGdCQUFNUSxpQkFBTixDQUF3QmhCLE1BQXhCLEVBQWdDQyxLQUFoQyxDQUFELENBRHJCO0FBRUxnQixxQkFBYXhCLGtCQUFrQnlCLDZCQUFsQixDQUFnRGQsbUJBQWhELEVBQXFFTCxZQUFyRTtBQUZSLE9BQVA7QUFmeUM7QUFtQjFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9NLGtCQUFQLENBQTBCYyxjQUExQixFQUF3RjtBQUN0RixRQUFJQSxrQkFBa0IsSUFBdEIsRUFBNEI7QUFBRSxhQUFPLElBQVA7QUFBYztBQUM1QyxXQUFPLENBQUNDLE1BQU1DLE9BQU4sQ0FBY0YsY0FBZCxJQUFnQ0EsY0FBaEMsR0FBaUQsQ0FBQ0EsY0FBRCxDQUFsRCxFQUFvRUcsTUFBcEUsQ0FBMkVDLEtBQUtBLEVBQUVSLEtBQUYsQ0FBUVMsS0FBUixJQUFpQixJQUFqRyxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT04sNkJBQVAsQ0FBcUNPLFNBQXJDLEVBQWlFMUIsWUFBakUsRUFBa0g7QUFDaEgsV0FBTzBCLFVBQVViLEdBQVYsQ0FBY1csTUFBTTtBQUN6QkcsWUFBTSxrQkFBUUMsU0FBUixDQUFrQkosRUFBRUssR0FBcEIsQ0FEbUI7QUFFekJDLGdCQUFVLGtCQUFRQyxlQUFSLENBQXdCUCxFQUFFUixLQUFGLENBQVFTLEtBQWhDLENBRmU7QUFHekJULGFBQU8sWUFBTWdCLFVBQU4sQ0FBaUIsa0JBQVFsQixrQkFBUixDQUEyQlUsRUFBRVIsS0FBN0IsQ0FBakIsQ0FIa0I7QUFJekJpQixnQkFBVWpDO0FBSmUsS0FBTixDQUFkLENBQVA7QUFNRDtBQTVFb0MsQztrQkFBbEJOLGlCIiwiZmlsZSI6ImRlZmluaXRpb24tYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgdHlwZSBMb2NhdGlvbixcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7UmFuZ2V9IGZyb20gJ2F0b20nO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXG4vLyBBdG9tIElERSBVSSBEZWZpbml0aW9ucyBwYWNrYWdlIGZvciAnR28gVG8gRGVmaW5pdGlvbicgZnVuY3Rpb25hbGl0eS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmluaXRpb25BZGFwdGVyIHtcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIGRlZmluaXRpb25Qcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kZWZpbml0aW9uUHJvdmlkZXIgPT09IHRydWU7XG4gIH1cblxuICAvLyBQdWJsaWM6IEdldCB0aGUgZGVmaW5pdGlvbnMgZm9yIGEgc3ltYm9sIGF0IGEgZ2l2ZW4ge1BvaW50fSB3aXRoaW4gYVxuICAvLyB7VGV4dEVkaXRvcn0gaW5jbHVkaW5nIG9wdGlvbmFsbHkgaGlnaGxpZ2h0aW5nIGFsbCBvdGhlciByZWZlcmVuY2VzXG4gIC8vIHdpdGhpbiB0aGUgZG9jdW1lbnQgaWYgdGhlIGxhbmdhdWdlIHNlcnZlciBhbHNvIHN1cHBvcnRzIGhpZ2hsaWdodGluZy5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBwcm92aWRlIGRlZmluaXRpb25zIGFuZCBoaWdobGlnaHRzLlxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSB1c2VkLlxuICAvLyAqIGBsYW5ndWFnZU5hbWVgIFRoZSBuYW1lIG9mIHRoZSBwcm9ncmFtbWluZyBsYW5ndWFnZS5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgc3ltYm9sIGFuZCBwb3RlbnRpYWwgaGlnaGxpZ2h0cy5cbiAgLy8gKiBgcG9pbnRgIFRoZSBBdG9tIHtQb2ludH0gY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHRleHQgdGhhdCByZXByZXNlbnRzIHRoZSBzeW1ib2xcbiAgLy8gICAgICAgICAgIGZvciB3aGljaCB0aGUgZGVmaW5pdGlvbiBhbmQgaGlnaGxpZ2h0cyBzaG91bGQgYmUgcHJvdmlkZWQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gIGFzeW5jIGdldERlZmluaXRpb24oXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzLFxuICAgIGxhbmd1YWdlTmFtZTogc3RyaW5nLFxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcbiAgICBwb2ludDogYXRvbSRQb2ludCxcbiAgKTogUHJvbWlzZTw/bnVjbGlkZSREZWZpbml0aW9uUXVlcnlSZXN1bHQ+IHtcbiAgICBjb25zdCBkb2N1bWVudFBvc2l0aW9uUGFyYW1zID0gQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvciwgcG9pbnQpO1xuICAgIGNvbnN0IGRlZmluaXRpb25Mb2NhdGlvbnMgPSBEZWZpbml0aW9uQWRhcHRlci5ub3JtYWxpemVMb2NhdGlvbnMoXG4gICAgICBhd2FpdCBjb25uZWN0aW9uLmdvdG9EZWZpbml0aW9uKGRvY3VtZW50UG9zaXRpb25QYXJhbXMpLFxuICAgICk7XG4gICAgaWYgKGRlZmluaXRpb25Mb2NhdGlvbnMgPT0gbnVsbCB8fCBkZWZpbml0aW9uTG9jYXRpb25zLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgbGV0IHF1ZXJ5UmFuZ2U7XG4gICAgaWYgKHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyKSB7XG4gICAgICBjb25zdCBoaWdobGlnaHRzID0gYXdhaXQgY29ubmVjdGlvbi5kb2N1bWVudEhpZ2hsaWdodChkb2N1bWVudFBvc2l0aW9uUGFyYW1zKTtcbiAgICAgIGlmIChoaWdobGlnaHRzICE9IG51bGwgJiYgaGlnaGxpZ2h0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHF1ZXJ5UmFuZ2UgPSBoaWdobGlnaHRzLm1hcChoID0+IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGgucmFuZ2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcXVlcnlSYW5nZTogcXVlcnlSYW5nZSB8fCBbVXRpbHMuZ2V0V29yZEF0UG9zaXRpb24oZWRpdG9yLCBwb2ludCldLFxuICAgICAgZGVmaW5pdGlvbnM6IERlZmluaXRpb25BZGFwdGVyLmNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zKGRlZmluaXRpb25Mb2NhdGlvbnMsIGxhbmd1YWdlTmFtZSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogTm9ybWFsaXplIHRoZSBsb2NhdGlvbnMgc28gYSBzaW5nbGUge0xvY2F0aW9ufSBiZWNvbWVzIGFuIHtBcnJheX0gb2YganVzdFxuICAvLyBvbmUuIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgcHJvdG9jb2wgcmV0dXJuIGVpdGhlciBhcyB0aGUgcHJvdG9jb2wgZXZvbHZlZCBiZXR3ZWVuIHYxIGFuZCB2Mi5cbiAgLy9cbiAgLy8gKiBgbG9jYXRpb25SZXN1bHRgIGVpdGhlciBhIHNpbmdsZSB7TG9jYXRpb259IG9iamVjdCBvciBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbnN9XG4gIC8vXG4gIC8vIFJldHVybnMgYW4ge0FycmF5fSBvZiB7TG9jYXRpb259cyBvciB7bnVsbH0gaWYgdGhlIGxvY2F0aW9uUmVzdWx0IHdhcyBudWxsLlxuICBzdGF0aWMgbm9ybWFsaXplTG9jYXRpb25zKGxvY2F0aW9uUmVzdWx0OiBMb2NhdGlvbiB8IEFycmF5PExvY2F0aW9uPik6ID9BcnJheTxMb2NhdGlvbj4ge1xuICAgIGlmIChsb2NhdGlvblJlc3VsdCA9PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGxvY2F0aW9uUmVzdWx0KSA/IGxvY2F0aW9uUmVzdWx0IDogW2xvY2F0aW9uUmVzdWx0XSkuZmlsdGVyKGQgPT4gZC5yYW5nZS5zdGFydCAhPSBudWxsKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiB7QXJyYXl9IG9mIHtMb2NhdGlvbn0gb2JqZWN0cyBpbnRvIGFuIEFycmF5IG9mIHtEZWZpbml0aW9ufXMuXG4gIC8vXG4gIC8vICogYGxvY2F0aW9uc2AgQW4ge0FycmF5fSBvZiB7TG9jYXRpb259IG9iamVjdHMgdG8gYmUgY29udmVydGVkLlxuICAvLyAqIGBsYW5ndWFnZU5hbWVgIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0aGVzZSBvYmplY3RzIGFyZSB3cml0dGVuIGluLlxuICAvL1xuICAvLyBSZXR1cm5zIGFuIHtBcnJheX0gb2Yge0RlZmluaXRpb259cyB0aGF0IHJlcHJlc2VudGVkIHRoZSBjb252ZXJ0ZWQge0xvY2F0aW9ufXMuXG4gIHN0YXRpYyBjb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhsb2NhdGlvbnM6IEFycmF5PExvY2F0aW9uPiwgbGFuZ3VhZ2VOYW1lOiBzdHJpbmcpOiBBcnJheTxudWNsaWRlJERlZmluaXRpb24+IHtcbiAgICByZXR1cm4gbG9jYXRpb25zLm1hcChkID0+ICh7XG4gICAgICBwYXRoOiBDb252ZXJ0LnVyaVRvUGF0aChkLnVyaSksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoZC5yYW5nZS5zdGFydCksXG4gICAgICByYW5nZTogUmFuZ2UuZnJvbU9iamVjdChDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShkLnJhbmdlKSksXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgIH0pKTtcbiAgfVxufVxuIl19