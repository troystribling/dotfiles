Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class DefinitionAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a definitionProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.definitionProvider === true;
  }

  // Public: Get the definitions for a symbol at a given {Point} within a
  // {TextEditor} including optionally highlighting all other references
  // within the document if the langauge server also supports highlighting.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will provide definitions and highlights.
  // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
  // * `languageName` The name of the programming language.
  // * `editor` The Atom {TextEditor} containing the symbol and potential highlights.
  // * `point` The Atom {Point} containing the position of the text that represents the symbol
  //           for which the definition and highlights should be provided.
  //
  // Returns a {Promise} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  async getDefinition(connection, serverCapabilities, languageName, editor, point) {
    const documentPositionParams = _convert2.default.editorToTextDocumentPositionParams(editor, point);
    const definitionLocations = DefinitionAdapter.normalizeLocations((await connection.gotoDefinition(documentPositionParams)));
    if (definitionLocations == null || definitionLocations.length === 0) {
      return null;
    }

    let queryRange;
    if (serverCapabilities.documentHighlightProvider) {
      const highlights = await connection.documentHighlight(documentPositionParams);
      if (highlights != null && highlights.length > 0) {
        queryRange = highlights.map(h => _convert2.default.lsRangeToAtomRange(h.range));
      }
    }

    return {
      queryRange: queryRange || [_utils2.default.getWordAtPosition(editor, point)],
      definitions: DefinitionAdapter.convertLocationsToDefinitions(definitionLocations, languageName)
    };
  }

  // Public: Normalize the locations so a single {Location} becomes an {Array} of just
  // one. The language server protocol return either as the protocol evolved between v1 and v2.
  //
  // * `locationResult` either a single {Location} object or an {Array} of {Locations}
  //
  // Returns an {Array} of {Location}s or {null} if the locationResult was null.
  static normalizeLocations(locationResult) {
    if (locationResult == null) {
      return null;
    }
    return (Array.isArray(locationResult) ? locationResult : [locationResult]).filter(d => d.range.start != null);
  }

  // Public: Convert an {Array} of {Location} objects into an Array of {Definition}s.
  //
  // * `locations` An {Array} of {Location} objects to be converted.
  // * `languageName` The name of the language these objects are written in.
  //
  // Returns an {Array} of {Definition}s that represented the converted {Location}s.
  static convertLocationsToDefinitions(locations, languageName) {
    return locations.map(d => ({
      path: _convert2.default.uriToPath(d.uri),
      position: _convert2.default.positionToPoint(d.range.start),
      range: _atom.Range.fromObject(_convert2.default.lsRangeToAtomRange(d.range)),
      language: languageName
    }));
  }
}
exports.default = DefinitionAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kZWZpbml0aW9uLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRGVmaW5pdGlvbkFkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRlZmluaXRpb25Qcm92aWRlciIsImdldERlZmluaXRpb24iLCJjb25uZWN0aW9uIiwibGFuZ3VhZ2VOYW1lIiwiZWRpdG9yIiwicG9pbnQiLCJkb2N1bWVudFBvc2l0aW9uUGFyYW1zIiwiZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyIsImRlZmluaXRpb25Mb2NhdGlvbnMiLCJub3JtYWxpemVMb2NhdGlvbnMiLCJnb3RvRGVmaW5pdGlvbiIsImxlbmd0aCIsInF1ZXJ5UmFuZ2UiLCJkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIiwiaGlnaGxpZ2h0cyIsImRvY3VtZW50SGlnaGxpZ2h0IiwibWFwIiwiaCIsImxzUmFuZ2VUb0F0b21SYW5nZSIsInJhbmdlIiwiZ2V0V29yZEF0UG9zaXRpb24iLCJkZWZpbml0aW9ucyIsImNvbnZlcnRMb2NhdGlvbnNUb0RlZmluaXRpb25zIiwibG9jYXRpb25SZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJmaWx0ZXIiLCJkIiwic3RhcnQiLCJsb2NhdGlvbnMiLCJwYXRoIiwidXJpVG9QYXRoIiwidXJpIiwicG9zaXRpb24iLCJwb3NpdGlvblRvUG9pbnQiLCJmcm9tT2JqZWN0IiwibGFuZ3VhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7QUFFQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUEsaUJBQU4sQ0FBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBT0EsbUJBQW1CQyxrQkFBbkIsS0FBMEMsSUFBakQ7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU1DLGFBQU4sQ0FDRUMsVUFERixFQUVFSCxrQkFGRixFQUdFSSxZQUhGLEVBSUVDLE1BSkYsRUFLRUMsS0FMRixFQU0yQztBQUN6QyxVQUFNQyx5QkFBeUIsa0JBQVFDLGtDQUFSLENBQTJDSCxNQUEzQyxFQUFtREMsS0FBbkQsQ0FBL0I7QUFDQSxVQUFNRyxzQkFBc0JYLGtCQUFrQlksa0JBQWxCLEVBQzFCLE1BQU1QLFdBQVdRLGNBQVgsQ0FBMEJKLHNCQUExQixDQURvQixFQUE1QjtBQUdBLFFBQUlFLHVCQUF1QixJQUF2QixJQUErQkEsb0JBQW9CRyxNQUFwQixLQUErQixDQUFsRSxFQUFxRTtBQUNuRSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJQyxVQUFKO0FBQ0EsUUFBSWIsbUJBQW1CYyx5QkFBdkIsRUFBa0Q7QUFDaEQsWUFBTUMsYUFBYSxNQUFNWixXQUFXYSxpQkFBWCxDQUE2QlQsc0JBQTdCLENBQXpCO0FBQ0EsVUFBSVEsY0FBYyxJQUFkLElBQXNCQSxXQUFXSCxNQUFYLEdBQW9CLENBQTlDLEVBQWlEO0FBQy9DQyxxQkFBYUUsV0FBV0UsR0FBWCxDQUFlQyxLQUFLLGtCQUFRQyxrQkFBUixDQUEyQkQsRUFBRUUsS0FBN0IsQ0FBcEIsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTztBQUNMUCxrQkFBWUEsY0FBYyxDQUFDLGdCQUFNUSxpQkFBTixDQUF3QmhCLE1BQXhCLEVBQWdDQyxLQUFoQyxDQUFELENBRHJCO0FBRUxnQixtQkFBYXhCLGtCQUFrQnlCLDZCQUFsQixDQUFnRGQsbUJBQWhELEVBQXFFTCxZQUFyRTtBQUZSLEtBQVA7QUFJRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPTSxrQkFBUCxDQUEwQmMsY0FBMUIsRUFBd0Y7QUFDdEYsUUFBSUEsa0JBQWtCLElBQXRCLEVBQTRCO0FBQzFCLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBTyxDQUFDQyxNQUFNQyxPQUFOLENBQWNGLGNBQWQsSUFBZ0NBLGNBQWhDLEdBQWlELENBQUNBLGNBQUQsQ0FBbEQsRUFBb0VHLE1BQXBFLENBQTJFQyxLQUFLQSxFQUFFUixLQUFGLENBQVFTLEtBQVIsSUFBaUIsSUFBakcsQ0FBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9OLDZCQUFQLENBQXFDTyxTQUFyQyxFQUFpRTFCLFlBQWpFLEVBQWtIO0FBQ2hILFdBQU8wQixVQUFVYixHQUFWLENBQWNXLE1BQU07QUFDekJHLFlBQU0sa0JBQVFDLFNBQVIsQ0FBa0JKLEVBQUVLLEdBQXBCLENBRG1CO0FBRXpCQyxnQkFBVSxrQkFBUUMsZUFBUixDQUF3QlAsRUFBRVIsS0FBRixDQUFRUyxLQUFoQyxDQUZlO0FBR3pCVCxhQUFPLFlBQU1nQixVQUFOLENBQWlCLGtCQUFRakIsa0JBQVIsQ0FBMkJTLEVBQUVSLEtBQTdCLENBQWpCLENBSGtCO0FBSXpCaUIsZ0JBQVVqQztBQUplLEtBQU4sQ0FBZCxDQUFQO0FBTUQ7QUFoRm9DO2tCQUFsQk4saUIiLCJmaWxlIjoiZGVmaW5pdGlvbi1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIHR5cGUgTG9jYXRpb24sIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzfSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQge1JhbmdlfSBmcm9tICdhdG9tJztcblxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBkZWZpbml0aW9uIHByb3ZpZGVyIHRvIHRoZVxuLy8gQXRvbSBJREUgVUkgRGVmaW5pdGlvbnMgcGFja2FnZSBmb3IgJ0dvIFRvIERlZmluaXRpb24nIGZ1bmN0aW9uYWxpdHkuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZpbml0aW9uQWRhcHRlciB7XG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSBkZWZpbml0aW9uUHJvdmlkZXIuXG4gIC8vXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXG4gIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMuZGVmaW5pdGlvblByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gUHVibGljOiBHZXQgdGhlIGRlZmluaXRpb25zIGZvciBhIHN5bWJvbCBhdCBhIGdpdmVuIHtQb2ludH0gd2l0aGluIGFcbiAgLy8ge1RleHRFZGl0b3J9IGluY2x1ZGluZyBvcHRpb25hbGx5IGhpZ2hsaWdodGluZyBhbGwgb3RoZXIgcmVmZXJlbmNlc1xuICAvLyB3aXRoaW4gdGhlIGRvY3VtZW50IGlmIHRoZSBsYW5nYXVnZSBzZXJ2ZXIgYWxzbyBzdXBwb3J0cyBoaWdobGlnaHRpbmcuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgcHJvdmlkZSBkZWZpbml0aW9ucyBhbmQgaGlnaGxpZ2h0cy5cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cbiAgLy8gKiBgbGFuZ3VhZ2VOYW1lYCBUaGUgbmFtZSBvZiB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UuXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHN5bWJvbCBhbmQgcG90ZW50aWFsIGhpZ2hsaWdodHMuXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvc2l0aW9uIG9mIHRoZSB0ZXh0IHRoYXQgcmVwcmVzZW50cyB0aGUgc3ltYm9sXG4gIC8vICAgICAgICAgICBmb3Igd2hpY2ggdGhlIGRlZmluaXRpb24gYW5kIGhpZ2hsaWdodHMgc2hvdWxkIGJlIHByb3ZpZGVkLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICBhc3luYyBnZXREZWZpbml0aW9uKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcbiAgICBsYW5ndWFnZU5hbWU6IHN0cmluZyxcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXG4gICAgcG9pbnQ6IGF0b20kUG9pbnQsXG4gICk6IFByb21pc2U8P2F0b21JZGUkRGVmaW5pdGlvblF1ZXJ5UmVzdWx0PiB7XG4gICAgY29uc3QgZG9jdW1lbnRQb3NpdGlvblBhcmFtcyA9IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvaW50KTtcbiAgICBjb25zdCBkZWZpbml0aW9uTG9jYXRpb25zID0gRGVmaW5pdGlvbkFkYXB0ZXIubm9ybWFsaXplTG9jYXRpb25zKFxuICAgICAgYXdhaXQgY29ubmVjdGlvbi5nb3RvRGVmaW5pdGlvbihkb2N1bWVudFBvc2l0aW9uUGFyYW1zKSxcbiAgICApO1xuICAgIGlmIChkZWZpbml0aW9uTG9jYXRpb25zID09IG51bGwgfHwgZGVmaW5pdGlvbkxvY2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBxdWVyeVJhbmdlO1xuICAgIGlmIChzZXJ2ZXJDYXBhYmlsaXRpZXMuZG9jdW1lbnRIaWdobGlnaHRQcm92aWRlcikge1xuICAgICAgY29uc3QgaGlnaGxpZ2h0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRIaWdobGlnaHQoZG9jdW1lbnRQb3NpdGlvblBhcmFtcyk7XG4gICAgICBpZiAoaGlnaGxpZ2h0cyAhPSBudWxsICYmIGhpZ2hsaWdodHMubGVuZ3RoID4gMCkge1xuICAgICAgICBxdWVyeVJhbmdlID0gaGlnaGxpZ2h0cy5tYXAoaCA9PiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShoLnJhbmdlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1ZXJ5UmFuZ2U6IHF1ZXJ5UmFuZ2UgfHwgW1V0aWxzLmdldFdvcmRBdFBvc2l0aW9uKGVkaXRvciwgcG9pbnQpXSxcbiAgICAgIGRlZmluaXRpb25zOiBEZWZpbml0aW9uQWRhcHRlci5jb252ZXJ0TG9jYXRpb25zVG9EZWZpbml0aW9ucyhkZWZpbml0aW9uTG9jYXRpb25zLCBsYW5ndWFnZU5hbWUpLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IE5vcm1hbGl6ZSB0aGUgbG9jYXRpb25zIHNvIGEgc2luZ2xlIHtMb2NhdGlvbn0gYmVjb21lcyBhbiB7QXJyYXl9IG9mIGp1c3RcbiAgLy8gb25lLiBUaGUgbGFuZ3VhZ2Ugc2VydmVyIHByb3RvY29sIHJldHVybiBlaXRoZXIgYXMgdGhlIHByb3RvY29sIGV2b2x2ZWQgYmV0d2VlbiB2MSBhbmQgdjIuXG4gIC8vXG4gIC8vICogYGxvY2F0aW9uUmVzdWx0YCBlaXRoZXIgYSBzaW5nbGUge0xvY2F0aW9ufSBvYmplY3Qgb3IgYW4ge0FycmF5fSBvZiB7TG9jYXRpb25zfVxuICAvL1xuICAvLyBSZXR1cm5zIGFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufXMgb3Ige251bGx9IGlmIHRoZSBsb2NhdGlvblJlc3VsdCB3YXMgbnVsbC5cbiAgc3RhdGljIG5vcm1hbGl6ZUxvY2F0aW9ucyhsb2NhdGlvblJlc3VsdDogTG9jYXRpb24gfCBBcnJheTxMb2NhdGlvbj4pOiA/QXJyYXk8TG9jYXRpb24+IHtcbiAgICBpZiAobG9jYXRpb25SZXN1bHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShsb2NhdGlvblJlc3VsdCkgPyBsb2NhdGlvblJlc3VsdCA6IFtsb2NhdGlvblJlc3VsdF0pLmZpbHRlcihkID0+IGQucmFuZ2Uuc3RhcnQgIT0gbnVsbCk7XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4ge0FycmF5fSBvZiB7TG9jYXRpb259IG9iamVjdHMgaW50byBhbiBBcnJheSBvZiB7RGVmaW5pdGlvbn1zLlxuICAvL1xuICAvLyAqIGBsb2NhdGlvbnNgIEFuIHtBcnJheX0gb2Yge0xvY2F0aW9ufSBvYmplY3RzIHRvIGJlIGNvbnZlcnRlZC5cbiAgLy8gKiBgbGFuZ3VhZ2VOYW1lYCBUaGUgbmFtZSBvZiB0aGUgbGFuZ3VhZ2UgdGhlc2Ugb2JqZWN0cyBhcmUgd3JpdHRlbiBpbi5cbiAgLy9cbiAgLy8gUmV0dXJucyBhbiB7QXJyYXl9IG9mIHtEZWZpbml0aW9ufXMgdGhhdCByZXByZXNlbnRlZCB0aGUgY29udmVydGVkIHtMb2NhdGlvbn1zLlxuICBzdGF0aWMgY29udmVydExvY2F0aW9uc1RvRGVmaW5pdGlvbnMobG9jYXRpb25zOiBBcnJheTxMb2NhdGlvbj4sIGxhbmd1YWdlTmFtZTogc3RyaW5nKTogQXJyYXk8YXRvbUlkZSREZWZpbml0aW9uPiB7XG4gICAgcmV0dXJuIGxvY2F0aW9ucy5tYXAoZCA9PiAoe1xuICAgICAgcGF0aDogQ29udmVydC51cmlUb1BhdGgoZC51cmkpLFxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KGQucmFuZ2Uuc3RhcnQpLFxuICAgICAgcmFuZ2U6IFJhbmdlLmZyb21PYmplY3QoQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoZC5yYW5nZSkpLFxuICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZSxcbiAgICB9KSk7XG4gIH1cbn1cbiJdfQ==