Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Synchronizes the documents between Atom and the language server by notifying
// each end of changes, opening, closing and other events as well as sending and applying
// changes either in whole or in part depending on what the language server supports.
class DocumentSyncAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix textDocumentSync capability either being Full or
  // Incremental.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return this.canAdaptV2(serverCapabilities) || this.canAdaptV3(serverCapabilities);
  }

  static canAdaptV2(serverCapabilities) {
    return serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Incremental || serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Full;
  }

  static canAdaptV3(serverCapabilities) {
    const options = serverCapabilities.textDocumentSync;
    return options !== null && typeof options === 'object' && (options.change === _languageclient.TextDocumentSyncKind.Incremental || options.change === _languageclient.TextDocumentSyncKind.Full);
  }

  // Public: Create a new {DocumentSyncAdapter} for the given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server to be kept in sync.
  // * `documentSyncKind` The type of document syncing supported - Full or Incremental.
  // * `editorSelector` A predicate function that takes a {TextEditor} and returns a {boolean}
  //                    indicating whether this adapter should care about the contents of the editor.
  constructor(connection, documentSyncKind, editorSelector) {
    this._disposable = new _atom.CompositeDisposable();
    this._editors = new WeakMap();
    this._versions = new Map();

    this._connection = connection;
    if (typeof documentSyncKind === 'number') {
      this._documentSyncKind = documentSyncKind;
    } else if (documentSyncKind != null && documentSyncKind.change != null) {
      this._documentSyncKind = documentSyncKind.change;
    } else {
      this._documentSyncKind = _languageclient.TextDocumentSyncKind.Full;
    }
    this._editorSelector = editorSelector;
    this._disposable.add(atom.textEditors.observe(this.observeTextEditor.bind(this)));
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Examine a {TextEditor} and decide if we wish to observe it. If so ensure that we stop observing it
  // when it is closed or otherwise destroyed.
  //
  // * `editor` A {TextEditor} to consider for observation.
  observeTextEditor(editor) {
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => {
      this._disposable.remove(listener);
      listener.dispose();
    }));
    this._disposable.add(listener);
    if (!this._editors.has(editor) && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleGrammarChange(editor) {
    const sync = this._editors.get(editor);
    if (sync != null && !this._editorSelector(editor)) {
      this._editors.delete(editor);
      this._disposable.remove(sync);
      sync.dispose();
    } else if (sync == null && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleNewEditor(editor) {
    const sync = new TextEditorSyncAdapter(editor, this._connection, this._documentSyncKind, this._versions);
    this._editors.set(editor, sync);
    this._disposable.add(sync);
    this._disposable.add(editor.onDidDestroy(() => {
      const destroyedSync = this._editors.get(editor);
      if (destroyedSync) {
        this._editors.delete(editor);
        this._disposable.remove(destroyedSync);
        destroyedSync.dispose();
      }
    }));
  }

  getEditorSyncAdapter(editor) {
    return this._editors.get(editor);
  }
}

exports.default = DocumentSyncAdapter; // Public: Keep a single {TextEditor} in sync with a given language server.

class TextEditorSyncAdapter {

  // Public: Create a {TextEditorSyncAdapter} in sync with a given language server.
  //
  // * `editor` A {TextEditor} to keep in sync.
  // * `connection` A {LanguageClientConnection} to a language server to keep in sync.
  // * `documentSyncKind` Whether to use Full (1) or Incremental (2) when sending changes.
  constructor(editor, connection, documentSyncKind, versions) {
    this._disposable = new _atom.CompositeDisposable();

    this._editor = editor;
    this._connection = connection;
    this._versions = versions;
    this._fakeDidChangeWatchedFiles = atom.project.onDidChangeFiles == null;

    const changeTracking = this.setupChangeTracking(documentSyncKind);
    if (changeTracking != null) {
      this._disposable.add(changeTracking);
    }

    this._disposable.add(editor.getBuffer().onWillSave(this.willSave.bind(this)), editor.onDidSave(this.didSave.bind(this)), editor.onDidDestroy(this.didClose.bind(this)), editor.onDidChangePath(this.didRename.bind(this)));

    this._currentUri = this.getEditorUri();
    this.didOpen();
  }

  // The change tracking disposable listener that will ensure that changes are sent to the
  // language server as appropriate.
  setupChangeTracking(documentSyncKind) {
    switch (documentSyncKind) {
      case _languageclient.TextDocumentSyncKind.Full:
        return this._editor.onDidChange(this.sendFullChanges.bind(this));
      case _languageclient.TextDocumentSyncKind.Incremental:
        return this._editor.getBuffer().onDidChangeText(this.sendIncrementalChanges.bind(this));
    }
    return null;
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Get the languageId field that will be sent to the language server by simply
  // using the grammar name.
  getLanguageId() {
    return this._editor.getGrammar().name;
  }

  // Public: Create a {VersionedTextDocumentIdentifier} for the document observed by
  // this adapter including both the Uri and the current Version.
  getVersionedTextDocumentIdentifier() {
    return {
      uri: this.getEditorUri(),
      version: this._getVersion(this._editor.getPath() || '')
    };
  }

  // Public: Send the entire document to the language server. This is used when
  // operating in Full (1) sync mode.
  sendFullChanges() {
    if (!this._isPrimaryAdapter()) {
      return;
    } // Multiple editors, we are not first

    this._bumpVersion();
    this._connection.didChangeTextDocument({
      textDocument: this.getVersionedTextDocumentIdentifier(),
      contentChanges: [{ text: this._editor.getText() }]
    });
  }

  // Public: Send the incremental text changes to the language server. This is used
  // when operating in Incremental (2) sync mode.
  //
  // * `event` The event fired by Atom to indicate the document has stopped changing
  //           including a list of changes since the last time this event fired for this
  //           text editor.
  // Note: The order of changes in the event is guaranteed top to bottom.  Language server
  // expects this in reverse.
  sendIncrementalChanges(event) {
    if (event.changes.length > 0) {
      if (!this._isPrimaryAdapter()) {
        return;
      } // Multiple editors, we are not first

      this._bumpVersion();
      this._connection.didChangeTextDocument({
        textDocument: this.getVersionedTextDocumentIdentifier(),
        contentChanges: event.changes.map(TextEditorSyncAdapter.textEditToContentChange).reverse()
      });
    }
  }

  // Public: Convert an Atom {TextEditEvent} to a language server {TextDocumentContentChangeEvent}
  // object.
  //
  // * `change` The Atom {TextEditEvent} to convert.
  //
  // Returns a {TextDocumentContentChangeEvent} that represents the converted {TextEditEvent}.
  static textEditToContentChange(change) {
    return {
      range: _convert2.default.atomRangeToLSRange(change.oldRange),
      rangeLength: change.oldText.length,
      text: change.newText
    };
  }

  _isPrimaryAdapter() {
    const lowestIdForBuffer = Math.min(...atom.workspace.getTextEditors().filter(t => t.getBuffer() === this._editor.getBuffer()).map(t => t.id));
    return lowestIdForBuffer === this._editor.id;
  }

  _bumpVersion() {
    const filePath = this._editor.getPath();
    if (filePath == null) {
      return;
    }
    this._versions.set(filePath, this._getVersion(filePath) + 1);
  }

  // Ensure when the document is opened we send notification to the language server
  // so it can load it in and keep track of diagnostics etc.
  didOpen() {
    const filePath = this._editor.getPath();
    if (filePath == null) {
      return;
    } // Not yet saved

    if (!this._isPrimaryAdapter()) {
      return;
    } // Multiple editors, we are not first

    this._connection.didOpenTextDocument({
      textDocument: {
        uri: this.getEditorUri(),
        languageId: this.getLanguageId().toLowerCase(),
        version: this._getVersion(filePath),
        text: this._editor.getText()
      }
    });
  }

  _getVersion(filePath) {
    return this._versions.get(filePath) || 1;
  }

  // Called when the {TextEditor} is closed and sends the 'didCloseTextDocument' notification to
  // the connected language server.
  didClose() {
    if (this._editor.getPath() == null) {
      return;
    } // Not yet saved

    const fileStillOpen = atom.workspace.getTextEditors().find(t => t.getBuffer() === this._editor.getBuffer());
    if (fileStillOpen) {
      return; // Other windows or editors still have this file open
    }

    this._connection.didCloseTextDocument({ textDocument: { uri: this.getEditorUri() } });
  }

  // Called just before the {TextEditor} saves and sends the 'willSaveTextDocument' notification to
  // the connected language server.
  willSave() {
    if (!this._isPrimaryAdapter()) {
      return;
    }

    const uri = this.getEditorUri();
    this._connection.willSaveTextDocument({
      textDocument: { uri },
      reason: _languageclient.TextDocumentSaveReason.Manual
    });
  }

  // Called when the {TextEditor} saves and sends the 'didSaveTextDocument' notification to
  // the connected language server.
  // Note: Right now this also sends the `didChangeWatchedFiles` notification as well but that
  // will be sent from elsewhere soon.
  didSave() {
    if (!this._isPrimaryAdapter()) {
      return;
    }

    const uri = this.getEditorUri();
    this._connection.didSaveTextDocument({ textDocument: { uri } });
    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri, type: _languageclient.FileChangeType.Changed }]
      });
    }
  }

  didRename() {
    if (!this._isPrimaryAdapter()) {
      return;
    }

    const oldUri = this._currentUri;
    this._currentUri = this.getEditorUri();
    if (!oldUri) {
      return; // Didn't previously have a name
    }

    this._connection.didCloseTextDocument({
      textDocument: { uri: oldUri }
    });

    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri: oldUri, type: _languageclient.FileChangeType.Deleted }, { uri: this._currentUri, type: _languageclient.FileChangeType.Created }]
      });
    }

    // Send an equivalent open event for this editor, which will now use the new
    // file path.
    this.didOpen();
  }

  // Public: Obtain the current {TextEditor} path and convert it to a Uri.
  getEditorUri() {
    return _convert2.default.pathToUri(this._editor.getPath() || '');
  }
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRG9jdW1lbnRTeW5jQWRhcHRlciIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiY2FuQWRhcHRWMiIsImNhbkFkYXB0VjMiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwiSW5jcmVtZW50YWwiLCJGdWxsIiwib3B0aW9ucyIsImNoYW5nZSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsImRvY3VtZW50U3luY0tpbmQiLCJlZGl0b3JTZWxlY3RvciIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvcnMiLCJXZWFrTWFwIiwiX3ZlcnNpb25zIiwiTWFwIiwiX2Nvbm5lY3Rpb24iLCJfZG9jdW1lbnRTeW5jS2luZCIsIl9lZGl0b3JTZWxlY3RvciIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvciIsImJpbmQiLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsInJlbW92ZSIsImhhcyIsIl9oYW5kbGVOZXdFZGl0b3IiLCJzeW5jIiwiZ2V0IiwiZGVsZXRlIiwiVGV4dEVkaXRvclN5bmNBZGFwdGVyIiwic2V0IiwiZGVzdHJveWVkU3luYyIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwidmVyc2lvbnMiLCJfZWRpdG9yIiwiX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMiLCJwcm9qZWN0Iiwib25EaWRDaGFuZ2VGaWxlcyIsImNoYW5nZVRyYWNraW5nIiwic2V0dXBDaGFuZ2VUcmFja2luZyIsImdldEJ1ZmZlciIsIm9uV2lsbFNhdmUiLCJ3aWxsU2F2ZSIsIm9uRGlkU2F2ZSIsImRpZFNhdmUiLCJkaWRDbG9zZSIsIm9uRGlkQ2hhbmdlUGF0aCIsImRpZFJlbmFtZSIsIl9jdXJyZW50VXJpIiwiZ2V0RWRpdG9yVXJpIiwiZGlkT3BlbiIsIm9uRGlkQ2hhbmdlIiwic2VuZEZ1bGxDaGFuZ2VzIiwib25EaWRDaGFuZ2VUZXh0Iiwic2VuZEluY3JlbWVudGFsQ2hhbmdlcyIsImdldExhbmd1YWdlSWQiLCJnZXRHcmFtbWFyIiwibmFtZSIsImdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJ1cmkiLCJ2ZXJzaW9uIiwiX2dldFZlcnNpb24iLCJnZXRQYXRoIiwiX2lzUHJpbWFyeUFkYXB0ZXIiLCJfYnVtcFZlcnNpb24iLCJkaWRDaGFuZ2VUZXh0RG9jdW1lbnQiLCJ0ZXh0RG9jdW1lbnQiLCJjb250ZW50Q2hhbmdlcyIsInRleHQiLCJnZXRUZXh0IiwiZXZlbnQiLCJjaGFuZ2VzIiwibGVuZ3RoIiwibWFwIiwidGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UiLCJyZXZlcnNlIiwicmFuZ2UiLCJhdG9tUmFuZ2VUb0xTUmFuZ2UiLCJvbGRSYW5nZSIsInJhbmdlTGVuZ3RoIiwib2xkVGV4dCIsIm5ld1RleHQiLCJsb3dlc3RJZEZvckJ1ZmZlciIsIk1hdGgiLCJtaW4iLCJ3b3Jrc3BhY2UiLCJnZXRUZXh0RWRpdG9ycyIsImZpbHRlciIsInQiLCJpZCIsImZpbGVQYXRoIiwiZGlkT3BlblRleHREb2N1bWVudCIsImxhbmd1YWdlSWQiLCJ0b0xvd2VyQ2FzZSIsImZpbGVTdGlsbE9wZW4iLCJmaW5kIiwiZGlkQ2xvc2VUZXh0RG9jdW1lbnQiLCJ3aWxsU2F2ZVRleHREb2N1bWVudCIsInJlYXNvbiIsIk1hbnVhbCIsImRpZFNhdmVUZXh0RG9jdW1lbnQiLCJkaWRDaGFuZ2VXYXRjaGVkRmlsZXMiLCJ0eXBlIiwiQ2hhbmdlZCIsIm9sZFVyaSIsIkRlbGV0ZWQiLCJDcmVhdGVkIiwicGF0aFRvVXJpIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBVUE7Ozs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNlLE1BQU1BLG1CQUFOLENBQTBCOztBQVF2QztBQUNBO0FBQ0E7QUFDQTtB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QUwsQ0FBYTRCLE9BQWIsTUFBMEIsRUFBNUMsQ0FBUDtBQUNEO0FBaE95QiIsImZpbGUiOiJkb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xyXG5cclxuaW1wb3J0IHtcclxuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgRmlsZUNoYW5nZVR5cGUsXHJcbiAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbixcclxuICBUZXh0RG9jdW1lbnRTeW5jS2luZCxcclxuICB0eXBlIFRleHREb2N1bWVudFN5bmNPcHRpb25zLFxyXG4gIHR5cGUgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50LFxyXG4gIHR5cGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcixcclxuICB0eXBlIFNlcnZlckNhcGFiaWxpdGllcyxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5pbXBvcnQge0NvbXBvc2l0ZURpc3Bvc2FibGV9IGZyb20gJ2F0b20nO1xyXG5cclxuLy8gUHVibGljOiBTeW5jaHJvbml6ZXMgdGhlIGRvY3VtZW50cyBiZXR3ZWVuIEF0b20gYW5kIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYnkgbm90aWZ5aW5nXHJcbi8vIGVhY2ggZW5kIG9mIGNoYW5nZXMsIG9wZW5pbmcsIGNsb3NpbmcgYW5kIG90aGVyIGV2ZW50cyBhcyB3ZWxsIGFzIHNlbmRpbmcgYW5kIGFwcGx5aW5nXHJcbi8vIGNoYW5nZXMgZWl0aGVyIGluIHdob2xlIG9yIGluIHBhcnQgZGVwZW5kaW5nIG9uIHdoYXQgdGhlIGxhbmd1YWdlIHNlcnZlciBzdXBwb3J0cy5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRTeW5jQWRhcHRlciB7XHJcbiAgX2VkaXRvclNlbGVjdG9yOiBhdG9tJFRleHRFZGl0b3IgPT4gYm9vbGVhbjtcclxuICBfZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XHJcbiAgX2RvY3VtZW50U3luY0tpbmQ6IG51bWJlcjtcclxuICBfZWRpdG9yczogV2Vha01hcDxhdG9tJFRleHRFZGl0b3IsIFRleHRFZGl0b3JTeW5jQWRhcHRlcj4gPSBuZXcgV2Vha01hcCgpO1xyXG4gIF9jb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb247XHJcbiAgX3ZlcnNpb25zOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IHRleHREb2N1bWVudFN5bmMgY2FwYWJpbGl0eSBlaXRoZXIgYmVpbmcgRnVsbCBvclxyXG4gIC8vIEluY3JlbWVudGFsLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmNhbkFkYXB0VjIoc2VydmVyQ2FwYWJpbGl0aWVzKSB8fCB0aGlzLmNhbkFkYXB0VjMoc2VydmVyQ2FwYWJpbGl0aWVzKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBjYW5BZGFwdFYyKHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYyA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWwgfHxcclxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgY2FuQWRhcHRWMyhzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3B0aW9ucyA9IHNlcnZlckNhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnRTeW5jO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgKG9wdGlvbnMuY2hhbmdlID09PSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCB8fCBvcHRpb25zLmNoYW5nZSA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIG5ldyB7RG9jdW1lbnRTeW5jQWRhcHRlcn0gZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gYmUga2VwdCBpbiBzeW5jLlxyXG4gIC8vICogYGRvY3VtZW50U3luY0tpbmRgIFRoZSB0eXBlIG9mIGRvY3VtZW50IHN5bmNpbmcgc3VwcG9ydGVkIC0gRnVsbCBvciBJbmNyZW1lbnRhbC5cclxuICAvLyAqIGBlZGl0b3JTZWxlY3RvcmAgQSBwcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHtUZXh0RWRpdG9yfSBhbmQgcmV0dXJucyBhIHtib29sZWFufVxyXG4gIC8vICAgICAgICAgICAgICAgICAgICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBhZGFwdGVyIHNob3VsZCBjYXJlIGFib3V0IHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdG9yLlxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gICAgZG9jdW1lbnRTeW5jS2luZDogPyhUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyB8IG51bWJlciksXHJcbiAgICBlZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW4sXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcclxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRTeW5jS2luZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCA9IGRvY3VtZW50U3luY0tpbmQ7XHJcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50U3luY0tpbmQgIT0gbnVsbCAmJiBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZSAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZWRpdG9yU2VsZWN0b3IgPSBlZGl0b3JTZWxlY3RvcjtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20udGV4dEVkaXRvcnMub2JzZXJ2ZSh0aGlzLm9ic2VydmVUZXh0RWRpdG9yLmJpbmQodGhpcykpKTtcclxuICB9XHJcblxyXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gRXhhbWluZSBhIHtUZXh0RWRpdG9yfSBhbmQgZGVjaWRlIGlmIHdlIHdpc2ggdG8gb2JzZXJ2ZSBpdC4gSWYgc28gZW5zdXJlIHRoYXQgd2Ugc3RvcCBvYnNlcnZpbmcgaXRcclxuICAvLyB3aGVuIGl0IGlzIGNsb3NlZCBvciBvdGhlcndpc2UgZGVzdHJveWVkLlxyXG4gIC8vXHJcbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0byBjb25zaWRlciBmb3Igb2JzZXJ2YXRpb24uXHJcbiAgb2JzZXJ2ZVRleHRFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IGxpc3RlbmVyID0gZWRpdG9yLm9ic2VydmVHcmFtbWFyKGdyYW1tYXIgPT4gdGhpcy5faGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3IpKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShsaXN0ZW5lcik7XHJcbiAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChsaXN0ZW5lcik7XHJcbiAgICBpZiAoIXRoaXMuX2VkaXRvcnMuaGFzKGVkaXRvcikgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xyXG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogdm9pZCB7XHJcbiAgICBjb25zdCBzeW5jID0gdGhpcy5fZWRpdG9ycy5nZXQoZWRpdG9yKTtcclxuICAgIGlmIChzeW5jICE9IG51bGwgJiYgIXRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcclxuICAgICAgdGhpcy5fZWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUoc3luYyk7XHJcbiAgICAgIHN5bmMuZGlzcG9zZSgpO1xyXG4gICAgfSBlbHNlIGlmIChzeW5jID09IG51bGwgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xyXG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IHN5bmMgPSBuZXcgVGV4dEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvciwgdGhpcy5fY29ubmVjdGlvbiwgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCwgdGhpcy5fdmVyc2lvbnMpO1xyXG4gICAgdGhpcy5fZWRpdG9ycy5zZXQoZWRpdG9yLCBzeW5jKTtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKHN5bmMpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlc3Ryb3llZFN5bmMgPSB0aGlzLl9lZGl0b3JzLmdldChlZGl0b3IpO1xyXG4gICAgICAgIGlmIChkZXN0cm95ZWRTeW5jKSB7XHJcbiAgICAgICAgICB0aGlzLl9lZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUoZGVzdHJveWVkU3luYyk7XHJcbiAgICAgICAgICBkZXN0cm95ZWRTeW5jLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogP1RleHRFZGl0b3JTeW5jQWRhcHRlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9ycy5nZXQoZWRpdG9yKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFB1YmxpYzogS2VlcCBhIHNpbmdsZSB7VGV4dEVkaXRvcn0gaW4gc3luYyB3aXRoIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxyXG5jbGFzcyBUZXh0RWRpdG9yU3luY0FkYXB0ZXIge1xyXG4gIF9kaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICBfZWRpdG9yOiBhdG9tJFRleHRFZGl0b3I7XHJcbiAgX2N1cnJlbnRVcmk6IHN0cmluZztcclxuICBfY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uO1xyXG4gIF9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzOiBib29sZWFuO1xyXG4gIF92ZXJzaW9uczogTWFwPHN0cmluZywgbnVtYmVyPjtcclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dEVkaXRvclN5bmNBZGFwdGVyfSBpbiBzeW5jIHdpdGggYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRvIGtlZXAgaW4gc3luYy5cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHRvIGtlZXAgaW4gc3luYy5cclxuICAvLyAqIGBkb2N1bWVudFN5bmNLaW5kYCBXaGV0aGVyIHRvIHVzZSBGdWxsICgxKSBvciBJbmNyZW1lbnRhbCAoMikgd2hlbiBzZW5kaW5nIGNoYW5nZXMuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcixcclxuICAgIHZlcnNpb25zOiBNYXA8c3RyaW5nLCBudW1iZXI+LFxyXG4gICkge1xyXG4gICAgdGhpcy5fZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XHJcbiAgICB0aGlzLl92ZXJzaW9ucyA9IHZlcnNpb25zO1xyXG4gICAgdGhpcy5fZmFrZURpZENoYW5nZVdhdGNoZWRGaWxlcyA9IGF0b20ucHJvamVjdC5vbkRpZENoYW5nZUZpbGVzID09IG51bGw7XHJcblxyXG4gICAgY29uc3QgY2hhbmdlVHJhY2tpbmcgPSB0aGlzLnNldHVwQ2hhbmdlVHJhY2tpbmcoZG9jdW1lbnRTeW5jS2luZCk7XHJcbiAgICBpZiAoY2hhbmdlVHJhY2tpbmcgIT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChjaGFuZ2VUcmFja2luZyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXHJcbiAgICAgIGVkaXRvci5nZXRCdWZmZXIoKS5vbldpbGxTYXZlKHRoaXMud2lsbFNhdmUuYmluZCh0aGlzKSksXHJcbiAgICAgIGVkaXRvci5vbkRpZFNhdmUodGhpcy5kaWRTYXZlLmJpbmQodGhpcykpLFxyXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KHRoaXMuZGlkQ2xvc2UuYmluZCh0aGlzKSksXHJcbiAgICAgIGVkaXRvci5vbkRpZENoYW5nZVBhdGgodGhpcy5kaWRSZW5hbWUuYmluZCh0aGlzKSksXHJcbiAgICApO1xyXG5cclxuICAgIHRoaXMuX2N1cnJlbnRVcmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xyXG4gICAgdGhpcy5kaWRPcGVuKCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaGUgY2hhbmdlIHRyYWNraW5nIGRpc3Bvc2FibGUgbGlzdGVuZXIgdGhhdCB3aWxsIGVuc3VyZSB0aGF0IGNoYW5nZXMgYXJlIHNlbnQgdG8gdGhlXHJcbiAgLy8gbGFuZ3VhZ2Ugc2VydmVyIGFzIGFwcHJvcHJpYXRlLlxyXG4gIHNldHVwQ2hhbmdlVHJhY2tpbmcoZG9jdW1lbnRTeW5jS2luZDogbnVtYmVyKTogP0lEaXNwb3NhYmxlIHtcclxuICAgIHN3aXRjaCAoZG9jdW1lbnRTeW5jS2luZCkge1xyXG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VkaXRvci5vbkRpZENoYW5nZSh0aGlzLnNlbmRGdWxsQ2hhbmdlcy5iaW5kKHRoaXMpKTtcclxuICAgICAgY2FzZSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbDpcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpLm9uRGlkQ2hhbmdlVGV4dCh0aGlzLnNlbmRJbmNyZW1lbnRhbENoYW5nZXMuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXHJcbiAgZGlzcG9zZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IHRoZSBsYW5ndWFnZUlkIGZpZWxkIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYnkgc2ltcGx5XHJcbiAgLy8gdXNpbmcgdGhlIGdyYW1tYXIgbmFtZS5cclxuICBnZXRMYW5ndWFnZUlkKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEdyYW1tYXIoKS5uYW1lO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gZm9yIHRoZSBkb2N1bWVudCBvYnNlcnZlZCBieVxyXG4gIC8vIHRoaXMgYWRhcHRlciBpbmNsdWRpbmcgYm90aCB0aGUgVXJpIGFuZCB0aGUgY3VycmVudCBWZXJzaW9uLlxyXG4gIGdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKTogVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cmk6IHRoaXMuZ2V0RWRpdG9yVXJpKCksXHJcbiAgICAgIHZlcnNpb246IHRoaXMuX2dldFZlcnNpb24odGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBTZW5kIHRoZSBlbnRpcmUgZG9jdW1lbnQgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpcyB1c2VkIHdoZW5cclxuICAvLyBvcGVyYXRpbmcgaW4gRnVsbCAoMSkgc3luYyBtb2RlLlxyXG4gIHNlbmRGdWxsQ2hhbmdlcygpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSB7IHJldHVybjsgfSAvLyBNdWx0aXBsZSBlZGl0b3JzLCB3ZSBhcmUgbm90IGZpcnN0XHJcblxyXG4gICAgdGhpcy5fYnVtcFZlcnNpb24oKTtcclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlVGV4dERvY3VtZW50KHtcclxuICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcclxuICAgICAgY29udGVudENoYW5nZXM6IFt7dGV4dDogdGhpcy5fZWRpdG9yLmdldFRleHQoKX1dLFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IFNlbmQgdGhlIGluY3JlbWVudGFsIHRleHQgY2hhbmdlcyB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGlzIHVzZWRcclxuICAvLyB3aGVuIG9wZXJhdGluZyBpbiBJbmNyZW1lbnRhbCAoMikgc3luYyBtb2RlLlxyXG4gIC8vXHJcbiAgLy8gKiBgZXZlbnRgIFRoZSBldmVudCBmaXJlZCBieSBBdG9tIHRvIGluZGljYXRlIHRoZSBkb2N1bWVudCBoYXMgc3RvcHBlZCBjaGFuZ2luZ1xyXG4gIC8vICAgICAgICAgICBpbmNsdWRpbmcgYSBsaXN0IG9mIGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgdGltZSB0aGlzIGV2ZW50IGZpcmVkIGZvciB0aGlzXHJcbiAgLy8gICAgICAgICAgIHRleHQgZWRpdG9yLlxyXG4gIC8vIE5vdGU6IFRoZSBvcmRlciBvZiBjaGFuZ2VzIGluIHRoZSBldmVudCBpcyBndWFyYW50ZWVkIHRvcCB0byBib3R0b20uICBMYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBleHBlY3RzIHRoaXMgaW4gcmV2ZXJzZS5cclxuICBzZW5kSW5jcmVtZW50YWxDaGFuZ2VzKGV2ZW50OiBhdG9tJERpZFN0b3BDaGFuZ2luZ0V2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAoZXZlbnQuY2hhbmdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSB7IHJldHVybjsgfSAvLyBNdWx0aXBsZSBlZGl0b3JzLCB3ZSBhcmUgbm90IGZpcnN0XHJcblxyXG4gICAgICB0aGlzLl9idW1wVmVyc2lvbigpO1xyXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVRleHREb2N1bWVudCh7XHJcbiAgICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcclxuICAgICAgICBjb250ZW50Q2hhbmdlczogZXZlbnQuY2hhbmdlcy5tYXAoVGV4dEVkaXRvclN5bmNBZGFwdGVyLnRleHRFZGl0VG9Db250ZW50Q2hhbmdlKS5yZXZlcnNlKCksXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIEF0b20ge1RleHRFZGl0RXZlbnR9IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHtUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnR9XHJcbiAgLy8gb2JqZWN0LlxyXG4gIC8vXHJcbiAgLy8gKiBgY2hhbmdlYCBUaGUgQXRvbSB7VGV4dEVkaXRFdmVudH0gdG8gY29udmVydC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7VGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50fSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnZlcnRlZCB7VGV4dEVkaXRFdmVudH0uXHJcbiAgc3RhdGljIHRleHRFZGl0VG9Db250ZW50Q2hhbmdlKGNoYW5nZTogYXRvbSRUZXh0RWRpdEV2ZW50KTogVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHJhbmdlOiBDb252ZXJ0LmF0b21SYW5nZVRvTFNSYW5nZShjaGFuZ2Uub2xkUmFuZ2UpLFxyXG4gICAgICByYW5nZUxlbmd0aDogY2hhbmdlLm9sZFRleHQubGVuZ3RoLFxyXG4gICAgICB0ZXh0OiBjaGFuZ2UubmV3VGV4dCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBfaXNQcmltYXJ5QWRhcHRlcigpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IGxvd2VzdElkRm9yQnVmZmVyID0gTWF0aC5taW4oXHJcbiAgICAgIC4uLmF0b20ud29ya3NwYWNlXHJcbiAgICAgICAgLmdldFRleHRFZGl0b3JzKClcclxuICAgICAgICAuZmlsdGVyKHQgPT4gdC5nZXRCdWZmZXIoKSA9PT0gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpKVxyXG4gICAgICAgIC5tYXAodCA9PiB0LmlkKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4gbG93ZXN0SWRGb3JCdWZmZXIgPT09IHRoaXMuX2VkaXRvci5pZDtcclxuICB9XHJcblxyXG4gIF9idW1wVmVyc2lvbigpOiB2b2lkIHtcclxuICAgIGNvbnN0IGZpbGVQYXRoID0gdGhpcy5fZWRpdG9yLmdldFBhdGgoKTtcclxuICAgIGlmIChmaWxlUGF0aCA9PSBudWxsKSB7IHJldHVybjsgfVxyXG4gICAgdGhpcy5fdmVyc2lvbnMuc2V0KGZpbGVQYXRoLCB0aGlzLl9nZXRWZXJzaW9uKGZpbGVQYXRoKSArIDEpO1xyXG4gIH1cclxuXHJcbiAgLy8gRW5zdXJlIHdoZW4gdGhlIGRvY3VtZW50IGlzIG9wZW5lZCB3ZSBzZW5kIG5vdGlmaWNhdGlvbiB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gc28gaXQgY2FuIGxvYWQgaXQgaW4gYW5kIGtlZXAgdHJhY2sgb2YgZGlhZ25vc3RpY3MgZXRjLlxyXG4gIGRpZE9wZW4oKTogdm9pZCB7XHJcbiAgICBjb25zdCBmaWxlUGF0aCA9IHRoaXMuX2VkaXRvci5nZXRQYXRoKCk7XHJcbiAgICBpZiAoZmlsZVBhdGggPT0gbnVsbCkgeyByZXR1cm47IH0gLy8gTm90IHlldCBzYXZlZFxyXG5cclxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSB7IHJldHVybjsgfSAvLyBNdWx0aXBsZSBlZGl0b3JzLCB3ZSBhcmUgbm90IGZpcnN0XHJcblxyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRPcGVuVGV4dERvY3VtZW50KHtcclxuICAgICAgdGV4dERvY3VtZW50OiB7XHJcbiAgICAgICAgdXJpOiB0aGlzLmdldEVkaXRvclVyaSgpLFxyXG4gICAgICAgIGxhbmd1YWdlSWQ6IHRoaXMuZ2V0TGFuZ3VhZ2VJZCgpLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fZ2V0VmVyc2lvbihmaWxlUGF0aCksXHJcbiAgICAgICAgdGV4dDogdGhpcy5fZWRpdG9yLmdldFRleHQoKSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgX2dldFZlcnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5fdmVyc2lvbnMuZ2V0KGZpbGVQYXRoKSB8fCAxO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsbGVkIHdoZW4gdGhlIHtUZXh0RWRpdG9yfSBpcyBjbG9zZWQgYW5kIHNlbmRzIHRoZSAnZGlkQ2xvc2VUZXh0RG9jdW1lbnQnIG5vdGlmaWNhdGlvbiB0b1xyXG4gIC8vIHRoZSBjb25uZWN0ZWQgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIGRpZENsb3NlKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2VkaXRvci5nZXRQYXRoKCkgPT0gbnVsbCkgeyByZXR1cm47IH0gLy8gTm90IHlldCBzYXZlZFxyXG5cclxuICAgIGNvbnN0IGZpbGVTdGlsbE9wZW4gPSBhdG9tLndvcmtzcGFjZS5nZXRUZXh0RWRpdG9ycygpLmZpbmQodCA9PiB0LmdldEJ1ZmZlcigpID09PSB0aGlzLl9lZGl0b3IuZ2V0QnVmZmVyKCkpO1xyXG4gICAgaWYgKGZpbGVTdGlsbE9wZW4pIHtcclxuICAgICAgcmV0dXJuOyAvLyBPdGhlciB3aW5kb3dzIG9yIGVkaXRvcnMgc3RpbGwgaGF2ZSB0aGlzIGZpbGUgb3BlblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2xvc2VUZXh0RG9jdW1lbnQoe3RleHREb2N1bWVudDoge3VyaTogdGhpcy5nZXRFZGl0b3JVcmkoKX19KTtcclxuICB9XHJcblxyXG4gIC8vIENhbGxlZCBqdXN0IGJlZm9yZSB0aGUge1RleHRFZGl0b3J9IHNhdmVzIGFuZCBzZW5kcyB0aGUgJ3dpbGxTYXZlVGV4dERvY3VtZW50JyBub3RpZmljYXRpb24gdG9cclxuICAvLyB0aGUgY29ubmVjdGVkIGxhbmd1YWdlIHNlcnZlci5cclxuICB3aWxsU2F2ZSgpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSB7IHJldHVybjsgfVxyXG5cclxuICAgIGNvbnN0IHVyaSA9IHRoaXMuZ2V0RWRpdG9yVXJpKCk7XHJcbiAgICB0aGlzLl9jb25uZWN0aW9uLndpbGxTYXZlVGV4dERvY3VtZW50KHtcclxuICAgICAgdGV4dERvY3VtZW50OiB7dXJpfSxcclxuICAgICAgcmVhc29uOiBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLk1hbnVhbCxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2FsbGVkIHdoZW4gdGhlIHtUZXh0RWRpdG9yfSBzYXZlcyBhbmQgc2VuZHMgdGhlICdkaWRTYXZlVGV4dERvY3VtZW50JyBub3RpZmljYXRpb24gdG9cclxuICAvLyB0aGUgY29ubmVjdGVkIGxhbmd1YWdlIHNlcnZlci5cclxuICAvLyBOb3RlOiBSaWdodCBub3cgdGhpcyBhbHNvIHNlbmRzIHRoZSBgZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzYCBub3RpZmljYXRpb24gYXMgd2VsbCBidXQgdGhhdFxyXG4gIC8vIHdpbGwgYmUgc2VudCBmcm9tIGVsc2V3aGVyZSBzb29uLlxyXG4gIGRpZFNhdmUoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2lzUHJpbWFyeUFkYXB0ZXIoKSkgeyByZXR1cm47IH1cclxuXHJcbiAgICBjb25zdCB1cmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRTYXZlVGV4dERvY3VtZW50KHt0ZXh0RG9jdW1lbnQ6IHt1cml9fSk7XHJcbiAgICBpZiAodGhpcy5fZmFrZURpZENoYW5nZVdhdGNoZWRGaWxlcykge1xyXG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVdhdGNoZWRGaWxlcyh7XHJcbiAgICAgICAgY2hhbmdlczogW3t1cmksIHR5cGU6IEZpbGVDaGFuZ2VUeXBlLkNoYW5nZWR9XSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBkaWRSZW5hbWUoKTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuX2lzUHJpbWFyeUFkYXB0ZXIoKSkgeyByZXR1cm47IH1cclxuXHJcbiAgICBjb25zdCBvbGRVcmkgPSB0aGlzLl9jdXJyZW50VXJpO1xyXG4gICAgdGhpcy5fY3VycmVudFVyaSA9IHRoaXMuZ2V0RWRpdG9yVXJpKCk7XHJcbiAgICBpZiAoIW9sZFVyaSkge1xyXG4gICAgICByZXR1cm47IC8vIERpZG4ndCBwcmV2aW91c2x5IGhhdmUgYSBuYW1lXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDbG9zZVRleHREb2N1bWVudCh7XHJcbiAgICAgIHRleHREb2N1bWVudDoge3VyaTogb2xkVXJpfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKSB7XHJcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKHtcclxuICAgICAgICBjaGFuZ2VzOiBbe3VyaTogb2xkVXJpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5EZWxldGVkfSwge3VyaTogdGhpcy5fY3VycmVudFVyaSwgdHlwZTogRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZH1dLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZW5kIGFuIGVxdWl2YWxlbnQgb3BlbiBldmVudCBmb3IgdGhpcyBlZGl0b3IsIHdoaWNoIHdpbGwgbm93IHVzZSB0aGUgbmV3XHJcbiAgICAvLyBmaWxlIHBhdGguXHJcbiAgICB0aGlzLmRpZE9wZW4oKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSBjdXJyZW50IHtUZXh0RWRpdG9yfSBwYXRoIGFuZCBjb252ZXJ0IGl0IHRvIGEgVXJpLlxyXG4gIGdldEVkaXRvclVyaSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIENvbnZlcnQucGF0aFRvVXJpKHRoaXMuX2VkaXRvci5nZXRQYXRoKCkgfHwgJycpO1xyXG4gIH1cclxufVxyXG4iXX0=