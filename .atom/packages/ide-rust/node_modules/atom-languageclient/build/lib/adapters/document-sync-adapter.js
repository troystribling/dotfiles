Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Synchronizes the documents between Atom and the language server by notifying
// each end of changes, opening, closing and other events as well as sending and applying
// changes either in whole or in part depending on what the language server supports.
let DocumentSyncAdapter = class DocumentSyncAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix textDocumentSync capability either being Full or
  // Incremental.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return this.canAdaptV2(serverCapabilities) || this.canAdaptV3(serverCapabilities);
  }

  static canAdaptV2(serverCapabilities) {
    return serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Incremental || serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Full;
  }

  static canAdaptV3(serverCapabilities) {
    const options = serverCapabilities.textDocumentSync;
    return options !== null && typeof options === 'object' && (options.change === _languageclient.TextDocumentSyncKind.Incremental || options.change === _languageclient.TextDocumentSyncKind.Full);
  }

  // Public: Create a new {DocumentSyncAdapter} for the given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server to be kept in sync.
  // * `documentSyncKind` The type of document syncing supported - Full or Incremental.
  // * `editorSelector` A predicate function that takes a {TextEditor} and returns a {boolean}
  //                    indicating whether this adapter should care about the contents of the editor.
  constructor(connection, documentSyncKind, editorSelector) {
    this._disposable = new _atom.CompositeDisposable();
    this._editors = new WeakMap();

    this._connection = connection;
    if (typeof documentSyncKind === 'object') {
      this._documentSyncKind = documentSyncKind.change;
    } else {
      this._documentSyncKind = documentSyncKind;
    }
    this._editorSelector = editorSelector;
    this._disposable.add(atom.textEditors.observe(this.observeTextEditor.bind(this)));
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Examine a {TextEditor} and decide if we wish to observe it. If so ensure that we stop observing it
  // when it is closed or otherwise destroyed.
  //
  // * `editor` A {TextEditor} to consider for observation.
  observeTextEditor(editor) {
    if (!this._editors.has(editor) && this._editorSelector(editor)) {
      const sync = new TextEditorSyncAdapter(editor, this._connection, this._documentSyncKind);
      this._editors.set(editor, sync);
      this._disposable.add(sync);
      this._disposable.add(editor.onDidDestroy(() => {
        this._editors.delete(editor);
        this._disposable.remove(sync);
        sync.dispose();
      }));
    }
  }
};

// Public: Keep a single {TextEditor} in sync with a given language server.

exports.default = DocumentSyncAdapter;
let TextEditorSyncAdapter = class TextEditorSyncAdapter {

  // Public: Create a {TextEditorSyncAdapter} in sync with a given language server.
  //
  // * `editor` A {TextEditor} to keep in sync.
  // * `connection` A {LanguageClientConnection} to a language server to keep in sync.
  // * `documentSyncKind` Whether to use Full (1) or Incremental (2) when sending changes.
  constructor(editor, connection, documentSyncKind) {
    this._disposable = new _atom.CompositeDisposable();
    this._version = 1;

    this._editor = editor;
    this._connection = connection;

    const changeTracking = this.setupChangeTracking(documentSyncKind);
    if (changeTracking != null) {
      this._disposable.add(changeTracking);
    }

    this._disposable.add(editor.onDidSave(this.didSave.bind(this)), editor.onDidDestroy(this.didDestroy.bind(this)));

    this.didOpen();
  }

  // The change tracking disposable listener that will ensure that changes are sent to the
  // language server as appropriate.
  setupChangeTracking(documentSyncKind) {
    switch (documentSyncKind) {
      case _languageclient.TextDocumentSyncKind.Full:
        return this._editor.onDidChange(this.sendFullChanges.bind(this));
      case _languageclient.TextDocumentSyncKind.Incremental:
        return this._editor.getBuffer().onDidChangeText(this.sendIncrementalChanges.bind(this));
    }
    return null;
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Get the languageId field that will be sent to the language server by simply
  // using the grammar name.
  getLanguageId() {
    return this._editor.getGrammar().name;
  }

  // Public: Create a {VersionedTextDocumentIdentifier} for the document observed by
  // this adapter including both the Uri and the current Version.
  getVersionedTextDocumentIdentifier() {
    return {
      uri: this.getEditorUri(),
      version: this._version
    };
  }

  // Ensure when the document is opened we send notification to the language server
  // so it can load it in and keep track of diagnostics etc.
  didOpen() {
    if (this._editor.getURI() == null) return; // Not yet saved

    this._connection.didOpenTextDocument({
      textDocument: {
        uri: this.getEditorUri(),
        languageId: this.getLanguageId().toLowerCase(),
        version: this._version,
        text: this._editor.getText()
      }
    });
  }

  // Public: Send the entire document to the language server. This is used when
  // operating in Full (1) sync mode.
  sendFullChanges() {
    this._version++;
    this._connection.didChangeTextDocument({
      textDocument: this.getVersionedTextDocumentIdentifier(),
      contentChanges: [{ text: this._editor.getText() }]
    });
  }

  // Public: Send the incremental text changes to the language server. This is used
  // when operating in Incremental (2) sync mode.
  //
  // * `event` The event fired by Atom to indicate the document has stopped changing
  //           including a list of changes since the last time this event fired for this
  //           text editor.
  sendIncrementalChanges(event) {
    if (event.changes.length > 0) {
      this._version++;
      this._connection.didChangeTextDocument({
        textDocument: this.getVersionedTextDocumentIdentifier(),
        contentChanges: event.changes.map(TextEditorSyncAdapter.textEditToContentChange)
      });
    }
  }

  // Public: Convert an Atom {TextEditEvent} to a language server {TextDocumentContentChangeEvent}
  // object.
  //
  // * `change` The Atom {TextEditEvent} to convert.
  //
  // Returns a {TextDocumentContentChangeEvent} that represents the converted {TextEditEvent}.
  static textEditToContentChange(change) {
    return {
      range: _convert2.default.atomRangeToLSRange(change.oldRange),
      rangeLength: change.oldText.length,
      text: change.newText
    };
  }

  // Called when the {TextEditor} is closed and sends the 'didCloseTextDocument' notification to
  // the connected language server.
  didDestroy() {
    if (this._editor.getURI() == null) return; // Not yet saved
    this._connection.didCloseTextDocument({ textDocument: { uri: this.getEditorUri() } });
  }

  // Called when the {TextEditor} saves and sends the 'didSaveTextDocument' notification to
  // the connected language server.
  // Note: Right now this also sends the `didChangeWatchedFiles` notification as well but that
  // will be sent from elsewhere soon.
  didSave() {
    this._connection.didSaveTextDocument({ textDocument: { uri: this.getEditorUri() } });
    // TODO: Move this to a file watching event once Atom has API support.
    this._connection.didChangeWatchedFiles({ changes: [{ uri: this.getEditorUri(), type: _languageclient.FileChangeType.Changed }] }); // Replace with file watch
  }

  // Public: Obtain the current {TextEditor} path and convert it to a Uri.
  getEditorUri() {
    return _convert2.default.pathToUri(this._editor.getPath() || '');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRG9jdW1lbnRTeW5jQWRhcHRlciIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiY2FuQWRhcHRWMiIsImNhbkFkYXB0VjMiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwiSW5jcmVtZW50YWwiLCJGdWxsIiwib3B0aW9ucyIsImNoYW5nZSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsImRvY3VtZW50U3luY0tpbmQiLCJlZGl0b3JTZWxlY3RvciIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvcnMiLCJXZWFrTWFwIiwiX2Nvbm5lY3Rpb24iLCJfZG9jdW1lbnRTeW5jS2luZCIsIl9lZGl0b3JTZWxlY3RvciIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvciIsImJpbmQiLCJkaXNwb3NlIiwiZWRpdG9yIiwiaGFzIiwic3luYyIsIlRleHRFZGl0b3JTeW5jQWRhcHRlciIsInNldCIsIm9uRGlkRGVzdHJveSIsImRlbGV0ZSIsInJlbW92ZSIsIl92ZXJzaW9uIiwiX2VkaXRvciIsImNoYW5nZVRyYWNraW5nIiwic2V0dXBDaGFuZ2VUcmFja2luZyIsIm9uRGlkU2F2ZSIsImRpZFNhdmUiLCJkaWREZXN0cm95IiwiZGlkT3BlbiIsIm9uRGlkQ2hhbmdlIiwic2VuZEZ1bGxDaGFuZ2VzIiwiZ2V0QnVmZmVyIiwib25EaWRDaGFuZ2VUZXh0Iiwic2VuZEluY3JlbWVudGFsQ2hhbmdlcyIsImdldExhbmd1YWdlSWQiLCJnZXRHcmFtbWFyIiwibmFtZSIsImdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJ1cmkiLCJnZXRFZGl0b3JVcmkiLCJ2ZXJzaW9uIiwiZ2V0VVJJIiwiZGlkT3BlblRleHREb2N1bWVudCIsInRleHREb2N1bWVudCIsImxhbmd1YWdlSWQiLCJ0b0xvd2VyQ2FzZSIsInRleHQiLCJnZXRUZXh0IiwiZGlkQ2hhbmdlVGV4dERvY3VtZW50IiwiY29udGVudENoYW5nZXMiLCJldmVudCIsImNoYW5nZXMiLCJsZW5ndGgiLCJtYXAiLCJ0ZXh0RWRpdFRvQ29udGVudENoYW5nZSIsInJhbmdlIiwiYXRvbVJhbmdlVG9MU1JhbmdlIiwib2xkUmFuZ2UiLCJyYW5nZUxlbmd0aCIsIm9sZFRleHQiLCJuZXdUZXh0IiwiZGlkQ2xvc2VUZXh0RG9jdW1lbnQiLCJkaWRTYXZlVGV4dERvY3VtZW50IiwiZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzIiwidHlwZSIsIkNoYW5nZWQiLCJwYXRoVG9VcmkiLCJnZXRQYXRoIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBOztBQVNBOzs7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7SUFDcUJBLG1CLEdBQU4sTUFBTUEsbUJBQU4sQ0FBMEI7O0FBT3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPQyxRQUFQLENBQWdCQyxrQkFBaEIsRUFBaUU7QUFDL0QsV0FBTyxLQUFLQyxVQUFMLENBQWdCRCxrQkFBaEIsS0FBdUMsS0FBS0UsVUFBTCxDQUFnQkYsa0JBQWhCLENBQTlDO0FBQ0Q7O0FBRUQsU0FBT0MsVUFBUCxDQUFrQkQsa0JBQWxCLEVBQW1FO0FBQ2pFLFdBQU9BLG1CQUFtQkcsZ0JBQW5CLEtBQXdDLHFDQUFxQkMsV0FBN0QsSUFDQUosbUJBQW1CRyxnQkFBbkIsS0FBd0MscUNBQXFCRSxJQURwRTtBQUVEOztBQUVELFNBQU9ILFVBQVAsQ0FBa0JGLGtCQUFsQixFQUFtRTtBQUNqRSxVQUFNTSxVQUFVTixtQkFBbUJHLGdCQUFuQztBQUNBLFdBQU9HLFlBQVksSUFBWixJQUFvQixPQUFPQSxPQUFQLEtBQW1CLFFBQXZDLEtBQ0NBLFFBQVFDLE1BQVIsS0FBbUIscUNBQXFCSCxXQUF4QyxJQUNHRSxRQUFRQyxNQUFSLEtBQW1CLHFDQUFxQkYsSUFGNUMsQ0FBUDtBQUdEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FB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QVIsQ0FBa0IsS0FBSzVDLE9BQUwsQ0FBYTZDLE9BQWIsTUFBMEIsRUFBNUMsQ0FBUDtBQUNEO0FBdkl5QixDIiwiZmlsZSI6ImRvY3VtZW50LXN5bmMtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgRmlsZUNoYW5nZVR5cGUsXG4gIFRleHREb2N1bWVudFN5bmNLaW5kLFxuICBUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyxcbiAgdHlwZSBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQsXG4gIHR5cGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcixcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXNcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5pbXBvcnQge0NvbXBvc2l0ZURpc3Bvc2FibGV9IGZyb20gJ2F0b20nO1xuXG4vLyBQdWJsaWM6IFN5bmNocm9uaXplcyB0aGUgZG9jdW1lbnRzIGJldHdlZW4gQXRvbSBhbmQgdGhlIGxhbmd1YWdlIHNlcnZlciBieSBub3RpZnlpbmdcbi8vIGVhY2ggZW5kIG9mIGNoYW5nZXMsIG9wZW5pbmcsIGNsb3NpbmcgYW5kIG90aGVyIGV2ZW50cyBhcyB3ZWxsIGFzIHNlbmRpbmcgYW5kIGFwcGx5aW5nXG4vLyBjaGFuZ2VzIGVpdGhlciBpbiB3aG9sZSBvciBpbiBwYXJ0IGRlcGVuZGluZyBvbiB3aGF0IHRoZSBsYW5ndWFnZSBzZXJ2ZXIgc3VwcG9ydHMuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudFN5bmNBZGFwdGVyIHtcbiAgX2VkaXRvclNlbGVjdG9yOiAoYXRvbSRUZXh0RWRpdG9yKSA9PiBib29sZWFuO1xuICBfZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gIF9kb2N1bWVudFN5bmNLaW5kOiBudW1iZXI7XG4gIF9lZGl0b3JzOiBXZWFrTWFwPGF0b20kVGV4dEVkaXRvciwgVGV4dEVkaXRvclN5bmNBZGFwdGVyPiA9IG5ldyBXZWFrTWFwKCk7XG4gIF9jb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb247XG5cbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggdGV4dERvY3VtZW50U3luYyBjYXBhYmlsaXR5IGVpdGhlciBiZWluZyBGdWxsIG9yXG4gIC8vIEluY3JlbWVudGFsLlxuICAvL1xuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxuICBzdGF0aWMgY2FuQWRhcHQoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jYW5BZGFwdFYyKHNlcnZlckNhcGFiaWxpdGllcykgfHwgdGhpcy5jYW5BZGFwdFYzKHNlcnZlckNhcGFiaWxpdGllcyk7XG4gIH1cblxuICBzdGF0aWMgY2FuQWRhcHRWMihzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYyA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuSW5jcmVtZW50YWxcbiAgICAgICAgfHwgc2VydmVyQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw7XG4gIH1cblxuICBzdGF0aWMgY2FuQWRhcHRWMyhzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYztcbiAgICByZXR1cm4gb3B0aW9ucyAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCdcbiAgICAgICAgJiYgKG9wdGlvbnMuY2hhbmdlID09PSBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbFxuICAgICAgICAgICAgfHwgb3B0aW9ucy5jaGFuZ2UgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGwpO1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUgYSBuZXcge0RvY3VtZW50U3luY0FkYXB0ZXJ9IGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gYmUga2VwdCBpbiBzeW5jLlxuICAvLyAqIGBkb2N1bWVudFN5bmNLaW5kYCBUaGUgdHlwZSBvZiBkb2N1bWVudCBzeW5jaW5nIHN1cHBvcnRlZCAtIEZ1bGwgb3IgSW5jcmVtZW50YWwuXG4gIC8vICogYGVkaXRvclNlbGVjdG9yYCBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IHRha2VzIGEge1RleHRFZGl0b3J9IGFuZCByZXR1cm5zIGEge2Jvb2xlYW59XG4gIC8vICAgICAgICAgICAgICAgICAgICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBhZGFwdGVyIHNob3VsZCBjYXJlIGFib3V0IHRoZSBjb250ZW50cyBvZiB0aGUgZWRpdG9yLlxuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIGRvY3VtZW50U3luY0tpbmQ6IFRleHREb2N1bWVudFN5bmNPcHRpb25zIHwgbnVtYmVyLCBlZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50U3luY0tpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudFN5bmNLaW5kID0gZG9jdW1lbnRTeW5jS2luZC5jaGFuZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0b3JTZWxlY3RvciA9IGVkaXRvclNlbGVjdG9yO1xuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20udGV4dEVkaXRvcnMub2JzZXJ2ZSh0aGlzLm9ic2VydmVUZXh0RWRpdG9yLmJpbmQodGhpcykpKTtcbiAgfVxuXG4gIC8vIERpc3Bvc2UgdGhpcyBhZGFwdGVyIGVuc3VyaW5nIGFueSByZXNvdXJjZXMgYXJlIGZyZWVkIGFuZCBldmVudHMgdW5ob29rZWQuXG4gIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5fZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gIH1cblxuICAvLyBFeGFtaW5lIGEge1RleHRFZGl0b3J9IGFuZCBkZWNpZGUgaWYgd2Ugd2lzaCB0byBvYnNlcnZlIGl0LiBJZiBzbyBlbnN1cmUgdGhhdCB3ZSBzdG9wIG9ic2VydmluZyBpdFxuICAvLyB3aGVuIGl0IGlzIGNsb3NlZCBvciBvdGhlcndpc2UgZGVzdHJveWVkLlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRvIGNvbnNpZGVyIGZvciBvYnNlcnZhdGlvbi5cbiAgb2JzZXJ2ZVRleHRFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2VkaXRvcnMuaGFzKGVkaXRvcikgJiYgdGhpcy5fZWRpdG9yU2VsZWN0b3IoZWRpdG9yKSkge1xuICAgICAgY29uc3Qgc3luYyA9IG5ldyBUZXh0RWRpdG9yU3luY0FkYXB0ZXIoZWRpdG9yLCB0aGlzLl9jb25uZWN0aW9uLCB0aGlzLl9kb2N1bWVudFN5bmNLaW5kKTtcbiAgICAgIHRoaXMuX2VkaXRvcnMuc2V0KGVkaXRvciwgc3luYyk7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChzeW5jKTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4ge1xuICAgICAgICB0aGlzLl9lZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShzeW5jKTtcbiAgICAgICAgc3luYy5kaXNwb3NlKCk7XG4gICAgICB9KSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFB1YmxpYzogS2VlcCBhIHNpbmdsZSB7VGV4dEVkaXRvcn0gaW4gc3luYyB3aXRoIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxuY2xhc3MgVGV4dEVkaXRvclN5bmNBZGFwdGVyIHtcbiAgX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICBfZWRpdG9yOiBhdG9tJFRleHRFZGl0b3I7XG4gIF9jb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb247XG4gIF92ZXJzaW9uID0gMTtcblxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIHtUZXh0RWRpdG9yU3luY0FkYXB0ZXJ9IGluIHN5bmMgd2l0aCBhIGdpdmVuIGxhbmd1YWdlIHNlcnZlci5cbiAgLy9cbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0byBrZWVwIGluIHN5bmMuXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gYSBsYW5ndWFnZSBzZXJ2ZXIgdG8ga2VlcCBpbiBzeW5jLlxuICAvLyAqIGBkb2N1bWVudFN5bmNLaW5kYCBXaGV0aGVyIHRvIHVzZSBGdWxsICgxKSBvciBJbmNyZW1lbnRhbCAoMikgd2hlbiBzZW5kaW5nIGNoYW5nZXMuXG4gIGNvbnN0cnVjdG9yKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcikge1xuICAgIHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcblxuICAgIGNvbnN0IGNoYW5nZVRyYWNraW5nID0gdGhpcy5zZXR1cENoYW5nZVRyYWNraW5nKGRvY3VtZW50U3luY0tpbmQpO1xuICAgIGlmIChjaGFuZ2VUcmFja2luZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChjaGFuZ2VUcmFja2luZyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXG4gICAgICBlZGl0b3Iub25EaWRTYXZlKHRoaXMuZGlkU2F2ZS5iaW5kKHRoaXMpKSxcbiAgICAgIGVkaXRvci5vbkRpZERlc3Ryb3kodGhpcy5kaWREZXN0cm95LmJpbmQodGhpcykpLFxuICAgICk7XG5cbiAgICB0aGlzLmRpZE9wZW4oKTtcbiAgfVxuXG4gIC8vIFRoZSBjaGFuZ2UgdHJhY2tpbmcgZGlzcG9zYWJsZSBsaXN0ZW5lciB0aGF0IHdpbGwgZW5zdXJlIHRoYXQgY2hhbmdlcyBhcmUgc2VudCB0byB0aGVcbiAgLy8gbGFuZ3VhZ2Ugc2VydmVyIGFzIGFwcHJvcHJpYXRlLlxuICBzZXR1cENoYW5nZVRyYWNraW5nKGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcik6ID9JRGlzcG9zYWJsZSB7XG4gICAgc3dpdGNoIChkb2N1bWVudFN5bmNLaW5kKSB7XG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw6XG4gICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3Iub25EaWRDaGFuZ2UodGhpcy5zZW5kRnVsbENoYW5nZXMuYmluZCh0aGlzKSk7XG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkluY3JlbWVudGFsOlxuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpLm9uRGlkQ2hhbmdlVGV4dCh0aGlzLnNlbmRJbmNyZW1lbnRhbENoYW5nZXMuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRGlzcG9zZSB0aGlzIGFkYXB0ZXIgZW5zdXJpbmcgYW55IHJlc291cmNlcyBhcmUgZnJlZWQgYW5kIGV2ZW50cyB1bmhvb2tlZC5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgbGFuZ3VhZ2VJZCBmaWVsZCB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGJ5IHNpbXBseVxuICAvLyB1c2luZyB0aGUgZ3JhbW1hciBuYW1lLlxuICBnZXRMYW5ndWFnZUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvci5nZXRHcmFtbWFyKCkubmFtZTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGZvciB0aGUgZG9jdW1lbnQgb2JzZXJ2ZWQgYnlcbiAgLy8gdGhpcyBhZGFwdGVyIGluY2x1ZGluZyBib3RoIHRoZSBVcmkgYW5kIHRoZSBjdXJyZW50IFZlcnNpb24uXG4gIGdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKTogVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVyaTogdGhpcy5nZXRFZGl0b3JVcmkoKSxcbiAgICAgIHZlcnNpb246IHRoaXMuX3ZlcnNpb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIEVuc3VyZSB3aGVuIHRoZSBkb2N1bWVudCBpcyBvcGVuZWQgd2Ugc2VuZCBub3RpZmljYXRpb24gdG8gdGhlIGxhbmd1YWdlIHNlcnZlclxuICAvLyBzbyBpdCBjYW4gbG9hZCBpdCBpbiBhbmQga2VlcCB0cmFjayBvZiBkaWFnbm9zdGljcyBldGMuXG4gIGRpZE9wZW4oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2VkaXRvci5nZXRVUkkoKSA9PSBudWxsKSByZXR1cm47IC8vIE5vdCB5ZXQgc2F2ZWRcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkT3BlblRleHREb2N1bWVudCh7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgdXJpOiB0aGlzLmdldEVkaXRvclVyaSgpLFxuICAgICAgICBsYW5ndWFnZUlkOiB0aGlzLmdldExhbmd1YWdlSWQoKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgICB0ZXh0OiB0aGlzLl9lZGl0b3IuZ2V0VGV4dCgpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogU2VuZCB0aGUgZW50aXJlIGRvY3VtZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaXMgdXNlZCB3aGVuXG4gIC8vIG9wZXJhdGluZyBpbiBGdWxsICgxKSBzeW5jIG1vZGUuXG4gIHNlbmRGdWxsQ2hhbmdlcygpOiB2b2lkIHtcbiAgICB0aGlzLl92ZXJzaW9uKys7XG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VUZXh0RG9jdW1lbnQoe1xuICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcbiAgICAgIGNvbnRlbnRDaGFuZ2VzOiBbe3RleHQ6IHRoaXMuX2VkaXRvci5nZXRUZXh0KCl9XSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogU2VuZCB0aGUgaW5jcmVtZW50YWwgdGV4dCBjaGFuZ2VzIHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaXMgdXNlZFxuICAvLyB3aGVuIG9wZXJhdGluZyBpbiBJbmNyZW1lbnRhbCAoMikgc3luYyBtb2RlLlxuICAvL1xuICAvLyAqIGBldmVudGAgVGhlIGV2ZW50IGZpcmVkIGJ5IEF0b20gdG8gaW5kaWNhdGUgdGhlIGRvY3VtZW50IGhhcyBzdG9wcGVkIGNoYW5naW5nXG4gIC8vICAgICAgICAgICBpbmNsdWRpbmcgYSBsaXN0IG9mIGNoYW5nZXMgc2luY2UgdGhlIGxhc3QgdGltZSB0aGlzIGV2ZW50IGZpcmVkIGZvciB0aGlzXG4gIC8vICAgICAgICAgICB0ZXh0IGVkaXRvci5cbiAgc2VuZEluY3JlbWVudGFsQ2hhbmdlcyhldmVudDogYXRvbSREaWRTdG9wQ2hhbmdpbmdFdmVudCk6IHZvaWQge1xuICAgIGlmIChldmVudC5jaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3ZlcnNpb24rKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlVGV4dERvY3VtZW50KHtcbiAgICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcbiAgICAgICAgY29udGVudENoYW5nZXM6IGV2ZW50LmNoYW5nZXMubWFwKFRleHRFZGl0b3JTeW5jQWRhcHRlci50ZXh0RWRpdFRvQ29udGVudENoYW5nZSksXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gQXRvbSB7VGV4dEVkaXRFdmVudH0gdG8gYSBsYW5ndWFnZSBzZXJ2ZXIge1RleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudH1cbiAgLy8gb2JqZWN0LlxuICAvL1xuICAvLyAqIGBjaGFuZ2VgIFRoZSBBdG9tIHtUZXh0RWRpdEV2ZW50fSB0byBjb252ZXJ0LlxuICAvL1xuICAvLyBSZXR1cm5zIGEge1RleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudH0gdGhhdCByZXByZXNlbnRzIHRoZSBjb252ZXJ0ZWQge1RleHRFZGl0RXZlbnR9LlxuICBzdGF0aWMgdGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UoY2hhbmdlOiBhdG9tJFRleHRFZGl0RXZlbnQpOiBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQge1xuICAgIHJldHVybiB7XG4gICAgICByYW5nZTogQ29udmVydC5hdG9tUmFuZ2VUb0xTUmFuZ2UoY2hhbmdlLm9sZFJhbmdlKSxcbiAgICAgIHJhbmdlTGVuZ3RoOiBjaGFuZ2Uub2xkVGV4dC5sZW5ndGgsXG4gICAgICB0ZXh0OiBjaGFuZ2UubmV3VGV4dCxcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4gdGhlIHtUZXh0RWRpdG9yfSBpcyBjbG9zZWQgYW5kIHNlbmRzIHRoZSAnZGlkQ2xvc2VUZXh0RG9jdW1lbnQnIG5vdGlmaWNhdGlvbiB0b1xuICAvLyB0aGUgY29ubmVjdGVkIGxhbmd1YWdlIHNlcnZlci5cbiAgZGlkRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZWRpdG9yLmdldFVSSSgpID09IG51bGwpIHJldHVybjsgLy8gTm90IHlldCBzYXZlZFxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2xvc2VUZXh0RG9jdW1lbnQoe3RleHREb2N1bWVudDoge3VyaTogdGhpcy5nZXRFZGl0b3JVcmkoKX19KTtcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuIHRoZSB7VGV4dEVkaXRvcn0gc2F2ZXMgYW5kIHNlbmRzIHRoZSAnZGlkU2F2ZVRleHREb2N1bWVudCcgbm90aWZpY2F0aW9uIHRvXG4gIC8vIHRoZSBjb25uZWN0ZWQgbGFuZ3VhZ2Ugc2VydmVyLlxuICAvLyBOb3RlOiBSaWdodCBub3cgdGhpcyBhbHNvIHNlbmRzIHRoZSBgZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzYCBub3RpZmljYXRpb24gYXMgd2VsbCBidXQgdGhhdFxuICAvLyB3aWxsIGJlIHNlbnQgZnJvbSBlbHNld2hlcmUgc29vbi5cbiAgZGlkU2F2ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZFNhdmVUZXh0RG9jdW1lbnQoe3RleHREb2N1bWVudDoge3VyaTogdGhpcy5nZXRFZGl0b3JVcmkoKX19KTtcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYSBmaWxlIHdhdGNoaW5nIGV2ZW50IG9uY2UgQXRvbSBoYXMgQVBJIHN1cHBvcnQuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VXYXRjaGVkRmlsZXMoe2NoYW5nZXM6IFt7dXJpOiB0aGlzLmdldEVkaXRvclVyaSgpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5DaGFuZ2VkfV19KTsgLy8gUmVwbGFjZSB3aXRoIGZpbGUgd2F0Y2hcbiAgfVxuXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSBjdXJyZW50IHtUZXh0RWRpdG9yfSBwYXRoIGFuZCBjb252ZXJ0IGl0IHRvIGEgVXJpLlxuICBnZXRFZGl0b3JVcmkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gQ29udmVydC5wYXRoVG9VcmkodGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyk7XG4gIH1cbn1cbiJdfQ==