Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Synchronizes the documents between Atom and the language server by notifying
// each end of changes, opening, closing and other events as well as sending and applying
// changes either in whole or in part depending on what the language server supports.
class DocumentSyncAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix textDocumentSync capability either being Full or
  // Incremental.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return this.canAdaptV2(serverCapabilities) || this.canAdaptV3(serverCapabilities);
  }

  static canAdaptV2(serverCapabilities) {
    return serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Incremental || serverCapabilities.textDocumentSync === _languageclient.TextDocumentSyncKind.Full;
  }

  static canAdaptV3(serverCapabilities) {
    const options = serverCapabilities.textDocumentSync;
    return options !== null && typeof options === 'object' && (options.change === _languageclient.TextDocumentSyncKind.Incremental || options.change === _languageclient.TextDocumentSyncKind.Full);
  }

  // Public: Create a new {DocumentSyncAdapter} for the given language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server to be kept in sync.
  // * `documentSyncKind` The type of document syncing supported - Full or Incremental.
  // * `editorSelector` A predicate function that takes a {TextEditor} and returns a {boolean}
  //                    indicating whether this adapter should care about the contents of the editor.
  constructor(connection, documentSyncKind, editorSelector) {
    this._disposable = new _atom.CompositeDisposable();
    this._editors = new WeakMap();
    this._versions = new Map();

    this._connection = connection;
    if (typeof documentSyncKind === 'number') {
      this._documentSyncKind = documentSyncKind;
    } else if (documentSyncKind != null && documentSyncKind.change != null) {
      this._documentSyncKind = documentSyncKind.change;
    } else {
      this._documentSyncKind = _languageclient.TextDocumentSyncKind.Full;
    }
    this._editorSelector = editorSelector;
    this._disposable.add(atom.textEditors.observe(this.observeTextEditor.bind(this)));
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Examine a {TextEditor} and decide if we wish to observe it. If so ensure that we stop observing it
  // when it is closed or otherwise destroyed.
  //
  // * `editor` A {TextEditor} to consider for observation.
  observeTextEditor(editor) {
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => {
      this._disposable.remove(listener);
      listener.dispose();
    }));
    this._disposable.add(listener);
    if (!this._editors.has(editor) && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleGrammarChange(editor) {
    const sync = this._editors.get(editor);
    if (sync != null && !this._editorSelector(editor)) {
      this._editors.delete(editor);
      this._disposable.remove(sync);
      sync.dispose();
    } else if (sync == null && this._editorSelector(editor)) {
      this._handleNewEditor(editor);
    }
  }

  _handleNewEditor(editor) {
    const sync = new TextEditorSyncAdapter(editor, this._connection, this._documentSyncKind, this._versions);
    this._editors.set(editor, sync);
    this._disposable.add(sync);
    this._disposable.add(editor.onDidDestroy(() => {
      const destroyedSync = this._editors.get(editor);
      if (destroyedSync) {
        this._editors.delete(editor);
        this._disposable.remove(destroyedSync);
        destroyedSync.dispose();
      }
    }));
  }

  getEditorSyncAdapter(editor) {
    return this._editors.get(editor);
  }
}

exports.default = DocumentSyncAdapter; // Public: Keep a single {TextEditor} in sync with a given language server.

class TextEditorSyncAdapter {

  // Public: Create a {TextEditorSyncAdapter} in sync with a given language server.
  //
  // * `editor` A {TextEditor} to keep in sync.
  // * `connection` A {LanguageClientConnection} to a language server to keep in sync.
  // * `documentSyncKind` Whether to use Full (1) or Incremental (2) when sending changes.
  constructor(editor, connection, documentSyncKind, versions) {
    this._disposable = new _atom.CompositeDisposable();

    this._editor = editor;
    this._connection = connection;
    this._versions = versions;
    this._fakeDidChangeWatchedFiles = atom.project.onDidChangeFiles == null;

    const changeTracking = this.setupChangeTracking(documentSyncKind);
    if (changeTracking != null) {
      this._disposable.add(changeTracking);
    }

    this._disposable.add(editor.getBuffer().onWillSave(this.willSave.bind(this)), editor.onDidSave(this.didSave.bind(this)), editor.onDidDestroy(this.didClose.bind(this)), editor.onDidChangePath(this.didRename.bind(this)));

    this._currentUri = this.getEditorUri();
    this.didOpen();
  }

  // The change tracking disposable listener that will ensure that changes are sent to the
  // language server as appropriate.
  setupChangeTracking(documentSyncKind) {
    switch (documentSyncKind) {
      case _languageclient.TextDocumentSyncKind.Full:
        return this._editor.onDidChange(this.sendFullChanges.bind(this));
      case _languageclient.TextDocumentSyncKind.Incremental:
        return this._editor.getBuffer().onDidChangeText(this.sendIncrementalChanges.bind(this));
    }
    return null;
  }

  // Dispose this adapter ensuring any resources are freed and events unhooked.
  dispose() {
    this._disposable.dispose();
  }

  // Get the languageId field that will be sent to the language server by simply
  // using the grammar name.
  getLanguageId() {
    return this._editor.getGrammar().name;
  }

  // Public: Create a {VersionedTextDocumentIdentifier} for the document observed by
  // this adapter including both the Uri and the current Version.
  getVersionedTextDocumentIdentifier() {
    return {
      uri: this.getEditorUri(),
      version: this._getVersion(this._editor.getPath() || '')
    };
  }

  // Public: Send the entire document to the language server. This is used when
  // operating in Full (1) sync mode.
  sendFullChanges() {
    if (!this._isPrimaryAdapter()) {
      return;
    } // Multiple editors, we are not first

    this._bumpVersion();
    this._connection.didChangeTextDocument({
      textDocument: this.getVersionedTextDocumentIdentifier(),
      contentChanges: [{ text: this._editor.getText() }]
    });
  }

  // Public: Send the incremental text changes to the language server. This is used
  // when operating in Incremental (2) sync mode.
  //
  // * `event` The event fired by Atom to indicate the document has stopped changing
  //           including a list of changes since the last time this event fired for this
  //           text editor.
  // Note: The order of changes in the event is guaranteed top to bottom.  Language server
  // expects this in reverse.
  sendIncrementalChanges(event) {
    if (event.changes.length > 0) {
      if (!this._isPrimaryAdapter()) {
        return;
      } // Multiple editors, we are not first

      this._bumpVersion();
      this._connection.didChangeTextDocument({
        textDocument: this.getVersionedTextDocumentIdentifier(),
        contentChanges: event.changes.map(TextEditorSyncAdapter.textEditToContentChange).reverse()
      });
    }
  }

  // Public: Convert an Atom {TextEditEvent} to a language server {TextDocumentContentChangeEvent}
  // object.
  //
  // * `change` The Atom {TextEditEvent} to convert.
  //
  // Returns a {TextDocumentContentChangeEvent} that represents the converted {TextEditEvent}.
  static textEditToContentChange(change) {
    return {
      range: _convert2.default.atomRangeToLSRange(change.oldRange),
      rangeLength: change.oldText.length,
      text: change.newText
    };
  }

  _isPrimaryAdapter() {
    const lowestIdForBuffer = Math.min(...atom.workspace.getTextEditors().filter(t => t.getBuffer() === this._editor.getBuffer()).map(t => t.id));
    return lowestIdForBuffer === this._editor.id;
  }

  _bumpVersion() {
    const filePath = this._editor.getPath();
    if (filePath == null) {
      return;
    }
    this._versions.set(filePath, this._getVersion(filePath) + 1);
  }

  // Ensure when the document is opened we send notification to the language server
  // so it can load it in and keep track of diagnostics etc.
  didOpen() {
    const filePath = this._editor.getPath();
    if (filePath == null) {
      return;
    } // Not yet saved

    if (!this._isPrimaryAdapter()) {
      return;
    } // Multiple editors, we are not first

    this._connection.didOpenTextDocument({
      textDocument: {
        uri: this.getEditorUri(),
        languageId: this.getLanguageId().toLowerCase(),
        version: this._getVersion(filePath),
        text: this._editor.getText()
      }
    });
  }

  _getVersion(filePath) {
    return this._versions.get(filePath) || 1;
  }

  // Called when the {TextEditor} is closed and sends the 'didCloseTextDocument' notification to
  // the connected language server.
  didClose() {
    if (this._editor.getPath() == null) {
      return;
    } // Not yet saved

    const fileStillOpen = atom.workspace.getTextEditors().find(t => t.getBuffer() === this._editor.getBuffer());
    if (fileStillOpen) {
      return; // Other windows or editors still have this file open
    }

    this._connection.didCloseTextDocument({ textDocument: { uri: this.getEditorUri() } });
  }

  // Called just before the {TextEditor} saves and sends the 'willSaveTextDocument' notification to
  // the connected language server.
  willSave() {
    if (!this._isPrimaryAdapter()) {
      return;
    }

    const uri = this.getEditorUri();
    this._connection.willSaveTextDocument({
      textDocument: { uri },
      reason: _languageclient.TextDocumentSaveReason.Manual
    });
  }

  // Called when the {TextEditor} saves and sends the 'didSaveTextDocument' notification to
  // the connected language server.
  // Note: Right now this also sends the `didChangeWatchedFiles` notification as well but that
  // will be sent from elsewhere soon.
  didSave() {
    if (!this._isPrimaryAdapter()) {
      return;
    }

    const uri = this.getEditorUri();
    this._connection.didSaveTextDocument({ textDocument: { uri } });
    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri, type: _languageclient.FileChangeType.Changed }]
      });
    }
  }

  didRename() {
    if (!this._isPrimaryAdapter()) {
      return;
    }

    const oldUri = this._currentUri;
    this._currentUri = this.getEditorUri();
    if (!oldUri) {
      return; // Didn't previously have a name
    }

    this._connection.didCloseTextDocument({
      textDocument: { uri: oldUri }
    });

    if (this._fakeDidChangeWatchedFiles) {
      this._connection.didChangeWatchedFiles({
        changes: [{ uri: oldUri, type: _languageclient.FileChangeType.Deleted }, { uri: this._currentUri, type: _languageclient.FileChangeType.Created }]
      });
    }

    // Send an equivalent open event for this editor, which will now use the new
    // file path.
    this.didOpen();
  }

  // Public: Obtain the current {TextEditor} path and convert it to a Uri.
  getEditorUri() {
    return _convert2.default.pathToUri(this._editor.getPath() || '');
  }
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiXSwibmFtZXMiOlsiRG9jdW1lbnRTeW5jQWRhcHRlciIsImNhbkFkYXB0Iiwic2VydmVyQ2FwYWJpbGl0aWVzIiwiY2FuQWRhcHRWMiIsImNhbkFkYXB0VjMiLCJ0ZXh0RG9jdW1lbnRTeW5jIiwiSW5jcmVtZW50YWwiLCJGdWxsIiwib3B0aW9ucyIsImNoYW5nZSIsImNvbnN0cnVjdG9yIiwiY29ubmVjdGlvbiIsImRvY3VtZW50U3luY0tpbmQiLCJlZGl0b3JTZWxlY3RvciIsIl9kaXNwb3NhYmxlIiwiX2VkaXRvcnMiLCJXZWFrTWFwIiwiX3ZlcnNpb25zIiwiTWFwIiwiX2Nvbm5lY3Rpb24iLCJfZG9jdW1lbnRTeW5jS2luZCIsIl9lZGl0b3JTZWxlY3RvciIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvciIsImJpbmQiLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsInJlbW92ZSIsImhhcyIsIl9oYW5kbGVOZXdFZGl0b3IiLCJzeW5jIiwiZ2V0IiwiZGVsZXRlIiwiVGV4dEVkaXRvclN5bmNBZGFwdGVyIiwic2V0IiwiZGVzdHJveWVkU3luYyIsImdldEVkaXRvclN5bmNBZGFwdGVyIiwidmVyc2lvbnMiLCJfZWRpdG9yIiwiX2Zha2VEaWRDaGFuZ2VXYXRjaGVkRmlsZXMiLCJwcm9qZWN0Iiwib25EaWRDaGFuZ2VGaWxlcyIsImNoYW5nZVRyYWNraW5nIiwic2V0dXBDaGFuZ2VUcmFja2luZyIsImdldEJ1ZmZlciIsIm9uV2lsbFNhdmUiLCJ3aWxsU2F2ZSIsIm9uRGlkU2F2ZSIsImRpZFNhdmUiLCJkaWRDbG9zZSIsIm9uRGlkQ2hhbmdlUGF0aCIsImRpZFJlbmFtZSIsIl9jdXJyZW50VXJpIiwiZ2V0RWRpdG9yVXJpIiwiZGlkT3BlbiIsIm9uRGlkQ2hhbmdlIiwic2VuZEZ1bGxDaGFuZ2VzIiwib25EaWRDaGFuZ2VUZXh0Iiwic2VuZEluY3JlbWVudGFsQ2hhbmdlcyIsImdldExhbmd1YWdlSWQiLCJnZXRHcmFtbWFyIiwibmFtZSIsImdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJ1cmkiLCJ2ZXJzaW9uIiwiX2dldFZlcnNpb24iLCJnZXRQYXRoIiwiX2lzUHJpbWFyeUFkYXB0ZXIiLCJfYnVtcFZlcnNpb24iLCJkaWRDaGFuZ2VUZXh0RG9jdW1lbnQiLCJ0ZXh0RG9jdW1lbnQiLCJjb250ZW50Q2hhbmdlcyIsInRleHQiLCJnZXRUZXh0IiwiZXZlbnQiLCJjaGFuZ2VzIiwibGVuZ3RoIiwibWFwIiwidGV4dEVkaXRUb0NvbnRlbnRDaGFuZ2UiLCJyZXZlcnNlIiwicmFuZ2UiLCJhdG9tUmFuZ2VUb0xTUmFuZ2UiLCJvbGRSYW5nZSIsInJhbmdlTGVuZ3RoIiwib2xkVGV4dCIsIm5ld1RleHQiLCJsb3dlc3RJZEZvckJ1ZmZlciIsIk1hdGgiLCJtaW4iLCJ3b3Jrc3BhY2UiLCJnZXRUZXh0RWRpdG9ycyIsImZpbHRlciIsInQiLCJpZCIsImZpbGVQYXRoIiwiZGlkT3BlblRleHREb2N1bWVudCIsImxhbmd1YWdlSWQiLCJ0b0xvd2VyQ2FzZSIsImZpbGVTdGlsbE9wZW4iLCJmaW5kIiwiZGlkQ2xvc2VUZXh0RG9jdW1lbnQiLCJ3aWxsU2F2ZVRleHREb2N1bWVudCIsInJlYXNvbiIsIk1hbnVhbCIsImRpZFNhdmVUZXh0RG9jdW1lbnQiLCJkaWRDaGFuZ2VXYXRjaGVkRmlsZXMiLCJ0eXBlIiwiQ2hhbmdlZCIsIm9sZFVyaSIsIkRlbGV0ZWQiLCJDcmVhdGVkIiwicGF0aFRvVXJpIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBVUE7Ozs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNlLE1BQU1BLG1CQUFOLENBQTBCOztBQVF2QztBQUNBO0FBQ0E7QUFDQTtB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QUwsQ0FBYTRCLE9BQWIsTUFBMEIsRUFBNUMsQ0FBUDtBQUNEO0FBaE95QiIsImZpbGUiOiJkb2N1bWVudC1zeW5jLWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIEZpbGVDaGFuZ2VUeXBlLFxuICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLFxuICBUZXh0RG9jdW1lbnRTeW5jS2luZCxcbiAgdHlwZSBUZXh0RG9jdW1lbnRTeW5jT3B0aW9ucyxcbiAgdHlwZSBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQsXG4gIHR5cGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcixcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdhdG9tJztcblxuLy8gUHVibGljOiBTeW5jaHJvbml6ZXMgdGhlIGRvY3VtZW50cyBiZXR3ZWVuIEF0b20gYW5kIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgYnkgbm90aWZ5aW5nXG4vLyBlYWNoIGVuZCBvZiBjaGFuZ2VzLCBvcGVuaW5nLCBjbG9zaW5nIGFuZCBvdGhlciBldmVudHMgYXMgd2VsbCBhcyBzZW5kaW5nIGFuZCBhcHBseWluZ1xuLy8gY2hhbmdlcyBlaXRoZXIgaW4gd2hvbGUgb3IgaW4gcGFydCBkZXBlbmRpbmcgb24gd2hhdCB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHN1cHBvcnRzLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRTeW5jQWRhcHRlciB7XG4gIF9lZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW47XG4gIF9kaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgX2RvY3VtZW50U3luY0tpbmQ6IG51bWJlcjtcbiAgX2VkaXRvcnM6IFdlYWtNYXA8YXRvbSRUZXh0RWRpdG9yLCBUZXh0RWRpdG9yU3luY0FkYXB0ZXI+ID0gbmV3IFdlYWtNYXAoKTtcbiAgX2Nvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbjtcbiAgX3ZlcnNpb25zOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIFB1YmxpYzogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBhZGFwdGVyIGNhbiBiZSB1c2VkIHRvIGFkYXB0IGEgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IHRleHREb2N1bWVudFN5bmMgY2FwYWJpbGl0eSBlaXRoZXIgYmVpbmcgRnVsbCBvclxuICAvLyBJbmNyZW1lbnRhbC5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2FuQWRhcHRWMihzZXJ2ZXJDYXBhYmlsaXRpZXMpIHx8IHRoaXMuY2FuQWRhcHRWMyhzZXJ2ZXJDYXBhYmlsaXRpZXMpO1xuICB9XG5cbiAgc3RhdGljIGNhbkFkYXB0VjIoc2VydmVyQ2FwYWJpbGl0aWVzOiBTZXJ2ZXJDYXBhYmlsaXRpZXMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgc2VydmVyQ2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkluY3JlbWVudGFsIHx8XG4gICAgICBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYyA9PT0gVGV4dERvY3VtZW50U3luY0tpbmQuRnVsbFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgY2FuQWRhcHRWMyhzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBzZXJ2ZXJDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50U3luYztcbiAgICByZXR1cm4gKFxuICAgICAgb3B0aW9ucyAhPT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmXG4gICAgICAob3B0aW9ucy5jaGFuZ2UgPT09IFRleHREb2N1bWVudFN5bmNLaW5kLkluY3JlbWVudGFsIHx8IG9wdGlvbnMuY2hhbmdlID09PSBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsKVxuICAgICk7XG4gIH1cblxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIG5ldyB7RG9jdW1lbnRTeW5jQWRhcHRlcn0gZm9yIHRoZSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0byBiZSBrZXB0IGluIHN5bmMuXG4gIC8vICogYGRvY3VtZW50U3luY0tpbmRgIFRoZSB0eXBlIG9mIGRvY3VtZW50IHN5bmNpbmcgc3VwcG9ydGVkIC0gRnVsbCBvciBJbmNyZW1lbnRhbC5cbiAgLy8gKiBgZWRpdG9yU2VsZWN0b3JgIEEgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB7VGV4dEVkaXRvcn0gYW5kIHJldHVybnMgYSB7Ym9vbGVhbn1cbiAgLy8gICAgICAgICAgICAgICAgICAgIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGFkYXB0ZXIgc2hvdWxkIGNhcmUgYWJvdXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBlZGl0b3IuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgICBkb2N1bWVudFN5bmNLaW5kOiA/KFRleHREb2N1bWVudFN5bmNPcHRpb25zIHwgbnVtYmVyKSxcbiAgICBlZGl0b3JTZWxlY3RvcjogYXRvbSRUZXh0RWRpdG9yID0+IGJvb2xlYW4sXG4gICkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnRTeW5jS2luZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRTeW5jS2luZCAhPSBudWxsICYmIGRvY3VtZW50U3luY0tpbmQuY2hhbmdlICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50U3luY0tpbmQgPSBkb2N1bWVudFN5bmNLaW5kLmNoYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZG9jdW1lbnRTeW5jS2luZCA9IFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRvclNlbGVjdG9yID0gZWRpdG9yU2VsZWN0b3I7XG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoYXRvbS50ZXh0RWRpdG9ycy5vYnNlcnZlKHRoaXMub2JzZXJ2ZVRleHRFZGl0b3IuYmluZCh0aGlzKSkpO1xuICB9XG5cbiAgLy8gRGlzcG9zZSB0aGlzIGFkYXB0ZXIgZW5zdXJpbmcgYW55IHJlc291cmNlcyBhcmUgZnJlZWQgYW5kIGV2ZW50cyB1bmhvb2tlZC5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIEV4YW1pbmUgYSB7VGV4dEVkaXRvcn0gYW5kIGRlY2lkZSBpZiB3ZSB3aXNoIHRvIG9ic2VydmUgaXQuIElmIHNvIGVuc3VyZSB0aGF0IHdlIHN0b3Agb2JzZXJ2aW5nIGl0XG4gIC8vIHdoZW4gaXQgaXMgY2xvc2VkIG9yIG90aGVyd2lzZSBkZXN0cm95ZWQuXG4gIC8vXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdG8gY29uc2lkZXIgZm9yIG9ic2VydmF0aW9uLlxuICBvYnNlcnZlVGV4dEVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IHZvaWQge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gZWRpdG9yLm9ic2VydmVHcmFtbWFyKGdyYW1tYXIgPT4gdGhpcy5faGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3IpKTtcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChcbiAgICAgIGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShsaXN0ZW5lcik7XG4gICAgICAgIGxpc3RlbmVyLmRpc3Bvc2UoKTtcbiAgICAgIH0pLFxuICAgICk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQobGlzdGVuZXIpO1xuICAgIGlmICghdGhpcy5fZWRpdG9ycy5oYXMoZWRpdG9yKSAmJiB0aGlzLl9lZGl0b3JTZWxlY3RvcihlZGl0b3IpKSB7XG4gICAgICB0aGlzLl9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yKTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IHZvaWQge1xuICAgIGNvbnN0IHN5bmMgPSB0aGlzLl9lZGl0b3JzLmdldChlZGl0b3IpO1xuICAgIGlmIChzeW5jICE9IG51bGwgJiYgIXRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuX2VkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLnJlbW92ZShzeW5jKTtcbiAgICAgIHN5bmMuZGlzcG9zZSgpO1xuICAgIH0gZWxzZSBpZiAoc3luYyA9PSBudWxsICYmIHRoaXMuX2VkaXRvclNlbGVjdG9yKGVkaXRvcikpIHtcbiAgICAgIHRoaXMuX2hhbmRsZU5ld0VkaXRvcihlZGl0b3IpO1xuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVOZXdFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiB2b2lkIHtcbiAgICBjb25zdCBzeW5jID0gbmV3IFRleHRFZGl0b3JTeW5jQWRhcHRlcihlZGl0b3IsIHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuX2RvY3VtZW50U3luY0tpbmQsIHRoaXMuX3ZlcnNpb25zKTtcbiAgICB0aGlzLl9lZGl0b3JzLnNldChlZGl0b3IsIHN5bmMpO1xuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKHN5bmMpO1xuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxuICAgICAgZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc3Ryb3llZFN5bmMgPSB0aGlzLl9lZGl0b3JzLmdldChlZGl0b3IpO1xuICAgICAgICBpZiAoZGVzdHJveWVkU3luYykge1xuICAgICAgICAgIHRoaXMuX2VkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgdGhpcy5fZGlzcG9zYWJsZS5yZW1vdmUoZGVzdHJveWVkU3luYyk7XG4gICAgICAgICAgZGVzdHJveWVkU3luYy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBnZXRFZGl0b3JTeW5jQWRhcHRlcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9UZXh0RWRpdG9yU3luY0FkYXB0ZXIge1xuICAgIHJldHVybiB0aGlzLl9lZGl0b3JzLmdldChlZGl0b3IpO1xuICB9XG59XG5cbi8vIFB1YmxpYzogS2VlcCBhIHNpbmdsZSB7VGV4dEVkaXRvcn0gaW4gc3luYyB3aXRoIGEgZ2l2ZW4gbGFuZ3VhZ2Ugc2VydmVyLlxuY2xhc3MgVGV4dEVkaXRvclN5bmNBZGFwdGVyIHtcbiAgX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xuICBfZWRpdG9yOiBhdG9tJFRleHRFZGl0b3I7XG4gIF9jdXJyZW50VXJpOiBzdHJpbmc7XG4gIF9jb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb247XG4gIF9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzOiBib29sZWFuO1xuICBfdmVyc2lvbnM6IE1hcDxzdHJpbmcsIG51bWJlcj47XG5cbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dEVkaXRvclN5bmNBZGFwdGVyfSBpbiBzeW5jIHdpdGggYSBnaXZlbiBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdG8ga2VlcCBpbiBzeW5jLlxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHRvIGtlZXAgaW4gc3luYy5cbiAgLy8gKiBgZG9jdW1lbnRTeW5jS2luZGAgV2hldGhlciB0byB1c2UgRnVsbCAoMSkgb3IgSW5jcmVtZW50YWwgKDIpIHdoZW4gc2VuZGluZyBjaGFuZ2VzLlxuICBjb25zdHJ1Y3RvcihcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gICAgZG9jdW1lbnRTeW5jS2luZDogbnVtYmVyLFxuICAgIHZlcnNpb25zOiBNYXA8c3RyaW5nLCBudW1iZXI+LFxuICApIHtcbiAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5fdmVyc2lvbnMgPSB2ZXJzaW9ucztcbiAgICB0aGlzLl9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzID0gYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlRmlsZXMgPT0gbnVsbDtcblxuICAgIGNvbnN0IGNoYW5nZVRyYWNraW5nID0gdGhpcy5zZXR1cENoYW5nZVRyYWNraW5nKGRvY3VtZW50U3luY0tpbmQpO1xuICAgIGlmIChjaGFuZ2VUcmFja2luZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChjaGFuZ2VUcmFja2luZyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkub25XaWxsU2F2ZSh0aGlzLndpbGxTYXZlLmJpbmQodGhpcykpLFxuICAgICAgZWRpdG9yLm9uRGlkU2F2ZSh0aGlzLmRpZFNhdmUuYmluZCh0aGlzKSksXG4gICAgICBlZGl0b3Iub25EaWREZXN0cm95KHRoaXMuZGlkQ2xvc2UuYmluZCh0aGlzKSksXG4gICAgICBlZGl0b3Iub25EaWRDaGFuZ2VQYXRoKHRoaXMuZGlkUmVuYW1lLmJpbmQodGhpcykpLFxuICAgICk7XG5cbiAgICB0aGlzLl9jdXJyZW50VXJpID0gdGhpcy5nZXRFZGl0b3JVcmkoKTtcbiAgICB0aGlzLmRpZE9wZW4oKTtcbiAgfVxuXG4gIC8vIFRoZSBjaGFuZ2UgdHJhY2tpbmcgZGlzcG9zYWJsZSBsaXN0ZW5lciB0aGF0IHdpbGwgZW5zdXJlIHRoYXQgY2hhbmdlcyBhcmUgc2VudCB0byB0aGVcbiAgLy8gbGFuZ3VhZ2Ugc2VydmVyIGFzIGFwcHJvcHJpYXRlLlxuICBzZXR1cENoYW5nZVRyYWNraW5nKGRvY3VtZW50U3luY0tpbmQ6IG51bWJlcik6ID9JRGlzcG9zYWJsZSB7XG4gICAgc3dpdGNoIChkb2N1bWVudFN5bmNLaW5kKSB7XG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkZ1bGw6XG4gICAgICAgIHJldHVybiB0aGlzLl9lZGl0b3Iub25EaWRDaGFuZ2UodGhpcy5zZW5kRnVsbENoYW5nZXMuYmluZCh0aGlzKSk7XG4gICAgICBjYXNlIFRleHREb2N1bWVudFN5bmNLaW5kLkluY3JlbWVudGFsOlxuICAgICAgICByZXR1cm4gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpLm9uRGlkQ2hhbmdlVGV4dCh0aGlzLnNlbmRJbmNyZW1lbnRhbENoYW5nZXMuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRGlzcG9zZSB0aGlzIGFkYXB0ZXIgZW5zdXJpbmcgYW55IHJlc291cmNlcyBhcmUgZnJlZWQgYW5kIGV2ZW50cyB1bmhvb2tlZC5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgbGFuZ3VhZ2VJZCBmaWVsZCB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGJ5IHNpbXBseVxuICAvLyB1c2luZyB0aGUgZ3JhbW1hciBuYW1lLlxuICBnZXRMYW5ndWFnZUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvci5nZXRHcmFtbWFyKCkubmFtZTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGEge1ZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGZvciB0aGUgZG9jdW1lbnQgb2JzZXJ2ZWQgYnlcbiAgLy8gdGhpcyBhZGFwdGVyIGluY2x1ZGluZyBib3RoIHRoZSBVcmkgYW5kIHRoZSBjdXJyZW50IFZlcnNpb24uXG4gIGdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKTogVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVyaTogdGhpcy5nZXRFZGl0b3JVcmkoKSxcbiAgICAgIHZlcnNpb246IHRoaXMuX2dldFZlcnNpb24odGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogU2VuZCB0aGUgZW50aXJlIGRvY3VtZW50IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaXMgdXNlZCB3aGVuXG4gIC8vIG9wZXJhdGluZyBpbiBGdWxsICgxKSBzeW5jIG1vZGUuXG4gIHNlbmRGdWxsQ2hhbmdlcygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2lzUHJpbWFyeUFkYXB0ZXIoKSkgeyByZXR1cm47IH0gLy8gTXVsdGlwbGUgZWRpdG9ycywgd2UgYXJlIG5vdCBmaXJzdFxuXG4gICAgdGhpcy5fYnVtcFZlcnNpb24oKTtcbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVRleHREb2N1bWVudCh7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IHRoaXMuZ2V0VmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcigpLFxuICAgICAgY29udGVudENoYW5nZXM6IFt7dGV4dDogdGhpcy5fZWRpdG9yLmdldFRleHQoKX1dLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUHVibGljOiBTZW5kIHRoZSBpbmNyZW1lbnRhbCB0ZXh0IGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci4gVGhpcyBpcyB1c2VkXG4gIC8vIHdoZW4gb3BlcmF0aW5nIGluIEluY3JlbWVudGFsICgyKSBzeW5jIG1vZGUuXG4gIC8vXG4gIC8vICogYGV2ZW50YCBUaGUgZXZlbnQgZmlyZWQgYnkgQXRvbSB0byBpbmRpY2F0ZSB0aGUgZG9jdW1lbnQgaGFzIHN0b3BwZWQgY2hhbmdpbmdcbiAgLy8gICAgICAgICAgIGluY2x1ZGluZyBhIGxpc3Qgb2YgY2hhbmdlcyBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoaXMgZXZlbnQgZmlyZWQgZm9yIHRoaXNcbiAgLy8gICAgICAgICAgIHRleHQgZWRpdG9yLlxuICAvLyBOb3RlOiBUaGUgb3JkZXIgb2YgY2hhbmdlcyBpbiB0aGUgZXZlbnQgaXMgZ3VhcmFudGVlZCB0b3AgdG8gYm90dG9tLiAgTGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGV4cGVjdHMgdGhpcyBpbiByZXZlcnNlLlxuICBzZW5kSW5jcmVtZW50YWxDaGFuZ2VzKGV2ZW50OiBhdG9tJERpZFN0b3BDaGFuZ2luZ0V2ZW50KTogdm9pZCB7XG4gICAgaWYgKGV2ZW50LmNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHsgcmV0dXJuOyB9IC8vIE11bHRpcGxlIGVkaXRvcnMsIHdlIGFyZSBub3QgZmlyc3RcblxuICAgICAgdGhpcy5fYnVtcFZlcnNpb24oKTtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkQ2hhbmdlVGV4dERvY3VtZW50KHtcbiAgICAgICAgdGV4dERvY3VtZW50OiB0aGlzLmdldFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIoKSxcbiAgICAgICAgY29udGVudENoYW5nZXM6IGV2ZW50LmNoYW5nZXMubWFwKFRleHRFZGl0b3JTeW5jQWRhcHRlci50ZXh0RWRpdFRvQ29udGVudENoYW5nZSkucmV2ZXJzZSgpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIEF0b20ge1RleHRFZGl0RXZlbnR9IHRvIGEgbGFuZ3VhZ2Ugc2VydmVyIHtUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnR9XG4gIC8vIG9iamVjdC5cbiAgLy9cbiAgLy8gKiBgY2hhbmdlYCBUaGUgQXRvbSB7VGV4dEVkaXRFdmVudH0gdG8gY29udmVydC5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnR9IHRoYXQgcmVwcmVzZW50cyB0aGUgY29udmVydGVkIHtUZXh0RWRpdEV2ZW50fS5cbiAgc3RhdGljIHRleHRFZGl0VG9Db250ZW50Q2hhbmdlKGNoYW5nZTogYXRvbSRUZXh0RWRpdEV2ZW50KTogVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2U6IENvbnZlcnQuYXRvbVJhbmdlVG9MU1JhbmdlKGNoYW5nZS5vbGRSYW5nZSksXG4gICAgICByYW5nZUxlbmd0aDogY2hhbmdlLm9sZFRleHQubGVuZ3RoLFxuICAgICAgdGV4dDogY2hhbmdlLm5ld1RleHQsXG4gICAgfTtcbiAgfVxuXG4gIF9pc1ByaW1hcnlBZGFwdGVyKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGxvd2VzdElkRm9yQnVmZmVyID0gTWF0aC5taW4oXG4gICAgICAuLi5hdG9tLndvcmtzcGFjZVxuICAgICAgICAuZ2V0VGV4dEVkaXRvcnMoKVxuICAgICAgICAuZmlsdGVyKHQgPT4gdC5nZXRCdWZmZXIoKSA9PT0gdGhpcy5fZWRpdG9yLmdldEJ1ZmZlcigpKVxuICAgICAgICAubWFwKHQgPT4gdC5pZCksXG4gICAgKTtcbiAgICByZXR1cm4gbG93ZXN0SWRGb3JCdWZmZXIgPT09IHRoaXMuX2VkaXRvci5pZDtcbiAgfVxuXG4gIF9idW1wVmVyc2lvbigpOiB2b2lkIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHRoaXMuX2VkaXRvci5nZXRQYXRoKCk7XG4gICAgaWYgKGZpbGVQYXRoID09IG51bGwpIHsgcmV0dXJuOyB9XG4gICAgdGhpcy5fdmVyc2lvbnMuc2V0KGZpbGVQYXRoLCB0aGlzLl9nZXRWZXJzaW9uKGZpbGVQYXRoKSArIDEpO1xuICB9XG5cbiAgLy8gRW5zdXJlIHdoZW4gdGhlIGRvY3VtZW50IGlzIG9wZW5lZCB3ZSBzZW5kIG5vdGlmaWNhdGlvbiB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIHNvIGl0IGNhbiBsb2FkIGl0IGluIGFuZCBrZWVwIHRyYWNrIG9mIGRpYWdub3N0aWNzIGV0Yy5cbiAgZGlkT3BlbigpOiB2b2lkIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IHRoaXMuX2VkaXRvci5nZXRQYXRoKCk7XG4gICAgaWYgKGZpbGVQYXRoID09IG51bGwpIHsgcmV0dXJuOyB9IC8vIE5vdCB5ZXQgc2F2ZWRcblxuICAgIGlmICghdGhpcy5faXNQcmltYXJ5QWRhcHRlcigpKSB7IHJldHVybjsgfSAvLyBNdWx0aXBsZSBlZGl0b3JzLCB3ZSBhcmUgbm90IGZpcnN0XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLmRpZE9wZW5UZXh0RG9jdW1lbnQoe1xuICAgICAgdGV4dERvY3VtZW50OiB7XG4gICAgICAgIHVyaTogdGhpcy5nZXRFZGl0b3JVcmkoKSxcbiAgICAgICAgbGFuZ3VhZ2VJZDogdGhpcy5nZXRMYW5ndWFnZUlkKCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fZ2V0VmVyc2lvbihmaWxlUGF0aCksXG4gICAgICAgIHRleHQ6IHRoaXMuX2VkaXRvci5nZXRUZXh0KCksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgX2dldFZlcnNpb24oZmlsZVBhdGg6IHN0cmluZyk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25zLmdldChmaWxlUGF0aCkgfHwgMTtcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuIHRoZSB7VGV4dEVkaXRvcn0gaXMgY2xvc2VkIGFuZCBzZW5kcyB0aGUgJ2RpZENsb3NlVGV4dERvY3VtZW50JyBub3RpZmljYXRpb24gdG9cbiAgLy8gdGhlIGNvbm5lY3RlZCBsYW5ndWFnZSBzZXJ2ZXIuXG4gIGRpZENsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9lZGl0b3IuZ2V0UGF0aCgpID09IG51bGwpIHsgcmV0dXJuOyB9IC8vIE5vdCB5ZXQgc2F2ZWRcblxuICAgIGNvbnN0IGZpbGVTdGlsbE9wZW4gPSBhdG9tLndvcmtzcGFjZS5nZXRUZXh0RWRpdG9ycygpLmZpbmQodCA9PiB0LmdldEJ1ZmZlcigpID09PSB0aGlzLl9lZGl0b3IuZ2V0QnVmZmVyKCkpO1xuICAgIGlmIChmaWxlU3RpbGxPcGVuKSB7XG4gICAgICByZXR1cm47IC8vIE90aGVyIHdpbmRvd3Mgb3IgZWRpdG9ycyBzdGlsbCBoYXZlIHRoaXMgZmlsZSBvcGVuXG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDbG9zZVRleHREb2N1bWVudCh7dGV4dERvY3VtZW50OiB7dXJpOiB0aGlzLmdldEVkaXRvclVyaSgpfX0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIGp1c3QgYmVmb3JlIHRoZSB7VGV4dEVkaXRvcn0gc2F2ZXMgYW5kIHNlbmRzIHRoZSAnd2lsbFNhdmVUZXh0RG9jdW1lbnQnIG5vdGlmaWNhdGlvbiB0b1xuICAvLyB0aGUgY29ubmVjdGVkIGxhbmd1YWdlIHNlcnZlci5cbiAgd2lsbFNhdmUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCB1cmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24ud2lsbFNhdmVUZXh0RG9jdW1lbnQoe1xuICAgICAgdGV4dERvY3VtZW50OiB7dXJpfSxcbiAgICAgIHJlYXNvbjogVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5NYW51YWwsXG4gICAgfSk7XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbiB0aGUge1RleHRFZGl0b3J9IHNhdmVzIGFuZCBzZW5kcyB0aGUgJ2RpZFNhdmVUZXh0RG9jdW1lbnQnIG5vdGlmaWNhdGlvbiB0b1xuICAvLyB0aGUgY29ubmVjdGVkIGxhbmd1YWdlIHNlcnZlci5cbiAgLy8gTm90ZTogUmlnaHQgbm93IHRoaXMgYWxzbyBzZW5kcyB0aGUgYGRpZENoYW5nZVdhdGNoZWRGaWxlc2Agbm90aWZpY2F0aW9uIGFzIHdlbGwgYnV0IHRoYXRcbiAgLy8gd2lsbCBiZSBzZW50IGZyb20gZWxzZXdoZXJlIHNvb24uXG4gIGRpZFNhdmUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCB1cmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZGlkU2F2ZVRleHREb2N1bWVudCh7dGV4dERvY3VtZW50OiB7dXJpfX0pO1xuICAgIGlmICh0aGlzLl9mYWtlRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKSB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uLmRpZENoYW5nZVdhdGNoZWRGaWxlcyh7XG4gICAgICAgIGNoYW5nZXM6IFt7dXJpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5DaGFuZ2VkfV0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkaWRSZW5hbWUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9pc1ByaW1hcnlBZGFwdGVyKCkpIHsgcmV0dXJuOyB9XG5cbiAgICBjb25zdCBvbGRVcmkgPSB0aGlzLl9jdXJyZW50VXJpO1xuICAgIHRoaXMuX2N1cnJlbnRVcmkgPSB0aGlzLmdldEVkaXRvclVyaSgpO1xuICAgIGlmICghb2xkVXJpKSB7XG4gICAgICByZXR1cm47IC8vIERpZG4ndCBwcmV2aW91c2x5IGhhdmUgYSBuYW1lXG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDbG9zZVRleHREb2N1bWVudCh7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IHt1cmk6IG9sZFVyaX0sXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5fZmFrZURpZENoYW5nZVdhdGNoZWRGaWxlcykge1xuICAgICAgdGhpcy5fY29ubmVjdGlvbi5kaWRDaGFuZ2VXYXRjaGVkRmlsZXMoe1xuICAgICAgICBjaGFuZ2VzOiBbe3VyaTogb2xkVXJpLCB0eXBlOiBGaWxlQ2hhbmdlVHlwZS5EZWxldGVkfSwge3VyaTogdGhpcy5fY3VycmVudFVyaSwgdHlwZTogRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZH1dLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2VuZCBhbiBlcXVpdmFsZW50IG9wZW4gZXZlbnQgZm9yIHRoaXMgZWRpdG9yLCB3aGljaCB3aWxsIG5vdyB1c2UgdGhlIG5ld1xuICAgIC8vIGZpbGUgcGF0aC5cbiAgICB0aGlzLmRpZE9wZW4oKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogT2J0YWluIHRoZSBjdXJyZW50IHtUZXh0RWRpdG9yfSBwYXRoIGFuZCBjb252ZXJ0IGl0IHRvIGEgVXJpLlxuICBnZXRFZGl0b3JVcmkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gQ29udmVydC5wYXRoVG9VcmkodGhpcy5fZWRpdG9yLmdldFBhdGgoKSB8fCAnJyk7XG4gIH1cbn1cbiJdfQ==