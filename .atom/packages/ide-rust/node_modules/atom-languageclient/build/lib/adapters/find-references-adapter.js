Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
let FindReferencesAdapter = class FindReferencesAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a referencesProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.referencesProvider === true;
  }

  // Public: Get the references for a specific symbol within the document as represented by
  // the {TextEditor} and {Point} within it via the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the references.
  // * `editor` The Atom {TextEditor} containing the text the references should relate to.
  // * `point` The Atom {Point} containing the point within the text the references should relate to.
  //
  // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
  // could find.
  getReferences(connection, editor, point, projectRoot) {
    return _asyncToGenerator(function* () {
      const locations = yield connection.findReferences(FindReferencesAdapter.createTextDocumentPositionParams(editor, point));
      if (locations == null) {
        return null;
      }

      const references = locations.map(FindReferencesAdapter.locationToReference);
      return {
        type: 'data',
        baseUri: projectRoot || '',
        referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
        references
      };
    })();
  }

  // Public: Create a {TextDocumentPositionParams} from a given {TextEditor} for a specific {Point}.
  //
  // * `editor` A {TextEditor} that represents the document.
  // * `point` A {Point} within the document.
  //
  // Returns a {DocumentPositionParams} built from the given parameters.
  static createTextDocumentPositionParams(editor, point) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      position: _convert2.default.pointToPosition(point),
      context: { includeDeclaration: true }
    };
  }

  // Public: Convert a {Location} into a {Reference}.
  //
  // * `location` A {Location} to convert.
  //
  // Returns a {Reference} equivalent to the given {Location}.
  static locationToReference(location) {
    return {
      uri: _convert2.default.uriToPath(location.uri),
      name: null,
      range: _convert2.default.lsRangeToAtomRange(location.range)
    };
  }

  // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
  static getReferencedSymbolName(editor, point, references) {
    if (references.length === 0) {
      return '';
    }
    const currentReference = references.find(r => r.range.containsPoint(point)) || references[0];
    return editor.getBuffer().getTextInRange(currentReference.range);
  }
};
exports.default = FindReferencesAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9maW5kLXJlZmVyZW5jZXMtYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJGaW5kUmVmZXJlbmNlc0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsInJlZmVyZW5jZXNQcm92aWRlciIsImdldFJlZmVyZW5jZXMiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicG9pbnQiLCJwcm9qZWN0Um9vdCIsImxvY2F0aW9ucyIsImZpbmRSZWZlcmVuY2VzIiwiY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJyZWZlcmVuY2VzIiwibWFwIiwibG9jYXRpb25Ub1JlZmVyZW5jZSIsInR5cGUiLCJiYXNlVXJpIiwicmVmZXJlbmNlZFN5bWJvbE5hbWUiLCJnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZSIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInBvc2l0aW9uIiwicG9pbnRUb1Bvc2l0aW9uIiwiY29udGV4dCIsImluY2x1ZGVEZWNsYXJhdGlvbiIsImxvY2F0aW9uIiwidXJpIiwidXJpVG9QYXRoIiwibmFtZSIsInJhbmdlIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwibGVuZ3RoIiwiY3VycmVudFJlZmVyZW5jZSIsImZpbmQiLCJyIiwiY29udGFpbnNQb2ludCIsImdldEJ1ZmZlciIsImdldFRleHRJblJhbmdlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBOztBQU1BOzs7Ozs7OztBQUVBO0FBQ0E7SUFDcUJBLHFCLEdBQU4sTUFBTUEscUJBQU4sQ0FBNEI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBT0MsUUFBUCxDQUFnQkMsa0JBQWhCLEVBQWlFO0FBQy9ELFdBQU9BLG1CQUFtQkMsa0JBQW5CLEtBQTBDLElBQWpEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTUMsZUFBTixDQUFvQkMsVUFBcEIsRUFBMERDLE1BQTFELEVBQW1GQyxLQUFuRixFQUFzR0MsV0FBdEcsRUFBb0s7QUFBQTtBQUNsSyxZQUFNQyxZQUFZLE1BQU1KLFdBQVdLLGNBQVgsQ0FBMEJWLHNCQUFzQlcsZ0NBQXRCLENBQXVETCxNQUF2RCxFQUErREMsS0FBL0QsQ0FBMUIsQ0FBeEI7QUFDQSxVQUFJRSxhQUFhLElBQWpCLEVBQXVCO0FBQUUsZUFBTyxJQUFQO0FBQWM7O0FBRXZDLFlBQU1HLGFBQWFILFVBQVVJLEdBQVYsQ0FBY2Isc0JBQXNCYyxtQkFBcEMsQ0FBbkI7QUFDQSxhQUFPO0FBQ0xDLGNBQU0sTUFERDtBQUVMQyxpQkFBU1IsZUFBZSxFQUZuQjtBQUdMUyw4QkFBc0JqQixzQkFBc0JrQix1QkFBdEIsQ0FBOENaLE1BQTlDLEVBQXNEQyxLQUF0RCxFQUE2REssVUFBN0QsQ0FIakI7QUFJTEE7QUFKSyxPQUFQO0FBTGtLO0FBV25LOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9ELGdDQUFQLENBQXdDTCxNQUF4QyxFQUFpRUMsS0FBakUsRUFBZ0g7QUFDOUcsV0FBTztBQUNMWSxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNkLE1BQXZDLENBRFQ7QUFFTGUsZ0JBQVUsa0JBQVFDLGVBQVIsQ0FBd0JmLEtBQXhCLENBRkw7QUFHTGdCLGVBQVMsRUFBQ0Msb0JBQW9CLElBQXJCO0FBSEosS0FBUDtBQUtEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPVixtQkFBUCxDQUEyQlcsUUFBM0IsRUFBa0U7QUFDaEUsV0FBTztBQUNMQyxXQUFLLGtCQUFRQyxTQUFSLENBQWtCRixTQUFTQyxHQUEzQixDQURBO0FBRUxFLFlBQU0sSUFGRDtBQUdMQyxhQUFPLGtCQUFRQyxrQkFBUixDQUEyQkwsU0FBU0ksS0FBcEM7QUFIRixLQUFQO0FBS0Q7O0FBRUQ7QUFDQSxTQUFPWCx1QkFBUCxDQUErQlosTUFBL0IsRUFBd0RDLEtBQXhELEVBQTJFSyxVQUEzRSxFQUF5SDtBQUN2SCxRQUFJQSxXQUFXbUIsTUFBWCxLQUFzQixDQUExQixFQUE2QjtBQUFFLGFBQU8sRUFBUDtBQUFZO0FBQzNDLFVBQU1DLG1CQUFtQnBCLFdBQVdxQixJQUFYLENBQWdCQyxLQUFLQSxFQUFFTCxLQUFGLENBQVFNLGFBQVIsQ0FBc0I1QixLQUF0QixDQUFyQixLQUFzREssV0FBVyxDQUFYLENBQS9FO0FBQ0EsV0FBT04sT0FBTzhCLFNBQVAsR0FBbUJDLGNBQW5CLENBQWtDTCxpQkFBaUJILEtBQW5ELENBQVA7QUFDRDtBQXBFd0MsQztrQkFBdEI3QixxQiIsImZpbGUiOiJmaW5kLXJlZmVyZW5jZXMtYWRhcHRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5cbmltcG9ydCB7XG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgdHlwZSBMb2NhdGlvbixcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsXG4gIHR5cGUgVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMsXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGRlZmluaXRpb24gcHJvdmlkZXIgdG8gdGhlXG4vLyBBdG9tIElERSBVSSBEZWZpbml0aW9ucyBwYWNrYWdlIGZvciAnR28gVG8gRGVmaW5pdGlvbicgZnVuY3Rpb25hbGl0eS5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbmRSZWZlcmVuY2VzQWRhcHRlciB7XG5cbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIHJlZmVyZW5jZXNQcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5yZWZlcmVuY2VzUHJvdmlkZXIgPT09IHRydWU7XG4gIH1cblxuICAvLyBQdWJsaWM6IEdldCB0aGUgcmVmZXJlbmNlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgd2l0aGluIHRoZSBkb2N1bWVudCBhcyByZXByZXNlbnRlZCBieVxuICAvLyB0aGUge1RleHRFZGl0b3J9IGFuZCB7UG9pbnR9IHdpdGhpbiBpdCB2aWEgdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgcmVmZXJlbmNlcy5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb2ludCB3aXRoaW4gdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIGEge0ZpbmRSZWZlcmVuY2VzUmV0dXJufSB3aXRoIGFsbCB0aGUgcmVmZXJlbmNlcyB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGNvdWxkIGZpbmQuXG4gIGFzeW5jIGdldFJlZmVyZW5jZXMoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcG9pbnQ6IGF0b20kUG9pbnQsIHByb2plY3RSb290OiA/c3RyaW5nKTogUHJvbWlzZTw/bnVjbGlkZSRGaW5kUmVmZXJlbmNlc1JldHVybj4ge1xuICAgIGNvbnN0IGxvY2F0aW9ucyA9IGF3YWl0IGNvbm5lY3Rpb24uZmluZFJlZmVyZW5jZXMoRmluZFJlZmVyZW5jZXNBZGFwdGVyLmNyZWF0ZVRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvciwgcG9pbnQpKTtcbiAgICBpZiAobG9jYXRpb25zID09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBsb2NhdGlvbnMubWFwKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5sb2NhdGlvblRvUmVmZXJlbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgYmFzZVVyaTogcHJvamVjdFJvb3QgfHwgJycsXG4gICAgICByZWZlcmVuY2VkU3ltYm9sTmFtZTogRmluZFJlZmVyZW5jZXNBZGFwdGVyLmdldFJlZmVyZW5jZWRTeW1ib2xOYW1lKGVkaXRvciwgcG9pbnQsIHJlZmVyZW5jZXMpLFxuICAgICAgcmVmZXJlbmNlcyxcbiAgICB9O1xuICB9XG5cbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXN9IGZyb20gYSBnaXZlbiB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fS5cbiAgLy9cbiAgLy8gKiBgZWRpdG9yYCBBIHtUZXh0RWRpdG9yfSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50LlxuICAvLyAqIGBwb2ludGAgQSB7UG9pbnR9IHdpdGhpbiB0aGUgZG9jdW1lbnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7RG9jdW1lbnRQb3NpdGlvblBhcmFtc30gYnVpbHQgZnJvbSB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgc3RhdGljIGNyZWF0ZVRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBwb2ludDogYXRvbSRQb2ludCk6IFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHBvaW50KSxcbiAgICAgIGNvbnRleHQ6IHtpbmNsdWRlRGVjbGFyYXRpb246IHRydWV9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHtMb2NhdGlvbn0gaW50byBhIHtSZWZlcmVuY2V9LlxuICAvL1xuICAvLyAqIGBsb2NhdGlvbmAgQSB7TG9jYXRpb259IHRvIGNvbnZlcnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UmVmZXJlbmNlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7TG9jYXRpb259LlxuICBzdGF0aWMgbG9jYXRpb25Ub1JlZmVyZW5jZShsb2NhdGlvbjogTG9jYXRpb24pOiBudWNsaWRlJFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVyaTogQ29udmVydC51cmlUb1BhdGgobG9jYXRpb24udXJpKSxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICByYW5nZTogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UobG9jYXRpb24ucmFuZ2UpLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IEdldCBhIHN5bWJvbCBuYW1lIGZyb20gYSB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fSBpbiB0aGUgZG9jdW1lbnQuXG4gIHN0YXRpYyBnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcG9pbnQ6IGF0b20kUG9pbnQsIHJlZmVyZW5jZXM6IEFycmF5PG51Y2xpZGUkUmVmZXJlbmNlPik6IHN0cmluZyB7XG4gICAgaWYgKHJlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJzsgfVxuICAgIGNvbnN0IGN1cnJlbnRSZWZlcmVuY2UgPSByZWZlcmVuY2VzLmZpbmQociA9PiByLnJhbmdlLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB8fCByZWZlcmVuY2VzWzBdO1xuICAgIHJldHVybiBlZGl0b3IuZ2V0QnVmZmVyKCkuZ2V0VGV4dEluUmFuZ2UoY3VycmVudFJlZmVyZW5jZS5yYW5nZSk7XG4gIH1cbn1cbiJdfQ==