Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class FindReferencesAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a referencesProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.referencesProvider === true;
  }

  // Public: Get the references for a specific symbol within the document as represented by
  // the {TextEditor} and {Point} within it via the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the references.
  // * `editor` The Atom {TextEditor} containing the text the references should relate to.
  // * `point` The Atom {Point} containing the point within the text the references should relate to.
  //
  // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
  // could find.
  async getReferences(connection, editor, point, projectRoot) {
    const locations = await connection.findReferences(FindReferencesAdapter.createTextDocumentPositionParams(editor, point));
    if (locations == null) {
      return null;
    }

    const references = locations.map(FindReferencesAdapter.locationToReference);
    return {
      type: 'data',
      baseUri: projectRoot || '',
      referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
      references
    };
  }

  // Public: Create a {TextDocumentPositionParams} from a given {TextEditor} for a specific {Point}.
  //
  // * `editor` A {TextEditor} that represents the document.
  // * `point` A {Point} within the document.
  //
  // Returns a {DocumentPositionParams} built from the given parameters.
  static createTextDocumentPositionParams(editor, point) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      position: _convert2.default.pointToPosition(point),
      context: { includeDeclaration: true }
    };
  }

  // Public: Convert a {Location} into a {Reference}.
  //
  // * `location` A {Location} to convert.
  //
  // Returns a {Reference} equivalent to the given {Location}.
  static locationToReference(location) {
    return {
      uri: _convert2.default.uriToPath(location.uri),
      name: null,
      range: _convert2.default.lsRangeToAtomRange(location.range)
    };
  }

  // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
  static getReferencedSymbolName(editor, point, references) {
    if (references.length === 0) {
      return '';
    }
    const currentReference = references.find(r => r.range.containsPoint(point)) || references[0];
    return editor.getBuffer().getTextInRange(currentReference.range);
  }
}
exports.default = FindReferencesAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9maW5kLXJlZmVyZW5jZXMtYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJGaW5kUmVmZXJlbmNlc0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsInJlZmVyZW5jZXNQcm92aWRlciIsImdldFJlZmVyZW5jZXMiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicG9pbnQiLCJwcm9qZWN0Um9vdCIsImxvY2F0aW9ucyIsImZpbmRSZWZlcmVuY2VzIiwiY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJyZWZlcmVuY2VzIiwibWFwIiwibG9jYXRpb25Ub1JlZmVyZW5jZSIsInR5cGUiLCJiYXNlVXJpIiwicmVmZXJlbmNlZFN5bWJvbE5hbWUiLCJnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZSIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInBvc2l0aW9uIiwicG9pbnRUb1Bvc2l0aW9uIiwiY29udGV4dCIsImluY2x1ZGVEZWNsYXJhdGlvbiIsImxvY2F0aW9uIiwidXJpIiwidXJpVG9QYXRoIiwibmFtZSIsInJhbmdlIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwibGVuZ3RoIiwiY3VycmVudFJlZmVyZW5jZSIsImZpbmQiLCJyIiwiY29udGFpbnNQb2ludCIsImdldEJ1ZmZlciIsImdldFRleHRJblJhbmdlIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBTUE7Ozs7OztBQUVBO0FBQ0E7QUFDZSxNQUFNQSxxQkFBTixDQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLGtCQUFuQixLQUEwQyxJQUFqRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsYUFBTixDQUNFQyxVQURGLEVBRUVDLE1BRkYsRUFHRUMsS0FIRixFQUlFQyxXQUpGLEVBSzBDO0FBQ3hDLFVBQU1DLFlBQVksTUFBTUosV0FBV0ssY0FBWCxDQUN0QlYsc0JBQXNCVyxnQ0FBdEIsQ0FBdURMLE1BQXZELEVBQStEQyxLQUEvRCxDQURzQixDQUF4QjtBQUdBLFFBQUlFLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBTUcsYUFBYUgsVUFBVUksR0FBVixDQUFjYixzQkFBc0JjLG1CQUFwQyxDQUFuQjtBQUNBLFdBQU87QUFDTEMsWUFBTSxNQUREO0FBRUxDLGVBQVNSLGVBQWUsRUFGbkI7QUFHTFMsNEJBQXNCakIsc0JBQXNCa0IsdUJBQXRCLENBQThDWixNQUE5QyxFQUFzREMsS0FBdEQsRUFBNkRLLFVBQTdELENBSGpCO0FBSUxBO0FBSkssS0FBUDtBQU1EOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9ELGdDQUFQLENBQXdDTCxNQUF4QyxFQUFpRUMsS0FBakUsRUFBZ0g7QUFDOUcsV0FBTztBQUNMWSxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNkLE1BQXZDLENBRFQ7QUFFTGUsZ0JBQVUsa0JBQVFDLGVBQVIsQ0FBd0JmLEtBQXhCLENBRkw7QUFHTGdCLGVBQVMsRUFBQ0Msb0JBQW9CLElBQXJCO0FBSEosS0FBUDtBQUtEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPVixtQkFBUCxDQUEyQlcsUUFBM0IsRUFBa0U7QUFDaEUsV0FBTztBQUNMQyxXQUFLLGtCQUFRQyxTQUFSLENBQWtCRixTQUFTQyxHQUEzQixDQURBO0FBRUxFLFlBQU0sSUFGRDtBQUdMQyxhQUFPLGtCQUFRQyxrQkFBUixDQUEyQkwsU0FBU0ksS0FBcEM7QUFIRixLQUFQO0FBS0Q7O0FBRUQ7QUFDQSxTQUFPWCx1QkFBUCxDQUNFWixNQURGLEVBRUVDLEtBRkYsRUFHRUssVUFIRixFQUlVO0FBQ1IsUUFBSUEsV0FBV21CLE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0IsYUFBTyxFQUFQO0FBQ0Q7QUFDRCxVQUFNQyxtQkFBbUJwQixXQUFXcUIsSUFBWCxDQUFnQkMsS0FBS0EsRUFBRUwsS0FBRixDQUFRTSxhQUFSLENBQXNCNUIsS0FBdEIsQ0FBckIsS0FBc0RLLFdBQVcsQ0FBWCxDQUEvRTtBQUNBLFdBQU9OLE9BQU84QixTQUFQLEdBQW1CQyxjQUFuQixDQUFrQ0wsaUJBQWlCSCxLQUFuRCxDQUFQO0FBQ0Q7QUFsRndDO2tCQUF0QjdCLHFCIiwiZmlsZSI6ImZpbmQtcmVmZXJlbmNlcy1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHtcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICB0eXBlIExvY2F0aW9uLFxuICB0eXBlIFNlcnZlckNhcGFiaWxpdGllcyxcbiAgdHlwZSBUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyxcbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XG5cbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgZGVmaW5pdGlvbiBwcm92aWRlciB0byB0aGVcbi8vIEF0b20gSURFIFVJIERlZmluaXRpb25zIHBhY2thZ2UgZm9yICdHbyBUbyBEZWZpbml0aW9uJyBmdW5jdGlvbmFsaXR5LlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmluZFJlZmVyZW5jZXNBZGFwdGVyIHtcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcbiAgLy8gYmFzZWQgb24gdGhlIHNlcnZlckNhcGFiaWxpdGllcyBtYXRyaXggY29udGFpbmluZyBhIHJlZmVyZW5jZXNQcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5yZWZlcmVuY2VzUHJvdmlkZXIgPT09IHRydWU7XG4gIH1cblxuICAvLyBQdWJsaWM6IEdldCB0aGUgcmVmZXJlbmNlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgd2l0aGluIHRoZSBkb2N1bWVudCBhcyByZXByZXNlbnRlZCBieVxuICAvLyB0aGUge1RleHRFZGl0b3J9IGFuZCB7UG9pbnR9IHdpdGhpbiBpdCB2aWEgdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAgLy9cbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgcmVmZXJlbmNlcy5cbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb2ludCB3aXRoaW4gdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIGEge0ZpbmRSZWZlcmVuY2VzUmV0dXJufSB3aXRoIGFsbCB0aGUgcmVmZXJlbmNlcyB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIGNvdWxkIGZpbmQuXG4gIGFzeW5jIGdldFJlZmVyZW5jZXMoXG4gICAgY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxuICAgIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxuICAgIHBvaW50OiBhdG9tJFBvaW50LFxuICAgIHByb2plY3RSb290OiA/c3RyaW5nLFxuICApOiBQcm9taXNlPD9hdG9tSWRlJEZpbmRSZWZlcmVuY2VzUmV0dXJuPiB7XG4gICAgY29uc3QgbG9jYXRpb25zID0gYXdhaXQgY29ubmVjdGlvbi5maW5kUmVmZXJlbmNlcyhcbiAgICAgIEZpbmRSZWZlcmVuY2VzQWRhcHRlci5jcmVhdGVUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvaW50KSxcbiAgICApO1xuICAgIGlmIChsb2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IGxvY2F0aW9ucy5tYXAoRmluZFJlZmVyZW5jZXNBZGFwdGVyLmxvY2F0aW9uVG9SZWZlcmVuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnZGF0YScsXG4gICAgICBiYXNlVXJpOiBwcm9qZWN0Um9vdCB8fCAnJyxcbiAgICAgIHJlZmVyZW5jZWRTeW1ib2xOYW1lOiBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIuZ2V0UmVmZXJlbmNlZFN5bWJvbE5hbWUoZWRpdG9yLCBwb2ludCwgcmVmZXJlbmNlcyksXG4gICAgICByZWZlcmVuY2VzLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIHtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc30gZnJvbSBhIGdpdmVuIHtUZXh0RWRpdG9yfSBmb3IgYSBzcGVjaWZpYyB7UG9pbnR9LlxuICAvL1xuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQuXG4gIC8vICogYHBvaW50YCBBIHtQb2ludH0gd2l0aGluIHRoZSBkb2N1bWVudC5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtEb2N1bWVudFBvc2l0aW9uUGFyYW1zfSBidWlsdCBmcm9tIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICBzdGF0aWMgY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHBvaW50OiBhdG9tJFBvaW50KTogVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocG9pbnQpLFxuICAgICAgY29udGV4dDoge2luY2x1ZGVEZWNsYXJhdGlvbjogdHJ1ZX0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHtMb2NhdGlvbn0gaW50byBhIHtSZWZlcmVuY2V9LlxuICAvL1xuICAvLyAqIGBsb2NhdGlvbmAgQSB7TG9jYXRpb259IHRvIGNvbnZlcnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UmVmZXJlbmNlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7TG9jYXRpb259LlxuICBzdGF0aWMgbG9jYXRpb25Ub1JlZmVyZW5jZShsb2NhdGlvbjogTG9jYXRpb24pOiBhdG9tSWRlJFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVyaTogQ29udmVydC51cmlUb1BhdGgobG9jYXRpb24udXJpKSxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICByYW5nZTogQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UobG9jYXRpb24ucmFuZ2UpLFxuICAgIH07XG4gIH1cblxuICAvLyBQdWJsaWM6IEdldCBhIHN5bWJvbCBuYW1lIGZyb20gYSB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fSBpbiB0aGUgZG9jdW1lbnQuXG4gIHN0YXRpYyBnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZShcbiAgICBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcbiAgICBwb2ludDogYXRvbSRQb2ludCxcbiAgICByZWZlcmVuY2VzOiBBcnJheTxhdG9tSWRlJFJlZmVyZW5jZT4sXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKHJlZmVyZW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRSZWZlcmVuY2UgPSByZWZlcmVuY2VzLmZpbmQociA9PiByLnJhbmdlLmNvbnRhaW5zUG9pbnQocG9pbnQpKSB8fCByZWZlcmVuY2VzWzBdO1xuICAgIHJldHVybiBlZGl0b3IuZ2V0QnVmZmVyKCkuZ2V0VGV4dEluUmFuZ2UoY3VycmVudFJlZmVyZW5jZS5yYW5nZSk7XG4gIH1cbn1cbiJdfQ==