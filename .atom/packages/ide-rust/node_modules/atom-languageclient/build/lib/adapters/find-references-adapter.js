"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class FindReferencesAdapter {
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a referencesProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.referencesProvider === true;
    }
    // Public: Get the references for a specific symbol within the document as represented by
    // the {TextEditor} and {Point} within it via the language server.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the references.
    // * `editor` The Atom {TextEditor} containing the text the references should relate to.
    // * `point` The Atom {Point} containing the point within the text the references should relate to.
    //
    // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
    // could find.
    getReferences(connection, editor, point, projectRoot) {
        return __awaiter(this, void 0, void 0, function* () {
            const locations = yield connection.findReferences(FindReferencesAdapter.createReferenceParams(editor, point));
            if (locations == null) {
                return null;
            }
            const references = locations.map(FindReferencesAdapter.locationToReference);
            return {
                type: 'data',
                baseUri: projectRoot || '',
                referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
                references,
            };
        });
    }
    // Public: Create a {ReferenceParams} from a given {TextEditor} for a specific {Point}.
    //
    // * `editor` A {TextEditor} that represents the document.
    // * `point` A {Point} within the document.
    //
    // Returns a {ReferenceParams} built from the given parameters.
    static createReferenceParams(editor, point) {
        return {
            textDocument: convert_1.default.editorToTextDocumentIdentifier(editor),
            position: convert_1.default.pointToPosition(point),
            context: { includeDeclaration: true },
        };
    }
    // Public: Convert a {Location} into a {Reference}.
    //
    // * `location` A {Location} to convert.
    //
    // Returns a {Reference} equivalent to the given {Location}.
    static locationToReference(location) {
        return {
            uri: convert_1.default.uriToPath(location.uri),
            name: null,
            range: convert_1.default.lsRangeToAtomRange(location.range),
        };
    }
    // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
    static getReferencedSymbolName(editor, point, references) {
        if (references.length === 0) {
            return '';
        }
        const currentReference = references.find((r) => r.range.containsPoint(point)) || references[0];
        return editor.getBuffer().getTextInRange(currentReference.range);
    }
}
exports.default = FindReferencesAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvZmluZC1yZWZlcmVuY2VzLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQVlqQyxnRUFBZ0U7QUFDaEUsd0VBQXdFO0FBQ3hFO0lBQ0UsZ0ZBQWdGO0lBQ2hGLDBFQUEwRTtJQUMxRSxFQUFFO0lBQ0Ysc0ZBQXNGO0lBQ3RGLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsNEJBQTRCO0lBQ3JCLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxrQkFBa0IsS0FBSyxJQUFJLENBQUM7SUFDeEQsQ0FBQztJQUVELHlGQUF5RjtJQUN6RixrRUFBa0U7SUFDbEUsRUFBRTtJQUNGLDBGQUEwRjtJQUMxRixxQ0FBcUM7SUFDckMsd0ZBQXdGO0lBQ3hGLG1HQUFtRztJQUNuRyxFQUFFO0lBQ0Ysc0dBQXNHO0lBQ3RHLGNBQWM7SUFDRCxhQUFhLENBQ3hCLFVBQW9DLEVBQ3BDLE1BQWtCLEVBQ2xCLEtBQVksRUFDWixXQUEwQjs7WUFFMUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxVQUFVLENBQUMsY0FBYyxDQUMvQyxxQkFBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQzNELENBQUM7WUFDRixFQUFFLENBQUMsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDdEIsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNkLENBQUM7WUFFRCxNQUFNLFVBQVUsR0FBd0IsU0FBUyxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2pHLE1BQU0sQ0FBQztnQkFDTCxJQUFJLEVBQUUsTUFBTTtnQkFDWixPQUFPLEVBQUUsV0FBVyxJQUFJLEVBQUU7Z0JBQzFCLG9CQUFvQixFQUFFLHFCQUFxQixDQUFDLHVCQUF1QixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsVUFBVSxDQUFDO2dCQUM5RixVQUFVO2FBQ1gsQ0FBQztRQUNKLENBQUM7S0FBQTtJQUVELHVGQUF1RjtJQUN2RixFQUFFO0lBQ0YsMERBQTBEO0lBQzFELDJDQUEyQztJQUMzQyxFQUFFO0lBQ0YsK0RBQStEO0lBQ3hELE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxNQUFrQixFQUFFLEtBQVk7UUFDbEUsTUFBTSxDQUFDO1lBQ0wsWUFBWSxFQUFFLGlCQUFPLENBQUMsOEJBQThCLENBQUMsTUFBTSxDQUFDO1lBQzVELFFBQVEsRUFBRSxpQkFBTyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUM7WUFDeEMsT0FBTyxFQUFFLEVBQUMsa0JBQWtCLEVBQUUsSUFBSSxFQUFDO1NBQ3BDLENBQUM7SUFDSixDQUFDO0lBRUQsbURBQW1EO0lBQ25ELEVBQUU7SUFDRix3Q0FBd0M7SUFDeEMsRUFBRTtJQUNGLDREQUE0RDtJQUNyRCxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBa0I7UUFDbEQsTUFBTSxDQUFDO1lBQ0wsR0FBRyxFQUFFLGlCQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUM7WUFDcEMsSUFBSSxFQUFFLElBQUk7WUFDVixLQUFLLEVBQUUsaUJBQU8sQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1NBQ2xELENBQUM7SUFDSixDQUFDO0lBRUQsd0ZBQXdGO0lBQ2pGLE1BQU0sQ0FBQyx1QkFBdUIsQ0FDbkMsTUFBa0IsRUFDbEIsS0FBWSxFQUNaLFVBQStCO1FBRS9CLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixNQUFNLENBQUMsRUFBRSxDQUFDO1FBQ1osQ0FBQztRQUNELE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0YsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkUsQ0FBQztDQUNGO0FBbkZELHdDQW1GQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGF0b21JZGUgZnJvbSAnYXRvbS1pZGUnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IHtcclxuICBQb2ludCxcclxuICBUZXh0RWRpdG9yLFxyXG59IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBMb2NhdGlvbixcclxuICBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgUmVmZXJlbmNlUGFyYW1zLFxyXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgZGVmaW5pdGlvbiBwcm92aWRlciB0byB0aGVcclxuLy8gQXRvbSBJREUgVUkgRGVmaW5pdGlvbnMgcGFja2FnZSBmb3IgJ0dvIFRvIERlZmluaXRpb24nIGZ1bmN0aW9uYWxpdHkuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbmRSZWZlcmVuY2VzQWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgcmVmZXJlbmNlc1Byb3ZpZGVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7Qm9vbGVhbn0gaW5kaWNhdGluZyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLnJlZmVyZW5jZXNQcm92aWRlciA9PT0gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogR2V0IHRoZSByZWZlcmVuY2VzIGZvciBhIHNwZWNpZmljIHN5bWJvbCB3aXRoaW4gdGhlIGRvY3VtZW50IGFzIHJlcHJlc2VudGVkIGJ5XHJcbiAgLy8gdGhlIHtUZXh0RWRpdG9yfSBhbmQge1BvaW50fSB3aXRoaW4gaXQgdmlhIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcclxuICAvLyAgICAgICAgICAgICAgICBmb3IgdGhlIHJlZmVyZW5jZXMuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxyXG4gIC8vICogYHBvaW50YCBUaGUgQXRvbSB7UG9pbnR9IGNvbnRhaW5pbmcgdGhlIHBvaW50IHdpdGhpbiB0aGUgdGV4dCB0aGUgcmVmZXJlbmNlcyBzaG91bGQgcmVsYXRlIHRvLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIGEge0ZpbmRSZWZlcmVuY2VzUmV0dXJufSB3aXRoIGFsbCB0aGUgcmVmZXJlbmNlcyB0aGUgbGFuZ3VhZ2Ugc2VydmVyXHJcbiAgLy8gY291bGQgZmluZC5cclxuICBwdWJsaWMgYXN5bmMgZ2V0UmVmZXJlbmNlcyhcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHBvaW50OiBQb2ludCxcclxuICAgIHByb2plY3RSb290OiBzdHJpbmcgfCBudWxsLFxyXG4gICk6IFByb21pc2U8YXRvbUlkZS5GaW5kUmVmZXJlbmNlc1JldHVybiB8IG51bGw+IHtcclxuICAgIGNvbnN0IGxvY2F0aW9ucyA9IGF3YWl0IGNvbm5lY3Rpb24uZmluZFJlZmVyZW5jZXMoXHJcbiAgICAgIEZpbmRSZWZlcmVuY2VzQWRhcHRlci5jcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yLCBwb2ludCksXHJcbiAgICApO1xyXG4gICAgaWYgKGxvY2F0aW9ucyA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZmVyZW5jZXM6IGF0b21JZGUuUmVmZXJlbmNlW10gPSBsb2NhdGlvbnMubWFwKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5sb2NhdGlvblRvUmVmZXJlbmNlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6ICdkYXRhJyxcclxuICAgICAgYmFzZVVyaTogcHJvamVjdFJvb3QgfHwgJycsXHJcbiAgICAgIHJlZmVyZW5jZWRTeW1ib2xOYW1lOiBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIuZ2V0UmVmZXJlbmNlZFN5bWJvbE5hbWUoZWRpdG9yLCBwb2ludCwgcmVmZXJlbmNlcyksXHJcbiAgICAgIHJlZmVyZW5jZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7UmVmZXJlbmNlUGFyYW1zfSBmcm9tIGEgZ2l2ZW4ge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0uXHJcbiAgLy9cclxuICAvLyAqIGBlZGl0b3JgIEEge1RleHRFZGl0b3J9IHRoYXQgcmVwcmVzZW50cyB0aGUgZG9jdW1lbnQuXHJcbiAgLy8gKiBgcG9pbnRgIEEge1BvaW50fSB3aXRoaW4gdGhlIGRvY3VtZW50LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtSZWZlcmVuY2VQYXJhbXN9IGJ1aWx0IGZyb20gdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgcHVibGljIHN0YXRpYyBjcmVhdGVSZWZlcmVuY2VQYXJhbXMoZWRpdG9yOiBUZXh0RWRpdG9yLCBwb2ludDogUG9pbnQpOiBSZWZlcmVuY2VQYXJhbXMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdGV4dERvY3VtZW50OiBDb252ZXJ0LmVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllcihlZGl0b3IpLFxyXG4gICAgICBwb3NpdGlvbjogQ29udmVydC5wb2ludFRvUG9zaXRpb24ocG9pbnQpLFxyXG4gICAgICBjb250ZXh0OiB7aW5jbHVkZURlY2xhcmF0aW9uOiB0cnVlfSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSB7TG9jYXRpb259IGludG8gYSB7UmVmZXJlbmNlfS5cclxuICAvL1xyXG4gIC8vICogYGxvY2F0aW9uYCBBIHtMb2NhdGlvbn0gdG8gY29udmVydC5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UmVmZXJlbmNlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7TG9jYXRpb259LlxyXG4gIHB1YmxpYyBzdGF0aWMgbG9jYXRpb25Ub1JlZmVyZW5jZShsb2NhdGlvbjogTG9jYXRpb24pOiBhdG9tSWRlLlJlZmVyZW5jZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cmk6IENvbnZlcnQudXJpVG9QYXRoKGxvY2F0aW9uLnVyaSksXHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIHJhbmdlOiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShsb2NhdGlvbi5yYW5nZSksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBHZXQgYSBzeW1ib2wgbmFtZSBmcm9tIGEge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0gaW4gdGhlIGRvY3VtZW50LlxyXG4gIHB1YmxpYyBzdGF0aWMgZ2V0UmVmZXJlbmNlZFN5bWJvbE5hbWUoXHJcbiAgICBlZGl0b3I6IFRleHRFZGl0b3IsXHJcbiAgICBwb2ludDogUG9pbnQsXHJcbiAgICByZWZlcmVuY2VzOiBhdG9tSWRlLlJlZmVyZW5jZVtdLFxyXG4gICk6IHN0cmluZyB7XHJcbiAgICBpZiAocmVmZXJlbmNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY3VycmVudFJlZmVyZW5jZSA9IHJlZmVyZW5jZXMuZmluZCgocikgPT4gci5yYW5nZS5jb250YWluc1BvaW50KHBvaW50KSkgfHwgcmVmZXJlbmNlc1swXTtcclxuICAgIHJldHVybiBlZGl0b3IuZ2V0QnVmZmVyKCkuZ2V0VGV4dEluUmFuZ2UoY3VycmVudFJlZmVyZW5jZS5yYW5nZSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==