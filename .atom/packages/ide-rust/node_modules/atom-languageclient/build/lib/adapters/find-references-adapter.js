Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the language server definition provider to the
// Atom IDE UI Definitions package for 'Go To Definition' functionality.
class FindReferencesAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a referencesProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.referencesProvider === true;
  }

  // Public: Get the references for a specific symbol within the document as represented by
  // the {TextEditor} and {Point} within it via the language server.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the references.
  // * `editor` The Atom {TextEditor} containing the text the references should relate to.
  // * `point` The Atom {Point} containing the point within the text the references should relate to.
  //
  // Returns a {Promise} containing a {FindReferencesReturn} with all the references the language server
  // could find.
  async getReferences(connection, editor, point, projectRoot) {
    const locations = await connection.findReferences(FindReferencesAdapter.createTextDocumentPositionParams(editor, point));
    if (locations == null) {
      return null;
    }

    const references = locations.map(FindReferencesAdapter.locationToReference);
    return {
      type: 'data',
      baseUri: projectRoot || '',
      referencedSymbolName: FindReferencesAdapter.getReferencedSymbolName(editor, point, references),
      references
    };
  }

  // Public: Create a {TextDocumentPositionParams} from a given {TextEditor} for a specific {Point}.
  //
  // * `editor` A {TextEditor} that represents the document.
  // * `point` A {Point} within the document.
  //
  // Returns a {DocumentPositionParams} built from the given parameters.
  static createTextDocumentPositionParams(editor, point) {
    return {
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor),
      position: _convert2.default.pointToPosition(point),
      context: { includeDeclaration: true }
    };
  }

  // Public: Convert a {Location} into a {Reference}.
  //
  // * `location` A {Location} to convert.
  //
  // Returns a {Reference} equivalent to the given {Location}.
  static locationToReference(location) {
    return {
      uri: _convert2.default.uriToPath(location.uri),
      name: null,
      range: _convert2.default.lsRangeToAtomRange(location.range)
    };
  }

  // Public: Get a symbol name from a {TextEditor} for a specific {Point} in the document.
  static getReferencedSymbolName(editor, point, references) {
    if (references.length === 0) {
      return '';
    }
    const currentReference = references.find(r => r.range.containsPoint(point)) || references[0];
    return editor.getBuffer().getTextInRange(currentReference.range);
  }
}
exports.default = FindReferencesAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9maW5kLXJlZmVyZW5jZXMtYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJGaW5kUmVmZXJlbmNlc0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsInJlZmVyZW5jZXNQcm92aWRlciIsImdldFJlZmVyZW5jZXMiLCJjb25uZWN0aW9uIiwiZWRpdG9yIiwicG9pbnQiLCJwcm9qZWN0Um9vdCIsImxvY2F0aW9ucyIsImZpbmRSZWZlcmVuY2VzIiwiY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMiLCJyZWZlcmVuY2VzIiwibWFwIiwibG9jYXRpb25Ub1JlZmVyZW5jZSIsInR5cGUiLCJiYXNlVXJpIiwicmVmZXJlbmNlZFN5bWJvbE5hbWUiLCJnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZSIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInBvc2l0aW9uIiwicG9pbnRUb1Bvc2l0aW9uIiwiY29udGV4dCIsImluY2x1ZGVEZWNsYXJhdGlvbiIsImxvY2F0aW9uIiwidXJpIiwidXJpVG9QYXRoIiwibmFtZSIsInJhbmdlIiwibHNSYW5nZVRvQXRvbVJhbmdlIiwibGVuZ3RoIiwiY3VycmVudFJlZmVyZW5jZSIsImZpbmQiLCJyIiwiY29udGFpbnNQb2ludCIsImdldEJ1ZmZlciIsImdldFRleHRJblJhbmdlIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBTUE7Ozs7OztBQUVBO0FBQ0E7QUFDZSxNQUFNQSxxQkFBTixDQUE0QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLGtCQUFuQixLQUEwQyxJQUFqRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTUMsYUFBTixDQUNFQyxVQURGLEVBRUVDLE1BRkYsRUFHRUMsS0FIRixFQUlFQyxXQUpGLEVBSzBDO0FBQ3hDLFVBQU1DLFlBQVksTUFBTUosV0FBV0ssY0FBWCxDQUN0QlYsc0JBQXNCVyxnQ0FBdEIsQ0FBdURMLE1BQXZELEVBQStEQyxLQUEvRCxDQURzQixDQUF4QjtBQUdBLFFBQUlFLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBTUcsYUFBYUgsVUFBVUksR0FBVixDQUFjYixzQkFBc0JjLG1CQUFwQyxDQUFuQjtBQUNBLFdBQU87QUFDTEMsWUFBTSxNQUREO0FBRUxDLGVBQVNSLGVBQWUsRUFGbkI7QUFHTFMsNEJBQXNCakIsc0JBQXNCa0IsdUJBQXRCLENBQThDWixNQUE5QyxFQUFzREMsS0FBdEQsRUFBNkRLLFVBQTdELENBSGpCO0FBSUxBO0FBSkssS0FBUDtBQU1EOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9ELGdDQUFQLENBQXdDTCxNQUF4QyxFQUFpRUMsS0FBakUsRUFBZ0g7QUFDOUcsV0FBTztBQUNMWSxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNkLE1BQXZDLENBRFQ7QUFFTGUsZ0JBQVUsa0JBQVFDLGVBQVIsQ0FBd0JmLEtBQXhCLENBRkw7QUFHTGdCLGVBQVMsRUFBQ0Msb0JBQW9CLElBQXJCO0FBSEosS0FBUDtBQUtEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPVixtQkFBUCxDQUEyQlcsUUFBM0IsRUFBa0U7QUFDaEUsV0FBTztBQUNMQyxXQUFLLGtCQUFRQyxTQUFSLENBQWtCRixTQUFTQyxHQUEzQixDQURBO0FBRUxFLFlBQU0sSUFGRDtBQUdMQyxhQUFPLGtCQUFRQyxrQkFBUixDQUEyQkwsU0FBU0ksS0FBcEM7QUFIRixLQUFQO0FBS0Q7O0FBRUQ7QUFDQSxTQUFPWCx1QkFBUCxDQUNFWixNQURGLEVBRUVDLEtBRkYsRUFHRUssVUFIRixFQUlVO0FBQ1IsUUFBSUEsV0FBV21CLE1BQVgsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0IsYUFBTyxFQUFQO0FBQ0Q7QUFDRCxVQUFNQyxtQkFBbUJwQixXQUFXcUIsSUFBWCxDQUFnQkMsS0FBS0EsRUFBRUwsS0FBRixDQUFRTSxhQUFSLENBQXNCNUIsS0FBdEIsQ0FBckIsS0FBc0RLLFdBQVcsQ0FBWCxDQUEvRTtBQUNBLFdBQU9OLE9BQU84QixTQUFQLEdBQW1CQyxjQUFuQixDQUFrQ0wsaUJBQWlCSCxLQUFuRCxDQUFQO0FBQ0Q7QUFsRndDO2tCQUF0QjdCLHFCIiwiZmlsZSI6ImZpbmQtcmVmZXJlbmNlcy1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7XHJcbiAgTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIHR5cGUgTG9jYXRpb24sXHJcbiAgdHlwZSBTZXJ2ZXJDYXBhYmlsaXRpZXMsXHJcbiAgdHlwZSBUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5cclxuLy8gUHVibGljOiBBZGFwdHMgdGhlIGxhbmd1YWdlIHNlcnZlciBkZWZpbml0aW9uIHByb3ZpZGVyIHRvIHRoZVxyXG4vLyBBdG9tIElERSBVSSBEZWZpbml0aW9ucyBwYWNrYWdlIGZvciAnR28gVG8gRGVmaW5pdGlvbicgZnVuY3Rpb25hbGl0eS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmluZFJlZmVyZW5jZXNBZGFwdGVyIHtcclxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGJhc2VkIG9uIHRoZSBzZXJ2ZXJDYXBhYmlsaXRpZXMgbWF0cml4IGNvbnRhaW5pbmcgYSByZWZlcmVuY2VzUHJvdmlkZXIuXHJcbiAgLy9cclxuICAvLyAqIGBzZXJ2ZXJDYXBhYmlsaXRpZXNgIFRoZSB7U2VydmVyQ2FwYWJpbGl0aWVzfSBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIGNvbnNpZGVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXHJcbiAgLy8gZ2l2ZW4gc2VydmVyQ2FwYWJpbGl0aWVzLlxyXG4gIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5yZWZlcmVuY2VzUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IEdldCB0aGUgcmVmZXJlbmNlcyBmb3IgYSBzcGVjaWZpYyBzeW1ib2wgd2l0aGluIHRoZSBkb2N1bWVudCBhcyByZXByZXNlbnRlZCBieVxyXG4gIC8vIHRoZSB7VGV4dEVkaXRvcn0gYW5kIHtQb2ludH0gd2l0aGluIGl0IHZpYSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBiZSBxdWVyaWVkXHJcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSByZWZlcmVuY2VzLlxyXG4gIC8vICogYGVkaXRvcmAgVGhlIEF0b20ge1RleHRFZGl0b3J9IGNvbnRhaW5pbmcgdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cclxuICAvLyAqIGBwb2ludGAgVGhlIEF0b20ge1BvaW50fSBjb250YWluaW5nIHRoZSBwb2ludCB3aXRoaW4gdGhlIHRleHQgdGhlIHJlZmVyZW5jZXMgc2hvdWxkIHJlbGF0ZSB0by5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyBhIHtGaW5kUmVmZXJlbmNlc1JldHVybn0gd2l0aCBhbGwgdGhlIHJlZmVyZW5jZXMgdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIGNvdWxkIGZpbmQuXHJcbiAgYXN5bmMgZ2V0UmVmZXJlbmNlcyhcclxuICAgIGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICAgIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IGF0b20kUG9pbnQsXHJcbiAgICBwcm9qZWN0Um9vdDogP3N0cmluZyxcclxuICApOiBQcm9taXNlPD9hdG9tSWRlJEZpbmRSZWZlcmVuY2VzUmV0dXJuPiB7XHJcbiAgICBjb25zdCBsb2NhdGlvbnMgPSBhd2FpdCBjb25uZWN0aW9uLmZpbmRSZWZlcmVuY2VzKFxyXG4gICAgICBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIuY3JlYXRlVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMoZWRpdG9yLCBwb2ludCksXHJcbiAgICApO1xyXG4gICAgaWYgKGxvY2F0aW9ucyA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBsb2NhdGlvbnMubWFwKEZpbmRSZWZlcmVuY2VzQWRhcHRlci5sb2NhdGlvblRvUmVmZXJlbmNlKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6ICdkYXRhJyxcclxuICAgICAgYmFzZVVyaTogcHJvamVjdFJvb3QgfHwgJycsXHJcbiAgICAgIHJlZmVyZW5jZWRTeW1ib2xOYW1lOiBGaW5kUmVmZXJlbmNlc0FkYXB0ZXIuZ2V0UmVmZXJlbmNlZFN5bWJvbE5hbWUoZWRpdG9yLCBwb2ludCwgcmVmZXJlbmNlcyksXHJcbiAgICAgIHJlZmVyZW5jZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYSB7VGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXN9IGZyb20gYSBnaXZlbiB7VGV4dEVkaXRvcn0gZm9yIGEgc3BlY2lmaWMge1BvaW50fS5cclxuICAvL1xyXG4gIC8vICogYGVkaXRvcmAgQSB7VGV4dEVkaXRvcn0gdGhhdCByZXByZXNlbnRzIHRoZSBkb2N1bWVudC5cclxuICAvLyAqIGBwb2ludGAgQSB7UG9pbnR9IHdpdGhpbiB0aGUgZG9jdW1lbnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0RvY3VtZW50UG9zaXRpb25QYXJhbXN9IGJ1aWx0IGZyb20gdGhlIGdpdmVuIHBhcmFtZXRlcnMuXHJcbiAgc3RhdGljIGNyZWF0ZVRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBwb2ludDogYXRvbSRQb2ludCk6IFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRleHREb2N1bWVudDogQ29udmVydC5lZGl0b3JUb1RleHREb2N1bWVudElkZW50aWZpZXIoZWRpdG9yKSxcclxuICAgICAgcG9zaXRpb246IENvbnZlcnQucG9pbnRUb1Bvc2l0aW9uKHBvaW50KSxcclxuICAgICAgY29udGV4dDoge2luY2x1ZGVEZWNsYXJhdGlvbjogdHJ1ZX0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEge0xvY2F0aW9ufSBpbnRvIGEge1JlZmVyZW5jZX0uXHJcbiAgLy9cclxuICAvLyAqIGBsb2NhdGlvbmAgQSB7TG9jYXRpb259IHRvIGNvbnZlcnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1JlZmVyZW5jZX0gZXF1aXZhbGVudCB0byB0aGUgZ2l2ZW4ge0xvY2F0aW9ufS5cclxuICBzdGF0aWMgbG9jYXRpb25Ub1JlZmVyZW5jZShsb2NhdGlvbjogTG9jYXRpb24pOiBhdG9tSWRlJFJlZmVyZW5jZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB1cmk6IENvbnZlcnQudXJpVG9QYXRoKGxvY2F0aW9uLnVyaSksXHJcbiAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgIHJhbmdlOiBDb252ZXJ0LmxzUmFuZ2VUb0F0b21SYW5nZShsb2NhdGlvbi5yYW5nZSksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBHZXQgYSBzeW1ib2wgbmFtZSBmcm9tIGEge1RleHRFZGl0b3J9IGZvciBhIHNwZWNpZmljIHtQb2ludH0gaW4gdGhlIGRvY3VtZW50LlxyXG4gIHN0YXRpYyBnZXRSZWZlcmVuY2VkU3ltYm9sTmFtZShcclxuICAgIGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gICAgcG9pbnQ6IGF0b20kUG9pbnQsXHJcbiAgICByZWZlcmVuY2VzOiBBcnJheTxhdG9tSWRlJFJlZmVyZW5jZT4sXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIGlmIChyZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjdXJyZW50UmVmZXJlbmNlID0gcmVmZXJlbmNlcy5maW5kKHIgPT4gci5yYW5nZS5jb250YWluc1BvaW50KHBvaW50KSkgfHwgcmVmZXJlbmNlc1swXTtcclxuICAgIHJldHVybiBlZGl0b3IuZ2V0QnVmZmVyKCkuZ2V0VGV4dEluUmFuZ2UoY3VycmVudFJlZmVyZW5jZS5yYW5nZSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==