Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Listen to diagnostics messages from the language server and publish them
// to the user by way of the Linter Push (Indie) v2 API supported by Atom IDE UI.
class LinterPushV2Adapter {

  // Public: Create a new {LinterPushV2Adapter} that will listen for diagnostics
  // via the supplied {LanguageClientConnection}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will provide diagnostics.
  constructor(connection) {
    this._diagnosticMap = new Map();
    this._diagnosticCodes = new Map();
    this._indies = new Set();

    connection.onPublishDiagnostics(this.captureDiagnostics.bind(this));
  }

  // Public: Attach this {LinterPushV2Adapter} to a given {V2IndieDelegate} registry.
  //
  // * `indie` A {V2IndieDelegate} that wants to receive messages.
  attach(indie) {
    this._indies.add(indie);
    this._diagnosticMap.forEach((value, key) => indie.setMessages(key, value));
    indie.onDidDestroy(() => {
      this._indies.delete(indie);
    });
  }

  // Public: Remove all {V2IndieDelegate} registries attached to this adapter and clear them.
  //
  // * `indie` A {V2IndieDelegate} that wants to receive messages.
  detachAll() {
    this._indies.forEach(i => i.clearMessages());
    this._indies.clear();
  }

  // Public: Capture the diagnostics sent from a langguage server, convert them to the
  // Linter V2 format and forward them on to any attached {V2IndieDelegate}s.
  //
  // * `params` The {PublishDiagnosticsParams} received from the language server that should
  //            be captured and forwarded on to any attached {V2IndieDelegate}s.
  captureDiagnostics(params) {
    const path = _convert2.default.uriToPath(params.uri);
    const codeMap = new Map();
    const messages = params.diagnostics.map(d => {
      const linterMessage = this.diagnosticToV2Message(path, d);
      codeMap.set(getCodeKey(linterMessage.location.position, d.message), d.code);
      return linterMessage;
    });
    this._diagnosticMap.set(path, messages);
    this._diagnosticCodes.set(path, codeMap);
    this._indies.forEach(i => i.setMessages(path, messages));
  }

  // Public: Convert a single {Diagnostic} received from a language server into a single
  // {V2Message} expected by the Linter V2 API.
  //
  // * `path` A string representing the path of the file the diagnostic belongs to.
  // * `diagnostics` A {Diagnostic} object received from the language server.
  //
  // Returns a {V2Message} equivalent to the {Diagnostic} object supplied by the language server.
  diagnosticToV2Message(path, diagnostic) {
    return {
      location: {
        file: path,
        position: _convert2.default.lsRangeToAtomRange(diagnostic.range)
      },
      excerpt: diagnostic.message,
      linterName: diagnostic.source,
      severity: LinterPushV2Adapter.diagnosticSeverityToSeverity(diagnostic.severity || -1)
    };
  }

  // Public: Convert a diagnostic severity number obtained from the language server into
  // the textual equivalent for a Linter {V2Message}.
  //
  // * `severity` A number representing the severity of the diagnostic.
  //
  // Returns a string of 'error', 'warning' or 'info' depending on the severity.
  static diagnosticSeverityToSeverity(severity) {
    switch (severity) {
      case _languageclient.DiagnosticSeverity.Error:
        return 'error';
      case _languageclient.DiagnosticSeverity.Warning:
        return 'warning';
      case _languageclient.DiagnosticSeverity.Information:
      case _languageclient.DiagnosticSeverity.Hint:
      default:
        return 'info';
    }
  }

  // Private: Get the recorded diagnostic code for a range/message.
  // Diagnostic codes are tricky because there's no suitable place in the Linter API for them.
  // For now, we'll record the original code for each range/message combination and retrieve it
  // when needed (e.g. for passing back into code actions)
  getDiagnosticCode(editor, range, text) {
    const path = editor.getPath();
    if (path != null) {
      const diagnosticCodes = this._diagnosticCodes.get(path);
      if (diagnosticCodes != null) {
        return diagnosticCodes.get(getCodeKey(range, text));
      }
    }
    return null;
  }
}

exports.default = LinterPushV2Adapter;
function getCodeKey(range, text) {
  return [].concat(...range.serialize(), text).join(',');
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9saW50ZXItcHVzaC12Mi1hZGFwdGVyLmpzIl0sIm5hbWVzIjpbIkxpbnRlclB1c2hWMkFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb24iLCJfZGlhZ25vc3RpY01hcCIsIk1hcCIsIl9kaWFnbm9zdGljQ29kZXMiLCJfaW5kaWVzIiwiU2V0Iiwib25QdWJsaXNoRGlhZ25vc3RpY3MiLCJjYXB0dXJlRGlhZ25vc3RpY3MiLCJiaW5kIiwiYXR0YWNoIiwiaW5kaWUiLCJhZGQiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJzZXRNZXNzYWdlcyIsIm9uRGlkRGVzdHJveSIsImRlbGV0ZSIsImRldGFjaEFsbCIsImkiLCJjbGVhck1lc3NhZ2VzIiwiY2xlYXIiLCJwYXJhbXMiLCJwYXRoIiwidXJpVG9QYXRoIiwidXJpIiwiY29kZU1hcCIsIm1lc3NhZ2VzIiwiZGlhZ25vc3RpY3MiLCJtYXAiLCJkIiwibGludGVyTWVzc2FnZSIsImRpYWdub3N0aWNUb1YyTWVzc2FnZSIsInNldCIsImdldENvZGVLZXkiLCJsb2NhdGlvbiIsInBvc2l0aW9uIiwibWVzc2FnZSIsImNvZGUiLCJkaWFnbm9zdGljIiwiZmlsZSIsImxzUmFuZ2VUb0F0b21SYW5nZSIsInJhbmdlIiwiZXhjZXJwdCIsImxpbnRlck5hbWUiLCJzb3VyY2UiLCJzZXZlcml0eSIsImRpYWdub3N0aWNTZXZlcml0eVRvU2V2ZXJpdHkiLCJFcnJvciIsIldhcm5pbmciLCJJbmZvcm1hdGlvbiIsIkhpbnQiLCJnZXREaWFnbm9zdGljQ29kZSIsImVkaXRvciIsInRleHQiLCJnZXRQYXRoIiwiZGlhZ25vc3RpY0NvZGVzIiwiZ2V0IiwiY29uY2F0Iiwic2VyaWFsaXplIiwiam9pbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOztBQU9BOzs7Ozs7QUFFQTtBQUNBO0FBQ2UsTUFBTUEsbUJBQU4sQ0FBMEI7O0FBS3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0FDLGNB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OUYsVUFBTS9CLE9BQU84QixPQUFPRSxPQUFQLEVBQWI7QUFDQSxRQUFJaEMsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFlBQU1pQyxrQkFBa0IsS0FBS3JELGdCQUFMLENBQXNCc0QsR0FBdEIsQ0FBMEJsQyxJQUExQixDQUF4QjtBQUNBLFVBQUlpQyxtQkFBbUIsSUFBdkIsRUFBNkI7QUFDM0IsZUFBT0EsZ0JBQWdCQyxHQUFoQixDQUFvQnZCLFdBQVdRLEtBQVgsRUFBa0JZLElBQWxCLENBQXBCLENBQVA7QUFDRDtBQUNGO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7QUFyR3NDOztrQkFBcEJ4RCxtQjtBQXdHckIsU0FBU29DLFVBQVQsQ0FBb0JRLEtBQXBCLEVBQXVDWSxJQUF2QyxFQUE2RDtBQUMzRCxTQUFPLEdBQUdJLE1BQUgsQ0FBVSxHQUFHaEIsTUFBTWlCLFNBQU4sRUFBYixFQUFnQ0wsSUFBaEMsRUFBc0NNLElBQXRDLENBQTJDLEdBQTNDLENBQVA7QUFDRCIsImZpbGUiOiJsaW50ZXItcHVzaC12Mi1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7XHJcbiAgRGlhZ25vc3RpY1NldmVyaXR5LFxyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICB0eXBlIERpYWdub3N0aWMsXHJcbiAgdHlwZSBEaWFnbm9zdGljQ29kZSxcclxuICB0eXBlIFB1Ymxpc2hEaWFnbm9zdGljc1BhcmFtcyxcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xyXG5cclxuLy8gUHVibGljOiBMaXN0ZW4gdG8gZGlhZ25vc3RpY3MgbWVzc2FnZXMgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyIGFuZCBwdWJsaXNoIHRoZW1cclxuLy8gdG8gdGhlIHVzZXIgYnkgd2F5IG9mIHRoZSBMaW50ZXIgUHVzaCAoSW5kaWUpIHYyIEFQSSBzdXBwb3J0ZWQgYnkgQXRvbSBJREUgVUkuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbnRlclB1c2hWMkFkYXB0ZXIge1xyXG4gIF9kaWFnbm9zdGljTWFwOiBNYXA8c3RyaW5nLCBBcnJheTxsaW50ZXIkVjJNZXNzYWdlPj4gPSBuZXcgTWFwKCk7XHJcbiAgX2RpYWdub3N0aWNDb2RlczogTWFwPHN0cmluZywgTWFwPHN0cmluZywgP0RpYWdub3N0aWNDb2RlPj4gPSBuZXcgTWFwKCk7XHJcbiAgX2luZGllczogU2V0PGxpbnRlciRWMkluZGllRGVsZWdhdGU+ID0gbmV3IFNldCgpO1xyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhIG5ldyB7TGludGVyUHVzaFYyQWRhcHRlcn0gdGhhdCB3aWxsIGxpc3RlbiBmb3IgZGlhZ25vc3RpY3NcclxuICAvLyB2aWEgdGhlIHN1cHBsaWVkIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259LlxyXG4gIC8vXHJcbiAgLy8gKiBgY29ubmVjdGlvbmAgQSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSB0byB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXQgd2lsbCBwcm92aWRlIGRpYWdub3N0aWNzLlxyXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb246IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbikge1xyXG4gICAgY29ubmVjdGlvbi5vblB1Ymxpc2hEaWFnbm9zdGljcyh0aGlzLmNhcHR1cmVEaWFnbm9zdGljcy5iaW5kKHRoaXMpKTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQXR0YWNoIHRoaXMge0xpbnRlclB1c2hWMkFkYXB0ZXJ9IHRvIGEgZ2l2ZW4ge1YySW5kaWVEZWxlZ2F0ZX0gcmVnaXN0cnkuXHJcbiAgLy9cclxuICAvLyAqIGBpbmRpZWAgQSB7VjJJbmRpZURlbGVnYXRlfSB0aGF0IHdhbnRzIHRvIHJlY2VpdmUgbWVzc2FnZXMuXHJcbiAgYXR0YWNoKGluZGllOiBsaW50ZXIkVjJJbmRpZURlbGVnYXRlKTogdm9pZCB7XHJcbiAgICB0aGlzLl9pbmRpZXMuYWRkKGluZGllKTtcclxuICAgIHRoaXMuX2RpYWdub3N0aWNNYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gaW5kaWUuc2V0TWVzc2FnZXMoa2V5LCB2YWx1ZSkpO1xyXG4gICAgaW5kaWUub25EaWREZXN0cm95KCgpID0+IHtcclxuICAgICAgdGhpcy5faW5kaWVzLmRlbGV0ZShpbmRpZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogUmVtb3ZlIGFsbCB7VjJJbmRpZURlbGVnYXRlfSByZWdpc3RyaWVzIGF0dGFjaGVkIHRvIHRoaXMgYWRhcHRlciBhbmQgY2xlYXIgdGhlbS5cclxuICAvL1xyXG4gIC8vICogYGluZGllYCBBIHtWMkluZGllRGVsZWdhdGV9IHRoYXQgd2FudHMgdG8gcmVjZWl2ZSBtZXNzYWdlcy5cclxuICBkZXRhY2hBbGwoKTogdm9pZCB7XHJcbiAgICB0aGlzLl9pbmRpZXMuZm9yRWFjaChpID0+IGkuY2xlYXJNZXNzYWdlcygpKTtcclxuICAgIHRoaXMuX2luZGllcy5jbGVhcigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDYXB0dXJlIHRoZSBkaWFnbm9zdGljcyBzZW50IGZyb20gYSBsYW5nZ3VhZ2Ugc2VydmVyLCBjb252ZXJ0IHRoZW0gdG8gdGhlXHJcbiAgLy8gTGludGVyIFYyIGZvcm1hdCBhbmQgZm9yd2FyZCB0aGVtIG9uIHRvIGFueSBhdHRhY2hlZCB7VjJJbmRpZURlbGVnYXRlfXMuXHJcbiAgLy9cclxuICAvLyAqIGBwYXJhbXNgIFRoZSB7UHVibGlzaERpYWdub3N0aWNzUGFyYW1zfSByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCBzaG91bGRcclxuICAvLyAgICAgICAgICAgIGJlIGNhcHR1cmVkIGFuZCBmb3J3YXJkZWQgb24gdG8gYW55IGF0dGFjaGVkIHtWMkluZGllRGVsZWdhdGV9cy5cclxuICBjYXB0dXJlRGlhZ25vc3RpY3MocGFyYW1zOiBQdWJsaXNoRGlhZ25vc3RpY3NQYXJhbXMpOiB2b2lkIHtcclxuICAgIGNvbnN0IHBhdGggPSBDb252ZXJ0LnVyaVRvUGF0aChwYXJhbXMudXJpKTtcclxuICAgIGNvbnN0IGNvZGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBtZXNzYWdlcyA9IHBhcmFtcy5kaWFnbm9zdGljcy5tYXAoZCA9PiB7XHJcbiAgICAgIGNvbnN0IGxpbnRlck1lc3NhZ2UgPSB0aGlzLmRpYWdub3N0aWNUb1YyTWVzc2FnZShwYXRoLCBkKTtcclxuICAgICAgY29kZU1hcC5zZXQoZ2V0Q29kZUtleShsaW50ZXJNZXNzYWdlLmxvY2F0aW9uLnBvc2l0aW9uLCBkLm1lc3NhZ2UpLCBkLmNvZGUpO1xyXG4gICAgICByZXR1cm4gbGludGVyTWVzc2FnZTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fZGlhZ25vc3RpY01hcC5zZXQocGF0aCwgbWVzc2FnZXMpO1xyXG4gICAgdGhpcy5fZGlhZ25vc3RpY0NvZGVzLnNldChwYXRoLCBjb2RlTWFwKTtcclxuICAgIHRoaXMuX2luZGllcy5mb3JFYWNoKGkgPT4gaS5zZXRNZXNzYWdlcyhwYXRoLCBtZXNzYWdlcykpO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGEgc2luZ2xlIHtEaWFnbm9zdGljfSByZWNlaXZlZCBmcm9tIGEgbGFuZ3VhZ2Ugc2VydmVyIGludG8gYSBzaW5nbGVcclxuICAvLyB7VjJNZXNzYWdlfSBleHBlY3RlZCBieSB0aGUgTGludGVyIFYyIEFQSS5cclxuICAvL1xyXG4gIC8vICogYHBhdGhgIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgcGF0aCBvZiB0aGUgZmlsZSB0aGUgZGlhZ25vc3RpYyBiZWxvbmdzIHRvLlxyXG4gIC8vICogYGRpYWdub3N0aWNzYCBBIHtEaWFnbm9zdGljfSBvYmplY3QgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtWMk1lc3NhZ2V9IGVxdWl2YWxlbnQgdG8gdGhlIHtEaWFnbm9zdGljfSBvYmplY3Qgc3VwcGxpZWQgYnkgdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICBkaWFnbm9zdGljVG9WMk1lc3NhZ2UocGF0aDogc3RyaW5nLCBkaWFnbm9zdGljOiBEaWFnbm9zdGljKTogbGludGVyJFYyTWVzc2FnZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsb2NhdGlvbjoge1xyXG4gICAgICAgIGZpbGU6IHBhdGgsXHJcbiAgICAgICAgcG9zaXRpb246IENvbnZlcnQubHNSYW5nZVRvQXRvbVJhbmdlKGRpYWdub3N0aWMucmFuZ2UpLFxyXG4gICAgICB9LFxyXG4gICAgICBleGNlcnB0OiBkaWFnbm9zdGljLm1lc3NhZ2UsXHJcbiAgICAgIGxpbnRlck5hbWU6IGRpYWdub3N0aWMuc291cmNlLFxyXG4gICAgICBzZXZlcml0eTogTGludGVyUHVzaFYyQWRhcHRlci5kaWFnbm9zdGljU2V2ZXJpdHlUb1NldmVyaXR5KGRpYWdub3N0aWMuc2V2ZXJpdHkgfHwgLTEpLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIGRpYWdub3N0aWMgc2V2ZXJpdHkgbnVtYmVyIG9idGFpbmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlciBpbnRvXHJcbiAgLy8gdGhlIHRleHR1YWwgZXF1aXZhbGVudCBmb3IgYSBMaW50ZXIge1YyTWVzc2FnZX0uXHJcbiAgLy9cclxuICAvLyAqIGBzZXZlcml0eWAgQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzZXZlcml0eSBvZiB0aGUgZGlhZ25vc3RpYy5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgb2YgJ2Vycm9yJywgJ3dhcm5pbmcnIG9yICdpbmZvJyBkZXBlbmRpbmcgb24gdGhlIHNldmVyaXR5LlxyXG4gIHN0YXRpYyBkaWFnbm9zdGljU2V2ZXJpdHlUb1NldmVyaXR5KHNldmVyaXR5OiBudW1iZXIpOiAnZXJyb3InIHwgJ3dhcm5pbmcnIHwgJ2luZm8nIHtcclxuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcclxuICAgICAgY2FzZSBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3I6XHJcbiAgICAgICAgcmV0dXJuICdlcnJvcic7XHJcbiAgICAgIGNhc2UgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmc6XHJcbiAgICAgICAgcmV0dXJuICd3YXJuaW5nJztcclxuICAgICAgY2FzZSBEaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb246XHJcbiAgICAgIGNhc2UgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQ6XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdpbmZvJztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFByaXZhdGU6IEdldCB0aGUgcmVjb3JkZWQgZGlhZ25vc3RpYyBjb2RlIGZvciBhIHJhbmdlL21lc3NhZ2UuXHJcbiAgLy8gRGlhZ25vc3RpYyBjb2RlcyBhcmUgdHJpY2t5IGJlY2F1c2UgdGhlcmUncyBubyBzdWl0YWJsZSBwbGFjZSBpbiB0aGUgTGludGVyIEFQSSBmb3IgdGhlbS5cclxuICAvLyBGb3Igbm93LCB3ZSdsbCByZWNvcmQgdGhlIG9yaWdpbmFsIGNvZGUgZm9yIGVhY2ggcmFuZ2UvbWVzc2FnZSBjb21iaW5hdGlvbiBhbmQgcmV0cmlldmUgaXRcclxuICAvLyB3aGVuIG5lZWRlZCAoZS5nLiBmb3IgcGFzc2luZyBiYWNrIGludG8gY29kZSBhY3Rpb25zKVxyXG4gIGdldERpYWdub3N0aWNDb2RlKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCByYW5nZTogYXRvbSRSYW5nZSwgdGV4dDogc3RyaW5nKTogPyhudW1iZXIgfCBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHBhdGggPSBlZGl0b3IuZ2V0UGF0aCgpO1xyXG4gICAgaWYgKHBhdGggIT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBkaWFnbm9zdGljQ29kZXMgPSB0aGlzLl9kaWFnbm9zdGljQ29kZXMuZ2V0KHBhdGgpO1xyXG4gICAgICBpZiAoZGlhZ25vc3RpY0NvZGVzICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZGlhZ25vc3RpY0NvZGVzLmdldChnZXRDb2RlS2V5KHJhbmdlLCB0ZXh0KSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q29kZUtleShyYW5nZTogYXRvbSRSYW5nZSwgdGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gW10uY29uY2F0KC4uLnJhbmdlLnNlcmlhbGl6ZSgpLCB0ZXh0KS5qb2luKCcsJyk7XHJcbn1cclxuIl19