Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
let OutlineViewAdapter = class OutlineViewAdapter {

  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  getOutline(connection, editor) {
    return _asyncToGenerator(function* () {
      const results = yield connection.documentSymbol({ textDocument: _convert2.default.editorToTextDocumentIdentifier(editor) });
      return {
        outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
      };
    })();
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    const byContainerName = OutlineViewAdapter.createContainerNamedOutline(symbols);
    const roots = new Map();
    byContainerName.forEach((v, k) => {
      const containerName = v.containerName;
      if (containerName == '' || containerName == null || k == containerName) {
        // No container name or contained within itself belong as top-level items
        roots.set(k, v.outline);
      } else {
        const container = byContainerName.get(containerName);
        if (container) {
          // Items with a container we know about get put in that container
          container.outline.children.push(v.outline);
        } else {
          // Items with a container we don't know about we dynamically create one for
          let rootContainer = roots.get(containerName);
          if (rootContainer == null) {
            rootContainer = {
              plainText: containerName,
              children: [],
              startPosition: new _atom.Point(0, 0)
            };
            roots.set(containerName, rootContainer);
          }
          rootContainer.children.push(v.outline);
        }
      }
    });
    return Array.from(roots.values());
  }

  // Public: Converts an {Array} of {SymbolInformation} received from a language server into a
  // {Map} of {ContainerNamedOutline} keyed by their symbol names. This allows us to find parents
  // quickly when assembling the tree through containerNames.
  //
  // * `symbols` An {Array} of {SymbolInformation}s to convert into the map.
  //
  // Returns a {Map} of {ContainerNamedOutline}s each converted from a {SymbolInformation}
  // and keyed by its containerName.
  static createContainerNamedOutline(symbols) {
    return symbols.reduce((map, symbol) => {
      map.set(symbol.name, {
        containerName: symbol.containerName,
        outline: OutlineViewAdapter.symbolToOutline(symbol)
      });
      return map;
    }, new Map());
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
};
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRvY3VtZW50U3ltYm9sUHJvdmlkZXIiLCJnZXRPdXRsaW5lIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInJlc3VsdHMiLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsIm91dGxpbmVUcmVlcyIsImNyZWF0ZU91dGxpbmVUcmVlcyIsInN5bWJvbHMiLCJieUNvbnRhaW5lck5hbWUiLCJjcmVhdGVDb250YWluZXJOYW1lZE91dGxpbmUiLCJyb290cyIsIk1hcCIsImZvckVhY2giLCJ2IiwiayIsImNvbnRhaW5lck5hbWUiLCJzZXQiLCJvdXRsaW5lIiwiY29udGFpbmVyIiwiZ2V0IiwiY2hpbGRyZW4iLCJwdXNoIiwicm9vdENvbnRhaW5lciIsInBsYWluVGV4dCIsInN0YXJ0UG9zaXRpb24iLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJtYXAiLCJzeW1ib2wiLCJuYW1lIiwic3ltYm9sVG9PdXRsaW5lIiwiaWNvbiIsInN5bWJvbEtpbmRUb0VudGl0eUtpbmQiLCJraW5kIiwidG9rZW5pemVkVGV4dCIsInN5bWJvbEtpbmRUb1Rva2VuS2luZCIsInZhbHVlIiwidW5kZWZpbmVkIiwicmVwcmVzZW50YXRpdmVOYW1lIiwicG9zaXRpb25Ub1BvaW50IiwibG9jYXRpb24iLCJyYW5nZSIsInN0YXJ0IiwiZW5kUG9zaXRpb24iLCJlbmQiLCJCb29sZWFuIiwiQ2xhc3MiLCJDb25zdGFudCIsIkNvbnN0cnVjdG9yIiwiRW51bSIsIkZpZWxkIiwiRmlsZSIsIkZ1bmN0aW9uIiwiSW50ZXJmYWNlIiwiTWV0aG9kIiwiTW9kdWxlIiwiTmFtZXNwYWNlIiwiTnVtYmVyIiwiUGFja2Fn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TyxhQUFQO0FBQ3hCLFdBQUssMkJBQVdDLE1BQWhCO0FBQXdCLGVBQU8sYUFBUDtBQUN4QixXQUFLLDJCQUFXQyxTQUFoQjtBQUEyQixlQUFPLGdCQUFQO0FBQzNCLFdBQUssMkJBQVdDLE1BQWhCO0FBQXdCLGVBQU8sYUFBUDtBQUN4QixXQUFLLDJCQUFXQyxPQUFoQjtBQUF5QixlQUFPLGNBQVA7QUFDekIsV0FBSywyQkFBV0MsUUFBaEI7QUFBMEIsZUFBTyxlQUFQO0FBQzFCLFdBQUssMkJBQVdDLE1BQWhCO0FBQXdCLGVBQU8sYUFBUDtBQUN4QixXQUFLLDJCQUFXQyxRQUFoQjtBQUEwQixlQUFPLGVBQVA7QUFDMUI7QUFBUyxlQUFPLElBQVA7QUFuQlg7QUFxQkQ7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBTzFCLHFCQUFQLENBQTZCUCxNQUE3QixFQUFnRTtBQUM5RCxZQUFRQSxNQUFSO0FBQ0UsV0FBSywyQkFBV2tCLEtBQWhCO0FBQ0UsZUFBTyxNQUFQO0FBQ0YsV0FBSywyQkFBV0UsV0FBaEI7QUFDRSxlQUFPLGFBQVA7QUFDRixXQUFLLDJCQUFXTSxNQUFoQjtBQUNBLFdBQUssMkJBQVdGLFFBQWhCO0FBQ0UsZUFBTyxRQUFQO0FBQ0YsV0FBSywyQkFBV1EsTUFBaEI7QUFDRSxlQUFPLFFBQVA7QUFDRjtBQUNFLGVBQU8sT0FBUDtBQVhKO0FBYUQ7QUE1SnFDLEM7a0JBQW5CcEUsa0IiLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQge1xuICBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXG4gIFN5bWJvbEtpbmQsXG4gIHR5cGUgU2VydmVyQ2FwYWJpbGl0aWVzLFxuICB0eXBlIFN5bWJvbEluZm9ybWF0aW9uXG59IGZyb20gJy4uL2xhbmd1YWdlY2xpZW50JztcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uL2NvbnZlcnQnO1xuaW1wb3J0IHtQb2ludH0gZnJvbSAnYXRvbSc7XG5cbnR5cGUgQ29udGFpbmVyTmFtZWRPdXRsaW5lID0ge1xuICBjb250YWluZXJOYW1lOiA/c3RyaW5nLFxuICBvdXRsaW5lOiBudWNsaWRlJE91dGxpbmVUcmVlXG59O1xuXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgZG9jdW1lbnRTeW1ib2xQcm92aWRlciBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHRoZSBPdXRsaW5lIFZpZXdcbi8vIHN1cHBsaWVkIGJ5IEF0b20gSURFIFVJLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0bGluZVZpZXdBZGFwdGVyIHtcblxuICAvLyBQdWJsaWM6IERldGVybWluZSB3aGV0aGVyIHRoaXMgYWRhcHRlciBjYW4gYmUgdXNlZCB0byBhZGFwdCBhIGxhbmd1YWdlIHNlcnZlclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZG9jdW1lbnRTeW1ib2xQcm92aWRlci5cbiAgLy9cbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0byBjb25zaWRlci5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtCb29sZWFufSBpbmRpY2F0aW5nIGFkYXB0ZXIgY2FuIGFkYXB0IHRoZSBzZXJ2ZXIgYmFzZWQgb24gdGhlXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIE91dGxpbmUgZm9yIGRvY3VtZW50IHZpYSB0aGUge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gYXMgaWRlbnRpZmllZFxuICAvLyBieSB0aGUge1RleHRFZGl0b3J9LlxuICAvL1xuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcbiAgLy8gICAgICAgICAgICAgICAgZm9yIHRoZSBvdXRsaW5lLlxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXG4gIC8vXG4gIC8vIFJldHVybnMgYSB7UHJvbWlzZX0gY29udGFpbmluZyB0aGUge091dGxpbmV9IG9mIHRoaXMgZG9jdW1lbnQuXG4gIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P251Y2xpZGUkT3V0bGluZT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50U3ltYm9sKHt0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvcil9KTtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0bGluZVRyZWVzOiBPdXRsaW5lVmlld0FkYXB0ZXIuY3JlYXRlT3V0bGluZVRyZWVzKHJlc3VsdHMpLFxuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYzogQ3JlYXRlIGFuIHtBcnJheX0gb2Yge091dGxpbmVUcmVlfXMgZnJvbSB0aGUgQXJyYXkgb2Yge1N5bWJvbEluZm9ybWF0aW9ufSByZWNpZXZlZFxuICAvLyBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaW5jbHVkZXMgZGV0ZXJtaW5pbmcgdGhlIGFwcHJvcHJpYXRlIGNoaWxkIGFuZCBwYXJlbnRcbiAgLy8gcmVsYXRpb25zaGlwcyBmb3IgdGhlIGhpZXJhcmNoeS5cbiAgLy9cbiAgLy8gKiBgc3ltYm9sc2AgQW4ge0FycmF5fSBvZiB7U3ltYm9sSW5mb3JtYXRpb259cyByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdFxuICAvLyAgICAgICAgICAgICBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIHtPdXRsaW5lVHJlZX0uXG4gIC8vXG4gIC8vIFJldHVybnMgYW4ge091dGxpbmVUcmVlfSBjb250YWluaW5nIHRoZSBnaXZlbiBzeW1ib2xzIHRoYXQgdGhlIE91dGxpbmUgVmlldyBjYW4gZGlzcGxheS5cbiAgc3RhdGljIGNyZWF0ZU91dGxpbmVUcmVlcyhzeW1ib2xzOiBBcnJheTxTeW1ib2xJbmZvcm1hdGlvbj4pOiBBcnJheTxudWNsaWRlJE91dGxpbmVUcmVlPiB7XG4gICAgY29uc3QgYnlDb250YWluZXJOYW1lID0gT3V0bGluZVZpZXdBZGFwdGVyLmNyZWF0ZUNvbnRhaW5lck5hbWVkT3V0bGluZShzeW1ib2xzKTtcbiAgICBjb25zdCByb290czogTWFwPHN0cmluZywgbnVjbGlkZSRPdXRsaW5lVHJlZT4gPSBuZXcgTWFwKCk7XG4gICAgYnlDb250YWluZXJOYW1lLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lck5hbWUgPSB2LmNvbnRhaW5lck5hbWU7XG4gICAgICBpZiAoY29udGFpbmVyTmFtZSA9PSAnJyB8fCBjb250YWluZXJOYW1lID09IG51bGwgfHwgayA9PSBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIC8vIE5vIGNvbnRhaW5lciBuYW1lIG9yIGNvbnRhaW5lZCB3aXRoaW4gaXRzZWxmIGJlbG9uZyBhcyB0b3AtbGV2ZWwgaXRlbXNcbiAgICAgICAgcm9vdHMuc2V0KGssIHYub3V0bGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBieUNvbnRhaW5lck5hbWUuZ2V0KGNvbnRhaW5lck5hbWUpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgLy8gSXRlbXMgd2l0aCBhIGNvbnRhaW5lciB3ZSBrbm93IGFib3V0IGdldCBwdXQgaW4gdGhhdCBjb250YWluZXJcbiAgICAgICAgICBjb250YWluZXIub3V0bGluZS5jaGlsZHJlbi5wdXNoKHYub3V0bGluZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlbXMgd2l0aCBhIGNvbnRhaW5lciB3ZSBkb24ndCBrbm93IGFib3V0IHdlIGR5bmFtaWNhbGx5IGNyZWF0ZSBvbmUgZm9yXG4gICAgICAgICAgbGV0IHJvb3RDb250YWluZXIgPSByb290cy5nZXQoY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgaWYgKHJvb3RDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdENvbnRhaW5lciA9IHtcbiAgICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogWyBdLFxuICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uOiBuZXcgUG9pbnQoMCwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByb290cy5zZXQoY29udGFpbmVyTmFtZSwgcm9vdENvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RDb250YWluZXIuY2hpbGRyZW4ucHVzaCh2Lm91dGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdHMudmFsdWVzKCkpO1xuICB9XG5cbiAgLy8gUHVibGljOiBDb252ZXJ0cyBhbiB7QXJyYXl9IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn0gcmVjZWl2ZWQgZnJvbSBhIGxhbmd1YWdlIHNlcnZlciBpbnRvIGFcbiAgLy8ge01hcH0gb2Yge0NvbnRhaW5lck5hbWVkT3V0bGluZX0ga2V5ZWQgYnkgdGhlaXIgc3ltYm9sIG5hbWVzLiBUaGlzIGFsbG93cyB1cyB0byBmaW5kIHBhcmVudHNcbiAgLy8gcXVpY2tseSB3aGVuIGFzc2VtYmxpbmcgdGhlIHRyZWUgdGhyb3VnaCBjb250YWluZXJOYW1lcy5cbiAgLy9cbiAgLy8gKiBgc3ltYm9sc2AgQW4ge0FycmF5fSBvZiB7U3ltYm9sSW5mb3JtYXRpb259cyB0byBjb252ZXJ0IGludG8gdGhlIG1hcC5cbiAgLy9cbiAgLy8gUmV0dXJucyBhIHtNYXB9IG9mIHtDb250YWluZXJOYW1lZE91dGxpbmV9cyBlYWNoIGNvbnZlcnRlZCBmcm9tIGEge1N5bWJvbEluZm9ybWF0aW9ufVxuICAvLyBhbmQga2V5ZWQgYnkgaXRzIGNvbnRhaW5lck5hbWUuXG4gIHN0YXRpYyBjcmVhdGVDb250YWluZXJOYW1lZE91dGxpbmUoc3ltYm9sczogQXJyYXk8U3ltYm9sSW5mb3JtYXRpb24+KTogTWFwPHN0cmluZywgQ29udGFpbmVyTmFtZWRPdXRsaW5lPiB7XG4gICAgcmV0dXJuIHN5bWJvbHMucmVkdWNlKChtYXAsIHN5bWJvbCkgPT4ge1xuICAgICAgbWFwLnNldChzeW1ib2wubmFtZSwge1xuICAgICAgICBjb250YWluZXJOYW1lOiBzeW1ib2wuY29udGFpbmVyTmFtZSxcbiAgICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgbmV3IE1hcCgpKTtcbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhbiBpbmRpdmlkdWFsIHtTeW1ib2xJbmZvcm1hdGlvbn0gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyXG4gIC8vIHRvIGFuIHtPdXRsaW5lVHJlZX0gZm9yIHVzZSBieSB0aGUgT3V0bGluZSBWaWV3LlxuICAvL1xuICAvLyAqIGBzeW1ib2xgIFRoZSB7U3ltYm9sSW5mb3JtYXRpb259IHRvIGNvbnZlcnQgdG8gYW4ge091dGxpbmVUcmVlfS5cbiAgLy9cbiAgLy8gUmV0dXJucyB0aGUge091dGxpbmVUcmVlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7U3ltYm9sSW5mb3JtYXRpb259LlxuICBzdGF0aWMgc3ltYm9sVG9PdXRsaW5lKHN5bWJvbDogU3ltYm9sSW5mb3JtYXRpb24pOiBudWNsaWRlJE91dGxpbmVUcmVlIHtcbiAgICBjb25zdCBpY29uID0gT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sLmtpbmQpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplZFRleHQ6IFsge1xuICAgICAgICBraW5kOiBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbC5raW5kKSxcbiAgICAgICAgdmFsdWU6IHN5bWJvbC5uYW1lLFxuICAgICAgfSBdLFxuICAgICAgaWNvbjogaWNvbiAhPSBudWxsID8gaWNvbiA6IHVuZGVmaW5lZCxcbiAgICAgIHJlcHJlc2VudGF0aXZlTmFtZTogc3ltYm9sLm5hbWUsXG4gICAgICBzdGFydFBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChzeW1ib2wubG9jYXRpb24ucmFuZ2Uuc3RhcnQpLFxuICAgICAgZW5kUG9zaXRpb246IENvbnZlcnQucG9zaXRpb25Ub1BvaW50KHN5bWJvbC5sb2NhdGlvbi5yYW5nZS5lbmQpLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIGludG8gYW4gb3V0bGluZSBlbnRpdHkga2luZCB1c2VkIHRvIGRldGVybWluZVxuICAvLyB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXG4gIC8vXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxuICAvL1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBPdXRsaW5lVmlldyBlbnRpdHkga2luZC5cbiAgc3RhdGljIHN5bWJvbEtpbmRUb0VudGl0eUtpbmQoc3ltYm9sOiBudW1iZXIpOiA/c3RyaW5nIHtcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkFycmF5OiByZXR1cm4gJ3R5cGUtYXJyYXknO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkJvb2xlYW46IHJldHVybiAndHlwZS1ib29sZWFuJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5DbGFzczogcmV0dXJuICd0eXBlLWNsYXNzJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdGFudDogcmV0dXJuICd0eXBlLWNvbnN0YW50JztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjogcmV0dXJuICd0eXBlLWNvbnN0cnVjdG9yJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5FbnVtOiByZXR1cm4gJ3R5cGUtZW51bSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmllbGQ6IHJldHVybiAndHlwZS1maWVsZCc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmlsZTogcmV0dXJuICd0eXBlLWZpbGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOiByZXR1cm4gJ3R5cGUtZnVuY3Rpb24nO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLkludGVyZmFjZTogcmV0dXJuICd0eXBlLWludGVyZmFjZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOiByZXR1cm4gJ3R5cGUtbWV0aG9kJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Nb2R1bGU6IHJldHVybiAndHlwZS1tb2R1bGUnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk5hbWVzcGFjZTogcmV0dXJuICd0eXBlLW5hbWVzcGFjZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTnVtYmVyOiByZXR1cm4gJ3R5cGUtbnVtYmVyJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5QYWNrYWdlOiByZXR1cm4gJ3R5cGUtcGFja2FnZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUHJvcGVydHk6IHJldHVybiAndHlwZS1wcm9wZXJ0eSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOiByZXR1cm4gJ3R5cGUtc3RyaW5nJztcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5WYXJpYWJsZTogcmV0dXJuICd0eXBlLXZhcmlhYmxlJztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIHRvIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBraW5kIHVzZWQgdG8gc3ludGF4XG4gIC8vIGhpZ2hsaWdodCB0aGUgc3ltYm9sIG5hbWUgaW4gdGhlIE91dGxpbmUgVmlldy5cbiAgLy9cbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcXVpdmFsZW50IHN5bnRheCB0b2tlbiBraW5kLlxuICBzdGF0aWMgc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbDogbnVtYmVyKTogbnVjbGlkZSRUb2tlbktpbmQge1xuICAgIHN3aXRjaCAoc3ltYm9sKSB7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XG4gICAgICAgIHJldHVybiAndHlwZSc7XG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XG4gICAgICAgIHJldHVybiAnY29uc3RydWN0b3InO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcbiAgICAgICAgcmV0dXJuICdtZXRob2QnO1xuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcbiAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdwbGFpbic7XG4gICAgfVxuICB9XG59XG4iXX0=