Object.defineProperty(exports, "__esModule", {
  value: true
});

var _languageclient = require('../languageclient');

var _convert = require('../convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
  // Public: Determine whether this adapter can be used to adapt a language server
  // based on the serverCapabilities matrix containing a documentSymbolProvider.
  //
  // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
  //
  // Returns a {Boolean} indicating adapter can adapt the server based on the
  // given serverCapabilities.
  static canAdapt(serverCapabilities) {
    return serverCapabilities.documentSymbolProvider === true;
  }

  // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
  // by the {TextEditor}.
  //
  // * `connection` A {LanguageClientConnection} to the language server that will be queried
  //                for the outline.
  // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
  //
  // Returns a {Promise} containing the {Outline} of this document.
  async getOutline(connection, editor) {
    const results = await connection.documentSymbol({
      textDocument: _convert2.default.editorToTextDocumentIdentifier(editor)
    });
    results.sort((a, b) => a.location.range.start.line === b.location.range.start.line ? a.location.range.start.character - b.location.range.start.character : a.location.range.start.line - b.location.range.start.line);
    return {
      outlineTrees: OutlineViewAdapter.createOutlineTrees(results)
    };
  }

  // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
  // from the language server. This includes determining the appropriate child and parent
  // relationships for the hierarchy.
  //
  // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
  //             should be converted to an {OutlineTree}.
  //
  // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
  static createOutlineTrees(symbols) {
    // Temporarily keep containerName through the conversion process
    const allItems = symbols.map(symbol => ({
      containerName: symbol.containerName,
      outline: OutlineViewAdapter.symbolToOutline(symbol)
    }));

    // Create a map of containers by name with all items that have that name
    const containers = allItems.reduce((map, item) => {
      const name = item.outline.representativeName;
      if (name != null) {
        const container = map.get(name);
        if (container == null) {
          map.set(name, [item.outline]);
        } else {
          container.push(item.outline);
        }
      }
      return map;
    }, new Map());

    const roots = [];

    // Put each item within its parent and extract out the roots
    for (const item of allItems) {
      const containerName = item.containerName;
      const child = item.outline;
      if (containerName == null || containerName === '') {
        roots.push(item.outline);
      } else {
        const possibleParents = containers.get(containerName);
        let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
        if (closestParent == null) {
          closestParent = {
            plainText: containerName,
            representativeName: containerName,
            startPosition: new _atom.Point(0, 0),
            children: [child]
          };
          roots.push(closestParent);
          if (possibleParents == null) {
            containers.set(containerName, [closestParent]);
          } else {
            possibleParents.push(closestParent);
          }
        } else {
          closestParent.children.push(child);
        }
      }
    }

    return roots;
  }

  static _getClosestParent(candidates, child) {
    if (candidates == null || candidates.length === 0) {
      return null;
    }

    let parent = null;
    for (const candidate of candidates) {
      if (candidate !== child && candidate.startPosition.isLessThanOrEqual(child.startPosition) && (candidate.endPosition == null || candidate.endPosition.isGreaterThanOrEqual(child.endPosition))) {
        if (parent == null || parent.startPosition.isLessThanOrEqual(candidate.startPosition) || parent.endPosition != null && parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)) {
          parent = candidate;
        }
      }
    }

    return parent;
  }

  // Public: Convert an individual {SymbolInformation} from the language server
  // to an {OutlineTree} for use by the Outline View.
  //
  // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
  //
  // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
  static symbolToOutline(symbol) {
    const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
    return {
      tokenizedText: [{
        kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
        value: symbol.name
      }],
      icon: icon != null ? icon : undefined,
      representativeName: symbol.name,
      startPosition: _convert2.default.positionToPoint(symbol.location.range.start),
      endPosition: _convert2.default.positionToPoint(symbol.location.range.end),
      children: []
    };
  }

  // Public: Convert a symbol kind into an outline entity kind used to determine
  // the styling such as the appropriate icon in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent OutlineView entity kind.
  static symbolKindToEntityKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Array:
        return 'type-array';
      case _languageclient.SymbolKind.Boolean:
        return 'type-boolean';
      case _languageclient.SymbolKind.Class:
        return 'type-class';
      case _languageclient.SymbolKind.Constant:
        return 'type-constant';
      case _languageclient.SymbolKind.Constructor:
        return 'type-constructor';
      case _languageclient.SymbolKind.Enum:
        return 'type-enum';
      case _languageclient.SymbolKind.Field:
        return 'type-field';
      case _languageclient.SymbolKind.File:
        return 'type-file';
      case _languageclient.SymbolKind.Function:
        return 'type-function';
      case _languageclient.SymbolKind.Interface:
        return 'type-interface';
      case _languageclient.SymbolKind.Method:
        return 'type-method';
      case _languageclient.SymbolKind.Module:
        return 'type-module';
      case _languageclient.SymbolKind.Namespace:
        return 'type-namespace';
      case _languageclient.SymbolKind.Number:
        return 'type-number';
      case _languageclient.SymbolKind.Package:
        return 'type-package';
      case _languageclient.SymbolKind.Property:
        return 'type-property';
      case _languageclient.SymbolKind.String:
        return 'type-string';
      case _languageclient.SymbolKind.Variable:
        return 'type-variable';
      default:
        return null;
    }
  }

  // Public: Convert a symbol kind to the appropriate token kind used to syntax
  // highlight the symbol name in the Outline View.
  //
  // * `symbol` The numeric symbol kind received from the language server.
  //
  // Returns a string representing the equivalent syntax token kind.
  static symbolKindToTokenKind(symbol) {
    switch (symbol) {
      case _languageclient.SymbolKind.Class:
        return 'type';
      case _languageclient.SymbolKind.Constructor:
        return 'constructor';
      case _languageclient.SymbolKind.Method:
      case _languageclient.SymbolKind.Function:
        return 'method';
      case _languageclient.SymbolKind.String:
        return 'string';
      default:
        return 'plain';
    }
  }
}
exports.default = OutlineViewAdapter;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9vdXRsaW5lLXZpZXctYWRhcHRlci5qcyJdLCJuYW1lcyI6WyJPdXRsaW5lVmlld0FkYXB0ZXIiLCJjYW5BZGFwdCIsInNlcnZlckNhcGFiaWxpdGllcyIsImRvY3VtZW50U3ltYm9sUHJvdmlkZXIiLCJnZXRPdXRsaW5lIiwiY29ubmVjdGlvbiIsImVkaXRvciIsInJlc3VsdHMiLCJkb2N1bWVudFN5bWJvbCIsInRleHREb2N1bWVudCIsImVkaXRvclRvVGV4dERvY3VtZW50SWRlbnRpZmllciIsInNvcnQiLCJhIiwiYiIsImxvY2F0aW9uIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJvdXRsaW5lVHJlZXMiLCJjcmVhdGVPdXRsaW5lVHJlZXMiLCJzeW1ib2xzIiwiYWxsSXRlbXMiLCJtYXAiLCJzeW1ib2wiLCJjb250YWluZXJOYW1lIiwib3V0bGluZSIsInN5bWJvbFRvT3V0bGluZSIsImNvbnRhaW5lcnMiLCJyZWR1Y2UiLCJpdGVtIiwibmFtZSIsInJlcHJlc2VudGF0aXZlTmFtZSIsImNvbnRhaW5lciIsImdldCIsInNldCIsInB1c2giLCJNYXAiLCJyb290cyIsImNoaWxkIiwicG9zc2libGVQYXJlbnRzIiwiY2xvc2VzdFBhcmVudCIsIl9nZXRDbG9zZXN0UGFyZW50IiwicGxhaW5UZXh0Iiwic3RhcnRQb3NpdGlvbiIsImNoaWxkcmVuIiwiY2FuZGlkYXRlcyIsImxlbmd0aCIsInBhcmVudCIsImNhbmRpZGF0ZSIsImlzTGVzc1RoYW5PckVxdWFsIiwiZW5kUG9zaXRpb24iLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbCIsImljb24iLCJzeW1ib2xLaW5kVG9FbnRpdHlLaW5kIiwia2luZCIsInRva2VuaXplZFRleHQiLCJzeW1ib2xLaW5kVG9Ub2tlbktpbmQiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsInBvc2l0aW9uVG9Qb2ludCIsImVuZCIsIkFycmF5IiwiQm9vbGVhbiIsIkNsYXNzIiwiQ29uc3RhbnQiLCJDb25zdHJ1Y3RvciIsIkVudW0iLCJGaWVsZCIsIkZpbGUiLCJGdW5jdGlvbiIsIkludGVyZmFjZSIsIk1ldGhvZCIsIk1vZHVsZSIsIk5hbWVzcGFjZSIsIk51bWJlciIsIlBhY2thZ2UiLCJQcm9wZXJ0eSIsIlN0cmluZyIsIlZhcmlhYmxlIl0sIm1hcHBpbmdzIjoiOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDZSxNQUFNQSxrQkFBTixDQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLFFBQVAsQ0FBZ0JDLGtCQUFoQixFQUFpRTtBQUMvRCxXQUFPQSxtQkFBbUJDLHNCQUFuQixLQUE4QyxJQUFyRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxVQUFOLENBQWlCQyxVQUFqQixFQUF1REMsTUFBdkQsRUFBMkc7QUFDekcsVUFBTUMsVUFBVSxNQUFNRixXQUFXRyxjQUFYLENBQTBCO0FBQzlDQyxvQkFBYyxrQkFBUUMsOEJBQVIsQ0FBdUNKLE1BQXZDO0FBRGdDLEtBQTFCLENBQXRCO0FBR0FDLFlBQVFJLElBQVIsQ0FDRSxDQUFDQyxDQUFELEVBQUlDLENBQUosS0FDR0QsRUFBRUUsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFBdkIsS0FBZ0NKLEVBQUVDLFFBQUYsQ0FBV0MsS0FBWCxDQUFpQkMsS0FBakIsQ0FBdUJDLElBQXZELEdBQ0dMLEVBQUVFLFFBQUYsQ0FBV0MsS0FBWCxDQUFpQkMsS0FBakIsQ0FBdUJFLFNBQXZCLEdBQW1DTCxFQUFFQyxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCRSxTQUQ3RCxHQUVHTixFQUFFRSxRQUFGLENBQVdDLEtBQVgsQ0FBaUJDLEtBQWpCLENBQXVCQyxJQUF2QixHQUE4QkosRUFBRUMsUUFBRixDQUFXQyxLQUFYLENBQWlCQyxLQUFqQixDQUF1QkMsSUFKN0Q7QUFNQSxX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QUF0TnFDO2tCQUFuQjlFLGtCIiwiZmlsZSI6Im91dGxpbmUtdmlldy1hZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBTeW1ib2xLaW5kLCB0eXBlIFNlcnZlckNhcGFiaWxpdGllcywgdHlwZSBTeW1ib2xJbmZvcm1hdGlvbn0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuaW1wb3J0IHtQb2ludH0gZnJvbSAnYXRvbSc7XHJcblxyXG4vLyBQdWJsaWM6IEFkYXB0cyB0aGUgZG9jdW1lbnRTeW1ib2xQcm92aWRlciBvZiB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRvIHRoZSBPdXRsaW5lIFZpZXdcclxuLy8gc3VwcGxpZWQgYnkgQXRvbSBJREUgVUkuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE91dGxpbmVWaWV3QWRhcHRlciB7XHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZG9jdW1lbnRTeW1ib2xQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50U3ltYm9sUHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IE9idGFpbiB0aGUgT3V0bGluZSBmb3IgZG9jdW1lbnQgdmlhIHRoZSB7TGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9ufSBhcyBpZGVudGlmaWVkXHJcbiAgLy8gYnkgdGhlIHtUZXh0RWRpdG9yfS5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgcXVlcmllZFxyXG4gIC8vICAgICAgICAgICAgICAgIGZvciB0aGUgb3V0bGluZS5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRoZSBPdXRsaW5lIHNob3VsZCByZXByZXNlbnQuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge1Byb21pc2V9IGNvbnRhaW5pbmcgdGhlIHtPdXRsaW5lfSBvZiB0aGlzIGRvY3VtZW50LlxyXG4gIGFzeW5jIGdldE91dGxpbmUoY29ubmVjdGlvbjogTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLCBlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8P2F0b21JZGUkT3V0bGluZT4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm5lY3Rpb24uZG9jdW1lbnRTeW1ib2woe1xyXG4gICAgICB0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvciksXHJcbiAgICB9KTtcclxuICAgIHJlc3VsdHMuc29ydChcclxuICAgICAgKGEsIGIpID0+XHJcbiAgICAgICAgKGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQubGluZSA9PT0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lXHJcbiAgICAgICAgICA/IGEubG9jYXRpb24ucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXJcclxuICAgICAgICAgIDogYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lIC0gYi5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBvdXRsaW5lVHJlZXM6IE91dGxpbmVWaWV3QWRhcHRlci5jcmVhdGVPdXRsaW5lVHJlZXMocmVzdWx0cyksXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDcmVhdGUgYW4ge0FycmF5fSBvZiB7T3V0bGluZVRyZWV9cyBmcm9tIHRoZSBBcnJheSBvZiB7U3ltYm9sSW5mb3JtYXRpb259IHJlY2lldmVkXHJcbiAgLy8gZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLiBUaGlzIGluY2x1ZGVzIGRldGVybWluaW5nIHRoZSBhcHByb3ByaWF0ZSBjaGlsZCBhbmQgcGFyZW50XHJcbiAgLy8gcmVsYXRpb25zaGlwcyBmb3IgdGhlIGhpZXJhcmNoeS5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbHNgIEFuIHtBcnJheX0gb2Yge1N5bWJvbEluZm9ybWF0aW9ufXMgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyIHRoYXRcclxuICAvLyAgICAgICAgICAgICBzaG91bGQgYmUgY29udmVydGVkIHRvIGFuIHtPdXRsaW5lVHJlZX0uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGFuIHtPdXRsaW5lVHJlZX0gY29udGFpbmluZyB0aGUgZ2l2ZW4gc3ltYm9scyB0aGF0IHRoZSBPdXRsaW5lIFZpZXcgY2FuIGRpc3BsYXkuXHJcbiAgc3RhdGljIGNyZWF0ZU91dGxpbmVUcmVlcyhzeW1ib2xzOiBBcnJheTxTeW1ib2xJbmZvcm1hdGlvbj4pOiBBcnJheTxhdG9tSWRlJE91dGxpbmVUcmVlPiB7XHJcbiAgICAvLyBUZW1wb3JhcmlseSBrZWVwIGNvbnRhaW5lck5hbWUgdGhyb3VnaCB0aGUgY29udmVyc2lvbiBwcm9jZXNzXHJcbiAgICBjb25zdCBhbGxJdGVtcyA9IHN5bWJvbHMubWFwKHN5bWJvbCA9PiAoe1xyXG4gICAgICBjb250YWluZXJOYW1lOiBzeW1ib2wuY29udGFpbmVyTmFtZSxcclxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxyXG4gICAgY29uc3QgY29udGFpbmVycyA9IGFsbEl0ZW1zLnJlZHVjZSgobWFwLCBpdGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLm91dGxpbmUucmVwcmVzZW50YXRpdmVOYW1lO1xyXG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250YWluZXIucHVzaChpdGVtLm91dGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuXHJcbiAgICBjb25zdCByb290czogQXJyYXk8YXRvbUlkZSRPdXRsaW5lVHJlZT4gPSBbXTtcclxuXHJcbiAgICAvLyBQdXQgZWFjaCBpdGVtIHdpdGhpbiBpdHMgcGFyZW50IGFuZCBleHRyYWN0IG91dCB0aGUgcm9vdHNcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhbGxJdGVtcykge1xyXG4gICAgICBjb25zdCBjb250YWluZXJOYW1lID0gaXRlbS5jb250YWluZXJOYW1lO1xyXG4gICAgICBjb25zdCBjaGlsZCA9IGl0ZW0ub3V0bGluZTtcclxuICAgICAgaWYgKGNvbnRhaW5lck5hbWUgPT0gbnVsbCB8fCBjb250YWluZXJOYW1lID09PSAnJykge1xyXG4gICAgICAgIHJvb3RzLnB1c2goaXRlbS5vdXRsaW5lKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBwb3NzaWJsZVBhcmVudHMgPSBjb250YWluZXJzLmdldChjb250YWluZXJOYW1lKTtcclxuICAgICAgICBsZXQgY2xvc2VzdFBhcmVudCA9IE91dGxpbmVWaWV3QWRhcHRlci5fZ2V0Q2xvc2VzdFBhcmVudChwb3NzaWJsZVBhcmVudHMsIGNoaWxkKTtcclxuICAgICAgICBpZiAoY2xvc2VzdFBhcmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICBjbG9zZXN0UGFyZW50ID0ge1xyXG4gICAgICAgICAgICBwbGFpblRleHQ6IGNvbnRhaW5lck5hbWUsXHJcbiAgICAgICAgICAgIHJlcHJlc2VudGF0aXZlTmFtZTogY29udGFpbmVyTmFtZSxcclxuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbjogbmV3IFBvaW50KDAsIDApLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogW2NoaWxkXSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICByb290cy5wdXNoKGNsb3Nlc3RQYXJlbnQpO1xyXG4gICAgICAgICAgaWYgKHBvc3NpYmxlUGFyZW50cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lcnMuc2V0KGNvbnRhaW5lck5hbWUsIFtjbG9zZXN0UGFyZW50XSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NzaWJsZVBhcmVudHMucHVzaChjbG9zZXN0UGFyZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY2xvc2VzdFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcm9vdHM7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX2dldENsb3Nlc3RQYXJlbnQoY2FuZGlkYXRlczogP0FycmF5PGF0b21JZGUkT3V0bGluZVRyZWU+LCBjaGlsZDogYXRvbUlkZSRPdXRsaW5lVHJlZSk6ID9hdG9tSWRlJE91dGxpbmVUcmVlIHtcclxuICAgIGlmIChjYW5kaWRhdGVzID09IG51bGwgfHwgY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBhcmVudCA9IG51bGw7XHJcbiAgICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBjYW5kaWRhdGVzKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBjYW5kaWRhdGUgIT09IGNoaWxkICYmXHJcbiAgICAgICAgY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2hpbGQuc3RhcnRQb3NpdGlvbikgJiZcclxuICAgICAgICAoY2FuZGlkYXRlLmVuZFBvc2l0aW9uID09IG51bGwgfHwgY2FuZGlkYXRlLmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNoaWxkLmVuZFBvc2l0aW9uKSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcGFyZW50ID09IG51bGwgfHxcclxuICAgICAgICAgIChwYXJlbnQuc3RhcnRQb3NpdGlvbi5pc0xlc3NUaGFuT3JFcXVhbChjYW5kaWRhdGUuc3RhcnRQb3NpdGlvbikgfHxcclxuICAgICAgICAgICAgKHBhcmVudC5lbmRQb3NpdGlvbiAhPSBudWxsICYmIHBhcmVudC5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjYW5kaWRhdGUuZW5kUG9zaXRpb24pKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHBhcmVudCA9IGNhbmRpZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50O1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBDb252ZXJ0IGFuIGluZGl2aWR1YWwge1N5bWJvbEluZm9ybWF0aW9ufSBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyB0byBhbiB7T3V0bGluZVRyZWV9IGZvciB1c2UgYnkgdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIHtTeW1ib2xJbmZvcm1hdGlvbn0gdG8gY29udmVydCB0byBhbiB7T3V0bGluZVRyZWV9LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyB0aGUge091dGxpbmVUcmVlfSBlcXVpdmFsZW50IHRvIHRoZSBnaXZlbiB7U3ltYm9sSW5mb3JtYXRpb259LlxyXG4gIHN0YXRpYyBzeW1ib2xUb091dGxpbmUoc3ltYm9sOiBTeW1ib2xJbmZvcm1hdGlvbik6IGF0b21JZGUkT3V0bGluZVRyZWUge1xyXG4gICAgY29uc3QgaWNvbiA9IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbC5raW5kKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRva2VuaXplZFRleHQ6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBraW5kOiBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbC5raW5kKSxcclxuICAgICAgICAgIHZhbHVlOiBzeW1ib2wubmFtZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBpY29uOiBpY29uICE9IG51bGwgPyBpY29uIDogdW5kZWZpbmVkLFxyXG4gICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IHN5bWJvbC5uYW1lLFxyXG4gICAgICBzdGFydFBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChzeW1ib2wubG9jYXRpb24ucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICBlbmRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLmVuZCksXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCBpbnRvIGFuIG91dGxpbmUgZW50aXR5IGtpbmQgdXNlZCB0byBkZXRlcm1pbmVcclxuICAvLyB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xgIFRoZSBudW1lcmljIHN5bWJvbCBraW5kIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcXVpdmFsZW50IE91dGxpbmVWaWV3IGVudGl0eSBraW5kLlxyXG4gIHN0YXRpYyBzeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbDogbnVtYmVyKTogP3N0cmluZyB7XHJcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQXJyYXk6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWFycmF5JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkJvb2xlYW46XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWJvb2xlYW4nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNsYXNzJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0YW50OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jb25zdGFudCc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY29uc3RydWN0b3InO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRW51bTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZW51bSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GaWVsZDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZmllbGQnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmlsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZmlsZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5GdW5jdGlvbjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtZnVuY3Rpb24nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuSW50ZXJmYWNlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1pbnRlcmZhY2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1tZXRob2QnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTW9kdWxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1tb2R1bGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTmFtZXNwYWNlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1uYW1lc3BhY2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTnVtYmVyOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1udW1iZXInO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUGFja2FnZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtcGFja2FnZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Qcm9wZXJ0eTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtcHJvcGVydHknO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1zdHJpbmcnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuVmFyaWFibGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXZhcmlhYmxlJztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFB1YmxpYzogQ29udmVydCBhIHN5bWJvbCBraW5kIHRvIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBraW5kIHVzZWQgdG8gc3ludGF4XHJcbiAgLy8gaGlnaGxpZ2h0IHRoZSBzeW1ib2wgbmFtZSBpbiB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUgbnVtZXJpYyBzeW1ib2wga2luZCByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXF1aXZhbGVudCBzeW50YXggdG9rZW4ga2luZC5cclxuICBzdGF0aWMgc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbDogbnVtYmVyKTogYXRvbUlkZSRUb2tlbktpbmQge1xyXG4gICAgc3dpdGNoIChzeW1ib2wpIHtcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNsYXNzOlxyXG4gICAgICAgIHJldHVybiAndHlwZSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdHJ1Y3RvcjpcclxuICAgICAgICByZXR1cm4gJ2NvbnN0cnVjdG9yJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZ1bmN0aW9uOlxyXG4gICAgICAgIHJldHVybiAnbWV0aG9kJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdwbGFpbic7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdfQ==