"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const convert_1 = require("../convert");
const utils_1 = require("../utils");
const languageclient_1 = require("../languageclient");
const atom_1 = require("atom");
// Public: Adapts the documentSymbolProvider of the language server to the Outline View
// supplied by Atom IDE UI.
class OutlineViewAdapter {
    constructor() {
        this._cancellationTokens = new WeakMap();
    }
    // Public: Determine whether this adapter can be used to adapt a language server
    // based on the serverCapabilities matrix containing a documentSymbolProvider.
    //
    // * `serverCapabilities` The {ServerCapabilities} of the language server to consider.
    //
    // Returns a {Boolean} indicating adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.documentSymbolProvider === true;
    }
    // Public: Obtain the Outline for document via the {LanguageClientConnection} as identified
    // by the {TextEditor}.
    //
    // * `connection` A {LanguageClientConnection} to the language server that will be queried
    //                for the outline.
    // * `editor` The Atom {TextEditor} containing the text the Outline should represent.
    //
    // Returns a {Promise} containing the {Outline} of this document.
    getOutline(connection, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield utils_1.default.doWithCancellationToken(connection, this._cancellationTokens, (cancellationToken) => connection.documentSymbol({ textDocument: convert_1.default.editorToTextDocumentIdentifier(editor) }, cancellationToken));
            results.sort((a, b) => (a.location.range.start.line === b.location.range.start.line
                ? a.location.range.start.character - b.location.range.start.character
                : a.location.range.start.line - b.location.range.start.line));
            return {
                outlineTrees: OutlineViewAdapter.createOutlineTrees(results),
            };
        });
    }
    // Public: Create an {Array} of {OutlineTree}s from the Array of {SymbolInformation} recieved
    // from the language server. This includes determining the appropriate child and parent
    // relationships for the hierarchy.
    //
    // * `symbols` An {Array} of {SymbolInformation}s received from the language server that
    //             should be converted to an {OutlineTree}.
    //
    // Returns an {OutlineTree} containing the given symbols that the Outline View can display.
    static createOutlineTrees(symbols) {
        // Temporarily keep containerName through the conversion process
        // Also filter out symbols without a name - it's part of the spec but some don't include it
        const allItems = symbols.filter((symbol) => symbol.name).map((symbol) => ({
            containerName: symbol.containerName,
            outline: OutlineViewAdapter.symbolToOutline(symbol),
        }));
        // Create a map of containers by name with all items that have that name
        const containers = allItems.reduce((map, item) => {
            const name = item.outline.representativeName;
            if (name != null) {
                const container = map.get(name);
                if (container == null) {
                    map.set(name, [item.outline]);
                }
                else {
                    container.push(item.outline);
                }
            }
            return map;
        }, new Map());
        const roots = [];
        // Put each item within its parent and extract out the roots
        for (const item of allItems) {
            const containerName = item.containerName;
            const child = item.outline;
            if (containerName == null || containerName === '') {
                roots.push(item.outline);
            }
            else {
                const possibleParents = containers.get(containerName);
                let closestParent = OutlineViewAdapter._getClosestParent(possibleParents, child);
                if (closestParent == null) {
                    closestParent = {
                        plainText: containerName,
                        representativeName: containerName,
                        startPosition: new atom_1.Point(0, 0),
                        children: [child],
                    };
                    roots.push(closestParent);
                    if (possibleParents == null) {
                        containers.set(containerName, [closestParent]);
                    }
                    else {
                        possibleParents.push(closestParent);
                    }
                }
                else {
                    closestParent.children.push(child);
                }
            }
        }
        return roots;
    }
    static _getClosestParent(candidates, child) {
        if (candidates == null || candidates.length === 0) {
            return null;
        }
        let parent;
        for (const candidate of candidates) {
            if (candidate !== child &&
                candidate.startPosition.isLessThanOrEqual(child.startPosition) &&
                (candidate.endPosition === undefined ||
                    (child.endPosition && candidate.endPosition.isGreaterThanOrEqual(child.endPosition)))) {
                if (parent === undefined ||
                    (parent.startPosition.isLessThanOrEqual(candidate.startPosition) ||
                        (parent.endPosition != null &&
                            candidate.endPosition &&
                            parent.endPosition.isGreaterThanOrEqual(candidate.endPosition)))) {
                    parent = candidate;
                }
            }
        }
        return parent || null;
    }
    // Public: Convert an individual {SymbolInformation} from the language server
    // to an {OutlineTree} for use by the Outline View.
    //
    // * `symbol` The {SymbolInformation} to convert to an {OutlineTree}.
    //
    // Returns the {OutlineTree} equivalent to the given {SymbolInformation}.
    static symbolToOutline(symbol) {
        const icon = OutlineViewAdapter.symbolKindToEntityKind(symbol.kind);
        return {
            tokenizedText: [
                {
                    kind: OutlineViewAdapter.symbolKindToTokenKind(symbol.kind),
                    value: symbol.name,
                },
            ],
            icon: icon != null ? icon : undefined,
            representativeName: symbol.name,
            startPosition: convert_1.default.positionToPoint(symbol.location.range.start),
            endPosition: convert_1.default.positionToPoint(symbol.location.range.end),
            children: [],
        };
    }
    // Public: Convert a symbol kind into an outline entity kind used to determine
    // the styling such as the appropriate icon in the Outline View.
    //
    // * `symbol` The numeric symbol kind received from the language server.
    //
    // Returns a string representing the equivalent OutlineView entity kind.
    static symbolKindToEntityKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Array:
                return 'type-array';
            case languageclient_1.SymbolKind.Boolean:
                return 'type-boolean';
            case languageclient_1.SymbolKind.Class:
                return 'type-class';
            case languageclient_1.SymbolKind.Constant:
                return 'type-constant';
            case languageclient_1.SymbolKind.Constructor:
                return 'type-constructor';
            case languageclient_1.SymbolKind.Enum:
                return 'type-enum';
            case languageclient_1.SymbolKind.Field:
                return 'type-field';
            case languageclient_1.SymbolKind.File:
                return 'type-file';
            case languageclient_1.SymbolKind.Function:
                return 'type-function';
            case languageclient_1.SymbolKind.Interface:
                return 'type-interface';
            case languageclient_1.SymbolKind.Method:
                return 'type-method';
            case languageclient_1.SymbolKind.Module:
                return 'type-module';
            case languageclient_1.SymbolKind.Namespace:
                return 'type-namespace';
            case languageclient_1.SymbolKind.Number:
                return 'type-number';
            case languageclient_1.SymbolKind.Package:
                return 'type-package';
            case languageclient_1.SymbolKind.Property:
                return 'type-property';
            case languageclient_1.SymbolKind.String:
                return 'type-string';
            case languageclient_1.SymbolKind.Variable:
                return 'type-variable';
            default:
                return null;
        }
    }
    // Public: Convert a symbol kind to the appropriate token kind used to syntax
    // highlight the symbol name in the Outline View.
    //
    // * `symbol` The numeric symbol kind received from the language server.
    //
    // Returns a string representing the equivalent syntax token kind.
    static symbolKindToTokenKind(symbol) {
        switch (symbol) {
            case languageclient_1.SymbolKind.Class:
                return 'type';
            case languageclient_1.SymbolKind.Constructor:
                return 'constructor';
            case languageclient_1.SymbolKind.Method:
            case languageclient_1.SymbolKind.Function:
                return 'method';
            case languageclient_1.SymbolKind.String:
                return 'string';
            default:
                return 'plain';
        }
    }
}
exports.default = OutlineViewAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0bGluZS12aWV3LWFkYXB0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9saWIvYWRhcHRlcnMvb3V0bGluZS12aWV3LWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBLHdDQUFpQztBQUNqQyxvQ0FBNkI7QUFFN0Isc0RBSzJCO0FBQzNCLCtCQUdjO0FBRWQsdUZBQXVGO0FBQ3ZGLDJCQUEyQjtBQUMzQjtJQUFBO1FBRVUsd0JBQW1CLEdBQStELElBQUksT0FBTyxFQUFFLENBQUM7SUErTjFHLENBQUM7SUE3TkMsZ0ZBQWdGO0lBQ2hGLDhFQUE4RTtJQUM5RSxFQUFFO0lBQ0Ysc0ZBQXNGO0lBQ3RGLEVBQUU7SUFDRiwyRUFBMkU7SUFDM0UsNEJBQTRCO0lBQ3JCLE1BQU0sQ0FBQyxRQUFRLENBQUMsa0JBQXNDO1FBQzNELE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxzQkFBc0IsS0FBSyxJQUFJLENBQUM7SUFDNUQsQ0FBQztJQUVELDJGQUEyRjtJQUMzRix1QkFBdUI7SUFDdkIsRUFBRTtJQUNGLDBGQUEwRjtJQUMxRixrQ0FBa0M7SUFDbEMscUZBQXFGO0lBQ3JGLEVBQUU7SUFDRixpRUFBaUU7SUFDcEQsVUFBVSxDQUFDLFVBQW9DLEVBQUUsTUFBa0I7O1lBQzlFLE1BQU0sT0FBTyxHQUFHLE1BQU0sZUFBSyxDQUFDLHVCQUF1QixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxFQUFFLENBQzlHLFVBQVUsQ0FBQyxjQUFjLENBQUMsRUFBQyxZQUFZLEVBQUUsaUJBQU8sQ0FBQyw4QkFBOEIsQ0FBQyxNQUFNLENBQUMsRUFBQyxFQUFFLGlCQUFpQixDQUFDLENBQzdHLENBQUM7WUFDRixPQUFPLENBQUMsSUFBSSxDQUNWLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ1AsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUss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O1lBQ2xCO2dCQUNFLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFDbkIsQ0FBQztJQUNILENBQUM7Q0FDRjtBQWpPRCxxQ0FpT0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBhdG9tSWRlIGZyb20gJ2F0b20taWRlJztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi4vY29udmVydCc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscyc7XHJcbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAndnNjb2RlLWpzb25ycGMnO1xyXG5pbXBvcnQge1xyXG4gIExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcclxuICBTeW1ib2xLaW5kLFxyXG4gIFNlcnZlckNhcGFiaWxpdGllcyxcclxuICBTeW1ib2xJbmZvcm1hdGlvbixcclxufSBmcm9tICcuLi9sYW5ndWFnZWNsaWVudCc7XHJcbmltcG9ydCB7XHJcbiAgUG9pbnQsXHJcbiAgVGV4dEVkaXRvcixcclxufSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFB1YmxpYzogQWRhcHRzIHRoZSBkb2N1bWVudFN5bWJvbFByb3ZpZGVyIG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gdGhlIE91dGxpbmUgVmlld1xyXG4vLyBzdXBwbGllZCBieSBBdG9tIElERSBVSS5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0bGluZVZpZXdBZGFwdGVyIHtcclxuXHJcbiAgcHJpdmF0ZSBfY2FuY2VsbGF0aW9uVG9rZW5zOiBXZWFrTWFwPExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U+ID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbiAgLy8gUHVibGljOiBEZXRlcm1pbmUgd2hldGhlciB0aGlzIGFkYXB0ZXIgY2FuIGJlIHVzZWQgdG8gYWRhcHQgYSBsYW5ndWFnZSBzZXJ2ZXJcclxuICAvLyBiYXNlZCBvbiB0aGUgc2VydmVyQ2FwYWJpbGl0aWVzIG1hdHJpeCBjb250YWluaW5nIGEgZG9jdW1lbnRTeW1ib2xQcm92aWRlci5cclxuICAvL1xyXG4gIC8vICogYHNlcnZlckNhcGFiaWxpdGllc2AgVGhlIHtTZXJ2ZXJDYXBhYmlsaXRpZXN9IG9mIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdG8gY29uc2lkZXIuXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgYWRhcHRlciBjYW4gYWRhcHQgdGhlIHNlcnZlciBiYXNlZCBvbiB0aGVcclxuICAvLyBnaXZlbiBzZXJ2ZXJDYXBhYmlsaXRpZXMuXHJcbiAgcHVibGljIHN0YXRpYyBjYW5BZGFwdChzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHNlcnZlckNhcGFiaWxpdGllcy5kb2N1bWVudFN5bWJvbFByb3ZpZGVyID09PSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gUHVibGljOiBPYnRhaW4gdGhlIE91dGxpbmUgZm9yIGRvY3VtZW50IHZpYSB0aGUge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gYXMgaWRlbnRpZmllZFxyXG4gIC8vIGJ5IHRoZSB7VGV4dEVkaXRvcn0uXHJcbiAgLy9cclxuICAvLyAqIGBjb25uZWN0aW9uYCBBIHtMYW5ndWFnZUNsaWVudENvbm5lY3Rpb259IHRvIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdCB3aWxsIGJlIHF1ZXJpZWRcclxuICAvLyAgICAgICAgICAgICAgICBmb3IgdGhlIG91dGxpbmUuXHJcbiAgLy8gKiBgZWRpdG9yYCBUaGUgQXRvbSB7VGV4dEVkaXRvcn0gY29udGFpbmluZyB0aGUgdGV4dCB0aGUgT3V0bGluZSBzaG91bGQgcmVwcmVzZW50LlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBjb250YWluaW5nIHRoZSB7T3V0bGluZX0gb2YgdGhpcyBkb2N1bWVudC5cclxuICBwdWJsaWMgYXN5bmMgZ2V0T3V0bGluZShjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sIGVkaXRvcjogVGV4dEVkaXRvcik6IFByb21pc2U8YXRvbUlkZS5PdXRsaW5lIHwgbnVsbD4ge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFV0aWxzLmRvV2l0aENhbmNlbGxhdGlvblRva2VuKGNvbm5lY3Rpb24sIHRoaXMuX2NhbmNlbGxhdGlvblRva2VucywgKGNhbmNlbGxhdGlvblRva2VuKSA9PlxyXG4gICAgICBjb25uZWN0aW9uLmRvY3VtZW50U3ltYm9sKHt0ZXh0RG9jdW1lbnQ6IENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRJZGVudGlmaWVyKGVkaXRvcil9LCBjYW5jZWxsYXRpb25Ub2tlbiksXHJcbiAgICApO1xyXG4gICAgcmVzdWx0cy5zb3J0KFxyXG4gICAgICAoYSwgYikgPT5cclxuICAgICAgICAoYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5saW5lID09PSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmVcclxuICAgICAgICAgID8gYS5sb2NhdGlvbi5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmNoYXJhY3RlclxyXG4gICAgICAgICAgOiBhLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLmxvY2F0aW9uLnJhbmdlLnN0YXJ0LmxpbmUpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG91dGxpbmVUcmVlczogT3V0bGluZVZpZXdBZGFwdGVyLmNyZWF0ZU91dGxpbmVUcmVlcyhyZXN1bHRzKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZSBhbiB7QXJyYXl9IG9mIHtPdXRsaW5lVHJlZX1zIGZyb20gdGhlIEFycmF5IG9mIHtTeW1ib2xJbmZvcm1hdGlvbn0gcmVjaWV2ZWRcclxuICAvLyBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIuIFRoaXMgaW5jbHVkZXMgZGV0ZXJtaW5pbmcgdGhlIGFwcHJvcHJpYXRlIGNoaWxkIGFuZCBwYXJlbnRcclxuICAvLyByZWxhdGlvbnNoaXBzIGZvciB0aGUgaGllcmFyY2h5LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sc2AgQW4ge0FycmF5fSBvZiB7U3ltYm9sSW5mb3JtYXRpb259cyByZWNlaXZlZCBmcm9tIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgdGhhdFxyXG4gIC8vICAgICAgICAgICAgIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYW4ge091dGxpbmVUcmVlfS5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYW4ge091dGxpbmVUcmVlfSBjb250YWluaW5nIHRoZSBnaXZlbiBzeW1ib2xzIHRoYXQgdGhlIE91dGxpbmUgVmlldyBjYW4gZGlzcGxheS5cclxuICBwdWJsaWMgc3RhdGljIGNyZWF0ZU91dGxpbmVUcmVlcyhzeW1ib2xzOiBTeW1ib2xJbmZvcm1hdGlvbltdKTogYXRvbUlkZS5PdXRsaW5lVHJlZVtdIHtcclxuICAgIC8vIFRlbXBvcmFyaWx5IGtlZXAgY29udGFpbmVyTmFtZSB0aHJvdWdoIHRoZSBjb252ZXJzaW9uIHByb2Nlc3NcclxuICAgIC8vIEFsc28gZmlsdGVyIG91dCBzeW1ib2xzIHdpdGhvdXQgYSBuYW1lIC0gaXQncyBwYXJ0IG9mIHRoZSBzcGVjIGJ1dCBzb21lIGRvbid0IGluY2x1ZGUgaXRcclxuICAgIGNvbnN0IGFsbEl0ZW1zID0gc3ltYm9scy5maWx0ZXIoKHN5bWJvbCkgPT4gc3ltYm9sLm5hbWUpLm1hcCgoc3ltYm9sKSA9PiAoe1xyXG4gICAgICBjb250YWluZXJOYW1lOiBzeW1ib2wuY29udGFpbmVyTmFtZSxcclxuICAgICAgb3V0bGluZTogT3V0bGluZVZpZXdBZGFwdGVyLnN5bWJvbFRvT3V0bGluZShzeW1ib2wpLFxyXG4gICAgfSkpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBjb250YWluZXJzIGJ5IG5hbWUgd2l0aCBhbGwgaXRlbXMgdGhhdCBoYXZlIHRoYXQgbmFtZVxyXG4gICAgY29uc3QgY29udGFpbmVycyA9IGFsbEl0ZW1zLnJlZHVjZSgobWFwLCBpdGVtKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLm91dGxpbmUucmVwcmVzZW50YXRpdmVOYW1lO1xyXG4gICAgICBpZiAobmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gbWFwLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcclxuICAgICAgICAgIG1hcC5zZXQobmFtZSwgW2l0ZW0ub3V0bGluZV0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250YWluZXIucHVzaChpdGVtLm91dGxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfSwgbmV3IE1hcCgpKTtcclxuXHJcbiAgICBjb25zdCByb290czogYXRvbUlkZS5PdXRsaW5lVHJlZVtdID0gW107XHJcblxyXG4gICAgLy8gUHV0IGVhY2ggaXRlbSB3aXRoaW4gaXRzIHBhcmVudCBhbmQgZXh0cmFjdCBvdXQgdGhlIHJvb3RzXHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWxsSXRlbXMpIHtcclxuICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IGl0ZW0uY29udGFpbmVyTmFtZTtcclxuICAgICAgY29uc3QgY2hpbGQgPSBpdGVtLm91dGxpbmU7XHJcbiAgICAgIGlmIChjb250YWluZXJOYW1lID09IG51bGwgfHwgY29udGFpbmVyTmFtZSA9PT0gJycpIHtcclxuICAgICAgICByb290cy5wdXNoKGl0ZW0ub3V0bGluZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcG9zc2libGVQYXJlbnRzID0gY29udGFpbmVycy5nZXQoY29udGFpbmVyTmFtZSk7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RQYXJlbnQgPSBPdXRsaW5lVmlld0FkYXB0ZXIuX2dldENsb3Nlc3RQYXJlbnQocG9zc2libGVQYXJlbnRzLCBjaGlsZCk7XHJcbiAgICAgICAgaWYgKGNsb3Nlc3RQYXJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgY2xvc2VzdFBhcmVudCA9IHtcclxuICAgICAgICAgICAgcGxhaW5UZXh0OiBjb250YWluZXJOYW1lLFxyXG4gICAgICAgICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IGNvbnRhaW5lck5hbWUsXHJcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246IG5ldyBQb2ludCgwLCAwKSxcclxuICAgICAgICAgICAgY2hpbGRyZW46IFtjaGlsZF0sXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgcm9vdHMucHVzaChjbG9zZXN0UGFyZW50KTtcclxuICAgICAgICAgIGlmIChwb3NzaWJsZVBhcmVudHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb250YWluZXJzLnNldChjb250YWluZXJOYW1lLCBbY2xvc2VzdFBhcmVudF0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcG9zc2libGVQYXJlbnRzLnB1c2goY2xvc2VzdFBhcmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNsb3Nlc3RQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvb3RzO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGF0aWMgX2dldENsb3Nlc3RQYXJlbnQoXHJcbiAgICBjYW5kaWRhdGVzOiBhdG9tSWRlLk91dGxpbmVUcmVlW10gfCBudWxsLFxyXG4gICAgY2hpbGQ6IGF0b21JZGUuT3V0bGluZVRyZWUsXHJcbiAgKTogYXRvbUlkZS5PdXRsaW5lVHJlZSB8IG51bGwge1xyXG4gICAgaWYgKGNhbmRpZGF0ZXMgPT0gbnVsbCB8fCBjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcGFyZW50OiBhdG9tSWRlLk91dGxpbmVUcmVlIHwgdW5kZWZpbmVkO1xyXG4gICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgY2FuZGlkYXRlcykge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY2FuZGlkYXRlICE9PSBjaGlsZCAmJlxyXG4gICAgICAgIGNhbmRpZGF0ZS5zdGFydFBvc2l0aW9uLmlzTGVzc1RoYW5PckVxdWFsKGNoaWxkLnN0YXJ0UG9zaXRpb24pICYmXHJcbiAgICAgICAgKGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAoY2hpbGQuZW5kUG9zaXRpb24gJiYgY2FuZGlkYXRlLmVuZFBvc2l0aW9uLmlzR3JlYXRlclRoYW5PckVxdWFsKGNoaWxkLmVuZFBvc2l0aW9uKSkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAocGFyZW50LnN0YXJ0UG9zaXRpb24uaXNMZXNzVGhhbk9yRXF1YWwoY2FuZGlkYXRlLnN0YXJ0UG9zaXRpb24pIHx8XHJcbiAgICAgICAgICAgIChwYXJlbnQuZW5kUG9zaXRpb24gIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgIGNhbmRpZGF0ZS5lbmRQb3NpdGlvbiAmJlxyXG4gICAgICAgICAgICAgIHBhcmVudC5lbmRQb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChjYW5kaWRhdGUuZW5kUG9zaXRpb24pKSlcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHBhcmVudCA9IGNhbmRpZGF0ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcGFyZW50IHx8IG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYW4gaW5kaXZpZHVhbCB7U3ltYm9sSW5mb3JtYXRpb259IGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlclxyXG4gIC8vIHRvIGFuIHtPdXRsaW5lVHJlZX0gZm9yIHVzZSBieSB0aGUgT3V0bGluZSBWaWV3LlxyXG4gIC8vXHJcbiAgLy8gKiBgc3ltYm9sYCBUaGUge1N5bWJvbEluZm9ybWF0aW9ufSB0byBjb252ZXJ0IHRvIGFuIHtPdXRsaW5lVHJlZX0uXHJcbiAgLy9cclxuICAvLyBSZXR1cm5zIHRoZSB7T3V0bGluZVRyZWV9IGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIHtTeW1ib2xJbmZvcm1hdGlvbn0uXHJcbiAgcHVibGljIHN0YXRpYyBzeW1ib2xUb091dGxpbmUoc3ltYm9sOiBTeW1ib2xJbmZvcm1hdGlvbik6IGF0b21JZGUuT3V0bGluZVRyZWUge1xyXG4gICAgY29uc3QgaWNvbiA9IE91dGxpbmVWaWV3QWRhcHRlci5zeW1ib2xLaW5kVG9FbnRpdHlLaW5kKHN5bWJvbC5raW5kKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRva2VuaXplZFRleHQ6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBraW5kOiBPdXRsaW5lVmlld0FkYXB0ZXIuc3ltYm9sS2luZFRvVG9rZW5LaW5kKHN5bWJvbC5raW5kKSxcclxuICAgICAgICAgIHZhbHVlOiBzeW1ib2wubmFtZSxcclxuICAgICAgICB9LFxyXG4gICAgICBdLFxyXG4gICAgICBpY29uOiBpY29uICE9IG51bGwgPyBpY29uIDogdW5kZWZpbmVkLFxyXG4gICAgICByZXByZXNlbnRhdGl2ZU5hbWU6IHN5bWJvbC5uYW1lLFxyXG4gICAgICBzdGFydFBvc2l0aW9uOiBDb252ZXJ0LnBvc2l0aW9uVG9Qb2ludChzeW1ib2wubG9jYXRpb24ucmFuZ2Uuc3RhcnQpLFxyXG4gICAgICBlbmRQb3NpdGlvbjogQ29udmVydC5wb3NpdGlvblRvUG9pbnQoc3ltYm9sLmxvY2F0aW9uLnJhbmdlLmVuZCksXHJcbiAgICAgIGNoaWxkcmVuOiBbXSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCBpbnRvIGFuIG91dGxpbmUgZW50aXR5IGtpbmQgdXNlZCB0byBkZXRlcm1pbmVcclxuICAvLyB0aGUgc3R5bGluZyBzdWNoIGFzIHRoZSBhcHByb3ByaWF0ZSBpY29uIGluIHRoZSBPdXRsaW5lIFZpZXcuXHJcbiAgLy9cclxuICAvLyAqIGBzeW1ib2xgIFRoZSBudW1lcmljIHN5bWJvbCBraW5kIHJlY2VpdmVkIGZyb20gdGhlIGxhbmd1YWdlIHNlcnZlci5cclxuICAvL1xyXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBlcXVpdmFsZW50IE91dGxpbmVWaWV3IGVudGl0eSBraW5kLlxyXG4gIHB1YmxpYyBzdGF0aWMgc3ltYm9sS2luZFRvRW50aXR5S2luZChzeW1ib2w6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xyXG4gICAgc3dpdGNoIChzeW1ib2wpIHtcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkFycmF5OlxyXG4gICAgICAgIHJldHVybiAndHlwZS1hcnJheSc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Cb29sZWFuOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1ib29sZWFuJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNsYXNzOlxyXG4gICAgICAgIHJldHVybiAndHlwZS1jbGFzcyc7XHJcbiAgICAgIGNhc2UgU3ltYm9sS2luZC5Db25zdGFudDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtY29uc3RhbnQnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ29uc3RydWN0b3I6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWNvbnN0cnVjdG9yJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkVudW06XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWVudW0nO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRmllbGQ6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpZWxkJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkZpbGU6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZpbGUnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLWZ1bmN0aW9uJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkludGVyZmFjZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtaW50ZXJmYWNlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1ldGhvZDpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbWV0aG9kJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk1vZHVsZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbW9kdWxlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk5hbWVzcGFjZTpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbmFtZXNwYWNlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLk51bWJlcjpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtbnVtYmVyJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlBhY2thZ2U6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXBhY2thZ2UnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuUHJvcGVydHk6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlLXByb3BlcnR5JztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gJ3R5cGUtc3RyaW5nJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLlZhcmlhYmxlOlxyXG4gICAgICAgIHJldHVybiAndHlwZS12YXJpYWJsZSc7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENvbnZlcnQgYSBzeW1ib2wga2luZCB0byB0aGUgYXBwcm9wcmlhdGUgdG9rZW4ga2luZCB1c2VkIHRvIHN5bnRheFxyXG4gIC8vIGhpZ2hsaWdodCB0aGUgc3ltYm9sIG5hbWUgaW4gdGhlIE91dGxpbmUgVmlldy5cclxuICAvL1xyXG4gIC8vICogYHN5bWJvbGAgVGhlIG51bWVyaWMgc3ltYm9sIGtpbmQgcmVjZWl2ZWQgZnJvbSB0aGUgbGFuZ3VhZ2Ugc2VydmVyLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVxdWl2YWxlbnQgc3ludGF4IHRva2VuIGtpbmQuXHJcbiAgcHVibGljIHN0YXRpYyBzeW1ib2xLaW5kVG9Ub2tlbktpbmQoc3ltYm9sOiBudW1iZXIpOiBhdG9tSWRlLlRva2VuS2luZCB7XHJcbiAgICBzd2l0Y2ggKHN5bWJvbCkge1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuQ2xhc3M6XHJcbiAgICAgICAgcmV0dXJuICd0eXBlJztcclxuICAgICAgY2FzZSBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yOlxyXG4gICAgICAgIHJldHVybiAnY29uc3RydWN0b3InO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuTWV0aG9kOlxyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuRnVuY3Rpb246XHJcbiAgICAgICAgcmV0dXJuICdtZXRob2QnO1xyXG4gICAgICBjYXNlIFN5bWJvbEtpbmQuU3RyaW5nOlxyXG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gJ3BsYWluJztcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19