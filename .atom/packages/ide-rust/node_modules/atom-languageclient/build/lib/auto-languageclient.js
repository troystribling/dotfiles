Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _net = require('net');

var net = _interopRequireWildcard(_net);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _vscodeJsonrpc = require('vscode-jsonrpc');

var rpc = _interopRequireWildcard(_vscodeJsonrpc);

var _atom = require('atom');

var _logger = require('./logger');

var _serverManager = require('./server-manager.js');

var _autocompleteAdapter = require('./adapters/autocomplete-adapter');

var _autocompleteAdapter2 = _interopRequireDefault(_autocompleteAdapter);

var _codeFormatAdapter = require('./adapters/code-format-adapter');

var _codeFormatAdapter2 = _interopRequireDefault(_codeFormatAdapter);

var _datatipAdapter = require('./adapters/datatip-adapter');

var _datatipAdapter2 = _interopRequireDefault(_datatipAdapter);

var _definitionAdapter = require('./adapters/definition-adapter');

var _definitionAdapter2 = _interopRequireDefault(_definitionAdapter);

var _documentSyncAdapter = require('./adapters/document-sync-adapter');

var _documentSyncAdapter2 = _interopRequireDefault(_documentSyncAdapter);

var _findReferencesAdapter = require('./adapters/find-references-adapter');

var _findReferencesAdapter2 = _interopRequireDefault(_findReferencesAdapter);

var _linterPushV2Adapter = require('./adapters/linter-push-v2-adapter');

var _linterPushV2Adapter2 = _interopRequireDefault(_linterPushV2Adapter);

var _notificationsAdapter = require('./adapters/notifications-adapter');

var _notificationsAdapter2 = _interopRequireDefault(_notificationsAdapter);

var _outlineViewAdapter = require('./adapters/outline-view-adapter');

var _outlineViewAdapter2 = _interopRequireDefault(_outlineViewAdapter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: AutoLanguageClient provides a simple way to have all the supported
// Atom-IDE services wired up entirely for you by just subclassing it and
// implementing startServerProcess/getGrammarScopes/getLanguageName and
// getServerName.
let AutoLanguageClient = class AutoLanguageClient {
  constructor() {
    this._disposable = new _atom.CompositeDisposable();
  }

  // Shared adapters that can take the RPC connection as required


  // You must implement these so we know how to deal with your language and server
  // -------------------------------------------------------------------------

  // Return an array of the grammar scopes you handle, e.g. [ 'source.js' ]
  getGrammarScopes() {
    throw Error('Must implement getGrammarScopes when extending AutoLanguageClient');
  }

  // Return the name of the language you support, e.g. 'JavaScript'
  getLanguageName() {
    throw Error('Must implement getLanguageName when extending AutoLanguageClient');
  }

  // Return the name of your server, e.g. 'Eclipse JDT'
  getServerName() {
    throw Error('Must implement getServerName when extending AutoLanguageClient');
  }

  // Start your server process
  startServerProcess(projectPath) {
    throw Error('Must override startServerProcess to start language server process when extending AutoLanguageClient');
  }

  // You might want to override these for different behavior
  // ---------------------------------------------------------------------------

  // Determine whether we should start a server for a given editor if we don't have one yet
  shouldStartForEditor(editor) {
    return this.getGrammarScopes().includes(editor.getGrammar().scopeName);
  }

  // Return the parameters used to initialize a client - you may want to extend capabilities
  getInitializeParams(projectPath, process) {
    return {
      processId: process.pid,
      capabilities: {},
      rootPath: projectPath
    };
  }

  // Early wire-up of listeners before initialize method is sent
  preInitialization(connection) {}

  // Late wire-up of listeners after initialize method has been sent
  postInitialization(initializationResult) {}

  // Determine whether to use ipc, stdio or socket to connect to the server
  getConnectionType() {
    const hasSocket = this.socket != null;
    return hasSocket ? 'socket' : 'stdio';
  }

  // Default implementation of the rest of the AutoLanguageClient
  // ---------------------------------------------------------------------------

  // Activate does very little for perf reasons - hooks in via ServerManager for later 'activation'
  activate() {
    this.name = `${this.getLanguageName()} (${this.getServerName()})`;
    this.logger = this.getLogger();
    this._serverManager = new _serverManager.ServerManager(p => this.startServer(p), this.logger, e => this.shouldStartForEditor(e));
  }

  // Deactivate disposes the resources we're using
  deactivate() {
    this._disposable.dispose();
    this._serverManager.dispose();
  }

  // By default LSP logging is switched off but you can switch it on via the core.debugLSP setting
  getLogger() {
    return atom.config.get('core.debugLSP') ? new _logger.ConsoleLogger(this.name) : new _logger.NullLogger();
  }

  // Starts the server by starting the process, then initializing the language server and starting adapters
  startServer(projectPath) {
    var _this = this;

    return _asyncToGenerator(function* () {
      const process = yield _this.startServerProcess(projectPath);
      const connection = new ls.LanguageClientConnection(_this.createRpcConnection(process), _this.logger);
      _this.preInitialization(connection);
      const initializeParams = _this.getInitializeParams(projectPath, process);
      const initializeResponse = yield connection.initialize(initializeParams);
      const newServer = {
        projectPath,
        process,
        connection,
        capabilities: initializeResponse.capabilities,
        disposable: new _atom.CompositeDisposable()
      };
      _this.postInitialization(newServer);
      _this.startExclusiveAdapters(newServer);
      return newServer;
    })();
  }

  // Creates the RPC connection which can be ipc, socket or stdio
  createRpcConnection(process) {
    let reader, writer;
    const connectionType = this.getConnectionType();

    switch (connectionType) {
      case 'ipc':
        reader = new rpc.IPCMessageReader(process);
        writer = new rpc.IPCMessageWriter(process);
        break;
      case 'socket':
        reader = new rpc.SocketMessageReader(this.socket);
        writer = new rpc.SocketMessageWriter(this.socket);
        break;
      case 'stdio':
        reader = new rpc.StreamMessageReader(process.stdout);
        writer = new rpc.StreamMessageWriter(process.stdin);
        break;
      default:
        throw new Error(`Unknown RPC connection type '${connectionType}' - must be 'ipc', 'socket' or 'stdio'`);
    }
    return rpc.createMessageConnection(reader, writer, { error: m => {
        this.logger.error(m);
      } });
  }

  // Start adapters that are not shared between servers
  startExclusiveAdapters(server) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      _notificationsAdapter2.default.attach(server.connection, _this2.name);

      if (_documentSyncAdapter2.default.canAdapt(server.capabilities)) {
        server.disposable.add(new _documentSyncAdapter2.default(server.connection, server.capabilities.textDocumentSync, function (editor) {
          return _this2.shouldSyncForEditor(editor, server.projectPath);
        }));
      }

      server.linterPushV2 = new _linterPushV2Adapter2.default(server.connection);
      if (_this2._linterDelegate != null) {
        server.linterPushV2.attach(_this2._linterDelegate);
      }
    })();
  }

  shouldSyncForEditor(editor, projectPath) {
    return this.isFileInProject(editor, projectPath) && this.shouldStartForEditor(editor);
  }

  isFileInProject(editor, projectPath) {
    return (editor.getURI() || '').startsWith(projectPath);
  }

  // Atom Autocomplete+ via LS completion---------------------------------------
  provideAutocomplete() {
    return {
      selector: this.getGrammarScopes().map(g => '.' + g).join(', '),
      excludeLowerPriority: false,
      getSuggestions: this.getSuggestions.bind(this)
    };
  }

  getSuggestions(request) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      const server = yield _this3._serverManager.getServer(request.editor);
      if (server == null || !_autocompleteAdapter2.default.canAdapt(server.capabilities)) {
        return [];
      }

      _this3.autoComplete = _this3.autoComplete || new _autocompleteAdapter2.default();
      return _this3.autoComplete.getSuggestions(server.connection, request);
    })();
  }

  // Definitions via LS documentHighlight and gotoDefinition------------
  provideDefinitions() {
    return {
      name: this.name,
      priority: 20,
      grammarScopes: this.getGrammarScopes(),
      getDefinition: this.getDefinition.bind(this)
    };
  }

  getDefinition(editor, point) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      const server = yield _this4._serverManager.getServer(editor);
      if (server == null || !_definitionAdapter2.default.canAdapt(server.capabilities)) {
        return null;
      }

      _this4.definitions = _this4.definitions || new _definitionAdapter2.default();
      return _this4.definitions.getDefinition(server.connection, server.capabilities, _this4.getLanguageName(), editor, point);
    })();
  }

  // Outline View via LS documentSymbol---------------------------------
  provideOutlines() {
    return {
      name: this.name,
      grammarScopes: this.getGrammarScopes(),
      priority: 1,
      getOutline: this.getOutline.bind(this)
    };
  }

  getOutline(editor) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      const server = yield _this5._serverManager.getServer(editor);
      if (server == null || !_outlineViewAdapter2.default.canAdapt(server.capabilities)) {
        return null;
      }

      _this5.outlineView = _this5.outlineView || new _outlineViewAdapter2.default();
      return _this5.outlineView.getOutline(server.connection, editor);
    })();
  }

  // Linter push v2 API via LS publishDiagnostics
  consumeLinterV2(registerIndie) {
    this._linterDelegate = registerIndie({ name: this.name });
    if (this._linterDelegate == null) return;

    for (var server of this._serverManager.getActiveServers()) {
      if (server.linterPushV2 != null) {
        server.linterPushV2.attach(this._linterDelegate);
      }
    }
  }

  // Find References via LS findReferences------------------------------
  provideFindReferences() {
    return {
      isEditorSupported: editor => this.getGrammarScopes().includes(editor.getGrammar().scopeName),
      findReferences: this.getReferences.bind(this)
    };
  }

  getReferences(editor, point) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      const server = yield _this6._serverManager.getServer(editor);
      if (server == null || !_findReferencesAdapter2.default.canAdapt(server.capabilities)) {
        return null;
      }

      _this6.findReferences = _this6.findReferences || new _findReferencesAdapter2.default();
      return _this6.findReferences.getReferences(server.connection, editor, point, server.projectPath);
    })();
  }

  // Datatip via LS textDocument/hover----------------------------------
  consumeDatatip(service) {
    this._disposable.add(service.addProvider({
      providerName: this.name,
      priority: 1,
      grammarScopes: this.getGrammarScopes(),
      validForScope: scopeName => {
        return this.getGrammarScopes().includes(scopeName);
      },
      datatip: this.getDatatip.bind(this)
    }));
  }

  getDatatip(editor, point) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      const server = yield _this7._serverManager.getServer(editor);
      if (server == null || !_datatipAdapter2.default.canAdapt(server.capabilities)) {
        return null;
      }

      _this7.datatip = _this7.datatip || new _datatipAdapter2.default();
      return _this7.datatip.getDatatip(server.connection, editor, point);
    })();
  }

  // Code Format via LS formatDocument & formatDocumentRange------------
  provideCodeFormat() {
    return {
      selector: this.getGrammarScopes().join(', '),
      inclusionPriority: 1,
      formatCode: this.getCodeFormat.bind(this)
    };
  }

  getCodeFormat(editor, range) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      const server = yield _this8._serverManager.getServer(editor);
      if (server == null || !_codeFormatAdapter2.default.canAdapt(server.capabilities)) {
        return [];
      }

      return _codeFormatAdapter2.default.format(server.connection, server.capabilities, editor, range);
    })();
  }
};
exports.default = AutoLanguageClient;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9hdXRvLWxhbmd1YWdlY2xpZW50LmpzIl0sIm5hbWVzIjpbIm5ldCIsImxzIiwicnBjIiwiQXV0b0xhbmd1YWdlQ2xpZW50IiwiX2Rpc3Bvc2FibGUiLCJnZXRHcmFtbWFyU2NvcGVzIiwiRXJyb3IiLCJnZXRMYW5ndWFnZU5hbWUiLCJnZXRTZXJ2ZXJOYW1lIiwic3RhcnRTZXJ2ZXJQcm9jZXNzIiwicHJvamVjdFBhdGgiLCJzaG91bGRTdGFydEZvckVkaXRvciIsImVkaXRvciIsImluY2x1ZGVzIiwiZ2V0R3JhbW1hciIsInNjb3BlTmFtZSIsImdldEluaXRpYWxpemVQYXJhbXMiLCJwcm9jZXNzIiwicHJvY2Vzc0lkIiwicGlkIiwiY2FwYWJpbGl0aWVzIiwicm9vdFBhdGgiLCJwcmVJbml0aWFsaXphdGlvbiIsImNvbm5lY3Rpb24iLCJwb3N0SW5pdGlhbGl6YXRpb24iLCJpbml0aWFsaXphdGlvblJlc3VsdCIsImdldENvbm5lY3Rpb25UeXBlIiwiaGFzU29ja2V0Iiwic29ja2V0IiwiYWN0aXZhdGUiLCJuYW1lIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiX3NlcnZlck1hbmFnZXIiLCJwIiwic3RhcnRTZXJ2ZXIiLCJlIiwiZGVhY3RpdmF0ZSIsImRpc3Bvc2UiLCJhdG9tIiwiY29uZmlnIiwiZ2V0IiwiTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uIiwiY3JlYXRlUnBjQ29ubmVjdGlvbiIsImluaXRpYWxpemVQYXJhbXMiLCJpbml0aWFsaXplUmVzcG9uc2UiLCJpbml0aWFsaXplIiwibmV3U2VydmVyIiwiZGlzcG9zYWJsZSIsInN0YXJ0RXhjbHVzaXZlQWRhcHRlcnMiLCJyZWFkZXIiLCJ3cml0ZXIiLCJjb25uZWN0aW9uVHlwZSIsIklQQ01lc3NhZ2VSZWFkZXIiLCJJUENNZXNzYWdlV3JpdGVyIiwiU29ja2V0TWVzc2FnZVJlYWRlciIsIlNvY2tldE1lc3NhZ2VXcml0ZXIiLCJTdHJlYW1NZXNzYWdlUmVhZGVyIiwic3Rkb3V0IiwiU3RyZWFtTWVzc2FnZVdyaXRlciIsInN0ZGluIiwiY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24iLCJlcnJvciIsIm0iLCJzZXJ2ZXIiLCJhdHRhY2giLCJjYW5BZGFwdCIsImFkZCIsInRleHREb2N1bWVudFN5bmMiLCJzaG91bGRTeW5jRm9yRWRpdG9yIiwibGludGVyUHVzaFYyIiwiX2xpbnRlckRlbGVnYXRlIiwiaXNGaWxlSW5Qcm9qZWN0IiwiZ2V0VVJJIiwic3RhcnRzV2l0aCIsInByb3ZpZGVBdXRvY29tcGxldGUiLCJzZWxlY3RvciIsIm1hcCIsImciLCJqb2luIiwiZXhjbHVkZUxvd2VyUHJpb3JpdHkiLCJnZXRTdWdnZXN0aW9ucyIsImJpbmQiLCJyZXF1ZXN0IiwiZ2V0U2VydmVyIiwiYXV0b0NvbXBsZXRlIiwicHJvdmlkZURlZmluaXRpb25zIiwicHJpb3JpdHkiLCJncmFtbWFyU2NvcGVzIiwiZ2V0RGVmaW5pdGlvbiIsInBvaW50IiwiZGVmaW5pdGlvbnMiLCJwcm92aWRlT3V0bGluZXMiLCJnZXRPdXRsaW5lIiwib3V0bGluZVZpZXciLCJjb25zdW1lTGludGVyVjIiLCJyZWdpc3RlckluZGllIiwiZ2V0QWN0aXZlU2VydmVycyIsInByb3ZpZGVGaW5kUmVmZXJlbmNlcyIsImlzRWRpdG9yU3VwcG9ydGVkIiwiZmluZFJlZmVyZW5jZXMiLCJnZXRSZWZlcmVuY2VzIiwiY29uc3VtZURhdGF0aXAiLCJzZXJ2aWNlIiwiYWRkUHJvdmlkZXIiLCJwcm92aWRlck5hbWUiLCJ2YWxpZEZvclNjb3BlIiwiZGF0YXRpcCIsImdldERhdGF0aXAiLCJwcm92aWRlQ29kZUZvcm1hdCIsImluY2x1c2lvblByaW9yaXR5IiwiZm9ybWF0Q29kZSIsImdldENvZGVGb3JtYXQiLCJyYW5nZSIsImZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7SUFBWUEsRzs7QUFDWjs7SUFBWUMsRTs7QUFDWjs7SUFBWUMsRzs7QUFDWjs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7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RSxNQUE5QixDQUFyQjtBQUNBLFVBQUlvRCxVQUFVLElBQVYsSUFBa0IsQ0FBQyx5QkFBZUUsUUFBZixDQUF3QkYsT0FBTzVDLFlBQS9CLENBQXZCLEVBQXFFO0FBQUUsZUFBTyxJQUFQO0FBQWM7O0FBRXJGLGFBQUt1RixPQUFMLEdBQWUsT0FBS0EsT0FBTCxJQUFnQiw4QkFBL0I7QUFDQSxhQUFPLE9BQUtBLE9BQUwsQ0FBYUMsVUFBYixDQUF3QjVDLE9BQU96QyxVQUEvQixFQUEyQ1gsTUFBM0MsRUFBbUQ4RSxLQUFuRCxDQUFQO0FBTHNGO0FBTXZGOztBQUVEO0FBQ0FtQixzQkFBZ0Q7QUFDOUMsV0FBTztBQUNMakMsZ0JBQVUsS0FBS3ZFLGdCQUFMLEdBQXdCMEUsSUFBeEIsQ0FBNkIsSUFBN0IsQ0FETDtBQUVMK0IseUJBQW1CLENBRmQ7QUFHTEMsa0JBQVksS0FBS0MsYUFBTCxDQUFtQjlCLElBQW5CLENBQXdCLElBQXhCO0FBSFAsS0FBUDtBQUtEOztBQUVLOEIsZUFBTixDQUFvQnBHLE1BQXBCLEVBQTZDcUcsS0FBN0MsRUFBa0c7QUFBQTs7QUFBQTtBQUNoRyxZQUFNakQsU0FBUyxNQUFNLE9BQUsvQixjQUFMLENBQW9CbUQsU0FBcEIsQ0FBOEJ4RSxNQUE5QixDQUFyQjtBQUNBLFVBQUlvRCxVQUFVLElBQVYsSUFBa0IsQ0FBQyw0QkFBa0JFLFFBQWxCLENBQTJCRixPQUFPNUMsWUFBbEMsQ0FBdkIsRUFBd0U7QUFBRSxlQUFPLEVBQVA7QUFBWTs7QUFFdEYsYUFBTyw0QkFBa0I4RixNQUFsQixDQUF5QmxELE9BQU96QyxVQUFoQyxFQUE0Q3lDLE9BQU81QyxZQUFuRCxFQUFpRVIsTUFBakUsRUFBeUVxRyxLQUF6RSxDQUFQO0FBSmdHO0FBS2pHO0FBbFJxQyxDO2tCQUFuQjlHLGtCIiwiZmlsZSI6ImF1dG8tbGFuZ3VhZ2VjbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBuZXQgZnJvbSAnbmV0JztcbmltcG9ydCAqIGFzIGxzIGZyb20gJy4vbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0ICogYXMgcnBjIGZyb20gJ3ZzY29kZS1qc29ucnBjJztcbmltcG9ydCB7Q29tcG9zaXRlRGlzcG9zYWJsZX0gZnJvbSAnYXRvbSc7XG5pbXBvcnQge0NvbnNvbGVMb2dnZXIsIE51bGxMb2dnZXIsIHR5cGUgTG9nZ2VyfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge1NlcnZlck1hbmFnZXIsIHR5cGUgQWN0aXZlU2VydmVyfSBmcm9tICcuL3NlcnZlci1tYW5hZ2VyLmpzJztcblxuaW1wb3J0IEF1dG9jb21wbGV0ZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9hdXRvY29tcGxldGUtYWRhcHRlcic7XG5pbXBvcnQgQ29kZUZvcm1hdEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9jb2RlLWZvcm1hdC1hZGFwdGVyJztcbmltcG9ydCBEYXRhdGlwQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2RhdGF0aXAtYWRhcHRlcic7XG5pbXBvcnQgRGVmaW5pdGlvbkFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9kZWZpbml0aW9uLWFkYXB0ZXInO1xuaW1wb3J0IERvY3VtZW50U3luY0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9kb2N1bWVudC1zeW5jLWFkYXB0ZXInO1xuaW1wb3J0IEZpbmRSZWZlcmVuY2VzQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2ZpbmQtcmVmZXJlbmNlcy1hZGFwdGVyJztcbmltcG9ydCBMaW50ZXJQdXNoVjJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvbGludGVyLXB1c2gtdjItYWRhcHRlcic7XG5pbXBvcnQgTm90aWZpY2F0aW9uc0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9ub3RpZmljYXRpb25zLWFkYXB0ZXInO1xuaW1wb3J0IE91dGxpbmVWaWV3QWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL291dGxpbmUtdmlldy1hZGFwdGVyJztcblxudHlwZSBDb25uZWN0aW9uVHlwZSA9ICdzdGRpbycgfCAnc29ja2V0JyB8ICdpcGMnO1xuXG4vLyBQdWJsaWM6IEF1dG9MYW5ndWFnZUNsaWVudCBwcm92aWRlcyBhIHNpbXBsZSB3YXkgdG8gaGF2ZSBhbGwgdGhlIHN1cHBvcnRlZFxuLy8gQXRvbS1JREUgc2VydmljZXMgd2lyZWQgdXAgZW50aXJlbHkgZm9yIHlvdSBieSBqdXN0IHN1YmNsYXNzaW5nIGl0IGFuZFxuLy8gaW1wbGVtZW50aW5nIHN0YXJ0U2VydmVyUHJvY2Vzcy9nZXRHcmFtbWFyU2NvcGVzL2dldExhbmd1YWdlTmFtZSBhbmRcbi8vIGdldFNlcnZlck5hbWUuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvTGFuZ3VhZ2VDbGllbnQge1xuICBfZGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gIF9zZXJ2ZXJNYW5hZ2VyOiBTZXJ2ZXJNYW5hZ2VyO1xuICBfbGludGVyRGVsZWdhdGU6IGxpbnRlciRWMkluZGllRGVsZWdhdGU7XG5cbiAgbG9nZ2VyOiBMb2dnZXI7XG4gIG5hbWU6IHN0cmluZztcbiAgc29ja2V0OiBuZXQkU29ja2V0O1xuXG4gIC8vIFNoYXJlZCBhZGFwdGVycyB0aGF0IGNhbiB0YWtlIHRoZSBSUEMgY29ubmVjdGlvbiBhcyByZXF1aXJlZFxuICBhdXRvQ29tcGxldGU6ID9BdXRvY29tcGxldGVBZGFwdGVyO1xuICBkYXRhdGlwOiA/RGF0YXRpcEFkYXB0ZXI7XG4gIGRlZmluaXRpb25zOiA/RGVmaW5pdGlvbkFkYXB0ZXI7XG4gIGZpbmRSZWZlcmVuY2VzOiA/RmluZFJlZmVyZW5jZXNBZGFwdGVyO1xuICBvdXRsaW5lVmlldzogP091dGxpbmVWaWV3QWRhcHRlcjtcblxuICAvLyBZb3UgbXVzdCBpbXBsZW1lbnQgdGhlc2Ugc28gd2Uga25vdyBob3cgdG8gZGVhbCB3aXRoIHlvdXIgbGFuZ3VhZ2UgYW5kIHNlcnZlclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV0dXJuIGFuIGFycmF5IG9mIHRoZSBncmFtbWFyIHNjb3BlcyB5b3UgaGFuZGxlLCBlLmcuIFsgJ3NvdXJjZS5qcycgXVxuICBnZXRHcmFtbWFyU2NvcGVzKCk6IEFycmF5PHN0cmluZz4ge1xuICAgIHRocm93IEVycm9yKCdNdXN0IGltcGxlbWVudCBnZXRHcmFtbWFyU2NvcGVzIHdoZW4gZXh0ZW5kaW5nIEF1dG9MYW5ndWFnZUNsaWVudCcpO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB5b3Ugc3VwcG9ydCwgZS5nLiAnSmF2YVNjcmlwdCdcbiAgZ2V0TGFuZ3VhZ2VOYW1lKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgRXJyb3IoJ011c3QgaW1wbGVtZW50IGdldExhbmd1YWdlTmFtZSB3aGVuIGV4dGVuZGluZyBBdXRvTGFuZ3VhZ2VDbGllbnQnKTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgbmFtZSBvZiB5b3VyIHNlcnZlciwgZS5nLiAnRWNsaXBzZSBKRFQnXG4gIGdldFNlcnZlck5hbWUoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBFcnJvcignTXVzdCBpbXBsZW1lbnQgZ2V0U2VydmVyTmFtZSB3aGVuIGV4dGVuZGluZyBBdXRvTGFuZ3VhZ2VDbGllbnQnKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IHlvdXIgc2VydmVyIHByb2Nlc3NcbiAgc3RhcnRTZXJ2ZXJQcm9jZXNzKHByb2plY3RQYXRoOiBzdHJpbmcpOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2VzcyB7XG4gICAgdGhyb3cgRXJyb3IoJ011c3Qgb3ZlcnJpZGUgc3RhcnRTZXJ2ZXJQcm9jZXNzIHRvIHN0YXJ0IGxhbmd1YWdlIHNlcnZlciBwcm9jZXNzIHdoZW4gZXh0ZW5kaW5nIEF1dG9MYW5ndWFnZUNsaWVudCcpO1xuICB9XG5cbiAgLy8gWW91IG1pZ2h0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlc2UgZm9yIGRpZmZlcmVudCBiZWhhdmlvclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciB3ZSBzaG91bGQgc3RhcnQgYSBzZXJ2ZXIgZm9yIGEgZ2l2ZW4gZWRpdG9yIGlmIHdlIGRvbid0IGhhdmUgb25lIHlldFxuICBzaG91bGRTdGFydEZvckVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEdyYW1tYXJTY29wZXMoKS5pbmNsdWRlcyhlZGl0b3IuZ2V0R3JhbW1hcigpLnNjb3BlTmFtZSk7XG4gIH1cblxuICAvLyBSZXR1cm4gdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBpbml0aWFsaXplIGEgY2xpZW50IC0geW91IG1heSB3YW50IHRvIGV4dGVuZCBjYXBhYmlsaXRpZXNcbiAgZ2V0SW5pdGlhbGl6ZVBhcmFtcyhwcm9qZWN0UGF0aDogc3RyaW5nLCBwcm9jZXNzOiBjaGlsZF9wcm9jZXNzJENoaWxkUHJvY2Vzcyk6IGxzLkluaXRpYWxpemVQYXJhbXMge1xuICAgIHJldHVybiB7XG4gICAgICBwcm9jZXNzSWQ6IHByb2Nlc3MucGlkLFxuICAgICAgY2FwYWJpbGl0aWVzOiB7IH0sXG4gICAgICByb290UGF0aDogcHJvamVjdFBhdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEVhcmx5IHdpcmUtdXAgb2YgbGlzdGVuZXJzIGJlZm9yZSBpbml0aWFsaXplIG1ldGhvZCBpcyBzZW50XG4gIHByZUluaXRpYWxpemF0aW9uKGNvbm5lY3Rpb246IGxzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbik6IHZvaWQge1xuICB9XG5cbiAgLy8gTGF0ZSB3aXJlLXVwIG9mIGxpc3RlbmVycyBhZnRlciBpbml0aWFsaXplIG1ldGhvZCBoYXMgYmVlbiBzZW50XG4gIHBvc3RJbml0aWFsaXphdGlvbihpbml0aWFsaXphdGlvblJlc3VsdDogbHMuSW5pdGlhbGl6ZVJlc3VsdCk6IHZvaWQge1xuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIGlwYywgc3RkaW8gb3Igc29ja2V0IHRvIGNvbm5lY3QgdG8gdGhlIHNlcnZlclxuICBnZXRDb25uZWN0aW9uVHlwZSgpOiBDb25uZWN0aW9uVHlwZSB7XG4gICAgY29uc3QgaGFzU29ja2V0ID0gdGhpcy5zb2NrZXQgIT0gbnVsbDtcbiAgICByZXR1cm4gaGFzU29ja2V0ID8gJ3NvY2tldCcgOiAnc3RkaW8nO1xuICB9XG5cbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcmVzdCBvZiB0aGUgQXV0b0xhbmd1YWdlQ2xpZW50XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEFjdGl2YXRlIGRvZXMgdmVyeSBsaXR0bGUgZm9yIHBlcmYgcmVhc29ucyAtIGhvb2tzIGluIHZpYSBTZXJ2ZXJNYW5hZ2VyIGZvciBsYXRlciAnYWN0aXZhdGlvbidcbiAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5uYW1lID0gYCR7dGhpcy5nZXRMYW5ndWFnZU5hbWUoKX0gKCR7dGhpcy5nZXRTZXJ2ZXJOYW1lKCl9KWA7XG4gICAgdGhpcy5sb2dnZXIgPSB0aGlzLmdldExvZ2dlcigpO1xuICAgIHRoaXMuX3NlcnZlck1hbmFnZXIgPSBuZXcgU2VydmVyTWFuYWdlcihwID0+IHRoaXMuc3RhcnRTZXJ2ZXIocCksIHRoaXMubG9nZ2VyLCBlID0+IHRoaXMuc2hvdWxkU3RhcnRGb3JFZGl0b3IoZSkpO1xuICB9XG5cbiAgLy8gRGVhY3RpdmF0ZSBkaXNwb3NlcyB0aGUgcmVzb3VyY2VzIHdlJ3JlIHVzaW5nXG4gIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5fZGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fc2VydmVyTWFuYWdlci5kaXNwb3NlKCk7XG4gIH1cblxuICAvLyBCeSBkZWZhdWx0IExTUCBsb2dnaW5nIGlzIHN3aXRjaGVkIG9mZiBidXQgeW91IGNhbiBzd2l0Y2ggaXQgb24gdmlhIHRoZSBjb3JlLmRlYnVnTFNQIHNldHRpbmdcbiAgZ2V0TG9nZ2VyKCk6IExvZ2dlciB7XG4gICAgcmV0dXJuIGF0b20uY29uZmlnLmdldCgnY29yZS5kZWJ1Z0xTUCcpID8gbmV3IENvbnNvbGVMb2dnZXIodGhpcy5uYW1lKSA6IG5ldyBOdWxsTG9nZ2VyKCk7XG4gIH1cblxuICAvLyBTdGFydHMgdGhlIHNlcnZlciBieSBzdGFydGluZyB0aGUgcHJvY2VzcywgdGhlbiBpbml0aWFsaXppbmcgdGhlIGxhbmd1YWdlIHNlcnZlciBhbmQgc3RhcnRpbmcgYWRhcHRlcnNcbiAgYXN5bmMgc3RhcnRTZXJ2ZXIocHJvamVjdFBhdGg6IHN0cmluZyk6IFByb21pc2U8QWN0aXZlU2VydmVyPiB7XG4gICAgY29uc3QgcHJvY2VzcyA9IGF3YWl0IHRoaXMuc3RhcnRTZXJ2ZXJQcm9jZXNzKHByb2plY3RQYXRoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IGxzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbih0aGlzLmNyZWF0ZVJwY0Nvbm5lY3Rpb24ocHJvY2VzcyksIHRoaXMubG9nZ2VyKTtcbiAgICB0aGlzLnByZUluaXRpYWxpemF0aW9uKGNvbm5lY3Rpb24pO1xuICAgIGNvbnN0IGluaXRpYWxpemVQYXJhbXMgPSB0aGlzLmdldEluaXRpYWxpemVQYXJhbXMocHJvamVjdFBhdGgsIHByb2Nlc3MpO1xuICAgIGNvbnN0IGluaXRpYWxpemVSZXNwb25zZSA9IGF3YWl0IGNvbm5lY3Rpb24uaW5pdGlhbGl6ZShpbml0aWFsaXplUGFyYW1zKTtcbiAgICBjb25zdCBuZXdTZXJ2ZXIgPSB7XG4gICAgICBwcm9qZWN0UGF0aCxcbiAgICAgIHByb2Nlc3MsXG4gICAgICBjb25uZWN0aW9uLFxuICAgICAgY2FwYWJpbGl0aWVzOiBpbml0aWFsaXplUmVzcG9uc2UuY2FwYWJpbGl0aWVzLFxuICAgICAgZGlzcG9zYWJsZTogbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKVxuICAgIH07XG4gICAgdGhpcy5wb3N0SW5pdGlhbGl6YXRpb24obmV3U2VydmVyKTtcbiAgICB0aGlzLnN0YXJ0RXhjbHVzaXZlQWRhcHRlcnMobmV3U2VydmVyKTtcbiAgICByZXR1cm4gbmV3U2VydmVyO1xuICB9XG5cbiAgLy8gQ3JlYXRlcyB0aGUgUlBDIGNvbm5lY3Rpb24gd2hpY2ggY2FuIGJlIGlwYywgc29ja2V0IG9yIHN0ZGlvXG4gIGNyZWF0ZVJwY0Nvbm5lY3Rpb24ocHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MpOiBycGMuQ29ubmVjdGlvbiB7XG4gICAgbGV0IHJlYWRlciwgd3JpdGVyO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25UeXBlID0gdGhpcy5nZXRDb25uZWN0aW9uVHlwZSgpO1xuXG4gICAgc3dpdGNoIChjb25uZWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSAnaXBjJzpcbiAgICAgICAgcmVhZGVyID0gbmV3IHJwYy5JUENNZXNzYWdlUmVhZGVyKHByb2Nlc3MpO1xuICAgICAgICB3cml0ZXIgPSBuZXcgcnBjLklQQ01lc3NhZ2VXcml0ZXIocHJvY2Vzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc29ja2V0JzpcbiAgICAgICAgcmVhZGVyID0gbmV3IHJwYy5Tb2NrZXRNZXNzYWdlUmVhZGVyKHRoaXMuc29ja2V0KTtcbiAgICAgICAgd3JpdGVyID0gbmV3IHJwYy5Tb2NrZXRNZXNzYWdlV3JpdGVyKHRoaXMuc29ja2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdGRpbyc6XG4gICAgICAgIHJlYWRlciA9IG5ldyBycGMuU3RyZWFtTWVzc2FnZVJlYWRlcihwcm9jZXNzLnN0ZG91dCk7XG4gICAgICAgIHdyaXRlciA9IG5ldyBycGMuU3RyZWFtTWVzc2FnZVdyaXRlcihwcm9jZXNzLnN0ZGluKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gUlBDIGNvbm5lY3Rpb24gdHlwZSAnJHtjb25uZWN0aW9uVHlwZX0nIC0gbXVzdCBiZSAnaXBjJywgJ3NvY2tldCcgb3IgJ3N0ZGlvJ2ApO1xuICAgIH1cbiAgICByZXR1cm4gcnBjLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCB7ZXJyb3I6IG0gPT4geyB0aGlzLmxvZ2dlci5lcnJvcihtKTsgfX0pO1xuICB9XG5cbiAgLy8gU3RhcnQgYWRhcHRlcnMgdGhhdCBhcmUgbm90IHNoYXJlZCBiZXR3ZWVuIHNlcnZlcnNcbiAgYXN5bmMgc3RhcnRFeGNsdXNpdmVBZGFwdGVycyhzZXJ2ZXI6IEFjdGl2ZVNlcnZlcik6IFByb21pc2U8dm9pZD4ge1xuICAgIE5vdGlmaWNhdGlvbnNBZGFwdGVyLmF0dGFjaChzZXJ2ZXIuY29ubmVjdGlvbiwgdGhpcy5uYW1lKTtcblxuICAgIGlmIChEb2N1bWVudFN5bmNBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7XG4gICAgICBzZXJ2ZXIuZGlzcG9zYWJsZS5hZGQoXG4gICAgICAgIG5ldyBEb2N1bWVudFN5bmNBZGFwdGVyKHNlcnZlci5jb25uZWN0aW9uLCBzZXJ2ZXIuY2FwYWJpbGl0aWVzLnRleHREb2N1bWVudFN5bmMsXG4gICAgICAgICAgZWRpdG9yID0+IHRoaXMuc2hvdWxkU3luY0ZvckVkaXRvcihlZGl0b3IsIHNlcnZlci5wcm9qZWN0UGF0aCkpKTtcbiAgICB9XG5cbiAgICBzZXJ2ZXIubGludGVyUHVzaFYyID0gbmV3IExpbnRlclB1c2hWMkFkYXB0ZXIoc2VydmVyLmNvbm5lY3Rpb24pO1xuICAgIGlmICh0aGlzLl9saW50ZXJEZWxlZ2F0ZSAhPSBudWxsKSB7XG4gICAgICBzZXJ2ZXIubGludGVyUHVzaFYyLmF0dGFjaCh0aGlzLl9saW50ZXJEZWxlZ2F0ZSk7XG4gICAgfVxuICB9XG5cbiAgc2hvdWxkU3luY0ZvckVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcHJvamVjdFBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRmlsZUluUHJvamVjdChlZGl0b3IsIHByb2plY3RQYXRoKSAmJiB0aGlzLnNob3VsZFN0YXJ0Rm9yRWRpdG9yKGVkaXRvcik7XG4gIH1cblxuICBpc0ZpbGVJblByb2plY3QoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHByb2plY3RQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKGVkaXRvci5nZXRVUkkoKSB8fCAnJykuc3RhcnRzV2l0aChwcm9qZWN0UGF0aCk7XG4gIH1cblxuICAvLyBBdG9tIEF1dG9jb21wbGV0ZSsgdmlhIExTIGNvbXBsZXRpb24tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHJvdmlkZUF1dG9jb21wbGV0ZSgpOiBhdG9tJEF1dG9jb21wbGV0ZVByb3ZpZGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0b3I6IHRoaXMuZ2V0R3JhbW1hclNjb3BlcygpLm1hcChnID0+ICcuJyArIGcpLmpvaW4oJywgJyksXG4gICAgICBleGNsdWRlTG93ZXJQcmlvcml0eTogZmFsc2UsXG4gICAgICBnZXRTdWdnZXN0aW9uczogdGhpcy5nZXRTdWdnZXN0aW9ucy5iaW5kKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRTdWdnZXN0aW9ucyhyZXF1ZXN0OiBhdG9tJEF1dG9jb21wbGV0ZVJlcXVlc3QpOiBQcm9taXNlPEFycmF5PGF0b20kQXV0b2NvbXBsZXRlU3VnZ2VzdGlvbj4+IHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmdldFNlcnZlcihyZXF1ZXN0LmVkaXRvcik7XG4gICAgaWYgKHNlcnZlciA9PSBudWxsIHx8ICFBdXRvY29tcGxldGVBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpICkgeyByZXR1cm4gW107IH1cblxuICAgIHRoaXMuYXV0b0NvbXBsZXRlID0gdGhpcy5hdXRvQ29tcGxldGUgfHwgbmV3IEF1dG9jb21wbGV0ZUFkYXB0ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5hdXRvQ29tcGxldGUuZ2V0U3VnZ2VzdGlvbnMoc2VydmVyLmNvbm5lY3Rpb24sIHJlcXVlc3QpO1xuICB9XG5cbiAgLy8gRGVmaW5pdGlvbnMgdmlhIExTIGRvY3VtZW50SGlnaGxpZ2h0IGFuZCBnb3RvRGVmaW5pdGlvbi0tLS0tLS0tLS0tLVxuICBwcm92aWRlRGVmaW5pdGlvbnMoKTogbnVjbGlkZSREZWZpbml0aW9uUHJvdmlkZXIge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBwcmlvcml0eTogMjAsXG4gICAgICBncmFtbWFyU2NvcGVzOiB0aGlzLmdldEdyYW1tYXJTY29wZXMoKSxcbiAgICAgIGdldERlZmluaXRpb246IHRoaXMuZ2V0RGVmaW5pdGlvbi5iaW5kKHRoaXMpXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldERlZmluaXRpb24oZWRpdG9yOiBUZXh0RWRpdG9yLCBwb2ludDogYXRvbSRQb2ludCk6IFByb21pc2U8P251Y2xpZGUkRGVmaW5pdGlvblF1ZXJ5UmVzdWx0PiB7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcbiAgICBpZiAoc2VydmVyID09IG51bGwgfHwgIURlZmluaXRpb25BZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICB0aGlzLmRlZmluaXRpb25zID0gdGhpcy5kZWZpbml0aW9ucyB8fCBuZXcgRGVmaW5pdGlvbkFkYXB0ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5kZWZpbml0aW9ucy5nZXREZWZpbml0aW9uKHNlcnZlci5jb25uZWN0aW9uLCBzZXJ2ZXIuY2FwYWJpbGl0aWVzLCB0aGlzLmdldExhbmd1YWdlTmFtZSgpLCBlZGl0b3IsIHBvaW50KTtcbiAgfVxuXG4gIC8vIE91dGxpbmUgVmlldyB2aWEgTFMgZG9jdW1lbnRTeW1ib2wtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHJvdmlkZU91dGxpbmVzKCk6IG51Y2xpZGUkT3V0bGluZVByb3ZpZGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgZ3JhbW1hclNjb3BlczogdGhpcy5nZXRHcmFtbWFyU2NvcGVzKCksXG4gICAgICBwcmlvcml0eTogMSxcbiAgICAgIGdldE91dGxpbmU6IHRoaXMuZ2V0T3V0bGluZS5iaW5kKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRPdXRsaW5lKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKTogUHJvbWlzZTw/bnVjbGlkZSRPdXRsaW5lPiB7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcbiAgICBpZiAoc2VydmVyID09IG51bGwgfHwgIU91dGxpbmVWaWV3QWRhcHRlci5jYW5BZGFwdChzZXJ2ZXIuY2FwYWJpbGl0aWVzKSkgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgdGhpcy5vdXRsaW5lVmlldyA9IHRoaXMub3V0bGluZVZpZXcgfHwgbmV3IE91dGxpbmVWaWV3QWRhcHRlcigpO1xuICAgIHJldHVybiB0aGlzLm91dGxpbmVWaWV3LmdldE91dGxpbmUoc2VydmVyLmNvbm5lY3Rpb24sIGVkaXRvcik7XG4gIH1cblxuICAvLyBMaW50ZXIgcHVzaCB2MiBBUEkgdmlhIExTIHB1Ymxpc2hEaWFnbm9zdGljc1xuICBjb25zdW1lTGludGVyVjIocmVnaXN0ZXJJbmRpZTogKCkgPT4gbGludGVyJFYySW5kaWVEZWxlZ2F0ZSk6IHZvaWQge1xuICAgIHRoaXMuX2xpbnRlckRlbGVnYXRlID0gcmVnaXN0ZXJJbmRpZSh7bmFtZTogdGhpcy5uYW1lfSk7XG4gICAgaWYgKHRoaXMuX2xpbnRlckRlbGVnYXRlID09IG51bGwpIHJldHVybjtcblxuICAgIGZvciAodmFyIHNlcnZlciBvZiB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmdldEFjdGl2ZVNlcnZlcnMoKSkge1xuICAgICAgaWYgKHNlcnZlci5saW50ZXJQdXNoVjIgIT0gbnVsbCkge1xuICAgICAgICBzZXJ2ZXIubGludGVyUHVzaFYyLmF0dGFjaCh0aGlzLl9saW50ZXJEZWxlZ2F0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBSZWZlcmVuY2VzIHZpYSBMUyBmaW5kUmVmZXJlbmNlcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwcm92aWRlRmluZFJlZmVyZW5jZXMoKTogbnVjbGlkZSRGaW5kUmVmZXJlbmNlc1Byb3ZpZGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNFZGl0b3JTdXBwb3J0ZWQ6IChlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikgPT4gdGhpcy5nZXRHcmFtbWFyU2NvcGVzKCkuaW5jbHVkZXMoZWRpdG9yLmdldEdyYW1tYXIoKS5zY29wZU5hbWUpLFxuICAgICAgZmluZFJlZmVyZW5jZXM6IHRoaXMuZ2V0UmVmZXJlbmNlcy5iaW5kKHRoaXMpLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBnZXRSZWZlcmVuY2VzKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLCBwb2ludDogYXRvbSRQb2ludCk6IFByb21pc2U8P251Y2xpZGUkRmluZFJlZmVyZW5jZXNSZXR1cm4+IHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBhd2FpdCB0aGlzLl9zZXJ2ZXJNYW5hZ2VyLmdldFNlcnZlcihlZGl0b3IpO1xuICAgIGlmIChzZXJ2ZXIgPT0gbnVsbCB8fCAhRmluZFJlZmVyZW5jZXNBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICB0aGlzLmZpbmRSZWZlcmVuY2VzID0gdGhpcy5maW5kUmVmZXJlbmNlcyB8fCBuZXcgRmluZFJlZmVyZW5jZXNBZGFwdGVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluZFJlZmVyZW5jZXMuZ2V0UmVmZXJlbmNlcyhzZXJ2ZXIuY29ubmVjdGlvbiwgZWRpdG9yLCBwb2ludCwgc2VydmVyLnByb2plY3RQYXRoKTtcbiAgfVxuXG4gIC8vIERhdGF0aXAgdmlhIExTIHRleHREb2N1bWVudC9ob3Zlci0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgY29uc3VtZURhdGF0aXAoc2VydmljZTogbnVjbGlkZSREYXRhdGlwU2VydmljZSk6IHZvaWQge1xuICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKHNlcnZpY2UuYWRkUHJvdmlkZXIoe1xuICAgICAgcHJvdmlkZXJOYW1lOiB0aGlzLm5hbWUsXG4gICAgICBwcmlvcml0eTogMSxcbiAgICAgIGdyYW1tYXJTY29wZXM6IHRoaXMuZ2V0R3JhbW1hclNjb3BlcygpLFxuICAgICAgdmFsaWRGb3JTY29wZTogKHNjb3BlTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyYW1tYXJTY29wZXMoKS5pbmNsdWRlcyhzY29wZU5hbWUpO1xuICAgICAgfSxcbiAgICAgIGRhdGF0aXA6IHRoaXMuZ2V0RGF0YXRpcC5iaW5kKHRoaXMpLFxuICAgIH0pKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGF0aXAoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IsIHBvaW50OiBhdG9tJFBvaW50KTogUHJvbWlzZTw/bnVjbGlkZSREYXRhdGlwPiB7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcbiAgICBpZiAoc2VydmVyID09IG51bGwgfHwgIURhdGF0aXBBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7IHJldHVybiBudWxsOyB9XG5cbiAgICB0aGlzLmRhdGF0aXAgPSB0aGlzLmRhdGF0aXAgfHwgbmV3IERhdGF0aXBBZGFwdGVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YXRpcC5nZXREYXRhdGlwKHNlcnZlci5jb25uZWN0aW9uLCBlZGl0b3IsIHBvaW50KTtcbiAgfVxuXG4gIC8vIENvZGUgRm9ybWF0IHZpYSBMUyBmb3JtYXREb2N1bWVudCAmIGZvcm1hdERvY3VtZW50UmFuZ2UtLS0tLS0tLS0tLS1cbiAgcHJvdmlkZUNvZGVGb3JtYXQoKTogbnVjbGlkZSRDb2RlRm9ybWF0UHJvdmlkZXIge1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogdGhpcy5nZXRHcmFtbWFyU2NvcGVzKCkuam9pbignLCAnKSxcbiAgICAgIGluY2x1c2lvblByaW9yaXR5OiAxLFxuICAgICAgZm9ybWF0Q29kZTogdGhpcy5nZXRDb2RlRm9ybWF0LmJpbmQodGhpcyksXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0Q29kZUZvcm1hdChlZGl0b3I6IGF0b20kVGV4dEVkaXRvciwgcmFuZ2U6IGF0b20kUmFuZ2UpOiBQcm9taXNlPEFycmF5PG51Y2xpZGUkVGV4dEVkaXQ+PiB7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5fc2VydmVyTWFuYWdlci5nZXRTZXJ2ZXIoZWRpdG9yKTtcbiAgICBpZiAoc2VydmVyID09IG51bGwgfHwgIUNvZGVGb3JtYXRBZGFwdGVyLmNhbkFkYXB0KHNlcnZlci5jYXBhYmlsaXRpZXMpKSB7IHJldHVybiBbXTsgfVxuXG4gICAgcmV0dXJuIENvZGVGb3JtYXRBZGFwdGVyLmZvcm1hdChzZXJ2ZXIuY29ubmVjdGlvbiwgc2VydmVyLmNhcGFiaWxpdGllcywgZWRpdG9yLCByYW5nZSk7XG4gIH1cbn1cbiJdfQ==