Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           Optional file length in bytes for cases where the server will not supply the
//                      Content-Length header but the value is known in advance. Without either the
//                      percentage on the callback can not be determined.
//
// Returns a {Promise} that will accept when complete.
exports.default = async function downloadFile(sourceUrl, targetFile, progressCallback, length) {
  const request = new Request(sourceUrl, {
    headers: new Headers({ 'Content-Type': 'application/octet-stream' })
  });

  const response = await fetch(request);
  if (!response.ok) {
    throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
  }

  const body = response.body;
  if (body == null) {
    throw Error('No response body');
  }

  const finalLength = length || parseInt(response.headers.get('Content-Length' || '0'), 10);
  const reader = body.getReader();
  const writer = _fs2.default.createWriteStream(targetFile);

  await streamWithProgress(finalLength, reader, writer, progressCallback);
  writer.end();
};

// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `targwriteretFile` {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.


async function streamWithProgress(length, reader, writer, progressCallback) {
  let bytesDone = 0;

  while (true) {
    const result = await reader.read();
    if (result.done) {
      if (progressCallback != null) {
        progressCallback(length, 100);
      }
      return;
    }

    const chunk = result.value;
    if (chunk == null) {
      throw Error('Empty chunk received during download');
    } else {
      writer.write(Buffer.from(chunk));
      if (progressCallback != null) {
        bytesDone += chunk.byteLength;
        const percent = length === 0 ? null : Math.floor(bytesDone / length * 100);
        progressCallback(bytesDone, percent);
      }
    }
  }
}

// Public: Progress callback function signature indicating the bytesDone and
// optional percentage when length is known.
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLmpzIl0sIm5hbWVzIjpbImRvd25sb2FkRmlsZSIsInNvdXJjZVVybCIsInRhcmdldEZpbGUiLCJwcm9ncmVzc0NhbGxiYWNrIiwibGVuZ3RoIiwicmVxdWVzdCIsIlJlcXVlc3QiLCJoZWFkZXJzIiwiSGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImJvZHkiLCJmaW5hbExlbmd0aCIsInBhcnNlSW50IiwiZ2V0IiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwid3JpdGVyIiwiY3JlYXRlV3JpdGVTdHJlYW0iLCJzdHJlYW1XaXRoUHJvZ3Jlc3MiLCJlbmQiLCJieXRlc0RvbmUiLCJyZXN1bHQiLCJyZWFkIiwiZG9uZSIsImNodW5rIiwidmFsdWUiLCJ3cml0ZSIsIkJ1ZmZlciIsImZyb20iLCJieXRlTGVuZ3RoIiwicGVyY2VudCIsIk1hdGgiLCJmbG9vciJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO2tCQUNnQixlQUFlQSxZQUFmLENBQ2RDLFNBRGMsRUFFZEMsVUFGYyxFQUdkQyxnQkFIYyxFQUlkQyxNQUpjLEVBS0M7QUFDZixRQUFNQyxVQUFVLElBQUlDLE9BQUosQ0FBWUwsU0FBWixFQUF1QjtBQUNyQ00sYUFBUyxJQUFJQyxPQUFKLENBQVksRUFBQyxnQkFBZ0IsMEJBQWpCLEVBQVo7QUFENEIsR0FBdkIsQ0FBaEI7O0FBSUEsUUFBTUMsV0FBVyxNQUFNQyxNQUFNTCxPQUFOLENBQXZCO0FBQ0EsTUFBSSxDQUFDSSxTQUFTRSxFQUFkLEVBQWtCO0FBQ2hCLFVBQU1DLE1BQU8sdUNBQXNDSCxTQUFTSSxNQUFPLElBQUdKLFNBQVNLLFVBQVcsRUFBcEYsQ0FBTjtBQUNEOztBQUVELFFBQU1DLE9BQU9OLFNBQVNNLElBQXRCO0FBQ0EsTUFBSUEsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCLFVBQU1ILE1BQU0sa0JBQU4sQ0FBTjtBQUNEOztBQUVELFFBQU1JLGNBQWNaLFVBQVVhLFNBQVNSLFNBQVNGLE9BQVQsQ0FBaUJXLEdBQWpCLENBQXFCLG9CQUFvQixHQUF6QyxDQUFULEVBQXdELEVBQXhELENBQTlCO0FBQ0EsUUFBTUMsU0FBU0osS0FBS0ssU0FBTCxFQUFmO0FBQ0EsUUFBTUMsU0FBUyxhQUFHQyxpQkFBSCxDQUFxQnBCLFVBQXJCLENBQWY7O0FBRUEsUUFBTXFCLG1CQUFtQlAsV0FBbkIsRUFBZ0NHLE1BQWhDLEVBQXdDRSxNQUF4QyxFQUFnRGxCLGdCQUFoRCxDQUFOO0FBQ0FrQixTQUFPRyxHQUFQO0FBQ0QsQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGVBQWVELGtCQUFmLENBQ0VuQixNQURGLEVBRUVlLE1BRkYsRUFHRUUsTUFIRixFQUlFbEIsZ0JBSkYsRUFLaUI7QUFDZixNQUFJc0IsWUFBWSxDQUFoQjs7QUFFQSxTQUFPLElBQVAsRUFBYTtBQUNYLFVBQU1DLFNBQVMsTUFBTVAsT0FBT1EsSUFBUCxFQUFyQjtBQUNBLFFBQUlELE9BQU9FLElBQVgsRUFBaUI7QUFDZixVQUFJekIsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCQSx5QkFBaUJDLE1BQWpCLEVBQXlCLEdBQXpCO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFVBQU15QixRQUFRSCxPQUFPSSxLQUFyQjtBQUNBLFFBQUlELFNBQVMsSUFBYixFQUFtQjtBQUNqQixZQUFNakIsTUFBTSxzQ0FBTixDQUFOO0FBQ0QsS0FGRCxNQUVPO0FBQ0xTLGFBQU9VLEtBQVAsQ0FBYUMsT0FBT0MsSUFBUCxDQUFZSixLQUFaLENBQWI7QUFDQSxVQUFJMUIsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCc0IscUJBQWFJLE1BQU1LLFVBQW5CO0FBQ0EsY0FBTUMsVUFBbUIvQixXQUFXLENBQVgsR0FBZSxJQUFmLEdBQXNCZ0MsS0FBS0MsS0FBTCxDQUFXWixZQUFZckIsTUFBWixHQUFxQixHQUFoQyxDQUEvQztBQUNBRCx5QkFBaUJzQixTQUFqQixFQUE0QlUsT0FBNUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBIiwiZmlsZSI6ImRvd25sb2FkLWZpbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuXG4vLyBQdWJsaWM6IERvd25sb2FkIGEgZmlsZSBhbmQgc3RvcmUgaXQgb24gYSBmaWxlIHN5c3RlbSB1c2luZyBzdHJlYW1pbmcgd2l0aCBhcHByb3ByaWF0ZSBwcm9ncmVzcyBjYWxsYmFjay5cbi8vXG4vLyAqIGBzb3VyY2VVcmxgICAgICAgICBVcmwgdG8gZG93bmxvYWQgZnJvbS5cbi8vICogYHRhcmdldEZpbGVgICAgICAgIEZpbGUgcGF0aCB0byBzYXZlIHRvLlxuLy8gKiBgcHJvZ3Jlc3NDYWxsYmFja2AgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGdpdmVuIGEge0J5dGVQcm9ncmVzc0NhbGxiYWNrfSBvYmplY3QgY29udGFpbmluZ1xuLy8gICAgICAgICAgICAgICAgICAgICAgYm90aCBieXRlc0RvbmUgYW5kIHBlcmNlbnQuXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBPcHRpb25hbCBmaWxlIGxlbmd0aCBpbiBieXRlcyBmb3IgY2FzZXMgd2hlcmUgdGhlIHNlcnZlciB3aWxsIG5vdCBzdXBwbHkgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICBDb250ZW50LUxlbmd0aCBoZWFkZXIgYnV0IHRoZSB2YWx1ZSBpcyBrbm93biBpbiBhZHZhbmNlLiBXaXRob3V0IGVpdGhlciB0aGVcbi8vICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRhZ2Ugb24gdGhlIGNhbGxiYWNrIGNhbiBub3QgYmUgZGV0ZXJtaW5lZC5cbi8vXG4vLyBSZXR1cm5zIGEge1Byb21pc2V9IHRoYXQgd2lsbCBhY2NlcHQgd2hlbiBjb21wbGV0ZS5cbmV4cG9ydCBkZWZhdWx0IChhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoXG4gIHNvdXJjZVVybDogc3RyaW5nLFxuICB0YXJnZXRGaWxlOiBzdHJpbmcsXG4gIHByb2dyZXNzQ2FsbGJhY2s6ID9CeXRlUHJvZ3Jlc3NDYWxsYmFjayxcbiAgbGVuZ3RoOiA/bnVtYmVyLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChzb3VyY2VVcmwsIHtcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh7J0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nfSksXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBFcnJvcihgVW5hYmxlIHRvIGRvd25sb2FkLCBzZXJ2ZXIgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgfVxuXG4gIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICBpZiAoYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknKTtcbiAgfVxuXG4gIGNvbnN0IGZpbmFsTGVuZ3RoID0gbGVuZ3RoIHx8IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcgfHwgJzAnKSwgMTApO1xuICBjb25zdCByZWFkZXIgPSBib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbSh0YXJnZXRGaWxlKTtcblxuICBhd2FpdCBzdHJlYW1XaXRoUHJvZ3Jlc3MoZmluYWxMZW5ndGgsIHJlYWRlciwgd3JpdGVyLCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgd3JpdGVyLmVuZCgpO1xufSk7XG5cbi8vIFN0cmVhbSBmcm9tIGEge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byBhIHtXcml0ZVN0cmVhbX0gd2l0aCBwcm9ncmVzcyBjYWxsYmFjay5cbi8vXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBGaWxlIGxlbmd0aCBpbiBieXRlcy5cbi8vICogYHJlYWRlcmAgICAgICAgICAgIHtSZWFkYWJsZVN0cmVhbVJlYWRlcn0gdG8gcmVhZCBmcm9tLlxuLy8gKiBgdGFyZ3dyaXRlcmV0RmlsZWAge1dyaXRlU3RyZWFtfSB0byB3cml0ZSB0by5cbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxuLy9cbi8vIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCB3aWxsIGFjY2VwdCB3aGVuIGNvbXBsZXRlLlxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtV2l0aFByb2dyZXNzKFxuICBsZW5ndGg6IG51bWJlcixcbiAgcmVhZGVyOiBSZWFkYWJsZVN0cmVhbVJlYWRlcixcbiAgd3JpdGVyOiBmcy5Xcml0ZVN0cmVhbSxcbiAgcHJvZ3Jlc3NDYWxsYmFjazogP0J5dGVQcm9ncmVzc0NhbGxiYWNrLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGxldCBieXRlc0RvbmUgPSAwO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhsZW5ndGgsIDEwMCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2h1bmsgPSByZXN1bHQudmFsdWU7XG4gICAgaWYgKGNodW5rID09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdFbXB0eSBjaHVuayByZWNlaXZlZCBkdXJpbmcgZG93bmxvYWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVyLndyaXRlKEJ1ZmZlci5mcm9tKGNodW5rKSk7XG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgIGJ5dGVzRG9uZSArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICBjb25zdCBwZXJjZW50OiA/bnVtYmVyID0gbGVuZ3RoID09PSAwID8gbnVsbCA6IE1hdGguZmxvb3IoYnl0ZXNEb25lIC8gbGVuZ3RoICogMTAwKTtcbiAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhieXRlc0RvbmUsIHBlcmNlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBQdWJsaWM6IFByb2dyZXNzIGNhbGxiYWNrIGZ1bmN0aW9uIHNpZ25hdHVyZSBpbmRpY2F0aW5nIHRoZSBieXRlc0RvbmUgYW5kXG4vLyBvcHRpb25hbCBwZXJjZW50YWdlIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxuZXhwb3J0IHR5cGUgQnl0ZVByb2dyZXNzQ2FsbGJhY2sgPSAoYnl0ZXNEb25lOiBudW1iZXIsIHBlcmNlbnQ6ID9udW1iZXIpID0+IHt9O1xuIl19