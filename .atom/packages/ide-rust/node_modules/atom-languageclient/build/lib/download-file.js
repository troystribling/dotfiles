Object.defineProperty(exports, "__esModule", {
  value: true
});

// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `targwriteretFile` {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.
let streamWithProgress = (() => {
  var _ref2 = _asyncToGenerator(function* (length, reader, writer, progressCallback) {
    let bytesDone = 0;

    while (true) {
      const result = yield reader.read();
      if (result.done) {
        if (progressCallback != null) {
          progressCallback(length, 100);
        }
        return;
      }

      const chunk = result.value;
      if (chunk == null) {
        throw Error('Empty chunk received during download');
      } else {
        writer.write(Buffer.from(chunk));
        if (progressCallback != null) {
          bytesDone += chunk.byteLength;
          const percent = length === 0 ? null : Math.floor(bytesDone / length * 100);
          progressCallback(bytesDone, percent);
        }
      }
    }
  });

  return function streamWithProgress(_x5, _x6, _x7, _x8) {
    return _ref2.apply(this, arguments);
  };
})();

// Public: Progress callback function signature indicating the bytesDone and
// optional percentage when length is known.


var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           Optional file length in bytes for cases where the server will not supply the
//                      Content-Length header but the value is known in advance. Without either the
//                      percentage on the callback can not be determined.
//
// Returns a {Promise} that will accept when complete.
exports.default = (() => {
  var _ref = _asyncToGenerator(function* (sourceUrl, targetFile, progressCallback, length) {
    const request = new Request(sourceUrl, {
      headers: new Headers({ 'Content-Type': 'application/octet-stream' })
    });

    const response = yield fetch(request);
    if (!response.ok) {
      throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
    }

    const body = response.body;
    if (body == null) {
      throw Error('No response body');
    }

    const finalLength = length || parseInt(response.headers.get('Content-Length' || '0'), 10);
    const reader = body.getReader();
    const writer = _fs2.default.createWriteStream(targetFile);

    yield streamWithProgress(finalLength, reader, writer, progressCallback);
    writer.end();
  });

  function downloadFile(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  }

  return downloadFile;
})();

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLmpzIl0sIm5hbWVzIjpbImxlbmd0aCIsInJlYWRlciIsIndyaXRlciIsInByb2dyZXNzQ2FsbGJhY2siLCJieXRlc0RvbmUiLCJyZXN1bHQiLCJyZWFkIiwiZG9uZSIsImNodW5rIiwidmFsdWUiLCJFcnJvciIsIndyaXRlIiwiQnVmZmVyIiwiZnJvbSIsImJ5dGVMZW5ndGgiLCJwZXJjZW50IiwiTWF0aCIsImZsb29yIiwic3RyZWFtV2l0aFByb2dyZXNzIiwic291cmNlVXJsIiwidGFyZ2V0RmlsZSIsInJlcXVlc3QiLCJSZXF1ZXN0IiwiaGVhZGVycyIsIkhlYWRlcnMiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiYm9keSIsImZpbmFsTGVuZ3RoIiwicGFyc2VJbnQiLCJnZXQiLCJnZXRSZWFkZXIiLCJjcmVhdGVXcml0ZVN0cmVhbSIsImVuZCIsImRvd25sb2FkRmlsZSJdLCJtYXBwaW5ncyI6Ijs7OztBQXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dDQUNBLFdBQWtDQSxNQUFsQyxFQUFrREMsTUFBbEQsRUFBZ0ZDLE1BQWhGLEVBQXdHQyxnQkFBeEcsRUFBZ0s7QUFDOUosUUFBSUMsWUFBWSxDQUFoQjs7QUFFQSxXQUFPLElBQVAsRUFBYTtBQUNYLFlBQU1DLFNBQVMsTUFBTUosT0FBT0ssSUFBUCxFQUFyQjtBQUNBLFVBQUlELE9BQU9FLElBQVgsRUFBaUI7QUFDZixZQUFJSixvQkFBb0IsSUFBeEIsRUFBOEI7QUFDNUJBLDJCQUFpQkgsTUFBakIsRUFBeUIsR0FBekI7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsWUFBTVEsUUFBUUgsT0FBT0ksS0FBckI7QUFDQSxVQUFJRCxTQUFTLElBQWIsRUFBbUI7QUFDakIsY0FBTUUsTUFBTSxzQ0FBTixDQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0xSLGVBQU9TLEtBQVAsQ0FBYUMsT0FBT0MsSUFBUCxDQUFZTCxLQUFaLENBQWI7QUFDQSxZQUFJTCxvQkFBb0IsSUFBeEIsRUFBOEI7QUFDNUJDLHVCQUFhSSxNQUFNTSxVQUFuQjtBQUNBLGdCQUFNQyxVQUFtQmYsV0FBVyxDQUFYLEdBQWUsSUFBZixHQUFzQmdCLEtBQUtDLEtBQUwsQ0FBV2IsWUFBWUosTUFBWixHQUFxQixHQUFoQyxDQUEvQztBQUNBRywyQkFBaUJDLFNBQWpCLEVBQTRCVyxPQUE1QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEc7O2tCQXhCY0csa0I7Ozs7O0FBMEJmO0FBQ0E7OztBQXhFQTs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrQkFDZSxXQUE0QkMsU0FBNUIsRUFBK0NDLFVBQS9DLEVBQW1FakIsZ0JBQW5FLEVBQTRHSCxNQUE1RyxFQUE0STtBQUN6SixVQUFNcUIsVUFBVSxJQUFJQyxPQUFKLENBQVlILFNBQVosRUFBdUI7QUFDckNJLGVBQVMsSUFBSUMsT0FBSixDQUFZLEVBQUMsZ0JBQWdCLDBCQUFqQixFQUFaO0FBRDRCLEtBQXZCLENBQWhCOztBQUlBLFVBQU1DLFdBQVcsTUFBTUMsTUFBTUwsT0FBTixDQUF2QjtBQUNBLFFBQUksQ0FBQ0ksU0FBU0UsRUFBZCxFQUFrQjtBQUNoQixZQUFNakIsTUFBTyx1Q0FBc0NlLFNBQVNHLE1BQU8sSUFBR0gsU0FBU0ksVUFBVyxFQUFwRixDQUFOO0FBQ0Q7O0FBRUQsVUFBTUMsT0FBT0wsU0FBU0ssSUFBdEI7QUFDQSxRQUFJQSxRQUFRLElBQVosRUFBa0I7QUFDaEIsWUFBTXBCLE1BQU0sa0JBQU4sQ0FBTjtBQUNEOztBQUVELFVBQU1xQixjQUFjL0IsVUFBVWdDLFNBQVNQLFNBQVNGLE9BQVQsQ0FBaUJVLEdBQWpCLENBQXFCLG9CQUFvQixHQUF6QyxDQUFULEVBQXdELEVBQXhELENBQTlCO0FBQ0EsVUFBTWhDLFNBQVM2QixLQUFLSSxTQUFMLEVBQWY7QUFDQSxVQUFNaEMsU0FBUyxhQUFHaUMsaUJBQUgsQ0FBcUJmLFVBQXJCLENBQWY7O0FBRUEsVUFBTUYsbUJBQW1CYSxXQUFuQixFQUFnQzlCLE1BQWhDLEVBQXdDQyxNQUF4QyxFQUFnREMsZ0JBQWhELENBQU47QUFDQUQsV0FBT2tDLEdBQVA7QUFDRCxHOztXQXJCNkJDLFk7Ozs7U0FBQUEsWSIsImZpbGUiOiJkb3dubG9hZC1maWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcblxuLy8gUHVibGljOiBEb3dubG9hZCBhIGZpbGUgYW5kIHN0b3JlIGl0IG9uIGEgZmlsZSBzeXN0ZW0gdXNpbmcgc3RyZWFtaW5nIHdpdGggYXBwcm9wcmlhdGUgcHJvZ3Jlc3MgY2FsbGJhY2suXG4vL1xuLy8gKiBgc291cmNlVXJsYCAgICAgICAgVXJsIHRvIGRvd25sb2FkIGZyb20uXG4vLyAqIGB0YXJnZXRGaWxlYCAgICAgICBGaWxlIHBhdGggdG8gc2F2ZSB0by5cbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxuLy8gKiBgbGVuZ3RoYCAgICAgICAgICAgT3B0aW9uYWwgZmlsZSBsZW5ndGggaW4gYnl0ZXMgZm9yIGNhc2VzIHdoZXJlIHRoZSBzZXJ2ZXIgd2lsbCBub3Qgc3VwcGx5IHRoZVxuLy8gICAgICAgICAgICAgICAgICAgICAgQ29udGVudC1MZW5ndGggaGVhZGVyIGJ1dCB0aGUgdmFsdWUgaXMga25vd24gaW4gYWR2YW5jZS4gV2l0aG91dCBlaXRoZXIgdGhlXG4vLyAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50YWdlIG9uIHRoZSBjYWxsYmFjayBjYW4gbm90IGJlIGRldGVybWluZWQuXG4vL1xuLy8gUmV0dXJucyBhIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBkb3dubG9hZEZpbGUoc291cmNlVXJsOiBzdHJpbmcsIHRhcmdldEZpbGU6IHN0cmluZywgcHJvZ3Jlc3NDYWxsYmFjazogP0J5dGVQcm9ncmVzc0NhbGxiYWNrLCBsZW5ndGg6ID9udW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHNvdXJjZVVybCwge1xuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSd9KSxcbiAgfSk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZG93bmxvYWQsIHNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICB9XG5cbiAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcignTm8gcmVzcG9uc2UgYm9keScpO1xuICB9XG5cbiAgY29uc3QgZmluYWxMZW5ndGggPSBsZW5ndGggfHwgcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoJ0NvbnRlbnQtTGVuZ3RoJyB8fCAnMCcpLCAxMCk7XG4gIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHRhcmdldEZpbGUpO1xuXG4gIGF3YWl0IHN0cmVhbVdpdGhQcm9ncmVzcyhmaW5hbExlbmd0aCwgcmVhZGVyLCB3cml0ZXIsIHByb2dyZXNzQ2FsbGJhY2spO1xuICB3cml0ZXIuZW5kKCk7XG59XG5cbi8vIFN0cmVhbSBmcm9tIGEge1JlYWRhYmxlU3RyZWFtUmVhZGVyfSB0byBhIHtXcml0ZVN0cmVhbX0gd2l0aCBwcm9ncmVzcyBjYWxsYmFjay5cbi8vXG4vLyAqIGBsZW5ndGhgICAgICAgICAgICBGaWxlIGxlbmd0aCBpbiBieXRlcy5cbi8vICogYHJlYWRlcmAgICAgICAgICAgIHtSZWFkYWJsZVN0cmVhbVJlYWRlcn0gdG8gcmVhZCBmcm9tLlxuLy8gKiBgdGFyZ3dyaXRlcmV0RmlsZWAge1dyaXRlU3RyZWFtfSB0byB3cml0ZSB0by5cbi8vICogYHByb2dyZXNzQ2FsbGJhY2tgIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBnaXZlbiBhIHtCeXRlUHJvZ3Jlc3NDYWxsYmFja30gb2JqZWN0IGNvbnRhaW5pbmdcbi8vICAgICAgICAgICAgICAgICAgICAgIGJvdGggYnl0ZXNEb25lIGFuZCBwZXJjZW50LlxuLy9cbi8vIFJldHVybnMgYSB7UHJvbWlzZX0gdGhhdCB3aWxsIGFjY2VwdCB3aGVuIGNvbXBsZXRlLlxuYXN5bmMgZnVuY3Rpb24gc3RyZWFtV2l0aFByb2dyZXNzKGxlbmd0aDogbnVtYmVyLCByZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyLCB3cml0ZXI6IGZzLldyaXRlU3RyZWFtLCBwcm9ncmVzc0NhbGxiYWNrOiA/Qnl0ZVByb2dyZXNzQ2FsbGJhY2spOiBQcm9taXNlPHZvaWQ+IHtcbiAgbGV0IGJ5dGVzRG9uZSA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGxlbmd0aCwgMTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaHVuayA9IHJlc3VsdC52YWx1ZTtcbiAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0VtcHR5IGNodW5rIHJlY2VpdmVkIGR1cmluZyBkb3dubG9hZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0ZXIud3JpdGUoQnVmZmVyLmZyb20oY2h1bmspKTtcbiAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgYnl0ZXNEb25lICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IHBlcmNlbnQ6ID9udW1iZXIgPSBsZW5ndGggPT09IDAgPyBudWxsIDogTWF0aC5mbG9vcihieXRlc0RvbmUgLyBsZW5ndGggKiAxMDApO1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKGJ5dGVzRG9uZSwgcGVyY2VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFB1YmxpYzogUHJvZ3Jlc3MgY2FsbGJhY2sgZnVuY3Rpb24gc2lnbmF0dXJlIGluZGljYXRpbmcgdGhlIGJ5dGVzRG9uZSBhbmRcbi8vIG9wdGlvbmFsIHBlcmNlbnRhZ2Ugd2hlbiBsZW5ndGggaXMga25vd24uXG5leHBvcnQgdHlwZSBCeXRlUHJvZ3Jlc3NDYWxsYmFjayA9IChieXRlc0RvbmU6IG51bWJlciwgcGVyY2VudDogP251bWJlcikgPT4ge307XG4iXX0=