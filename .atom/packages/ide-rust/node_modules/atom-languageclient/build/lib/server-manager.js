Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerManager = undefined;

require('./logger');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _convert = require('./convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Manages the language server lifecycles and their associated objects necessary
// for adapting them to Atom IDE.


// The necessary elements for a server that has started or is starting.
class ServerManager {

  constructor(startServer, logger, startForEditor, changeWatchedFileFilter, busySignalServiceGetter, languageServerName) {
    this._activeServers = [];
    this._startingServerPromises = new Map();
    this._restartCounterPerProject = new Map();
    this._stoppingServers = [];
    this._disposable = new _atom.CompositeDisposable();
    this._editorToServer = new Map();
    this._normalizedProjectPaths = [];
    this._isStarted = false;

    this._languageServerName = languageServerName;
    this._startServer = startServer;
    this._logger = logger;
    this._startForEditor = startForEditor;
    this.updateNormalizedProjectPaths();
    this._changeWatchedFileFilter = changeWatchedFileFilter;
    this._getBusySignalService = busySignalServiceGetter;
  }

  startListening() {
    if (!this._isStarted) {
      this._disposable = new _atom.CompositeDisposable();
      this._disposable.add(atom.textEditors.observe(this.observeTextEditors.bind(this)));
      this._disposable.add(atom.project.onDidChangePaths(this.projectPathsChanged.bind(this)));
      if (atom.project.onDidChangeFiles) {
        this._disposable.add(atom.project.onDidChangeFiles(this.projectFilesChanged.bind(this)));
      }
    }
  }

  stopListening() {
    if (this._isStarted) {
      this._disposable.dispose();
      this._isStarted = false;
    }
  }

  observeTextEditors(editor) {
    // Track grammar changes for opened editors
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => listener.dispose()));
    // Try to see if editor can have LS connected to it
    this._handleTextEditor(editor);
  }

  async _handleTextEditor(editor) {
    if (!this._editorToServer.has(editor)) {
      // editor hasn't been processed yet, so process it by allocating LS for it if necessary
      const server = await this.getServer(editor, { shouldStart: true });
      if (server != null) {
        // There LS for the editor (either started now and already running)
        this._editorToServer.set(editor, server);
        this._disposable.add(editor.onDidDestroy(() => {
          this._editorToServer.delete(editor);
          this.stopUnusedServers();
        }));
      }
    }
  }

  _handleGrammarChange(editor) {
    if (this._startForEditor(editor)) {
      // If editor is interesting for LS process the editor further to attempt to start LS if needed
      this._handleTextEditor(editor);
    } else {
      // Editor is not supported by the LS
      const server = this._editorToServer.get(editor);
      // If LS is running for the unsupported editor then disconnect the editor from LS and shut down LS if necessary
      if (server) {
        // LS is up for unsupported server
        if (server.docSyncAdapter) {
          const syncAdapter = server.docSyncAdapter.getEditorSyncAdapter(editor);
          if (syncAdapter) {
            // Immitate editor close to disconnect LS from the editor
            syncAdapter.didClose();
          }
        }
        // Remove editor from the cache
        this._editorToServer.delete(editor);
        // Shut down LS if it's used by any other editor
        this.stopUnusedServers();
      }
    }
  }

  getActiveServers() {
    return this._activeServers.slice();
  }

  async getServer(textEditor, { shouldStart } = { shouldStart: false }) {
    const finalProjectPath = this.determineProjectPath(textEditor);
    if (finalProjectPath == null) {
      // Files not yet saved have no path
      return null;
    }

    const foundActiveServer = this._activeServers.find(s => finalProjectPath === s.projectPath);
    if (foundActiveServer) {
      return foundActiveServer;
    }

    const startingPromise = this._startingServerPromises.get(finalProjectPath);
    if (startingPromise) {
      return startingPromise;
    }

    return shouldStart && this._startForEditor(textEditor) ? await this.startServer(finalProjectPath) : null;
  }

  async startServer(projectPath) {
    this._logger.debug(`Server starting "${projectPath}"`);
    const startingPromise = this._startServer(projectPath);
    this._startingServerPromises.set(projectPath, startingPromise);
    try {
      const startedActiveServer = await startingPromise;
      this._activeServers.push(startedActiveServer);
      this._startingServerPromises.delete(projectPath);
      this._logger.debug(`Server started "${projectPath}" (pid ${startedActiveServer.process.pid})`);
      return startedActiveServer;
    } catch (e) {
      this._startingServerPromises.delete(projectPath);
      throw e;
    }
  }

  async stopUnusedServers() {
    const usedServers = new Set(this._editorToServer.values());
    const unusedServers = this._activeServers.filter(s => !usedServers.has(s));
    if (unusedServers.length > 0) {
      this._logger.debug(`Stopping ${unusedServers.length} unused servers`);
      await Promise.all(unusedServers.map(s => this.stopServer(s)));
    }
  }

  async stopAllServers() {
    for (const [projectPath, restartCounter] of this._restartCounterPerProject) {
      clearTimeout(restartCounter.timerId);
      this._restartCounterPerProject.delete(projectPath);
    }

    await Promise.all(this._activeServers.map(s => this.stopServer(s)));
  }

  async restartAllServers() {
    this.stopListening();
    await this.stopAllServers();
    this._editorToServer = new Map();
    this.startListening();
  }

  hasServerReachedRestartLimit(server) {
    let restartCounter = this._restartCounterPerProject.get(server.projectPath);

    if (!restartCounter) {
      restartCounter = {
        restarts: 0,
        timerId: setTimeout(() => {
          this._restartCounterPerProject.delete(server.projectPath);
        }, 3 * 60 * 1000 /* 3 minutes */)
      };

      this._restartCounterPerProject.set(server.projectPath, restartCounter);
    }

    return ++restartCounter.restarts > 5;
  }

  async stopServer(server) {
    const busySignalService = this._getBusySignalService();
    const signal = busySignalService && busySignalService.reportBusy(`Stopping ${this._languageServerName} for ${_path2.default.basename(server.projectPath)}`);
    try {
      this._logger.debug(`Server stopping "${server.projectPath}"`);
      // Immediately remove the server to prevent further usage.
      // If we re-open the file after this point, we'll get a new server.
      this._activeServers.splice(this._activeServers.indexOf(server), 1);
      this._stoppingServers.push(server);
      server.disposable.dispose();
      if (server.connection.isConnected) {
        await server.connection.shutdown();
      }

      for (const [editor, mappedServer] of this._editorToServer) {
        if (mappedServer === server) {
          this._editorToServer.delete(editor);
        }
      }

      this.exitServer(server);
      this._stoppingServers.splice(this._stoppingServers.indexOf(server), 1);
    } finally {
      signal && signal.dispose();
    }
  }

  exitServer(server) {
    const pid = server.process.pid;
    try {
      if (server.connection.isConnected) {
        server.connection.exit();
        server.connection.dispose();
      }
    } finally {
      server.process.kill();
    }
    this._logger.debug(`Server stopped "${server.projectPath}" (pid ${pid})`);
  }

  terminate() {
    this._stoppingServers.forEach(server => {
      this._logger.debug(`Server terminating "${server.projectPath}"`);
      this.exitServer(server);
    });
  }

  determineProjectPath(textEditor) {
    const filePath = textEditor.getPath();
    if (filePath == null) {
      return null;
    }
    return this._normalizedProjectPaths.find(d => filePath.startsWith(d));
  }

  updateNormalizedProjectPaths() {
    this._normalizedProjectPaths = atom.project.getDirectories().map(d => this.normalizePath(d.getPath()));
  }

  normalizePath(projectPath) {
    return !projectPath.endsWith(_path2.default.sep) ? _path2.default.join(projectPath, _path2.default.sep) : projectPath;
  }

  projectPathsChanged(projectPaths) {
    const pathsSet = new Set(projectPaths.map(this.normalizePath));
    const serversToStop = this._activeServers.filter(s => !pathsSet.has(s.projectPath));
    Promise.all(serversToStop.map(s => this.stopServer(s)));
    this.updateNormalizedProjectPaths();
  }

  projectFilesChanged(fileEvents) {
    if (this._activeServers.length === 0) {
      return;
    }

    for (const activeServer of this._activeServers) {
      const changes = [];
      for (const fileEvent of fileEvents) {
        if (fileEvent.path.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.path)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[0]);
        }
        if (fileEvent.oldPath && fileEvent.oldPath.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.oldPath)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[1]);
        }
      }
      if (changes.length > 0) {
        activeServer.connection.didChangeWatchedFiles({ changes });
      }
    }
  }
}
exports.ServerManager = ServerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9zZXJ2ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJscyIsIlNlcnZlck1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0U2VydmVyIiwibG9nZ2VyIiwic3RhcnRGb3JFZGl0b3IiLCJjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlciIsImJ1c3lTaWduYWxTZXJ2aWNlR2V0dGVyIiwibGFuZ3VhZ2VTZXJ2ZXJOYW1lIiwiX2FjdGl2ZVNlcnZlcnMiLCJfc3RhcnRpbmdTZXJ2ZXJQcm9taXNlcyIsIk1hcCIsIl9yZXN0YXJ0Q291bnRlclBlclByb2plY3QiLCJfc3RvcHBpbmdTZXJ2ZXJzIiwiX2Rpc3Bvc2FibGUiLCJfZWRpdG9yVG9TZXJ2ZXIiLCJfbm9ybWFsaXplZFByb2plY3RQYXRocyIsIl9pc1N0YXJ0ZWQiLCJfbGFuZ3VhZ2VTZXJ2ZXJOYW1lIiwiX3N0YXJ0U2VydmVyIiwiX2xvZ2dlciIsIl9zdGFydEZvckVkaXRvciIsInVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMiLCJfY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIiLCJfZ2V0QnVzeVNpZ25hbFNlcnZpY2UiLCJzdGFydExpc3RlbmluZyIsImFkZCIsImF0b20iLCJ0ZXh0RWRpdG9ycyIsIm9ic2VydmUiLCJvYnNlcnZlVGV4dEVkaXRvcnMiLCJiaW5kIiwicHJvamVjdCIsIm9uRGlkQ2hhbmdlUGF0aHMiLCJwcm9qZWN0UGF0aHNDaGFuZ2VkIiwib25EaWRDaGFuZ2VGaWxlcyIsInByb2plY3RGaWxlc0NoYW5nZWQiLCJzdG9wTGlzdGVuaW5nIiwiZGlzcG9zZSIsImVkaXRvciIsImxpc3RlbmVyIiwib2JzZXJ2ZUdyYW1tYXIiLCJncmFtbWFyIiwiX2hhbmRsZUdyYW1tYXJDaGFuZ2UiLCJvbkRpZERlc3Ryb3kiLCJfaGFuZGxlVGV4dEVkaXRvciIsImhhcyIsInNlcnZlciIsImdldFNlcnZlciIsInNob3VsZFN0YXJ0Iiwic2V0IiwiZGVsZXRlIiwic3RvcFVudXNlZFNlcnZlcnMiLCJnZXQiLCJkb2NTeW5jQWRhcHRlciIsInN5bmNBZGFwdGVyIiwiZ2V0RWRpdG9yU3luY0FkYXB0ZXIiLCJkaWRDbG9zZSIsImdldEFjdGl2ZVNlcnZlcnMiLCJzbGljZSIsInRleHRFZGl0b3IiLCJmaW5hbFByb2plY3RQYXRoIiwiZGV0ZXJtaW5lUHJvamVjdFBhdGgiLCJmb3VuZEFjdGl2ZVNlcnZlciIsImZpbmQiLCJzIiwicHJvamVjdFBhdGgiLCJzdGFydGluZ1Byb21pc2UiLCJkZWJ1ZyIsInN0YXJ0ZWRBY3RpdmVTZXJ2ZXIiLCJwdXNoIiwicHJvY2VzcyIsInBpZCIsImUiLCJ1c2VkU2VydmVycyIsIlNldCIsInZhbHVlcyIsInVudXNlZFNlcnZlcnMiLCJmaWx0ZXIiLCJsZW5ndGgiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwic3RvcFNlcnZlciIsInN0b3BBbGxTZXJ2ZXJzIiwicmVzdGFydENvdW50ZXIiLCJjbGVhclRpbWVvdXQiLCJ0aW1lcklkIiwicmVzdGFydEFsbFNlcnZlcnMiLCJoYXNTZXJ2ZXJSZWFjaGVkUmVzdGFydExpbWl0IiwicmVzdGFydHMiLCJzZXRUaW1lb3V0IiwiYnVzeVNpZ25hbFNlcnZpY2UiLCJzaWduYWwiLCJyZXBvcnRCdXN5IiwiYmFzZW5hbWUiLCJzcGxpY2UiLCJpbmRleE9mIiwiZGlzcG9zYWJsZSIsImNvbm5lY3Rpb24iLCJpc0Nvbm5lY3RlZCIsInNodXRkb3duIiwibWFwcGVkU2VydmVyIiwiZXhpdFNlcnZlciIsImV4aXQiLCJraWxsIiwidGVybWluYXRlIiwiZm9yRWFjaCIsImZpbGVQYXRoIiwiZ2V0UGF0aCIsImQiLCJzdGFydHNXaXRoIiwiZ2V0RGlyZWN0b3JpZXMiLCJub3JtYWxpemVQYXRoIiwiZW5kc1dpdGgiLCJzZXAiLCJqb2luIiwicHJvamVjdFBhdGhzIiwicGF0aHNTZXQiLCJzZXJ2ZXJzVG9TdG9wIiwiZmlsZUV2ZW50cyIsImFjdGl2ZVNlcnZlciIsImNoYW5nZXMiLCJmaWxlRXZlbnQiLCJwYXRoIiwiYXRvbUZpbGVFdmVudFRvTFNGaWxlRXZlbnRzIiwib2xkUGF0aCIsImRpZENoYW5nZVdhdGNoZWRGaWxlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFQTs7QUFLQTs7OztBQUNBOztJQUFZQSxFOztBQUNaOzs7O0FBQ0E7Ozs7OztBQW1CQTtBQUNBOzs7QUFsQkE7QUFtQk8sTUFBTUMsYUFBTixDQUFvQjs7QUFnQnpCQyxjQUNFQyxXQURGLEVBRUVDLE1BRkYsRUFHRUMsY0FIRixFQUlFQyx1QkFKRixFQUtFQyx1QkFMRixFQU1FQyxrQkFORixFQU9FO0FBQUEsU0F0QkZDLGNBc0JFLEdBdEJvQyxFQXNCcEM7QUFBQSxTQXJCRkMsdUJBcUJFLEdBckI0RCxJQUFJQyxHQUFKLEVBcUI1RDtBQUFBLFNBcEJGQyx5QkFvQkUsR0FwQnVELElBQUlELEdBQUosRUFvQnZEO0FBQUEsU0FuQkZFLGdCQW1CRSxHQW5Cc0MsRUFtQnRDO0FBQUEsU0FsQkZDLFdBa0JFLEdBbEJpQywrQkFrQmpDO0FBQUEsU0FqQkZDLGVBaUJFLEdBakJvRCxJQUFJSixHQUFKLEVBaUJwRDtBQUFBLFNBZkZLLHVCQWVFLEdBZnVDLEVBZXZDO0FBQUEsU0FURkMsVUFTRSxHQVRXLEtBU1g7O0FBQ0EsU0FBS0MsbUJBQUwsR0FBMkJWLGtCQUEzQjtBQUNBLFNBQUtXLFlBQUwsR0FBb0JoQixXQUFwQjtBQUNBLFNBQUtpQixPQUFMLEdBQWVoQixNQUFmO0FBQ0EsU0FBS2lCLGVBQUwsR0FBdUJoQixjQUF2QjtBQUNBLFNBQUtpQiw0QkFBTDtBQUNBLFNBQUtDLHdCQUFMLEdBQWdDakIsdUJBQWhDO0FBQ0EsU0FBS2tCLHFCQUFMLEdBQTZCakIsdUJBQTdCO0FBQ0Q7O0FBRURrQixtQkFBdUI7QUFDckIsUUFBSSxDQUFDLEtBQUtSLFVBQVYsRUFBc0I7QUFDcEIsV0FBS0gsV0FBTCxHQUFtQiwrQkFBbkI7QUFDQSxXQUFLQSxXQUFMLENBQWlCWSxHQUFqQixDQUFxQkMsS0FBS0MsV0FBTCxDQUFpQkMsT0FBakIsQ0FBeUIsS0FBS0Msa0JBQUwsQ0FBd0JDLElBQXhCLENBQTZCLElBQTdCLENBQXpCLENBQXJCO0FBQ0EsV0FBS2pCLFdBQUwsQ0FBaUJZLEdBQWpCLENBQXFCQyxLQUFLSyxPQUFMLENBQWFDLGdCQUFiLENBQThCLEtBQUtDLG1CQUFMLENBQXlCSCxJQUF6QixDQUE4QixJQUE5QixDQUE5QixDQUFyQjtBQUNBLFVBQUlKLEtBQUtLLE9BQUwsQ0FBYUcsZ0JBQWpCLEVBQW1DO0FBQ2pDLGFBQUtyQixXQUFMLENBQWlCWSxHQUFqQixDQUFxQkMsS0FBS0ssT0FBTCxDQUFhRyxnQkFBYixDQUE4QixLQUFLQyxtQkFBTCxDQUF5QkwsSUFBekIsQ0FBOEIsSUFBOUIsQ0FBOUIsQ0FBckI7QUFDRDtBQUNGO0FBQ0Y7O0FBRURNLGtCQUFzQjtBQUNwQixRQUFJLEtBQUtwQixVQUFULEVBQXFCO0FBQ25CLFdBQUtILFdBQUwsQ0FBaUJ3QixPQUFqQjtBQUNBLFdBQUtyQixVQUFMLEdBQWtCLEtBQWxCO0FBQ0Q7QUFDRjs7QUFFRGEscUJBQW1CUyxNQUFuQixFQUFrRDtBQUNoRDtBQUNBLFVBQU1DLFdBQVdELE9BQU9FLGNBQVAsQ0FBc0JDLFdBQVcsS0FBS0Msb0JBQUwsQ0FBMEJKLE1BQTFCLENBQWpDLENBQWpCO0FBQ0EsU0FBS3pCLFdBQUwsQ0FBaUJZLEdBQWpCLENBQXFCYSxPQUFPSyxZQUFQLENBQW9CLE1BQU1KLFNBQVNGLE9BQVQsRUFBMUIsQ0FBckI7QUFDQTtBQUNBLFNBQUtPLGlCQUFMLENBQXVCTixNQUF2QjtBQUNEOztBQUVELFFBQU1NLGlCQUFOLENBQXdCTixNQUF4QixFQUFnRTtBQUM5RCxRQUFJLENBQUMsS0FBS3hCLGVBQUwsQ0FBcUIrQixHQUFyQixDQUF5QlAsTUFBekIsQ0FBTCxFQUF1QztBQUNyQztBQUNBLFlBQU1RLFNBQVMsTUFBTSxLQUFLQyxTQUFMLENBQWVULE1BQWYsRUFBdUIsRUFBQ1UsYUFBYSxJQUFkLEVBQXZCLENBQXJCO0FBQ0EsVUFBSUYsVUFBVSxJQUFkLEVBQW9CO0FBQ2xCO0FBQ0EsYUFBS2hDLGVBQUwsQ0FBcUJtQyxHQUFyQixDQUF5QlgsTUFBekIsRUFBaUNRLE1BQWpDO0FBQ0EsYUFBS2pDLFdBQUwsQ0FBaUJZLEdBQWpCLENBQ0VhLE9BQU9LLFlBQVAsQ0FBb0IsTUFBTTtBQUN4QixlQUFLN0IsZUFBTCxDQUFxQm9DLE1BQXJCLENBQTRCWixNQUE1QjtBQUNBLGVBQUthLGlCQUFMO0FBQ0QsU0FIRCxDQURGO0FBTUQ7QUFDRjtBQUNGOztBQUVEVCx1QkFBcUJKLE1BQXJCLEVBQThDO0FBQzVDLFFBQUksS0FBS2xCLGVBQUwsQ0FBcUJrQixNQUFyQixDQUFKLEVBQWtDO0FBQ2hDO0FBQ0EsV0FBS00saUJBQUwsQ0FBdUJOLE1BQXZCO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQSxZQUFNUSxTQUFTLEtBQUtoQyxlQUFMLENBQXFCc0MsR0FBckIsQ0FBeUJkLE1BQXpCLENBQWY7QUFDQTtBQUNBLFVBQUlRLE1BQUosRUFBWTtBQUNWO0FBQ0EsWUFBSUEsT0FBT08sY0FBWCxFQUEyQjtBQUN6QixnQkFBTUMsY0FBY1IsT0FBT08sY0FBUCxDQUFzQkUsb0JBQXRCLENBQTJDakIsTUFBM0MsQ0FBcEI7QUFDQSxjQUFJZ0IsV0FBSixFQUFpQjtBQUNmO0FBQ0FBLHdCQUFZRSxRQUFaO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsYUFBSzFDLGVBQUwsQ0FBcUJvQyxNQUFyQixDQUE0QlosTUFBNUI7QUFDQTtBQUNBLGFBQUthLGlCQUFMO0FBQ0Q7QUFDRjtBQUNGOztBQUVETSxxQkFBd0M7QUFDdEMsV0FBTyxLQUFLakQsY0FBTCxDQUFvQmtELEtBQXBCLEVBQVA7QUFDRDs7QUFFRCxRQUFNWCxTQUFOLENBQ0VZLFVBREYsRUFFRSxFQUFDWCxXQUFELEtBQXlDLEVBQUNBLGFBQWEsS0FBZCxFQUYzQyxFQUcwQjtBQUN4QixVQUFNWSxtQkFBbUIsS0FBS0Msb0JBQUwsQ0FBMEJGLFVBQTFCLENBQXpCO0FBQ0EsUUFBSUMsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBTUUsb0JBQW9CLEtBQUt0RCxjQUFMLENBQW9CdUQsSUFBcEIsQ0FBeUJDLEtBQUtKLHFCQUFxQkksRUFBRUMsV0FBckQsQ0FBMUI7QUFDQSxRQUFJSCxpQkFBSixFQUF1QjtBQUNyQixhQUFPQSxpQkFBUDtBQUNEOztBQUVELFVBQU1JLGtCQUFrQixLQUFLekQsdUJBQUwsQ0FBNkIyQyxHQUE3QixDQUFpQ1EsZ0JBQWpDLENBQXhCO0FBQ0EsUUFBSU0sZUFBSixFQUFxQjtBQUNuQixhQUFPQSxlQUFQO0FBQ0Q7O0FBRUQsV0FBT2xCLGVBQWUsS0FBSzVCLGVBQUwsQ0FBcUJ1QyxVQUFyQixDQUFmLEdBQWtELE1BQU0sS0FBS3pELFdBQUwsQ0FBaUIwRCxnQkFBakIsQ0FBeEQsR0FBNkYsSUFBcEc7QUFDRDs7QUFFRCxRQUFNMUQsV0FBTixDQUFrQitELFdBQWxCLEVBQThEO0FBQzVELFNBQUs5QyxPQUFMLENBQWFnRCxLQUFiLENBQW9CLG9CQUFtQkYsV0FBWSxHQUFuRDtBQUNBLFVBQU1DLGtCQUFrQixLQUFLaEQsWUFBTCxDQUFrQitDLFdBQWxCLENBQXhCO0FBQ0EsU0FBS3hELHVCQUFMLENBQTZCd0MsR0FBN0IsQ0FBaUNnQixXQUFqQyxFQUE4Q0MsZUFBOUM7QUFDQSxRQUFJO0FBQ0YsWUFBTUUsc0JBQXNCLE1BQU1GLGVBQWxDO0FBQ0EsV0FBSzFELGNBQUwsQ0FBb0I2RCxJQUFwQixDQUF5QkQsbUJBQXpCO0FBQ0EsV0FBSzNELHVCQUFMLENBQTZCeUMsTUFBN0IsQ0FBb0NlLFdBQXBDO0FBQ0EsV0FBSzlDLE9BQUwsQ0FBYWdELEtBQWIsQ0FBb0IsbUJBQWtCRixXQUFZLFVBQVNHLG9CQUFvQkUsT0FBcEIsQ0FBNEJDLEdBQUksR0FBM0Y7QUFDQSxhQUFPSCxtQkFBUDtBQUNELEtBTkQsQ0FNRSxPQUFPSSxDQUFQLEVBQVU7QUFDVixXQUFLL0QsdUJBQUwsQ0FBNkJ5QyxNQUE3QixDQUFvQ2UsV0FBcEM7QUFDQSxZQUFNTyxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNckIsaUJBQU4sR0FBeUM7QUFDdkMsVUFBTXNCLGNBQWMsSUFBSUMsR0FBSixDQUFRLEtBQUs1RCxlQUFMLENBQXFCNkQsTUFBckIsRUFBUixDQUFwQjtBQUNBLFVBQU1DLGdCQUFnQixLQUFLcEUsY0FBTCxDQUFvQnFFLE1BQXBCLENBQTJCYixLQUFLLENBQUNTLFlBQVk1QixHQUFaLENBQWdCbUIsQ0FBaEIsQ0FBakMsQ0FBdEI7QUFDQSxRQUFJWSxjQUFjRSxNQUFkLEdBQXVCLENBQTNCLEVBQThCO0FBQzVCLFdBQUszRCxPQUFMLENBQWFnRCxLQUFiLENBQW9CLFlBQVdTLGNBQWNFLE1BQU8saUJBQXBEO0FBQ0EsWUFBTUMsUUFBUUMsR0FBUixDQUFZSixjQUFjSyxHQUFkLENBQWtCakIsS0FBSyxLQUFLa0IsVUFBTCxDQUFnQmxCLENBQWhCLENBQXZCLENBQVosQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsUUFBTW1CLGNBQU4sR0FBc0M7QUFDcEMsU0FBSyxNQUFNLENBQUNsQixXQUFELEVBQWNtQixjQUFkLENBQVgsSUFBNEMsS0FBS3pFLHlCQUFqRCxFQUE0RTtBQUMxRTBFLG1CQUFhRCxlQUFlRSxPQUE1QjtBQUNBLFdBQUszRSx5QkFBTCxDQUErQnVDLE1BQS9CLENBQXNDZSxXQUF0QztBQUNEOztBQUVELFVBQU1jLFFBQVFDLEdBQVIsQ0FBWSxLQUFLeEUsY0FBTCxDQUFvQnlFLEdBQXBCLENBQXdCakIsS0FBSyxLQUFLa0IsVUFBTCxDQUFnQmxCLENBQWhCLENBQTdCLENBQVosQ0FBTjtBQUNEOztBQUVELFFBQU11QixpQkFBTixHQUF5QztBQUN2QyxTQUFLbkQsYUFBTDtBQUNBLFVBQU0sS0FBSytDLGNBQUwsRUFBTjtBQUNBLFNBQUtyRSxlQUFMLEdBQXVCLElBQUlKLEdBQUosRUFBdkI7QUFDQSxTQUFLYyxjQUFMO0FBQ0Q7O0FBRURnRSwrQkFBNkIxQyxNQUE3QixFQUFtRDtBQUNqRCxRQUFJc0MsaUJBQWlCLEtBQUt6RSx5QkFBTCxDQUErQnlDLEdBQS9CLENBQW1DTixPQUFPbUIsV0FBMUMsQ0FBckI7O0FBRUEsUUFBSSxDQUFDbUIsY0FBTCxFQUFxQjtBQUNuQkEsdUJBQWlCO0FBQ2ZLLGtCQUFVLENBREs7QUFFZkgsaUJBQVNJLFdBQVcsTUFBTTtBQUN4QixlQUFLL0UseUJBQUwsQ0FBK0J1QyxNQUEvQixDQUFzQ0osT0FBT21CLFdBQTdDO0FBQ0QsU0FGUSxFQUVOLElBQUksRUFBSixHQUFTLElBRkgsQ0FFUSxlQUZSO0FBRk0sT0FBakI7O0FBT0EsV0FBS3RELHlCQUFMLENBQStCc0MsR0FBL0IsQ0FBbUNILE9BQU9tQixXQUExQyxFQUF1RG1CLGNBQXZEO0FBQ0Q7O0FBRUQsV0FBTyxFQUFFQSxlQUFlSyxRQUFqQixHQUE0QixDQUFuQztBQUNEOztBQUVELFFBQU1QLFVBQU4sQ0FBaUJwQyxNQUFqQixFQUFzRDtBQUNwRCxVQUFNNkMsb0JBQW9CLEtBQUtwRSxxQkFBTCxFQUExQjtBQUNBLFVBQU1xRSxTQUFTRCxxQkFBcUJBLGtCQUFrQkUsVUFBbEIsQ0FDakMsWUFBVyxLQUFLNUUsbUJBQW9CLFFBQU8sZUFBSzZFLFFBQUwsQ0FBY2hELE9BQU9tQixXQUFyQixDQUFrQyxFQUQ1QyxDQUFwQztBQUdBLFFBQUk7QUFDRixXQUFLOUMsT0FBTCxDQUFhZ0QsS0FBYixDQUFvQixvQkFBbUJyQixPQUFPbUIsV0FBWSxHQUExRDtBQUNBO0FBQ0E7QUFDQSxXQUFLekQsY0FBTCxDQUFvQnVGLE1BQXBCLENBQTJCLEtBQUt2RixjQUFMLENBQW9Cd0YsT0FBcEIsQ0FBNEJsRCxNQUE1QixDQUEzQixFQUFnRSxDQUFoRTtBQUNBLFdBQUtsQyxnQkFBTCxDQUFzQnlELElBQXRCLENBQTJCdkIsTUFBM0I7QUFDQUEsYUFBT21ELFVBQVAsQ0FBa0I1RCxPQUFsQjtBQUNBLFVBQUlTLE9BQU9vRCxVQUFQLENBQWtCQyxXQUF0QixFQUFtQztBQUNqQyxjQUFNckQsT0FBT29ELFVBQVAsQ0FBa0JFLFFBQWxCLEVBQU47QUFDRDs7QUFFRCxXQUFLLE1BQU0sQ0FBQzlELE1BQUQsRUFBUytELFlBQVQsQ0FBWCxJQUFxQyxLQUFLdkYsZUFBMUMsRUFBMkQ7QUFDekQsWUFBSXVGLGlCQUFpQnZELE1BQXJCLEVBQTZCO0FBQzNCLGVBQUtoQyxlQUFMLENBQXFCb0MsTUFBckIsQ0FBNEJaLE1BQTVCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFLZ0UsVUFBTCxDQUFnQnhELE1BQWhCO0FBQ0EsV0FBS2xDLGdCQUFMLENBQXNCbUYsTUFBdEIsQ0FBNkIsS0FBS25GLGdCQUFMLENBQXNCb0YsT0FBdEIsQ0FBOEJsRCxNQUE5QixDQUE3QixFQUFvRSxDQUFwRTtBQUNELEtBbkJELFNBbUJVO0FBQ1I4QyxnQkFBVUEsT0FBT3ZELE9BQVAsRUFBVjtBQUNEO0FBQ0Y7O0FBRURpRSxhQUFXeEQsTUFBWCxFQUF1QztBQUNyQyxVQUFNeUIsTUFBTXpCLE9BQU93QixPQUFQLENBQWVDLEdBQTNCO0FBQ0EsUUFBSTtBQUNGLFVBQUl6QixPQUFPb0QsVUFBUCxDQUFrQkMsV0FBdEIsRUFBbUM7QUFDakNyRCxlQUFPb0QsVUFBUCxDQUFrQkssSUFBbEI7QUFDQXpELGVBQU9vRCxVQUFQLENBQWtCN0QsT0FBbEI7QUFDRDtBQUNGLEtBTEQsU0FLVTtBQUNSUyxhQUFPd0IsT0FBUCxDQUFla0MsSUFBZjtBQUNEO0FBQ0QsU0FBS3JGLE9BQUwsQ0FBYWdELEtBQWIsQ0FBb0IsbUJBQWtCckIsT0FBT21CLFdBQVksVUFBU00sR0FBSSxHQUF0RTtBQUNEOztBQUVEa0MsY0FBa0I7QUFDaEIsU0FBSzdGLGdCQUFMLENBQXNCOEYsT0FBdEIsQ0FBOEI1RCxVQUFVO0FBQ3RDLFdBQUszQixPQUFMLENBQWFnRCxLQUFiLENBQW9CLHVCQUFzQnJCLE9BQU9tQixXQUFZLEdBQTdEO0FBQ0EsV0FBS3FDLFVBQUwsQ0FBZ0J4RCxNQUFoQjtBQUNELEtBSEQ7QUFJRDs7QUFFRGUsdUJBQXFCRixVQUFyQixFQUEyRDtBQUN6RCxVQUFNZ0QsV0FBV2hELFdBQVdpRCxPQUFYLEVBQWpCO0FBQ0EsUUFBSUQsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixhQUFPLElBQVA7QUFDRDtBQUNELFdBQU8sS0FBSzVGLHVCQUFMLENBQTZCZ0QsSUFBN0IsQ0FBa0M4QyxLQUFLRixTQUFTRyxVQUFULENBQW9CRCxDQUFwQixDQUF2QyxDQUFQO0FBQ0Q7O0FBRUR4RixpQ0FBcUM7QUFDbkMsU0FBS04sdUJBQUwsR0FBK0JXLEtBQUtLLE9BQUwsQ0FBYWdGLGNBQWIsR0FBOEI5QixHQUE5QixDQUFrQzRCLEtBQUssS0FBS0csYUFBTCxDQUFtQkgsRUFBRUQsT0FBRixFQUFuQixDQUF2QyxDQUEvQjtBQUNEOztBQUVESSxnQkFBYy9DLFdBQWQsRUFBMkM7QUFDekMsV0FBTyxDQUFDQSxZQUFZZ0QsUUFBWixDQUFxQixlQUFLQyxHQUExQixDQUFELEdBQWtDLGVBQUtDLElBQUwsQ0FBVWxELFdBQVYsRUFBdUIsZUFBS2lELEdBQTVCLENBQWxDLEdBQXFFakQsV0FBNUU7QUFDRDs7QUFFRGhDLHNCQUFvQm1GLFlBQXBCLEVBQXVEO0FBQ3JELFVBQU1DLFdBQVcsSUFBSTNDLEdBQUosQ0FBUTBDLGFBQWFuQyxHQUFiLENBQWlCLEtBQUsrQixhQUF0QixDQUFSLENBQWpCO0FBQ0EsVUFBTU0sZ0JBQWdCLEtBQUs5RyxjQUFMLENBQW9CcUUsTUFBcEIsQ0FBMkJiLEtBQUssQ0FBQ3FELFNBQVN4RSxHQUFULENBQWFtQixFQUFFQyxXQUFmLENBQWpDLENBQXRCO0FBQ0FjLFlBQVFDLEdBQVIsQ0FBWXNDLGNBQWNyQyxHQUFkLENBQWtCakIsS0FBSyxLQUFLa0IsVUFBTCxDQUFnQmxCLENBQWhCLENBQXZCLENBQVo7QUFDQSxTQUFLM0MsNEJBQUw7QUFDRDs7QUFFRGMsc0JBQW9Cb0YsVUFBcEIsRUFBb0U7QUFDbEUsUUFBSSxLQUFLL0csY0FBTCxDQUFvQnNFLE1BQXBCLEtBQStCLENBQW5DLEVBQXNDO0FBQ3BDO0FBQ0Q7O0FBRUQsU0FBSyxNQUFNMEMsWUFBWCxJQUEyQixLQUFLaEgsY0FBaEMsRUFBZ0Q7QUFDOUMsWUFBTWlILFVBQVUsRUFBaEI7QUFDQSxXQUFLLE1BQU1DLFNBQVgsSUFBd0JILFVBQXhCLEVBQW9DO0FBQ2xDLFlBQUlHLFVBQVVDLElBQVYsQ0FBZWIsVUFBZixDQUEwQlUsYUFBYXZELFdBQXZDLEtBQXVELEtBQUszQyx3QkFBTCxDQUE4Qm9HLFVBQVVDLElBQXhDLENBQTNELEVBQTBHO0FBQ3hHRixrQkFBUXBELElBQVIsQ0FBYSxrQkFBUXVELDJCQUFSLENBQW9DRixTQUFwQyxFQUErQyxDQUEvQyxDQUFiO0FBQ0Q7QUFDRCxZQUNFQSxVQUFVRyxPQUFWLElBQ0FILFVBQVVHLE9BQVYsQ0FBa0JmLFVBQWxCLENBQTZCVSxhQUFhdkQsV0FBMUMsQ0FEQSxJQUVBLEtBQUszQyx3QkFBTCxDQUE4Qm9HLFVBQVVHLE9BQXhDLENBSEYsRUFJRTtBQUNBSixrQkFBUXBELElBQVIsQ0FBYSxrQkFBUXVELDJCQUFSLENBQW9DRixTQUFwQyxFQUErQyxDQUEvQyxDQUFiO0FBQ0Q7QUFDRjtBQUNELFVBQUlELFFBQVEzQyxNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCMEMscUJBQWF0QixVQUFiLENBQXdCNEIscUJBQXhCLENBQThDLEVBQUNMLE9BQUQsRUFBOUM7QUFDRDtBQUNGO0FBQ0Y7QUF6UndCO1FBQWR6SCxhLEdBQUFBLGEiLCJmaWxlIjoic2VydmVyLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQge3R5cGUgTG9nZ2VyfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgdHlwZSBMaW50ZXJQdXNoVjJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvbGludGVyLXB1c2gtdjItYWRhcHRlcic7XG5pbXBvcnQgdHlwZSBEb2N1bWVudFN5bmNBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvZG9jdW1lbnQtc3luYy1hZGFwdGVyJztcbmltcG9ydCB0eXBlIFNpZ25hdHVyZUhlbHBBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvc2lnbmF0dXJlLWhlbHAtYWRhcHRlcic7XG5cbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgbHMgZnJvbSAnLi9sYW5ndWFnZWNsaWVudCc7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuL2NvbnZlcnQnO1xuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdhdG9tJztcblxuLy8gVGhlIG5lY2Vzc2FyeSBlbGVtZW50cyBmb3IgYSBzZXJ2ZXIgdGhhdCBoYXMgc3RhcnRlZCBvciBpcyBzdGFydGluZy5cbmV4cG9ydCB0eXBlIEFjdGl2ZVNlcnZlciA9IHtcbiAgZGlzcG9zYWJsZTogQ29tcG9zaXRlRGlzcG9zYWJsZSxcbiAgcHJvamVjdFBhdGg6IHN0cmluZyxcbiAgcHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXG4gIGNvbm5lY3Rpb246IGxzLkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbixcbiAgY2FwYWJpbGl0aWVzOiBscy5TZXJ2ZXJDYXBhYmlsaXRpZXMsXG4gIGxpbnRlclB1c2hWMj86IExpbnRlclB1c2hWMkFkYXB0ZXIsXG4gIGRvY1N5bmNBZGFwdGVyPzogRG9jdW1lbnRTeW5jQWRhcHRlcixcbiAgc2lnbmF0dXJlSGVscEFkYXB0ZXI/OiBTaWduYXR1cmVIZWxwQWRhcHRlcixcbn07XG5cbnR5cGUgUmVzdGFydENvdW50ZXIgPSB7XG4gIHJlc3RhcnRzOiBudW1iZXI7XG4gIHRpbWVySWQ6IG51bWJlcjtcbn07XG5cbi8vIE1hbmFnZXMgdGhlIGxhbmd1YWdlIHNlcnZlciBsaWZlY3ljbGVzIGFuZCB0aGVpciBhc3NvY2lhdGVkIG9iamVjdHMgbmVjZXNzYXJ5XG4vLyBmb3IgYWRhcHRpbmcgdGhlbSB0byBBdG9tIElERS5cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJNYW5hZ2VyIHtcbiAgX2FjdGl2ZVNlcnZlcnM6IEFycmF5PEFjdGl2ZVNlcnZlcj4gPSBbXTtcbiAgX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXM6IE1hcDxzdHJpbmcsIFByb21pc2U8QWN0aXZlU2VydmVyPj4gPSBuZXcgTWFwKCk7XG4gIF9yZXN0YXJ0Q291bnRlclBlclByb2plY3Q6IE1hcDxzdHJpbmcsIFJlc3RhcnRDb3VudGVyPiA9IG5ldyBNYXAoKTtcbiAgX3N0b3BwaW5nU2VydmVyczogQXJyYXk8QWN0aXZlU2VydmVyPiA9IFtdO1xuICBfZGlzcG9zYWJsZTogQ29tcG9zaXRlRGlzcG9zYWJsZSA9IG5ldyBDb21wb3NpdGVEaXNwb3NhYmxlKCk7XG4gIF9lZGl0b3JUb1NlcnZlcjogTWFwPGF0b20kVGV4dEVkaXRvciwgQWN0aXZlU2VydmVyPiA9IG5ldyBNYXAoKTtcbiAgX2xvZ2dlcjogTG9nZ2VyO1xuICBfbm9ybWFsaXplZFByb2plY3RQYXRoczogQXJyYXk8c3RyaW5nPiA9IFtdO1xuICBfc3RhcnRGb3JFZGl0b3I6IChlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikgPT4gYm9vbGVhbjtcbiAgX3N0YXJ0U2VydmVyOiAocHJvamVjdFBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+O1xuICBfY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXI6IChmaWxlUGF0aDogc3RyaW5nKSA9PiBib29sZWFuO1xuICBfZ2V0QnVzeVNpZ25hbFNlcnZpY2U6ICgpID0+ID9hdG9tSWRlJEJ1c3lTaWduYWxTZXJ2aWNlO1xuICBfbGFuZ3VhZ2VTZXJ2ZXJOYW1lOiBzdHJpbmc7XG4gIF9pc1N0YXJ0ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGFydFNlcnZlcjogKHByb2plY3RQYXRoOiBzdHJpbmcpID0+IFByb21pc2U8QWN0aXZlU2VydmVyPixcbiAgICBsb2dnZXI6IExvZ2dlcixcbiAgICBzdGFydEZvckVkaXRvcjogKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKSA9PiBib29sZWFuLFxuICAgIGNoYW5nZVdhdGNoZWRGaWxlRmlsdGVyOiAoZmlsZVBhdGg6IHN0cmluZykgPT4gYm9vbGVhbixcbiAgICBidXN5U2lnbmFsU2VydmljZUdldHRlcjogKCkgPT4gP2F0b21JZGUkQnVzeVNpZ25hbFNlcnZpY2UsXG4gICAgbGFuZ3VhZ2VTZXJ2ZXJOYW1lOiBzdHJpbmcsXG4gICkge1xuICAgIHRoaXMuX2xhbmd1YWdlU2VydmVyTmFtZSA9IGxhbmd1YWdlU2VydmVyTmFtZTtcbiAgICB0aGlzLl9zdGFydFNlcnZlciA9IHN0YXJ0U2VydmVyO1xuICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLl9zdGFydEZvckVkaXRvciA9IHN0YXJ0Rm9yRWRpdG9yO1xuICAgIHRoaXMudXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpO1xuICAgIHRoaXMuX2NoYW5nZVdhdGNoZWRGaWxlRmlsdGVyID0gY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXI7XG4gICAgdGhpcy5fZ2V0QnVzeVNpZ25hbFNlcnZpY2UgPSBidXN5U2lnbmFsU2VydmljZUdldHRlcjtcbiAgfVxuXG4gIHN0YXJ0TGlzdGVuaW5nKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5faXNTdGFydGVkKSB7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20udGV4dEVkaXRvcnMub2JzZXJ2ZSh0aGlzLm9ic2VydmVUZXh0RWRpdG9ycy5iaW5kKHRoaXMpKSk7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VQYXRocyh0aGlzLnByb2plY3RQYXRoc0NoYW5nZWQuYmluZCh0aGlzKSkpO1xuICAgICAgaWYgKGF0b20ucHJvamVjdC5vbkRpZENoYW5nZUZpbGVzKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKGF0b20ucHJvamVjdC5vbkRpZENoYW5nZUZpbGVzKHRoaXMucHJvamVjdEZpbGVzQ2hhbmdlZC5iaW5kKHRoaXMpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RvcExpc3RlbmluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faXNTdGFydGVkKSB7XG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIG9ic2VydmVUZXh0RWRpdG9ycyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IHZvaWQge1xuICAgIC8vIFRyYWNrIGdyYW1tYXIgY2hhbmdlcyBmb3Igb3BlbmVkIGVkaXRvcnNcbiAgICBjb25zdCBsaXN0ZW5lciA9IGVkaXRvci5vYnNlcnZlR3JhbW1hcihncmFtbWFyID0+IHRoaXMuX2hhbmRsZUdyYW1tYXJDaGFuZ2UoZWRpdG9yKSk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiBsaXN0ZW5lci5kaXNwb3NlKCkpKTtcbiAgICAvLyBUcnkgdG8gc2VlIGlmIGVkaXRvciBjYW4gaGF2ZSBMUyBjb25uZWN0ZWQgdG8gaXRcbiAgICB0aGlzLl9oYW5kbGVUZXh0RWRpdG9yKGVkaXRvcik7XG4gIH1cblxuICBhc3luYyBfaGFuZGxlVGV4dEVkaXRvcihlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuaGFzKGVkaXRvcikpIHtcbiAgICAgIC8vIGVkaXRvciBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LCBzbyBwcm9jZXNzIGl0IGJ5IGFsbG9jYXRpbmcgTFMgZm9yIGl0IGlmIG5lY2Vzc2FyeVxuICAgICAgY29uc3Qgc2VydmVyID0gYXdhaXQgdGhpcy5nZXRTZXJ2ZXIoZWRpdG9yLCB7c2hvdWxkU3RhcnQ6IHRydWV9KTtcbiAgICAgIGlmIChzZXJ2ZXIgIT0gbnVsbCkge1xuICAgICAgICAvLyBUaGVyZSBMUyBmb3IgdGhlIGVkaXRvciAoZWl0aGVyIHN0YXJ0ZWQgbm93IGFuZCBhbHJlYWR5IHJ1bm5pbmcpXG4gICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLnNldChlZGl0b3IsIHNlcnZlcik7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxuICAgICAgICAgIGVkaXRvci5vbkRpZERlc3Ryb3koKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUdyYW1tYXJDaGFuZ2UoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpIHtcbiAgICBpZiAodGhpcy5fc3RhcnRGb3JFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgLy8gSWYgZWRpdG9yIGlzIGludGVyZXN0aW5nIGZvciBMUyBwcm9jZXNzIHRoZSBlZGl0b3IgZnVydGhlciB0byBhdHRlbXB0IHRvIHN0YXJ0IExTIGlmIG5lZWRlZFxuICAgICAgdGhpcy5faGFuZGxlVGV4dEVkaXRvcihlZGl0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFZGl0b3IgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgTFNcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX2VkaXRvclRvU2VydmVyLmdldChlZGl0b3IpO1xuICAgICAgLy8gSWYgTFMgaXMgcnVubmluZyBmb3IgdGhlIHVuc3VwcG9ydGVkIGVkaXRvciB0aGVuIGRpc2Nvbm5lY3QgdGhlIGVkaXRvciBmcm9tIExTIGFuZCBzaHV0IGRvd24gTFMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc2VydmVyKSB7XG4gICAgICAgIC8vIExTIGlzIHVwIGZvciB1bnN1cHBvcnRlZCBzZXJ2ZXJcbiAgICAgICAgaWYgKHNlcnZlci5kb2NTeW5jQWRhcHRlcikge1xuICAgICAgICAgIGNvbnN0IHN5bmNBZGFwdGVyID0gc2VydmVyLmRvY1N5bmNBZGFwdGVyLmdldEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvcik7XG4gICAgICAgICAgaWYgKHN5bmNBZGFwdGVyKSB7XG4gICAgICAgICAgICAvLyBJbW1pdGF0ZSBlZGl0b3IgY2xvc2UgdG8gZGlzY29ubmVjdCBMUyBmcm9tIHRoZSBlZGl0b3JcbiAgICAgICAgICAgIHN5bmNBZGFwdGVyLmRpZENsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBlZGl0b3IgZnJvbSB0aGUgY2FjaGVcbiAgICAgICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIC8vIFNodXQgZG93biBMUyBpZiBpdCdzIHVzZWQgYnkgYW55IG90aGVyIGVkaXRvclxuICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0QWN0aXZlU2VydmVycygpOiBBcnJheTxBY3RpdmVTZXJ2ZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlU2VydmVycy5zbGljZSgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2VydmVyKFxuICAgIHRleHRFZGl0b3I6IGF0b20kVGV4dEVkaXRvcixcbiAgICB7c2hvdWxkU3RhcnR9OiB7c2hvdWxkU3RhcnQ/OiBib29sZWFufSA9IHtzaG91bGRTdGFydDogZmFsc2V9LFxuICApOiBQcm9taXNlPD9BY3RpdmVTZXJ2ZXI+IHtcbiAgICBjb25zdCBmaW5hbFByb2plY3RQYXRoID0gdGhpcy5kZXRlcm1pbmVQcm9qZWN0UGF0aCh0ZXh0RWRpdG9yKTtcbiAgICBpZiAoZmluYWxQcm9qZWN0UGF0aCA9PSBudWxsKSB7XG4gICAgICAvLyBGaWxlcyBub3QgeWV0IHNhdmVkIGhhdmUgbm8gcGF0aFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZm91bmRBY3RpdmVTZXJ2ZXIgPSB0aGlzLl9hY3RpdmVTZXJ2ZXJzLmZpbmQocyA9PiBmaW5hbFByb2plY3RQYXRoID09PSBzLnByb2plY3RQYXRoKTtcbiAgICBpZiAoZm91bmRBY3RpdmVTZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBmb3VuZEFjdGl2ZVNlcnZlcjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmdldChmaW5hbFByb2plY3RQYXRoKTtcbiAgICBpZiAoc3RhcnRpbmdQcm9taXNlKSB7XG4gICAgICByZXR1cm4gc3RhcnRpbmdQcm9taXNlO1xuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRTdGFydCAmJiB0aGlzLl9zdGFydEZvckVkaXRvcih0ZXh0RWRpdG9yKSA/IGF3YWl0IHRoaXMuc3RhcnRTZXJ2ZXIoZmluYWxQcm9qZWN0UGF0aCkgOiBudWxsO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRTZXJ2ZXIocHJvamVjdFBhdGg6IHN0cmluZyk6IFByb21pc2U8QWN0aXZlU2VydmVyPiB7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RhcnRpbmcgXCIke3Byb2plY3RQYXRofVwiYCk7XG4gICAgY29uc3Qgc3RhcnRpbmdQcm9taXNlID0gdGhpcy5fc3RhcnRTZXJ2ZXIocHJvamVjdFBhdGgpO1xuICAgIHRoaXMuX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXMuc2V0KHByb2plY3RQYXRoLCBzdGFydGluZ1Byb21pc2UpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydGVkQWN0aXZlU2VydmVyID0gYXdhaXQgc3RhcnRpbmdQcm9taXNlO1xuICAgICAgdGhpcy5fYWN0aXZlU2VydmVycy5wdXNoKHN0YXJ0ZWRBY3RpdmVTZXJ2ZXIpO1xuICAgICAgdGhpcy5fc3RhcnRpbmdTZXJ2ZXJQcm9taXNlcy5kZWxldGUocHJvamVjdFBhdGgpO1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RhcnRlZCBcIiR7cHJvamVjdFBhdGh9XCIgKHBpZCAke3N0YXJ0ZWRBY3RpdmVTZXJ2ZXIucHJvY2Vzcy5waWR9KWApO1xuICAgICAgcmV0dXJuIHN0YXJ0ZWRBY3RpdmVTZXJ2ZXI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5fc3RhcnRpbmdTZXJ2ZXJQcm9taXNlcy5kZWxldGUocHJvamVjdFBhdGgpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdG9wVW51c2VkU2VydmVycygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB1c2VkU2VydmVycyA9IG5ldyBTZXQodGhpcy5fZWRpdG9yVG9TZXJ2ZXIudmFsdWVzKCkpO1xuICAgIGNvbnN0IHVudXNlZFNlcnZlcnMgPSB0aGlzLl9hY3RpdmVTZXJ2ZXJzLmZpbHRlcihzID0+ICF1c2VkU2VydmVycy5oYXMocykpO1xuICAgIGlmICh1bnVzZWRTZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU3RvcHBpbmcgJHt1bnVzZWRTZXJ2ZXJzLmxlbmd0aH0gdW51c2VkIHNlcnZlcnNgKTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHVudXNlZFNlcnZlcnMubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RvcEFsbFNlcnZlcnMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZm9yIChjb25zdCBbcHJvamVjdFBhdGgsIHJlc3RhcnRDb3VudGVyXSBvZiB0aGlzLl9yZXN0YXJ0Q291bnRlclBlclByb2plY3QpIHtcbiAgICAgIGNsZWFyVGltZW91dChyZXN0YXJ0Q291bnRlci50aW1lcklkKTtcbiAgICAgIHRoaXMuX3Jlc3RhcnRDb3VudGVyUGVyUHJvamVjdC5kZWxldGUocHJvamVjdFBhdGgpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX2FjdGl2ZVNlcnZlcnMubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XG4gIH1cblxuICBhc3luYyByZXN0YXJ0QWxsU2VydmVycygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTtcbiAgICBhd2FpdCB0aGlzLnN0b3BBbGxTZXJ2ZXJzKCk7XG4gICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICB9XG5cbiAgaGFzU2VydmVyUmVhY2hlZFJlc3RhcnRMaW1pdChzZXJ2ZXI6IEFjdGl2ZVNlcnZlcikge1xuICAgIGxldCByZXN0YXJ0Q291bnRlciA9IHRoaXMuX3Jlc3RhcnRDb3VudGVyUGVyUHJvamVjdC5nZXQoc2VydmVyLnByb2plY3RQYXRoKTtcblxuICAgIGlmICghcmVzdGFydENvdW50ZXIpIHtcbiAgICAgIHJlc3RhcnRDb3VudGVyID0ge1xuICAgICAgICByZXN0YXJ0czogMCxcbiAgICAgICAgdGltZXJJZDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVzdGFydENvdW50ZXJQZXJQcm9qZWN0LmRlbGV0ZShzZXJ2ZXIucHJvamVjdFBhdGgpO1xuICAgICAgICB9LCAzICogNjAgKiAxMDAwIC8qIDMgbWludXRlcyAqLyksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9yZXN0YXJ0Q291bnRlclBlclByb2plY3Quc2V0KHNlcnZlci5wcm9qZWN0UGF0aCwgcmVzdGFydENvdW50ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiArK3Jlc3RhcnRDb3VudGVyLnJlc3RhcnRzID4gNTtcbiAgfVxuXG4gIGFzeW5jIHN0b3BTZXJ2ZXIoc2VydmVyOiBBY3RpdmVTZXJ2ZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBidXN5U2lnbmFsU2VydmljZSA9IHRoaXMuX2dldEJ1c3lTaWduYWxTZXJ2aWNlKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gYnVzeVNpZ25hbFNlcnZpY2UgJiYgYnVzeVNpZ25hbFNlcnZpY2UucmVwb3J0QnVzeShcbiAgICAgIGBTdG9wcGluZyAke3RoaXMuX2xhbmd1YWdlU2VydmVyTmFtZX0gZm9yICR7cGF0aC5iYXNlbmFtZShzZXJ2ZXIucHJvamVjdFBhdGgpfWAsXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RvcHBpbmcgXCIke3NlcnZlci5wcm9qZWN0UGF0aH1cImApO1xuICAgICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBzZXJ2ZXIgdG8gcHJldmVudCBmdXJ0aGVyIHVzYWdlLlxuICAgICAgLy8gSWYgd2UgcmUtb3BlbiB0aGUgZmlsZSBhZnRlciB0aGlzIHBvaW50LCB3ZSdsbCBnZXQgYSBuZXcgc2VydmVyLlxuICAgICAgdGhpcy5fYWN0aXZlU2VydmVycy5zcGxpY2UodGhpcy5fYWN0aXZlU2VydmVycy5pbmRleE9mKHNlcnZlciksIDEpO1xuICAgICAgdGhpcy5fc3RvcHBpbmdTZXJ2ZXJzLnB1c2goc2VydmVyKTtcbiAgICAgIHNlcnZlci5kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgIGlmIChzZXJ2ZXIuY29ubmVjdGlvbi5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5zaHV0ZG93bigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIG1hcHBlZFNlcnZlcl0gb2YgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG1hcHBlZFNlcnZlciA9PT0gc2VydmVyKSB7XG4gICAgICAgICAgdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5leGl0U2VydmVyKHNlcnZlcik7XG4gICAgICB0aGlzLl9zdG9wcGluZ1NlcnZlcnMuc3BsaWNlKHRoaXMuX3N0b3BwaW5nU2VydmVycy5pbmRleE9mKHNlcnZlciksIDEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzaWduYWwgJiYgc2lnbmFsLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBleGl0U2VydmVyKHNlcnZlcjogQWN0aXZlU2VydmVyKTogdm9pZCB7XG4gICAgY29uc3QgcGlkID0gc2VydmVyLnByb2Nlc3MucGlkO1xuICAgIHRyeSB7XG4gICAgICBpZiAoc2VydmVyLmNvbm5lY3Rpb24uaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgc2VydmVyLmNvbm5lY3Rpb24uZXhpdCgpO1xuICAgICAgICBzZXJ2ZXIuY29ubmVjdGlvbi5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNlcnZlci5wcm9jZXNzLmtpbGwoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RvcHBlZCBcIiR7c2VydmVyLnByb2plY3RQYXRofVwiIChwaWQgJHtwaWR9KWApO1xuICB9XG5cbiAgdGVybWluYXRlKCk6IHZvaWQge1xuICAgIHRoaXMuX3N0b3BwaW5nU2VydmVycy5mb3JFYWNoKHNlcnZlciA9PiB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciB0ZXJtaW5hdGluZyBcIiR7c2VydmVyLnByb2plY3RQYXRofVwiYCk7XG4gICAgICB0aGlzLmV4aXRTZXJ2ZXIoc2VydmVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9zdHJpbmcge1xuICAgIGNvbnN0IGZpbGVQYXRoID0gdGV4dEVkaXRvci5nZXRQYXRoKCk7XG4gICAgaWYgKGZpbGVQYXRoID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplZFByb2plY3RQYXRocy5maW5kKGQgPT4gZmlsZVBhdGguc3RhcnRzV2l0aChkKSk7XG4gIH1cblxuICB1cGRhdGVOb3JtYWxpemVkUHJvamVjdFBhdGhzKCk6IHZvaWQge1xuICAgIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMgPSBhdG9tLnByb2plY3QuZ2V0RGlyZWN0b3JpZXMoKS5tYXAoZCA9PiB0aGlzLm5vcm1hbGl6ZVBhdGgoZC5nZXRQYXRoKCkpKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZVBhdGgocHJvamVjdFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuICFwcm9qZWN0UGF0aC5lbmRzV2l0aChwYXRoLnNlcCkgPyBwYXRoLmpvaW4ocHJvamVjdFBhdGgsIHBhdGguc2VwKSA6IHByb2plY3RQYXRoO1xuICB9XG5cbiAgcHJvamVjdFBhdGhzQ2hhbmdlZChwcm9qZWN0UGF0aHM6IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcbiAgICBjb25zdCBwYXRoc1NldCA9IG5ldyBTZXQocHJvamVjdFBhdGhzLm1hcCh0aGlzLm5vcm1hbGl6ZVBhdGgpKTtcbiAgICBjb25zdCBzZXJ2ZXJzVG9TdG9wID0gdGhpcy5fYWN0aXZlU2VydmVycy5maWx0ZXIocyA9PiAhcGF0aHNTZXQuaGFzKHMucHJvamVjdFBhdGgpKTtcbiAgICBQcm9taXNlLmFsbChzZXJ2ZXJzVG9TdG9wLm1hcChzID0+IHRoaXMuc3RvcFNlcnZlcihzKSkpO1xuICAgIHRoaXMudXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpO1xuICB9XG5cbiAgcHJvamVjdEZpbGVzQ2hhbmdlZChmaWxlRXZlbnRzOiBBcnJheTxhdG9tJFByb2plY3RGaWxlRXZlbnQ+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBhY3RpdmVTZXJ2ZXIgb2YgdGhpcy5fYWN0aXZlU2VydmVycykge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWxlRXZlbnQgb2YgZmlsZUV2ZW50cykge1xuICAgICAgICBpZiAoZmlsZUV2ZW50LnBhdGguc3RhcnRzV2l0aChhY3RpdmVTZXJ2ZXIucHJvamVjdFBhdGgpICYmIHRoaXMuX2NoYW5nZVdhdGNoZWRGaWxlRmlsdGVyKGZpbGVFdmVudC5wYXRoKSkge1xuICAgICAgICAgIGNoYW5nZXMucHVzaChDb252ZXJ0LmF0b21GaWxlRXZlbnRUb0xTRmlsZUV2ZW50cyhmaWxlRXZlbnQpWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlsZUV2ZW50Lm9sZFBhdGggJiZcbiAgICAgICAgICBmaWxlRXZlbnQub2xkUGF0aC5zdGFydHNXaXRoKGFjdGl2ZVNlcnZlci5wcm9qZWN0UGF0aCkgJiZcbiAgICAgICAgICB0aGlzLl9jaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcihmaWxlRXZlbnQub2xkUGF0aClcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2hhbmdlcy5wdXNoKENvbnZlcnQuYXRvbUZpbGVFdmVudFRvTFNGaWxlRXZlbnRzKGZpbGVFdmVudClbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGl2ZVNlcnZlci5jb25uZWN0aW9uLmRpZENoYW5nZVdhdGNoZWRGaWxlcyh7Y2hhbmdlc30pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19