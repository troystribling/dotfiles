Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerManager = undefined;

require('./logger');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _languageclient = require('./languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _convert = require('./convert');

var _convert2 = _interopRequireDefault(_convert);

var _atom = require('atom');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Manages the language server lifecycles and their associated objects necessary
// for adapting them to Atom IDE.


// The necessary elements for a server that has started or is starting.
class ServerManager {

  constructor(startServer, logger, startForEditor, changeWatchedFileFilter, busySignalServiceGetter, languageServerName) {
    this._activeServers = [];
    this._startingServerPromises = new Map();
    this._stoppingServers = [];
    this._disposable = new _atom.CompositeDisposable();
    this._editorToServer = new Map();
    this._normalizedProjectPaths = [];
    this._isStarted = false;

    this._languageServerName = languageServerName;
    this._startServer = startServer;
    this._logger = logger;
    this._startForEditor = startForEditor;
    this.updateNormalizedProjectPaths();
    this._changeWatchedFileFilter = changeWatchedFileFilter;
    this._getBusySignalService = busySignalServiceGetter;
  }

  startListening() {
    if (!this._isStarted) {
      this._disposable = new _atom.CompositeDisposable();
      this._disposable.add(atom.textEditors.observe(this.observeTextEditors.bind(this)));
      this._disposable.add(atom.project.onDidChangePaths(this.projectPathsChanged.bind(this)));
      if (atom.project.onDidChangeFiles) {
        this._disposable.add(atom.project.onDidChangeFiles(this.projectFilesChanged.bind(this)));
      }
    }
  }

  stopListening() {
    if (this._isStarted) {
      this._disposable.dispose();
    }
  }

  observeTextEditors(editor) {
    // Track grammar changes for opened editors
    const listener = editor.observeGrammar(grammar => this._handleGrammarChange(editor));
    this._disposable.add(editor.onDidDestroy(() => listener.dispose()));
    // Try to see if editor can have LS connected to it
    this._handleTextEditor(editor);
  }

  async _handleTextEditor(editor) {
    if (!this._editorToServer.has(editor)) {
      // editor hasn't been processed yet, so process it by allocating LS for it if necessary
      const server = await this.getServer(editor, { shouldStart: true });
      if (server != null) {
        // There LS for the editor (either started now and already running)
        this._editorToServer.set(editor, server);
        this._disposable.add(editor.onDidDestroy(() => {
          this._editorToServer.delete(editor);
          this.stopUnusedServers();
        }));
      }
    }
  }

  _handleGrammarChange(editor) {
    if (this._startForEditor(editor)) {
      // If editor is interesting for LS process the editor further to attempt to start LS if needed
      this._handleTextEditor(editor);
    } else {
      // Editor is not supported by the LS
      const server = this._editorToServer.get(editor);
      // If LS is running for the unsupported editor then disconnect the editor from LS and shut down LS if necessary
      if (server) {
        // LS is up for unsupported server
        if (server.docSyncAdapter) {
          const syncAdapter = server.docSyncAdapter.getEditorSyncAdapter(editor);
          if (syncAdapter) {
            // Immitate editor close to disconnect LS from the editor
            syncAdapter.didClose();
          }
        }
        // Remove editor from the cache
        this._editorToServer.delete(editor);
        // Shut down LS if it's used by any other editor
        this.stopUnusedServers();
      }
    }
  }

  getActiveServers() {
    return this._activeServers.slice();
  }

  async getServer(textEditor, { shouldStart } = { shouldStart: false }) {
    const finalProjectPath = this.determineProjectPath(textEditor);
    if (finalProjectPath == null) {
      // Files not yet saved have no path
      return null;
    }

    const foundActiveServer = this._activeServers.find(s => finalProjectPath === s.projectPath);
    if (foundActiveServer) {
      return foundActiveServer;
    }

    const startingPromise = this._startingServerPromises.get(finalProjectPath);
    if (startingPromise) {
      return startingPromise;
    }

    return shouldStart && this._startForEditor(textEditor) ? await this.startServer(finalProjectPath) : null;
  }

  async startServer(projectPath) {
    this._logger.debug(`Server starting "${projectPath}"`);
    const startingPromise = this._startServer(projectPath);
    this._startingServerPromises.set(projectPath, startingPromise);
    const startedActiveServer = await startingPromise;
    this._activeServers.push(startedActiveServer);
    this._startingServerPromises.delete(projectPath);
    this._logger.debug(`Server started "${projectPath}" (pid ${startedActiveServer.process.pid})`);
    return startedActiveServer;
  }

  async stopUnusedServers() {
    const usedServers = new Set(this._editorToServer.values());
    const unusedServers = this._activeServers.filter(s => !usedServers.has(s));
    if (unusedServers.length > 0) {
      this._logger.debug(`Stopping ${unusedServers.length} unused servers`);
      await Promise.all(unusedServers.map(s => this.stopServer(s)));
    }
  }

  async stopAllServers() {
    await Promise.all(this._activeServers.map(s => this.stopServer(s)));
  }

  async stopServer(server) {
    const busySignalService = this._getBusySignalService();
    const signal = busySignalService && busySignalService.reportBusy(`Stopping ${this._languageServerName} for ${_path2.default.basename(server.projectPath)}`);
    try {
      this._logger.debug(`Server stopping "${server.projectPath}"`);
      // Immediately remove the server to prevent further usage.
      // If we re-open the file after this point, we'll get a new server.
      this._activeServers.splice(this._activeServers.indexOf(server), 1);
      this._stoppingServers.push(server);
      server.disposable.dispose();
      await server.connection.shutdown();

      if (server.linterPushV2 != null) {
        server.linterPushV2.detachAll();
      }

      if (server.signatureHelpAdapter != null) {
        server.signatureHelpAdapter.dispose();
      }

      this.exitServer(server);
      this._stoppingServers.splice(this._stoppingServers.indexOf(server), 1);
    } finally {
      signal && signal.dispose();
    }
  }

  exitServer(server) {
    const pid = server.process.pid;
    try {
      server.connection.exit();
      server.connection.dispose();
    } finally {
      server.process.kill();
    }
    this._logger.debug(`Server stopped "${server.projectPath}" (pid ${pid})`);
  }

  terminate() {
    this._stoppingServers.forEach(server => {
      this._logger.debug(`Server terminating "${server.projectPath}"`);
      this.exitServer(server);
    });
  }

  determineProjectPath(textEditor) {
    const filePath = textEditor.getPath();
    if (filePath == null) {
      return null;
    }
    return this._normalizedProjectPaths.find(d => filePath.startsWith(d));
  }

  updateNormalizedProjectPaths() {
    this._normalizedProjectPaths = atom.project.getDirectories().map(d => this.normalizePath(d.getPath()));
  }

  normalizePath(projectPath) {
    return !projectPath.endsWith(_path2.default.sep) ? _path2.default.join(projectPath, _path2.default.sep) : projectPath;
  }

  projectPathsChanged(projectPaths) {
    const pathsSet = new Set(projectPaths.map(this.normalizePath));
    const serversToStop = this._activeServers.filter(s => !pathsSet.has(s.projectPath));
    Promise.all(serversToStop.map(s => this.stopServer(s)));
    this.updateNormalizedProjectPaths();
  }

  projectFilesChanged(fileEvents) {
    if (this._activeServers.length === 0) {
      return;
    }

    for (const activeServer of this._activeServers) {
      const changes = [];
      for (const fileEvent of fileEvents) {
        if (fileEvent.path.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.path)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[0]);
        }
        if (fileEvent.oldPath && fileEvent.oldPath.startsWith(activeServer.projectPath) && this._changeWatchedFileFilter(fileEvent.oldPath)) {
          changes.push(_convert2.default.atomFileEventToLSFileEvents(fileEvent)[1]);
        }
      }
      if (changes.length > 0) {
        activeServer.connection.didChangeWatchedFiles({ changes });
      }
    }
  }
}
exports.ServerManager = ServerManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9zZXJ2ZXItbWFuYWdlci5qcyJdLCJuYW1lcyI6WyJscyIsIlNlcnZlck1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN0YXJ0U2VydmVyIiwibG9nZ2VyIiwic3RhcnRGb3JFZGl0b3IiLCJjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlciIsImJ1c3lTaWduYWxTZXJ2aWNlR2V0dGVyIiwibGFuZ3VhZ2VTZXJ2ZXJOYW1lIiwiX2FjdGl2ZVNlcnZlcnMiLCJfc3RhcnRpbmdTZXJ2ZXJQcm9taXNlcyIsIk1hcCIsIl9zdG9wcGluZ1NlcnZlcnMiLCJfZGlzcG9zYWJsZSIsIl9lZGl0b3JUb1NlcnZlciIsIl9ub3JtYWxpemVkUHJvamVjdFBhdGhzIiwiX2lzU3RhcnRlZCIsIl9sYW5ndWFnZVNlcnZlck5hbWUiLCJfc3RhcnRTZXJ2ZXIiLCJfbG9nZ2VyIiwiX3N0YXJ0Rm9yRWRpdG9yIiwidXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocyIsIl9jaGFuZ2VXYXRjaGVkRmlsZUZpbHRlciIsIl9nZXRCdXN5U2lnbmFsU2VydmljZSIsInN0YXJ0TGlzdGVuaW5nIiwiYWRkIiwiYXRvbSIsInRleHRFZGl0b3JzIiwib2JzZXJ2ZSIsIm9ic2VydmVUZXh0RWRpdG9ycyIsImJpbmQiLCJwcm9qZWN0Iiwib25EaWRDaGFuZ2VQYXRocyIsInByb2plY3RQYXRoc0NoYW5nZWQiLCJvbkRpZENoYW5nZUZpbGVzIiwicHJvamVjdEZpbGVzQ2hhbmdlZCIsInN0b3BMaXN0ZW5pbmciLCJkaXNwb3NlIiwiZWRpdG9yIiwibGlzdGVuZXIiLCJvYnNlcnZlR3JhbW1hciIsImdyYW1tYXIiLCJfaGFuZGxlR3JhbW1hckNoYW5nZSIsIm9uRGlkRGVzdHJveSIsIl9oYW5kbGVUZXh0RWRpdG9yIiwiaGFzIiwic2VydmVyIiwiZ2V0U2VydmVyIiwic2hvdWxkU3RhcnQiLCJzZXQiLCJkZWxldGUiLCJzdG9wVW51c2VkU2VydmVycyIsImdldCIsImRvY1N5bmNBZGFwdGVyIiwic3luY0FkYXB0ZXIiLCJnZXRFZGl0b3JTeW5jQWRhcHRlciIsImRpZENsb3NlIiwiZ2V0QWN0aXZlU2VydmVycyIsInNsaWNlIiwidGV4dEVkaXRvciIsImZpbmFsUHJvamVjdFBhdGgiLCJkZXRlcm1pbmVQcm9qZWN0UGF0aCIsImZvdW5kQWN0aXZlU2VydmVyIiwiZmluZCIsInMiLCJwcm9qZWN0UGF0aCIsInN0YXJ0aW5nUHJvbWlzZSIsImRlYnVnIiwic3RhcnRlZEFjdGl2ZVNlcnZlciIsInB1c2giLCJwcm9jZXNzIiwicGlkIiwidXNlZFNlcnZlcnMiLCJTZXQiLCJ2YWx1ZXMiLCJ1bnVzZWRTZXJ2ZXJzIiwiZmlsdGVyIiwibGVuZ3RoIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsInN0b3BTZXJ2ZXIiLCJzdG9wQWxsU2VydmVycyIsImJ1c3lTaWduYWxTZXJ2aWNlIiwic2lnbmFsIiwicmVwb3J0QnVzeSIsImJhc2VuYW1lIiwic3BsaWNlIiwiaW5kZXhPZiIsImRpc3Bvc2FibGUiLCJjb25uZWN0aW9uIiwic2h1dGRvd24iLCJsaW50ZXJQdXNoVjIiLCJkZXRhY2hBbGwiLCJzaWduYXR1cmVIZWxwQWRhcHRlciIsImV4aXRTZXJ2ZXIiLCJleGl0Iiwia2lsbCIsInRlcm1pbmF0ZSIsImZvckVhY2giLCJmaWxlUGF0aCIsImdldFBhdGgiLCJkIiwic3RhcnRzV2l0aCIsImdldERpcmVjdG9yaWVzIiwibm9ybWFsaXplUGF0aCIsImVuZHNXaXRoIiwic2VwIiwiam9pbiIsInByb2plY3RQYXRocyIsInBhdGhzU2V0Iiwic2VydmVyc1RvU3RvcCIsImZpbGVFdmVudHMiLCJhY3RpdmVTZXJ2ZXIiLCJjaGFuZ2VzIiwiZmlsZUV2ZW50IiwicGF0aCIsImF0b21GaWxlRXZlbnRUb0xTRmlsZUV2ZW50cyIsIm9sZFBhdGgiLCJkaWRDaGFuZ2VXYXRjaGVkRmlsZXMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7O0FBS0E7Ozs7QUFDQTs7SUFBWUEsRTs7QUFDWjs7OztBQUNBOzs7Ozs7QUFjQTtB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WUFDRUEsVUFBVUcsT0FBVixJQUNBSCxVQUFVRyxPQUFWLENBQWtCZixVQUFsQixDQUE2QlUsYUFBYWhELFdBQTFDLENBREEsSUFFQSxLQUFLM0Msd0JBQUwsQ0FBOEI2RixVQUFVRyxPQUF4QyxDQUhGLEVBSUU7QUFDQUosa0JBQVE3QyxJQUFSLENBQWEsa0JBQVFnRCwyQkFBUixDQUFvQ0YsU0FBcEMsRUFBK0MsQ0FBL0MsQ0FBYjtBQUNEO0FBQ0Y7QUFDRCxVQUFJRCxRQUFRckMsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUN0Qm9DLHFCQUFhdkIsVUFBYixDQUF3QjZCLHFCQUF4QixDQUE4QyxFQUFDTCxPQUFELEVBQTlDO0FBQ0Q7QUFDRjtBQUNGO0FBblB3QjtRQUFkakgsYSxHQUFBQSxhIiwiZmlsZSI6InNlcnZlci1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7dHlwZSBMb2dnZXJ9IGZyb20gJy4vbG9nZ2VyJztcclxuaW1wb3J0IHR5cGUgTGludGVyUHVzaFYyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXJzL2xpbnRlci1wdXNoLXYyLWFkYXB0ZXInO1xyXG5pbXBvcnQgdHlwZSBEb2N1bWVudFN5bmNBZGFwdGVyIGZyb20gJy4vYWRhcHRlcnMvZG9jdW1lbnQtc3luYy1hZGFwdGVyJztcclxuaW1wb3J0IHR5cGUgU2lnbmF0dXJlSGVscEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVycy9zaWduYXR1cmUtaGVscC1hZGFwdGVyJztcclxuXHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xyXG5pbXBvcnQgKiBhcyBscyBmcm9tICcuL2xhbmd1YWdlY2xpZW50JztcclxuaW1wb3J0IENvbnZlcnQgZnJvbSAnLi9jb252ZXJ0JztcclxuaW1wb3J0IHtDb21wb3NpdGVEaXNwb3NhYmxlfSBmcm9tICdhdG9tJztcclxuXHJcbi8vIFRoZSBuZWNlc3NhcnkgZWxlbWVudHMgZm9yIGEgc2VydmVyIHRoYXQgaGFzIHN0YXJ0ZWQgb3IgaXMgc3RhcnRpbmcuXHJcbmV4cG9ydCB0eXBlIEFjdGl2ZVNlcnZlciA9IHtcclxuICBkaXNwb3NhYmxlOiBDb21wb3NpdGVEaXNwb3NhYmxlLFxyXG4gIHByb2plY3RQYXRoOiBzdHJpbmcsXHJcbiAgcHJvY2VzczogY2hpbGRfcHJvY2VzcyRDaGlsZFByb2Nlc3MsXHJcbiAgY29ubmVjdGlvbjogbHMuTGFuZ3VhZ2VDbGllbnRDb25uZWN0aW9uLFxyXG4gIGNhcGFiaWxpdGllczogbHMuU2VydmVyQ2FwYWJpbGl0aWVzLFxyXG4gIGxpbnRlclB1c2hWMj86IExpbnRlclB1c2hWMkFkYXB0ZXIsXHJcbiAgZG9jU3luY0FkYXB0ZXI/OiBEb2N1bWVudFN5bmNBZGFwdGVyLFxyXG4gIHNpZ25hdHVyZUhlbHBBZGFwdGVyPzogU2lnbmF0dXJlSGVscEFkYXB0ZXIsXHJcbn07XHJcblxyXG4vLyBNYW5hZ2VzIHRoZSBsYW5ndWFnZSBzZXJ2ZXIgbGlmZWN5Y2xlcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBvYmplY3RzIG5lY2Vzc2FyeVxyXG4vLyBmb3IgYWRhcHRpbmcgdGhlbSB0byBBdG9tIElERS5cclxuZXhwb3J0IGNsYXNzIFNlcnZlck1hbmFnZXIge1xyXG4gIF9hY3RpdmVTZXJ2ZXJzOiBBcnJheTxBY3RpdmVTZXJ2ZXI+ID0gW107XHJcbiAgX3N0YXJ0aW5nU2VydmVyUHJvbWlzZXM6IE1hcDxzdHJpbmcsIFByb21pc2U8QWN0aXZlU2VydmVyPj4gPSBuZXcgTWFwKCk7XHJcbiAgX3N0b3BwaW5nU2VydmVyczogQXJyYXk8QWN0aXZlU2VydmVyPiA9IFtdO1xyXG4gIF9kaXNwb3NhYmxlOiBDb21wb3NpdGVEaXNwb3NhYmxlID0gbmV3IENvbXBvc2l0ZURpc3Bvc2FibGUoKTtcclxuICBfZWRpdG9yVG9TZXJ2ZXI6IE1hcDxhdG9tJFRleHRFZGl0b3IsIEFjdGl2ZVNlcnZlcj4gPSBuZXcgTWFwKCk7XHJcbiAgX2xvZ2dlcjogTG9nZ2VyO1xyXG4gIF9ub3JtYWxpemVkUHJvamVjdFBhdGhzOiBBcnJheTxzdHJpbmc+ID0gW107XHJcbiAgX3N0YXJ0Rm9yRWRpdG9yOiAoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpID0+IGJvb2xlYW47XHJcbiAgX3N0YXJ0U2VydmVyOiAocHJvamVjdFBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+O1xyXG4gIF9jaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcjogKGZpbGVQYXRoOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcbiAgX2dldEJ1c3lTaWduYWxTZXJ2aWNlOiAoKSA9PiA/YXRvbUlkZSRCdXN5U2lnbmFsU2VydmljZTtcclxuICBfbGFuZ3VhZ2VTZXJ2ZXJOYW1lOiBzdHJpbmc7XHJcbiAgX2lzU3RhcnRlZCA9IGZhbHNlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHN0YXJ0U2VydmVyOiAocHJvamVjdFBhdGg6IHN0cmluZykgPT4gUHJvbWlzZTxBY3RpdmVTZXJ2ZXI+LFxyXG4gICAgbG9nZ2VyOiBMb2dnZXIsXHJcbiAgICBzdGFydEZvckVkaXRvcjogKGVkaXRvcjogYXRvbSRUZXh0RWRpdG9yKSA9PiBib29sZWFuLFxyXG4gICAgY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXI6IChmaWxlUGF0aDogc3RyaW5nKSA9PiBib29sZWFuLFxyXG4gICAgYnVzeVNpZ25hbFNlcnZpY2VHZXR0ZXI6ICgpID0+ID9hdG9tSWRlJEJ1c3lTaWduYWxTZXJ2aWNlLFxyXG4gICAgbGFuZ3VhZ2VTZXJ2ZXJOYW1lOiBzdHJpbmcsXHJcbiAgKSB7XHJcbiAgICB0aGlzLl9sYW5ndWFnZVNlcnZlck5hbWUgPSBsYW5ndWFnZVNlcnZlck5hbWU7XHJcbiAgICB0aGlzLl9zdGFydFNlcnZlciA9IHN0YXJ0U2VydmVyO1xyXG4gICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgdGhpcy5fc3RhcnRGb3JFZGl0b3IgPSBzdGFydEZvckVkaXRvcjtcclxuICAgIHRoaXMudXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpO1xyXG4gICAgdGhpcy5fY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIgPSBjaGFuZ2VXYXRjaGVkRmlsZUZpbHRlcjtcclxuICAgIHRoaXMuX2dldEJ1c3lTaWduYWxTZXJ2aWNlID0gYnVzeVNpZ25hbFNlcnZpY2VHZXR0ZXI7XHJcbiAgfVxyXG5cclxuICBzdGFydExpc3RlbmluZygpOiB2b2lkIHtcclxuICAgIGlmICghdGhpcy5faXNTdGFydGVkKSB7XHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnRleHRFZGl0b3JzLm9ic2VydmUodGhpcy5vYnNlcnZlVGV4dEVkaXRvcnMuYmluZCh0aGlzKSkpO1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VQYXRocyh0aGlzLnByb2plY3RQYXRoc0NoYW5nZWQuYmluZCh0aGlzKSkpO1xyXG4gICAgICBpZiAoYXRvbS5wcm9qZWN0Lm9uRGlkQ2hhbmdlRmlsZXMpIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NhYmxlLmFkZChhdG9tLnByb2plY3Qub25EaWRDaGFuZ2VGaWxlcyh0aGlzLnByb2plY3RGaWxlc0NoYW5nZWQuYmluZCh0aGlzKSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdG9wTGlzdGVuaW5nKCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2lzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLl9kaXNwb3NhYmxlLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG9ic2VydmVUZXh0RWRpdG9ycyhlZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6IHZvaWQge1xyXG4gICAgLy8gVHJhY2sgZ3JhbW1hciBjaGFuZ2VzIGZvciBvcGVuZWQgZWRpdG9yc1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBlZGl0b3Iub2JzZXJ2ZUdyYW1tYXIoZ3JhbW1hciA9PiB0aGlzLl9oYW5kbGVHcmFtbWFyQ2hhbmdlKGVkaXRvcikpO1xyXG4gICAgdGhpcy5fZGlzcG9zYWJsZS5hZGQoZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiBsaXN0ZW5lci5kaXNwb3NlKCkpKTtcclxuICAgIC8vIFRyeSB0byBzZWUgaWYgZWRpdG9yIGNhbiBoYXZlIExTIGNvbm5lY3RlZCB0byBpdFxyXG4gICAgdGhpcy5faGFuZGxlVGV4dEVkaXRvcihlZGl0b3IpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2hhbmRsZVRleHRFZGl0b3IoZWRpdG9yOiBhdG9tJFRleHRFZGl0b3IpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGlmICghdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuaGFzKGVkaXRvcikpIHtcclxuICAgICAgLy8gZWRpdG9yIGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQsIHNvIHByb2Nlc3MgaXQgYnkgYWxsb2NhdGluZyBMUyBmb3IgaXQgaWYgbmVjZXNzYXJ5XHJcbiAgICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IHRoaXMuZ2V0U2VydmVyKGVkaXRvciwge3Nob3VsZFN0YXJ0OiB0cnVlfSk7XHJcbiAgICAgIGlmIChzZXJ2ZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoZXJlIExTIGZvciB0aGUgZWRpdG9yIChlaXRoZXIgc3RhcnRlZCBub3cgYW5kIGFscmVhZHkgcnVubmluZylcclxuICAgICAgICB0aGlzLl9lZGl0b3JUb1NlcnZlci5zZXQoZWRpdG9yLCBzZXJ2ZXIpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuYWRkKFxyXG4gICAgICAgICAgZWRpdG9yLm9uRGlkRGVzdHJveSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VkaXRvclRvU2VydmVyLmRlbGV0ZShlZGl0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfaGFuZGxlR3JhbW1hckNoYW5nZShlZGl0b3I6IGF0b20kVGV4dEVkaXRvcikge1xyXG4gICAgaWYgKHRoaXMuX3N0YXJ0Rm9yRWRpdG9yKGVkaXRvcikpIHtcclxuICAgICAgLy8gSWYgZWRpdG9yIGlzIGludGVyZXN0aW5nIGZvciBMUyBwcm9jZXNzIHRoZSBlZGl0b3IgZnVydGhlciB0byBhdHRlbXB0IHRvIHN0YXJ0IExTIGlmIG5lZWRlZFxyXG4gICAgICB0aGlzLl9oYW5kbGVUZXh0RWRpdG9yKGVkaXRvcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBFZGl0b3IgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgTFNcclxuICAgICAgY29uc3Qgc2VydmVyID0gdGhpcy5fZWRpdG9yVG9TZXJ2ZXIuZ2V0KGVkaXRvcik7XHJcbiAgICAgIC8vIElmIExTIGlzIHJ1bm5pbmcgZm9yIHRoZSB1bnN1cHBvcnRlZCBlZGl0b3IgdGhlbiBkaXNjb25uZWN0IHRoZSBlZGl0b3IgZnJvbSBMUyBhbmQgc2h1dCBkb3duIExTIGlmIG5lY2Vzc2FyeVxyXG4gICAgICBpZiAoc2VydmVyKSB7XHJcbiAgICAgICAgLy8gTFMgaXMgdXAgZm9yIHVuc3VwcG9ydGVkIHNlcnZlclxyXG4gICAgICAgIGlmIChzZXJ2ZXIuZG9jU3luY0FkYXB0ZXIpIHtcclxuICAgICAgICAgIGNvbnN0IHN5bmNBZGFwdGVyID0gc2VydmVyLmRvY1N5bmNBZGFwdGVyLmdldEVkaXRvclN5bmNBZGFwdGVyKGVkaXRvcik7XHJcbiAgICAgICAgICBpZiAoc3luY0FkYXB0ZXIpIHtcclxuICAgICAgICAgICAgLy8gSW1taXRhdGUgZWRpdG9yIGNsb3NlIHRvIGRpc2Nvbm5lY3QgTFMgZnJvbSB0aGUgZWRpdG9yXHJcbiAgICAgICAgICAgIHN5bmNBZGFwdGVyLmRpZENsb3NlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBlZGl0b3IgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICB0aGlzLl9lZGl0b3JUb1NlcnZlci5kZWxldGUoZWRpdG9yKTtcclxuICAgICAgICAvLyBTaHV0IGRvd24gTFMgaWYgaXQncyB1c2VkIGJ5IGFueSBvdGhlciBlZGl0b3JcclxuICAgICAgICB0aGlzLnN0b3BVbnVzZWRTZXJ2ZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldEFjdGl2ZVNlcnZlcnMoKTogQXJyYXk8QWN0aXZlU2VydmVyPiB7XHJcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlU2VydmVycy5zbGljZSgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U2VydmVyKFxyXG4gICAgdGV4dEVkaXRvcjogYXRvbSRUZXh0RWRpdG9yLFxyXG4gICAge3Nob3VsZFN0YXJ0fToge3Nob3VsZFN0YXJ0PzogYm9vbGVhbn0gPSB7c2hvdWxkU3RhcnQ6IGZhbHNlfSxcclxuICApOiBQcm9taXNlPD9BY3RpdmVTZXJ2ZXI+IHtcclxuICAgIGNvbnN0IGZpbmFsUHJvamVjdFBhdGggPSB0aGlzLmRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3IpO1xyXG4gICAgaWYgKGZpbmFsUHJvamVjdFBhdGggPT0gbnVsbCkge1xyXG4gICAgICAvLyBGaWxlcyBub3QgeWV0IHNhdmVkIGhhdmUgbm8gcGF0aFxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBmb3VuZEFjdGl2ZVNlcnZlciA9IHRoaXMuX2FjdGl2ZVNlcnZlcnMuZmluZChzID0+IGZpbmFsUHJvamVjdFBhdGggPT09IHMucHJvamVjdFBhdGgpO1xyXG4gICAgaWYgKGZvdW5kQWN0aXZlU2VydmVyKSB7XHJcbiAgICAgIHJldHVybiBmb3VuZEFjdGl2ZVNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmdldChmaW5hbFByb2plY3RQYXRoKTtcclxuICAgIGlmIChzdGFydGluZ1Byb21pc2UpIHtcclxuICAgICAgcmV0dXJuIHN0YXJ0aW5nUHJvbWlzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2hvdWxkU3RhcnQgJiYgdGhpcy5fc3RhcnRGb3JFZGl0b3IodGV4dEVkaXRvcikgPyBhd2FpdCB0aGlzLnN0YXJ0U2VydmVyKGZpbmFsUHJvamVjdFBhdGgpIDogbnVsbDtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0YXJ0U2VydmVyKHByb2plY3RQYXRoOiBzdHJpbmcpOiBQcm9taXNlPEFjdGl2ZVNlcnZlcj4ge1xyXG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGBTZXJ2ZXIgc3RhcnRpbmcgXCIke3Byb2plY3RQYXRofVwiYCk7XHJcbiAgICBjb25zdCBzdGFydGluZ1Byb21pc2UgPSB0aGlzLl9zdGFydFNlcnZlcihwcm9qZWN0UGF0aCk7XHJcbiAgICB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLnNldChwcm9qZWN0UGF0aCwgc3RhcnRpbmdQcm9taXNlKTtcclxuICAgIGNvbnN0IHN0YXJ0ZWRBY3RpdmVTZXJ2ZXIgPSBhd2FpdCBzdGFydGluZ1Byb21pc2U7XHJcbiAgICB0aGlzLl9hY3RpdmVTZXJ2ZXJzLnB1c2goc3RhcnRlZEFjdGl2ZVNlcnZlcik7XHJcbiAgICB0aGlzLl9zdGFydGluZ1NlcnZlclByb21pc2VzLmRlbGV0ZShwcm9qZWN0UGF0aCk7XHJcbiAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFNlcnZlciBzdGFydGVkIFwiJHtwcm9qZWN0UGF0aH1cIiAocGlkICR7c3RhcnRlZEFjdGl2ZVNlcnZlci5wcm9jZXNzLnBpZH0pYCk7XHJcbiAgICByZXR1cm4gc3RhcnRlZEFjdGl2ZVNlcnZlcjtcclxuICB9XHJcblxyXG4gIGFzeW5jIHN0b3BVbnVzZWRTZXJ2ZXJzKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgY29uc3QgdXNlZFNlcnZlcnMgPSBuZXcgU2V0KHRoaXMuX2VkaXRvclRvU2VydmVyLnZhbHVlcygpKTtcclxuICAgIGNvbnN0IHVudXNlZFNlcnZlcnMgPSB0aGlzLl9hY3RpdmVTZXJ2ZXJzLmZpbHRlcihzID0+ICF1c2VkU2VydmVycy5oYXMocykpO1xyXG4gICAgaWYgKHVudXNlZFNlcnZlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYFN0b3BwaW5nICR7dW51c2VkU2VydmVycy5sZW5ndGh9IHVudXNlZCBzZXJ2ZXJzYCk7XHJcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHVudXNlZFNlcnZlcnMubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wQWxsU2VydmVycygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX2FjdGl2ZVNlcnZlcnMubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBzdG9wU2VydmVyKHNlcnZlcjogQWN0aXZlU2VydmVyKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCBidXN5U2lnbmFsU2VydmljZSA9IHRoaXMuX2dldEJ1c3lTaWduYWxTZXJ2aWNlKCk7XHJcbiAgICBjb25zdCBzaWduYWwgPSBidXN5U2lnbmFsU2VydmljZSAmJiBidXN5U2lnbmFsU2VydmljZS5yZXBvcnRCdXN5KFxyXG4gICAgICBgU3RvcHBpbmcgJHt0aGlzLl9sYW5ndWFnZVNlcnZlck5hbWV9IGZvciAke3BhdGguYmFzZW5hbWUoc2VydmVyLnByb2plY3RQYXRoKX1gLFxyXG4gICAgKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0b3BwaW5nIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCJgKTtcclxuICAgICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBzZXJ2ZXIgdG8gcHJldmVudCBmdXJ0aGVyIHVzYWdlLlxyXG4gICAgICAvLyBJZiB3ZSByZS1vcGVuIHRoZSBmaWxlIGFmdGVyIHRoaXMgcG9pbnQsIHdlJ2xsIGdldCBhIG5ldyBzZXJ2ZXIuXHJcbiAgICAgIHRoaXMuX2FjdGl2ZVNlcnZlcnMuc3BsaWNlKHRoaXMuX2FjdGl2ZVNlcnZlcnMuaW5kZXhPZihzZXJ2ZXIpLCAxKTtcclxuICAgICAgdGhpcy5fc3RvcHBpbmdTZXJ2ZXJzLnB1c2goc2VydmVyKTtcclxuICAgICAgc2VydmVyLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xyXG4gICAgICBhd2FpdCBzZXJ2ZXIuY29ubmVjdGlvbi5zaHV0ZG93bigpO1xyXG5cclxuICAgICAgaWYgKHNlcnZlci5saW50ZXJQdXNoVjIgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlci5saW50ZXJQdXNoVjIuZGV0YWNoQWxsKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZXJ2ZXIuc2lnbmF0dXJlSGVscEFkYXB0ZXIgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlci5zaWduYXR1cmVIZWxwQWRhcHRlci5kaXNwb3NlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZXhpdFNlcnZlcihzZXJ2ZXIpO1xyXG4gICAgICB0aGlzLl9zdG9wcGluZ1NlcnZlcnMuc3BsaWNlKHRoaXMuX3N0b3BwaW5nU2VydmVycy5pbmRleE9mKHNlcnZlciksIDEpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2lnbmFsICYmIHNpZ25hbC5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBleGl0U2VydmVyKHNlcnZlcjogQWN0aXZlU2VydmVyKTogdm9pZCB7XHJcbiAgICBjb25zdCBwaWQgPSBzZXJ2ZXIucHJvY2Vzcy5waWQ7XHJcbiAgICB0cnkge1xyXG4gICAgICBzZXJ2ZXIuY29ubmVjdGlvbi5leGl0KCk7XHJcbiAgICAgIHNlcnZlci5jb25uZWN0aW9uLmRpc3Bvc2UoKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNlcnZlci5wcm9jZXNzLmtpbGwoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHN0b3BwZWQgXCIke3NlcnZlci5wcm9qZWN0UGF0aH1cIiAocGlkICR7cGlkfSlgKTtcclxuICB9XHJcblxyXG4gIHRlcm1pbmF0ZSgpOiB2b2lkIHtcclxuICAgIHRoaXMuX3N0b3BwaW5nU2VydmVycy5mb3JFYWNoKHNlcnZlciA9PiB7XHJcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgU2VydmVyIHRlcm1pbmF0aW5nIFwiJHtzZXJ2ZXIucHJvamVjdFBhdGh9XCJgKTtcclxuICAgICAgdGhpcy5leGl0U2VydmVyKHNlcnZlcik7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGRldGVybWluZVByb2plY3RQYXRoKHRleHRFZGl0b3I6IGF0b20kVGV4dEVkaXRvcik6ID9zdHJpbmcge1xyXG4gICAgY29uc3QgZmlsZVBhdGggPSB0ZXh0RWRpdG9yLmdldFBhdGgoKTtcclxuICAgIGlmIChmaWxlUGF0aCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMuZmluZChkID0+IGZpbGVQYXRoLnN0YXJ0c1dpdGgoZCkpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlTm9ybWFsaXplZFByb2plY3RQYXRocygpOiB2b2lkIHtcclxuICAgIHRoaXMuX25vcm1hbGl6ZWRQcm9qZWN0UGF0aHMgPSBhdG9tLnByb2plY3QuZ2V0RGlyZWN0b3JpZXMoKS5tYXAoZCA9PiB0aGlzLm5vcm1hbGl6ZVBhdGgoZC5nZXRQYXRoKCkpKTtcclxuICB9XHJcblxyXG4gIG5vcm1hbGl6ZVBhdGgocHJvamVjdFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gIXByb2plY3RQYXRoLmVuZHNXaXRoKHBhdGguc2VwKSA/IHBhdGguam9pbihwcm9qZWN0UGF0aCwgcGF0aC5zZXApIDogcHJvamVjdFBhdGg7XHJcbiAgfVxyXG5cclxuICBwcm9qZWN0UGF0aHNDaGFuZ2VkKHByb2plY3RQYXRoczogQXJyYXk8c3RyaW5nPik6IHZvaWQge1xyXG4gICAgY29uc3QgcGF0aHNTZXQgPSBuZXcgU2V0KHByb2plY3RQYXRocy5tYXAodGhpcy5ub3JtYWxpemVQYXRoKSk7XHJcbiAgICBjb25zdCBzZXJ2ZXJzVG9TdG9wID0gdGhpcy5fYWN0aXZlU2VydmVycy5maWx0ZXIocyA9PiAhcGF0aHNTZXQuaGFzKHMucHJvamVjdFBhdGgpKTtcclxuICAgIFByb21pc2UuYWxsKHNlcnZlcnNUb1N0b3AubWFwKHMgPT4gdGhpcy5zdG9wU2VydmVyKHMpKSk7XHJcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbGl6ZWRQcm9qZWN0UGF0aHMoKTtcclxuICB9XHJcblxyXG4gIHByb2plY3RGaWxlc0NoYW5nZWQoZmlsZUV2ZW50czogQXJyYXk8YXRvbSRQcm9qZWN0RmlsZUV2ZW50Pik6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX2FjdGl2ZVNlcnZlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGFjdGl2ZVNlcnZlciBvZiB0aGlzLl9hY3RpdmVTZXJ2ZXJzKSB7XHJcbiAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcclxuICAgICAgZm9yIChjb25zdCBmaWxlRXZlbnQgb2YgZmlsZUV2ZW50cykge1xyXG4gICAgICAgIGlmIChmaWxlRXZlbnQucGF0aC5zdGFydHNXaXRoKGFjdGl2ZVNlcnZlci5wcm9qZWN0UGF0aCkgJiYgdGhpcy5fY2hhbmdlV2F0Y2hlZEZpbGVGaWx0ZXIoZmlsZUV2ZW50LnBhdGgpKSB7XHJcbiAgICAgICAgICBjaGFuZ2VzLnB1c2goQ29udmVydC5hdG9tRmlsZUV2ZW50VG9MU0ZpbGVFdmVudHMoZmlsZUV2ZW50KVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIGZpbGVFdmVudC5vbGRQYXRoICYmXHJcbiAgICAgICAgICBmaWxlRXZlbnQub2xkUGF0aC5zdGFydHNXaXRoKGFjdGl2ZVNlcnZlci5wcm9qZWN0UGF0aCkgJiZcclxuICAgICAgICAgIHRoaXMuX2NoYW5nZVdhdGNoZWRGaWxlRmlsdGVyKGZpbGVFdmVudC5vbGRQYXRoKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgY2hhbmdlcy5wdXNoKENvbnZlcnQuYXRvbUZpbGVFdmVudFRvTFNGaWxlRXZlbnRzKGZpbGVFdmVudClbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgYWN0aXZlU2VydmVyLmNvbm5lY3Rpb24uZGlkQ2hhbmdlV2F0Y2hlZEZpbGVzKHtjaGFuZ2VzfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19