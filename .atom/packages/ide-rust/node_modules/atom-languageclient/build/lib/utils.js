Object.defineProperty(exports, "__esModule", {
  value: true
});

var _atom = require('atom');

var _vscodeJsonrpc = require('vscode-jsonrpc');

class Utils {
  /**
   * Obtain the range of the word at the given editor position.
   * Uses the non-word characters from the position's grammar scope.
   */
  static getWordAtPosition(editor, position) {
    const scopeDescriptor = editor.scopeDescriptorForBufferPosition(position);
    const nonWordCharacters = Utils.escapeRegExp(editor.getNonWordCharacters(scopeDescriptor));
    const range = Utils._getRegexpRangeAtPosition(editor.getBuffer(), position, new RegExp(`^[\t ]*$|[^\\s${nonWordCharacters}]+`, 'g'));
    if (range == null) {
      return new _atom.Range(position, position);
    }
    return range;
  }

  static escapeRegExp(string) {
    // From atom/underscore-plus.
    return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  static _getRegexpRangeAtPosition(buffer, position, wordRegex) {
    const { row, column } = position;
    const rowRange = buffer.rangeForRow(row);
    let matchData;
    // Extract the expression from the row text.
    buffer.scanInRange(wordRegex, rowRange, data => {
      const { range } = data;
      if (position.isGreaterThanOrEqual(range.start) &&
      // Range endpoints are exclusive.
      position.isLessThan(range.end)) {
        matchData = data;
        data.stop();
        return;
      }
      // Stop the scan if the scanner has passed our position.
      if (range.end.column > column) {
        data.stop();
      }
    });
    return matchData == null ? null : matchData.range;
  }

  /**
   * For the given connection and cancellationTokens map, cancel the existing
   * CancellationToken for that connection then create and store a new
   * CancellationToken to be used for the current request.
   */
  static cancelAndRefreshCancellationToken(key, cancellationTokens) {

    let cancellationToken = cancellationTokens.get(key);
    if (cancellationToken !== undefined && !cancellationToken.token.isCancellationRequested) {
      cancellationToken.cancel();
    }

    cancellationToken = new _vscodeJsonrpc.CancellationTokenSource();
    cancellationTokens.set(key, cancellationToken);
    return cancellationToken.token;
  }

  static async doWithCancellationToken(key, cancellationTokens, work) {
    const token = Utils.cancelAndRefreshCancellationToken(key, cancellationTokens);
    const result = await work(token);
    cancellationTokens.delete(key);
    return result;
  }
}
exports.default = Utils;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi91dGlscy5qcyJdLCJuYW1lcyI6WyJVdGlscyIsImdldFdvcmRBdFBvc2l0aW9uIiwiZWRpdG9yIiwicG9zaXRpb24iLCJzY29wZURlc2NyaXB0b3IiLCJzY29wZURlc2NyaXB0b3JGb3JCdWZmZXJQb3NpdGlvbiIsIm5vbldvcmRDaGFyYWN0ZXJzIiwiZXNjYXBlUmVnRXhwIiwiZ2V0Tm9uV29yZENoYXJhY3RlcnMiLCJyYW5nZSIsIl9nZXRSZWdleHBSYW5nZUF0UG9zaXRpb24iLCJnZXRCdWZmZXIiLCJSZWdFeHAiLCJzdHJpbmciLCJyZXBsYWNlIiwiYnVmZmVyIiwid29yZFJlZ2V4Iiwicm93IiwiY29sdW1uIiwicm93UmFuZ2UiLCJyYW5nZUZvclJvdyIsIm1hdGNoRGF0YSIsInNjYW5JblJhbmdlIiwiZGF0YSIsImlzR3JlYXRlclRoYW5PckVxdWFsIiwic3RhcnQiLCJpc0xlc3NUaGFuIiwiZW5kIiwic3RvcCIsImNhbmNlbEFuZFJlZnJlc2hDYW5jZWxsYXRpb25Ub2tlbiIsImtleSIsImNhbmNlbGxhdGlvblRva2VucyIsImNhbmNlbGxhdGlvblRva2VuIiwiZ2V0IiwidW5kZWZpbmVkIiwidG9rZW4iLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsImNhbmNlbCIsInNldCIsImRvV2l0aENhbmNlbGxhdGlvblRva2VuIiwid29yayIsInJlc3VsdCIsImRlbGV0ZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOztBQUNBOztBQUVlLE1BQU1BLEtBQU4sQ0FBWTtBQUN6Qjs7OztBQUlBLFNBQU9DLGlCQUFQLENBQXlCQyxNQUF6QixFQUE2Q0MsUUFBN0MsRUFBMEU7QUFDeEUsVUFBTUMsa0JBQWtCRixPQUFPRyxnQ0FBUCxDQUF3Q0YsUUFBeEMsQ0FBeEI7QUFDQSxVQUFNRyxvQkFBb0JOLE1BQU1PLFlBQU4sQ0FBbUJMLE9BQU9NLG9CQUFQLENBQTRCSixlQUE1QixDQUFuQixDQUExQjtBQUNBLFVBQU1LLFFBQVFULE1BQU1VLHlCQUFOLENBQ1pSLE9BQU9TLFNBQVAsRUFEWSxFQUVaUixRQUZZLEVBR1osSUFBSVMsTUFBSixDQUFZLGlCQUFnQk4saUJBQWtCLElBQTlDLEVBQW1ELEdBQW5ELENBSFksQ0FBZDtBQUtBLFFBQUlHLFNBQVMsSUFBYixFQUFtQjtBQUNqQixhQUFPLGdCQUFVTixRQUFWLEVBQW9CQSxRQUFwQixDQUFQO0FBQ0Q7QUFDRCxXQUFPTSxLQUFQO0FBQ0Q7O0FBRUQsU0FBT0YsWUFBUCxDQUFvQk0sTUFBcEIsRUFBNEM7QUFDMUM7QUFDQSxXQUFPQSxPQUFPQyxPQUFQLENBQWUsdUJBQWYsRUFBd0MsTUFBeEMsQ0FBUDtBQUNEOztBQUVELFNBQU9KLHlCQUFQLENBQWlDSyxNQUFqQyxFQUEwRFosUUFBMUQsRUFBZ0ZhLFNBQWhGLEVBQTJHO0FBQ3pHLFVBQU0sRUFBQ0MsR0FBRCxFQUFNQyxNQUFOLEtBQWdCZixRQUF0QjtBQUNBLFVBQU1nQixXQUFXSixPQUFPSyxXQUFQLENBQW1CSCxHQUFuQixDQUFqQjtBQUNBLFFBQUlJLFNBQUo7QUFDQTtBQUNBTixXQUFPTyxXQUFQLENBQW1CTixTQUFuQixFQUE4QkcsUUFBOUIsRUFBd0NJLFFBQVE7QUFDOUMsWUFBTSxFQUFDZCxLQUFELEtBQVVjLElBQWhCO0FBQ0EsVUFDRXBCLFNBQVNxQixvQkFBVCxDQUE4QmYsTUFBTWdCLEtBQXBDO0FBQ0E7QUFDQXRCLGVBQVN1QixVQUFULENBQW9CakIsTUFBTWtCLEdBQTFCLENBSEYsRUFJRTtBQUNBTixvQkFBWUUsSUFBWjtBQUNBQSxhQUFLSyxJQUFMO0FBQ0E7QUFDRDtBQUNEO0FBQ0EsVUFBSW5CLE1BQU1rQixHQUFOLENBQVVULE1BQVYsR0FBbUJBLE1BQXZCLEVBQStCO0FBQzdCSyxhQUFLSyxJQUFMO0FBQ0Q7QUFDRixLQWZEO0FBZ0JBLFdBQU9QLGFBQWEsSUFBYixHQUFvQixJQUFwQixHQUEyQkEsVUFBVVosS0FBNUM7QUFDRDs7QUFFRDs7Ozs7QUFLQSxTQUFPb0IsaUNBQVAsQ0FDRUMsR0FERixFQUVFQyxrQkFGRixFQUU4RTs7QUFFNUUsUUFBSUMsb0JBQW9CRCxtQkFBbUJFLEdBQW5CLENBQXVCSCxHQUF2QixDQUF4QjtBQUNBLFFBQUlFLHNCQUFzQkUsU0FBdEIsSUFBbUMsQ0FBQ0Ysa0JBQWtCRyxLQUFsQixDQUF3QkMsdUJBQWhFLEVBQXlGO0FBQ3ZGSix3QkFBa0JLLE1BQWxCO0FBQ0Q7O0FBRURMLHdCQUFvQiw0Q0FBcEI7QUFDQUQsdUJBQW1CTyxHQUFuQixDQUF1QlIsR0FBdkIsRUFBNEJFLGlCQUE1QjtBQUNBLFdBQU9BLGtCQUFrQkcsS0FBekI7QUFDRDs7QUFFRCxlQUFhSSx1QkFBYixDQUNFVCxHQURGLEVBRUVDLGtCQUZGLEVBR0VTLElBSEYsRUFJZTtBQUNiLFVBQU1MLFFBQVFuQyxNQUFNNkIsaUNBQU4sQ0FBd0NDLEdBQXhDLEVBQTZDQyxrQkFBN0MsQ0FBZDtBQUNBLFVBQU1VLFNBQVksTUFBTUQsS0FBS0wsS0FBTCxDQUF4QjtBQUNBSix1QkFBbUJXLE1BQW5CLENBQTBCWixHQUExQjtBQUNBLFdBQU9XLE1BQVA7QUFDRDtBQTVFd0I7a0JBQU56QyxLIiwiZmlsZSI6InV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHtSYW5nZX0gZnJvbSAnYXRvbSc7XG5pbXBvcnQge0NhbmNlbGxhdGlvblRva2VuU291cmNlfSBmcm9tICd2c2NvZGUtanNvbnJwYyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFV0aWxzIHtcbiAgLyoqXG4gICAqIE9idGFpbiB0aGUgcmFuZ2Ugb2YgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIGVkaXRvciBwb3NpdGlvbi5cbiAgICogVXNlcyB0aGUgbm9uLXdvcmQgY2hhcmFjdGVycyBmcm9tIHRoZSBwb3NpdGlvbidzIGdyYW1tYXIgc2NvcGUuXG4gICAqL1xuICBzdGF0aWMgZ2V0V29yZEF0UG9zaXRpb24oZWRpdG9yOiBUZXh0RWRpdG9yLCBwb3NpdGlvbjogYXRvbSRQb2ludCk6IFJhbmdlIHtcbiAgICBjb25zdCBzY29wZURlc2NyaXB0b3IgPSBlZGl0b3Iuc2NvcGVEZXNjcmlwdG9yRm9yQnVmZmVyUG9zaXRpb24ocG9zaXRpb24pO1xuICAgIGNvbnN0IG5vbldvcmRDaGFyYWN0ZXJzID0gVXRpbHMuZXNjYXBlUmVnRXhwKGVkaXRvci5nZXROb25Xb3JkQ2hhcmFjdGVycyhzY29wZURlc2NyaXB0b3IpKTtcbiAgICBjb25zdCByYW5nZSA9IFV0aWxzLl9nZXRSZWdleHBSYW5nZUF0UG9zaXRpb24oXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCksXG4gICAgICBwb3NpdGlvbixcbiAgICAgIG5ldyBSZWdFeHAoYF5bXFx0IF0qJHxbXlxcXFxzJHtub25Xb3JkQ2hhcmFjdGVyc31dK2AsICdnJyksXG4gICAgKTtcbiAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbiwgcG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBzdGF0aWMgZXNjYXBlUmVnRXhwKHN0cmluZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBGcm9tIGF0b20vdW5kZXJzY29yZS1wbHVzLlxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICB9XG5cbiAgc3RhdGljIF9nZXRSZWdleHBSYW5nZUF0UG9zaXRpb24oYnVmZmVyOiBhdG9tJFRleHRCdWZmZXIsIHBvc2l0aW9uOiBhdG9tJFBvaW50LCB3b3JkUmVnZXg6IFJlZ0V4cCk6ID9SYW5nZSB7XG4gICAgY29uc3Qge3JvdywgY29sdW1ufSA9IHBvc2l0aW9uO1xuICAgIGNvbnN0IHJvd1JhbmdlID0gYnVmZmVyLnJhbmdlRm9yUm93KHJvdyk7XG4gICAgbGV0IG1hdGNoRGF0YTtcbiAgICAvLyBFeHRyYWN0IHRoZSBleHByZXNzaW9uIGZyb20gdGhlIHJvdyB0ZXh0LlxuICAgIGJ1ZmZlci5zY2FuSW5SYW5nZSh3b3JkUmVnZXgsIHJvd1JhbmdlLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHtyYW5nZX0gPSBkYXRhO1xuICAgICAgaWYgKFxuICAgICAgICBwb3NpdGlvbi5pc0dyZWF0ZXJUaGFuT3JFcXVhbChyYW5nZS5zdGFydCkgJiZcbiAgICAgICAgLy8gUmFuZ2UgZW5kcG9pbnRzIGFyZSBleGNsdXNpdmUuXG4gICAgICAgIHBvc2l0aW9uLmlzTGVzc1RoYW4ocmFuZ2UuZW5kKVxuICAgICAgKSB7XG4gICAgICAgIG1hdGNoRGF0YSA9IGRhdGE7XG4gICAgICAgIGRhdGEuc3RvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTdG9wIHRoZSBzY2FuIGlmIHRoZSBzY2FubmVyIGhhcyBwYXNzZWQgb3VyIHBvc2l0aW9uLlxuICAgICAgaWYgKHJhbmdlLmVuZC5jb2x1bW4gPiBjb2x1bW4pIHtcbiAgICAgICAgZGF0YS5zdG9wKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdGNoRGF0YSA9PSBudWxsID8gbnVsbCA6IG1hdGNoRGF0YS5yYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgdGhlIGdpdmVuIGNvbm5lY3Rpb24gYW5kIGNhbmNlbGxhdGlvblRva2VucyBtYXAsIGNhbmNlbCB0aGUgZXhpc3RpbmdcbiAgICogQ2FuY2VsbGF0aW9uVG9rZW4gZm9yIHRoYXQgY29ubmVjdGlvbiB0aGVuIGNyZWF0ZSBhbmQgc3RvcmUgYSBuZXdcbiAgICogQ2FuY2VsbGF0aW9uVG9rZW4gdG8gYmUgdXNlZCBmb3IgdGhlIGN1cnJlbnQgcmVxdWVzdC5cbiAgICovXG4gIHN0YXRpYyBjYW5jZWxBbmRSZWZyZXNoQ2FuY2VsbGF0aW9uVG9rZW48VD4oXG4gICAga2V5OiBULFxuICAgIGNhbmNlbGxhdGlvblRva2VuczogV2Vha01hcDxULCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZT4pOiBDYW5jZWxsYXRpb25Ub2tlbiB7XG5cbiAgICBsZXQgY2FuY2VsbGF0aW9uVG9rZW4gPSBjYW5jZWxsYXRpb25Ub2tlbnMuZ2V0KGtleSk7XG4gICAgaWYgKGNhbmNlbGxhdGlvblRva2VuICE9PSB1bmRlZmluZWQgJiYgIWNhbmNlbGxhdGlvblRva2VuLnRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XG4gICAgICBjYW5jZWxsYXRpb25Ub2tlbi5jYW5jZWwoKTtcbiAgICB9XG5cbiAgICBjYW5jZWxsYXRpb25Ub2tlbiA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgIGNhbmNlbGxhdGlvblRva2Vucy5zZXQoa2V5LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgcmV0dXJuIGNhbmNlbGxhdGlvblRva2VuLnRva2VuO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGRvV2l0aENhbmNlbGxhdGlvblRva2VuPFQxLCBUMj4oXG4gICAga2V5OiBUMSxcbiAgICBjYW5jZWxsYXRpb25Ub2tlbnM6IFdlYWtNYXA8VDEsIENhbmNlbGxhdGlvblRva2VuU291cmNlPixcbiAgICB3b3JrOiAoQ2FuY2VsbGF0aW9uVG9rZW4pID0+IFByb21pc2U8VDI+LFxuICApOiBQcm9taXNlPFQyPiB7XG4gICAgY29uc3QgdG9rZW4gPSBVdGlscy5jYW5jZWxBbmRSZWZyZXNoQ2FuY2VsbGF0aW9uVG9rZW4oa2V5LCBjYW5jZWxsYXRpb25Ub2tlbnMpO1xuICAgIGNvbnN0IHJlc3VsdDpUMiA9IGF3YWl0IHdvcmsodG9rZW4pO1xuICAgIGNhbmNlbGxhdGlvblRva2Vucy5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iXX0=