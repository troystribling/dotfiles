var _chai = require('chai');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _applyEditAdapter = require('../../lib/adapters/apply-edit-adapter');

var _applyEditAdapter2 = _interopRequireDefault(_applyEditAdapter);

var _convert = require('../../lib/convert');

var _convert2 = _interopRequireDefault(_convert);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TEST_PATH1 = _path2.default.join(__dirname, 'test.txt');

const TEST_PATH2 = _path2.default.join(__dirname, 'test2.txt');
const TEST_PATH3 = _path2.default.join(__dirname, 'test3.txt');
const TEST_PATH4 = _path2.default.join(__dirname, 'test4.txt');

describe('ApplyEditAdapter', () => {
  describe('onApplyEdit', () => {
    beforeEach(() => {
      _sinon2.default.spy(atom.notifications, 'addError');
    });

    afterEach(() => {
      atom.notifications.addError.restore();
    });

    it('works for open files', async () => {
      const editor = await atom.workspace.open(TEST_PATH1);
      editor.setText('abc\ndef\n');

      const result = await _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [_convert2.default.pathToUri(TEST_PATH1)]: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 3 }
              },
              newText: 'def'
            }, {
              range: {
                start: { line: 1, character: 0 },
                end: { line: 1, character: 3 }
              },
              newText: 'ghi'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(true);
      (0, _chai.expect)(editor.getText()).to.equal('def\nghi\n');

      // Undo should be atomic.
      editor.getBuffer().undo();
      (0, _chai.expect)(editor.getText()).to.equal('abc\ndef\n');
    });

    it('works with TextDocumentEdits', async () => {
      const editor = await atom.workspace.open(TEST_PATH1);
      editor.setText('abc\ndef\n');

      const result = await _applyEditAdapter2.default.onApplyEdit({
        edit: {
          documentChanges: [{
            textDocument: {
              version: 1,
              uri: _convert2.default.pathToUri(TEST_PATH1)
            },
            edits: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 3 }
              },
              newText: 'def'
            }, {
              range: {
                start: { line: 1, character: 0 },
                end: { line: 1, character: 3 }
              },
              newText: 'ghi'
            }]
          }]
        }
      });

      (0, _chai.expect)(result.applied).to.equal(true);
      (0, _chai.expect)(editor.getText()).to.equal('def\nghi\n');

      // Undo should be atomic.
      editor.getBuffer().undo();
      (0, _chai.expect)(editor.getText()).to.equal('abc\ndef\n');
    });

    it('opens files that are not already open', async () => {
      const result = await _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [TEST_PATH2]: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 0 }
              },
              newText: 'abc'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(true);
      const editor = await atom.workspace.open(TEST_PATH2);
      (0, _chai.expect)(editor.getText()).to.equal('abc');
    });

    it('fails with overlapping edits', async () => {
      const editor = await atom.workspace.open(TEST_PATH3);
      editor.setText('abcdef\n');

      const result = await _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [TEST_PATH3]: [{
              range: {
                start: { line: 0, character: 0 },
                end: { line: 0, character: 3 }
              },
              newText: 'def'
            }, {
              range: {
                start: { line: 0, character: 2 },
                end: { line: 0, character: 4 }
              },
              newText: 'ghi'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(false);
      (0, _chai.expect)(atom.notifications.addError.calledWith('workspace/applyEdits failed', {
        description: 'Failed to apply edits.',
        detail: `Found overlapping edit ranges in ${TEST_PATH3}`
      })).to.equal(true);
      // No changes.
      (0, _chai.expect)(editor.getText()).to.equal('abcdef\n');
    });

    it('fails with out-of-range edits', async () => {
      const result = await _applyEditAdapter2.default.onApplyEdit({
        edit: {
          changes: {
            [TEST_PATH4]: [{
              range: {
                start: { line: 0, character: 1 },
                end: { line: 0, character: 2 }
              },
              newText: 'def'
            }]
          }
        }
      });

      (0, _chai.expect)(result.applied).to.equal(false);
      const errorCalls = atom.notifications.addError.getCalls();
      (0, _chai.expect)(errorCalls.length).to.equal(1);
      (0, _chai.expect)(errorCalls[0].args[1].detail).to.equal(`Out of range edit on ${TEST_PATH4}:1:2`);
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvYXBwbHktZWRpdC1hZGFwdGVyLnRlc3QuanMiXSwibmFtZXMiOlsiVEVTVF9QQVRIMSIsImpvaW4iLCJfX2Rpcm5hbWUiLCJURVNUX1BBVEgyIiwiVEVTVF9QQVRIMyIsIlRFU1RfUEFUSDQiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJzcHkiLCJhdG9tIiwibm90aWZpY2F0aW9ucyIsImFmdGVyRWFjaCIsImFkZEVycm9yIiwicmVzdG9yZSIsIml0IiwiZWRpdG9yIiwid29ya3NwYWNlIiwib3BlbiIsInNldFRleHQiLCJyZXN1bHQiLCJvbkFwcGx5RWRpdCIsImVkaXQiLCJjaGFuZ2VzIiwicGF0aFRvVXJpIiwicmFuZ2UiLCJzdGFydCIsImxpbmUiLCJjaGFyYWN0ZXIiLCJlbmQiLCJuZXdUZXh0IiwiYXBwbGllZCIsInRvIiwiZXF1YWwiLCJnZXRUZXh0IiwiZ2V0QnVmZmVyIiwidW5kbyIsImRvY3VtZW50Q2hhbmdlcyIsInRleHREb2N1bWVudCIsInZlcnNpb24iLCJ1cmkiLCJlZGl0cyIsImNhbGxlZFdpdGgiLCJkZXNjcmlwdGlvbiIsImRldGFpbCIsImVycm9yQ2FsbHMiLCJnZXRDYWxscyIsImxlbmd0aCIsImFyZ3MiXSwibWFwcGluZ3MiOiJBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxhQUFhLGVBQUtDLElBQUwsQ0FBVUMsU0FBVixFQUFxQixVQUFyQixDQUFuQjs7QUFDQSxNQUFNQyxhQUFhLGVBQUtGLElBQUwsQ0FBVUMsU0FBVixFQUFxQixXQUFyQixDQUFuQjtBQUNBLE1BQU1FLGFBQWEsZUFBS0gsSUFBTCxDQUFVQyxTQUFWLEVBQXFCLFdBQXJCLENBQW5CO0FBQ0EsTUFBTUcsYUFBYSxlQUFLSixJQUFMLENBQVVDLFNBQVYsRUFBcUIsV0FBckIsQ0FBbkI7O0FBRUFJLFNBQVMsa0JBQVQsRUFBNkIsTUFBTTtBQUNqQ0EsV0FBUyxhQUFULEVB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QUExQixDQUE2QkMsS0FBN0IsQ0FBbUMsQ0FBbkM7QUFDQSx3QkFBT1ksV0FBVyxDQUFYLEVBQWNHLElBQWQsQ0FBbUIsQ0FBbkIsRUFBc0JKLE1BQTdCLEVBQXFDWixFQUFyQyxDQUF3Q0MsS0FBeEMsQ0FBK0Msd0JBQXVCM0IsVUFBVyxNQUFqRjtBQUNELEtBckJEO0FBc0JELEdBcktEO0FBc0tELENBdktEIiwiZmlsZSI6ImFwcGx5LWVkaXQtYWRhcHRlci50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHtleHBlY3R9IGZyb20gJ2NoYWknO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2lub24gZnJvbSAnc2lub24nO1xuaW1wb3J0IEFwcGx5RWRpdEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlcic7XG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi8uLi9saWIvY29udmVydCc7XG5cbmNvbnN0IFRFU1RfUEFUSDEgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdC50eHQnKTtcbmNvbnN0IFRFU1RfUEFUSDIgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGVzdDIudHh0Jyk7XG5jb25zdCBURVNUX1BBVEgzID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3QzLnR4dCcpO1xuY29uc3QgVEVTVF9QQVRINCA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0NC50eHQnKTtcblxuZGVzY3JpYmUoJ0FwcGx5RWRpdEFkYXB0ZXInLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdvbkFwcGx5RWRpdCcsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHNpbm9uLnNweShhdG9tLm5vdGlmaWNhdGlvbnMsICdhZGRFcnJvcicpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvci5yZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnd29ya3MgZm9yIG9wZW4gZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBhdG9tLndvcmtzcGFjZS5vcGVuKFRFU1RfUEFUSDEpO1xuICAgICAgZWRpdG9yLnNldFRleHQoJ2FiY1xcbmRlZlxcbicpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KHtcbiAgICAgICAgZWRpdDoge1xuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIFtDb252ZXJ0LnBhdGhUb1VyaShURVNUX1BBVEgxKV06IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDN9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2RlZicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAxLCBjaGFyYWN0ZXI6IDB9LFxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMSwgY2hhcmFjdGVyOiAzfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdnaGknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZCkudG8uZXF1YWwodHJ1ZSk7XG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2RlZlxcbmdoaVxcbicpO1xuXG4gICAgICAvLyBVbmRvIHNob3VsZCBiZSBhdG9taWMuXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkudW5kbygpO1xuICAgICAgZXhwZWN0KGVkaXRvci5nZXRUZXh0KCkpLnRvLmVxdWFsKCdhYmNcXG5kZWZcXG4nKTtcbiAgICB9KTtcblxuICAgIGl0KCd3b3JrcyB3aXRoIFRleHREb2N1bWVudEVkaXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yID0gYXdhaXQgYXRvbS53b3Jrc3BhY2Uub3BlbihURVNUX1BBVEgxKTtcbiAgICAgIGVkaXRvci5zZXRUZXh0KCdhYmNcXG5kZWZcXG4nKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XG4gICAgICAgIGVkaXQ6IHtcbiAgICAgICAgICBkb2N1bWVudENoYW5nZXM6IFt7XG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgdXJpOiBDb252ZXJ0LnBhdGhUb1VyaShURVNUX1BBVEgxKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlZGl0czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAwfSxcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogM30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDEsIGNoYXJhY3RlcjogMH0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAxLCBjaGFyYWN0ZXI6IDN9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2doaScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH1dLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZCkudG8uZXF1YWwodHJ1ZSk7XG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2RlZlxcbmdoaVxcbicpO1xuXG4gICAgICAvLyBVbmRvIHNob3VsZCBiZSBhdG9taWMuXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkudW5kbygpO1xuICAgICAgZXhwZWN0KGVkaXRvci5nZXRUZXh0KCkpLnRvLmVxdWFsKCdhYmNcXG5kZWZcXG4nKTtcbiAgICB9KTtcblxuICAgIGl0KCdvcGVucyBmaWxlcyB0aGF0IGFyZSBub3QgYWxyZWFkeSBvcGVuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XG4gICAgICAgIGVkaXQ6IHtcbiAgICAgICAgICBjaGFuZ2VzOiB7XG4gICAgICAgICAgICBbVEVTVF9QQVRIMl06IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2FiYycsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkKS50by5lcXVhbCh0cnVlKTtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oVEVTVF9QQVRIMik7XG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2FiYycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ZhaWxzIHdpdGggb3ZlcmxhcHBpbmcgZWRpdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBhdG9tLndvcmtzcGFjZS5vcGVuKFRFU1RfUEFUSDMpO1xuICAgICAgZWRpdG9yLnNldFRleHQoJ2FiY2RlZlxcbicpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KHtcbiAgICAgICAgZWRpdDoge1xuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIFtURVNUX1BBVEgzXTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAwfSxcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogM30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDR9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2doaScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5hcHBsaWVkKS50by5lcXVhbChmYWxzZSk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRFcnJvci5jYWxsZWRXaXRoKCd3b3Jrc3BhY2UvYXBwbHlFZGl0cyBmYWlsZWQnLCB7XG4gICAgICAgICAgZGVzY3JpcHRpb246ICdGYWlsZWQgdG8gYXBwbHkgZWRpdHMuJyxcbiAgICAgICAgICBkZXRhaWw6IGBGb3VuZCBvdmVybGFwcGluZyBlZGl0IHJhbmdlcyBpbiAke1RFU1RfUEFUSDN9YCxcbiAgICAgICAgfSksXG4gICAgICApLnRvLmVxdWFsKHRydWUpO1xuICAgICAgLy8gTm8gY2hhbmdlcy5cbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnYWJjZGVmXFxuJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnZmFpbHMgd2l0aCBvdXQtb2YtcmFuZ2UgZWRpdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KHtcbiAgICAgICAgZWRpdDoge1xuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIFtURVNUX1BBVEg0XTogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAxfSxcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKGZhbHNlKTtcbiAgICAgIGNvbnN0IGVycm9yQ2FsbHMgPSBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkRXJyb3IuZ2V0Q2FsbHMoKTtcbiAgICAgIGV4cGVjdChlcnJvckNhbGxzLmxlbmd0aCkudG8uZXF1YWwoMSk7XG4gICAgICBleHBlY3QoZXJyb3JDYWxsc1swXS5hcmdzWzFdLmRldGFpbCkudG8uZXF1YWwoYE91dCBvZiByYW5nZSBlZGl0IG9uICR7VEVTVF9QQVRINH06MToyYCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=