"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const path = require("path");
const sinon = require("sinon");
const apply_edit_adapter_1 = require("../../lib/adapters/apply-edit-adapter");
const convert_1 = require("../../lib/convert");
const TEST_PATH1 = path.join(__dirname, 'test.txt');
const TEST_PATH2 = path.join(__dirname, 'test2.txt');
const TEST_PATH3 = path.join(__dirname, 'test3.txt');
const TEST_PATH4 = path.join(__dirname, 'test4.txt');
describe('ApplyEditAdapter', () => {
    describe('onApplyEdit', () => {
        beforeEach(() => {
            sinon.spy(atom.notifications, 'addError');
        });
        afterEach(() => {
            atom.notifications.addError.restore();
        });
        it('works for open files', () => __awaiter(this, void 0, void 0, function* () {
            const editor = yield atom.workspace.open(TEST_PATH1);
            editor.setText('abc\ndef\n');
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [convert_1.default.pathToUri(TEST_PATH1)]: [
                            {
                                range: {
                                    start: { line: 0, character: 0 },
                                    end: { line: 0, character: 3 },
                                },
                                newText: 'def',
                            },
                            {
                                range: {
                                    start: { line: 1, character: 0 },
                                    end: { line: 1, character: 3 },
                                },
                                newText: 'ghi',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(true);
            chai_1.expect(editor.getText()).to.equal('def\nghi\n');
            // Undo should be atomic.
            editor.getBuffer().undo();
            chai_1.expect(editor.getText()).to.equal('abc\ndef\n');
        }));
        it('works with TextDocumentEdits', () => __awaiter(this, void 0, void 0, function* () {
            const editor = yield atom.workspace.open(TEST_PATH1);
            editor.setText('abc\ndef\n');
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    documentChanges: [{
                            textDocument: {
                                version: 1,
                                uri: convert_1.default.pathToUri(TEST_PATH1),
                            },
                            edits: [
                                {
                                    range: {
                                        start: { line: 0, character: 0 },
                                        end: { line: 0, character: 3 },
                                    },
                                    newText: 'def',
                                },
                                {
                                    range: {
                                        start: { line: 1, character: 0 },
                                        end: { line: 1, character: 3 },
                                    },
                                    newText: 'ghi',
                                },
                            ],
                        }],
                },
            });
            chai_1.expect(result.applied).to.equal(true);
            chai_1.expect(editor.getText()).to.equal('def\nghi\n');
            // Undo should be atomic.
            editor.getBuffer().undo();
            chai_1.expect(editor.getText()).to.equal('abc\ndef\n');
        }));
        it('opens files that are not already open', () => __awaiter(this, void 0, void 0, function* () {
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [TEST_PATH2]: [
                            {
                                range: {
                                    start: { line: 0, character: 0 },
                                    end: { line: 0, character: 0 },
                                },
                                newText: 'abc',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(true);
            const editor = yield atom.workspace.open(TEST_PATH2);
            chai_1.expect(editor.getText()).to.equal('abc');
        }));
        it('fails with overlapping edits', () => __awaiter(this, void 0, void 0, function* () {
            const editor = yield atom.workspace.open(TEST_PATH3);
            editor.setText('abcdef\n');
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [TEST_PATH3]: [
                            {
                                range: {
                                    start: { line: 0, character: 0 },
                                    end: { line: 0, character: 3 },
                                },
                                newText: 'def',
                            },
                            {
                                range: {
                                    start: { line: 0, character: 2 },
                                    end: { line: 0, character: 4 },
                                },
                                newText: 'ghi',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(false);
            chai_1.expect(atom.notifications.addError.calledWith('workspace/applyEdits failed', {
                description: 'Failed to apply edits.',
                detail: `Found overlapping edit ranges in ${TEST_PATH3}`,
            })).to.equal(true);
            // No changes.
            chai_1.expect(editor.getText()).to.equal('abcdef\n');
        }));
        it('fails with out-of-range edits', () => __awaiter(this, void 0, void 0, function* () {
            const result = yield apply_edit_adapter_1.default.onApplyEdit({
                edit: {
                    changes: {
                        [TEST_PATH4]: [
                            {
                                range: {
                                    start: { line: 0, character: 1 },
                                    end: { line: 0, character: 2 },
                                },
                                newText: 'def',
                            },
                        ],
                    },
                },
            });
            chai_1.expect(result.applied).to.equal(false);
            const errorCalls = atom.notifications.addError.getCalls();
            chai_1.expect(errorCalls.length).to.equal(1);
            chai_1.expect(errorCalls[0].args[1].detail).to.equal(`Out of range edit on ${TEST_PATH4}:1:2`);
        }));
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwbHktZWRpdC1hZGFwdGVyLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi90ZXN0L2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlci50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSwrQkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiw4RUFBcUU7QUFDckUsK0NBQXdDO0FBR3hDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ3BELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3JELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQ3JELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBRXJELFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7SUFDaEMsUUFBUSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7UUFDM0IsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUM1QyxDQUFDLENBQUMsQ0FBQztRQUVILFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDWixJQUFZLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxHQUFTLEVBQUU7WUFDcEMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQWUsQ0FBQztZQUNuRSxNQUFNLENBQUMsT0FBTyxDQUFD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TSxNQUFNLEdBQUcsTUFBTSw0QkFBZ0IsQ0FBQyxXQUFXLENBQUM7Z0JBQ2hELElBQUksRUFBRTtvQkFDSixPQUFPLEVBQUU7d0JBQ1AsQ0FBQyxVQUFVLENBQUMsRUFBRTs0QkFDWjtnQ0FDRSxLQUFLLEVBQUU7b0NBQ0wsS0FBSyxFQUFFLEVBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFDO29DQUM5QixHQUFHLEVBQUUsRUFBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxDQUFDLEVBQUM7aUNBQzdCO2dDQUNELE9BQU8sRUFBRSxLQUFLOzZCQUNmO3lCQUNGO3FCQUNGO2lCQUNGO2FBQ0YsQ0FBQyxDQUFDO1lBRUgsYUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZDLE1BQU0sVUFBVSxHQUFJLElBQVksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ25FLGFBQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN0QyxhQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLHdCQUF3QixVQUFVLE1BQU0sQ0FBQyxDQUFDO1FBQzFGLENBQUMsQ0FBQSxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnY2hhaSc7XHJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XHJcbmltcG9ydCAqIGFzIHNpbm9uIGZyb20gJ3Npbm9uJztcclxuaW1wb3J0IEFwcGx5RWRpdEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL2FwcGx5LWVkaXQtYWRhcHRlcic7XHJcbmltcG9ydCBDb252ZXJ0IGZyb20gJy4uLy4uL2xpYi9jb252ZXJ0JztcclxuaW1wb3J0IHsgVGV4dEVkaXRvciB9IGZyb20gJ2F0b20nO1xyXG5cclxuY29uc3QgVEVTVF9QQVRIMSA9IHBhdGguam9pbihfX2Rpcm5hbWUsICd0ZXN0LnR4dCcpO1xyXG5jb25zdCBURVNUX1BBVEgyID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3QyLnR4dCcpO1xyXG5jb25zdCBURVNUX1BBVEgzID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3QzLnR4dCcpO1xyXG5jb25zdCBURVNUX1BBVEg0ID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3Rlc3Q0LnR4dCcpO1xyXG5cclxuZGVzY3JpYmUoJ0FwcGx5RWRpdEFkYXB0ZXInLCAoKSA9PiB7XHJcbiAgZGVzY3JpYmUoJ29uQXBwbHlFZGl0JywgKCkgPT4ge1xyXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICAgIHNpbm9uLnNweShhdG9tLm5vdGlmaWNhdGlvbnMsICdhZGRFcnJvcicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcclxuICAgICAgKGF0b20gYXMgYW55KS5ub3RpZmljYXRpb25zLmFkZEVycm9yLnJlc3RvcmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCd3b3JrcyBmb3Igb3BlbiBmaWxlcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZWRpdG9yID0gYXdhaXQgYXRvbS53b3Jrc3BhY2Uub3BlbihURVNUX1BBVEgxKSBhcyBUZXh0RWRpdG9yO1xyXG4gICAgICBlZGl0b3Iuc2V0VGV4dCgnYWJjXFxuZGVmXFxuJyk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KHtcclxuICAgICAgICBlZGl0OiB7XHJcbiAgICAgICAgICBjaGFuZ2VzOiB7XHJcbiAgICAgICAgICAgIFtDb252ZXJ0LnBhdGhUb1VyaShURVNUX1BBVEgxKV06IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogM30sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2RlZicsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDEsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDEsIGNoYXJhY3RlcjogM30sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2doaScsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKHRydWUpO1xyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2RlZlxcbmdoaVxcbicpO1xyXG5cclxuICAgICAgLy8gVW5kbyBzaG91bGQgYmUgYXRvbWljLlxyXG4gICAgICBlZGl0b3IuZ2V0QnVmZmVyKCkudW5kbygpO1xyXG4gICAgICBleHBlY3QoZWRpdG9yLmdldFRleHQoKSkudG8uZXF1YWwoJ2FiY1xcbmRlZlxcbicpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3dvcmtzIHdpdGggVGV4dERvY3VtZW50RWRpdHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IGF0b20ud29ya3NwYWNlLm9wZW4oVEVTVF9QQVRIMSkgYXMgVGV4dEVkaXRvcjtcclxuICAgICAgZWRpdG9yLnNldFRleHQoJ2FiY1xcbmRlZlxcbicpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XHJcbiAgICAgICAgZWRpdDoge1xyXG4gICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBbe1xyXG4gICAgICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcclxuICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxyXG4gICAgICAgICAgICAgIHVyaTogQ29udmVydC5wYXRoVG9VcmkoVEVTVF9QQVRIMSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVkaXRzOiBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDN9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdkZWYnLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcclxuICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtsaW5lOiAxLCBjaGFyYWN0ZXI6IDB9LFxyXG4gICAgICAgICAgICAgICAgICBlbmQ6IHtsaW5lOiAxLCBjaGFyYWN0ZXI6IDN9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG5ld1RleHQ6ICdnaGknLFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICB9XSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZCkudG8uZXF1YWwodHJ1ZSk7XHJcbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnZGVmXFxuZ2hpXFxuJyk7XHJcblxyXG4gICAgICAvLyBVbmRvIHNob3VsZCBiZSBhdG9taWMuXHJcbiAgICAgIGVkaXRvci5nZXRCdWZmZXIoKS51bmRvKCk7XHJcbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnYWJjXFxuZGVmXFxuJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnb3BlbnMgZmlsZXMgdGhhdCBhcmUgbm90IGFscmVhZHkgb3BlbicsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XHJcbiAgICAgICAgZWRpdDoge1xyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICBbVEVTVF9QQVRIMl06IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2FiYycsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKHRydWUpO1xyXG4gICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBhdG9tLndvcmtzcGFjZS5vcGVuKFRFU1RfUEFUSDIpIGFzIFRleHRFZGl0b3I7XHJcbiAgICAgIGV4cGVjdChlZGl0b3IuZ2V0VGV4dCgpKS50by5lcXVhbCgnYWJjJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnZmFpbHMgd2l0aCBvdmVybGFwcGluZyBlZGl0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgZWRpdG9yID0gYXdhaXQgYXRvbS53b3Jrc3BhY2Uub3BlbihURVNUX1BBVEgzKSBhcyBUZXh0RWRpdG9yO1xyXG4gICAgICBlZGl0b3Iuc2V0VGV4dCgnYWJjZGVmXFxuJyk7XHJcblxyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBcHBseUVkaXRBZGFwdGVyLm9uQXBwbHlFZGl0KHtcclxuICAgICAgICBlZGl0OiB7XHJcbiAgICAgICAgICBjaGFuZ2VzOiB7XHJcbiAgICAgICAgICAgIFtURVNUX1BBVEgzXTogW1xyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAwfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMCwgY2hhcmFjdGVyOiAzfSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZGVmJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhbmdlOiB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7bGluZTogMCwgY2hhcmFjdGVyOiAyfSxcclxuICAgICAgICAgICAgICAgICAgZW5kOiB7bGluZTogMCwgY2hhcmFjdGVyOiA0fSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBuZXdUZXh0OiAnZ2hpJyxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGV4cGVjdChyZXN1bHQuYXBwbGllZCkudG8uZXF1YWwoZmFsc2UpO1xyXG4gICAgICBleHBlY3QoXHJcbiAgICAgICAgKGF0b20gYXMgYW55KS5ub3RpZmljYXRpb25zLmFkZEVycm9yLmNhbGxlZFdpdGgoJ3dvcmtzcGFjZS9hcHBseUVkaXRzIGZhaWxlZCcsIHtcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmFpbGVkIHRvIGFwcGx5IGVkaXRzLicsXHJcbiAgICAgICAgICBkZXRhaWw6IGBGb3VuZCBvdmVybGFwcGluZyBlZGl0IHJhbmdlcyBpbiAke1RFU1RfUEFUSDN9YCxcclxuICAgICAgICB9KSxcclxuICAgICAgKS50by5lcXVhbCh0cnVlKTtcclxuICAgICAgLy8gTm8gY2hhbmdlcy5cclxuICAgICAgZXhwZWN0KGVkaXRvci5nZXRUZXh0KCkpLnRvLmVxdWFsKCdhYmNkZWZcXG4nKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdmYWlscyB3aXRoIG91dC1vZi1yYW5nZSBlZGl0cycsIGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgQXBwbHlFZGl0QWRhcHRlci5vbkFwcGx5RWRpdCh7XHJcbiAgICAgICAgZWRpdDoge1xyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICBbVEVTVF9QQVRINF06IFtcclxuICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByYW5nZToge1xyXG4gICAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMX0sXHJcbiAgICAgICAgICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbmV3VGV4dDogJ2RlZicsXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBleHBlY3QocmVzdWx0LmFwcGxpZWQpLnRvLmVxdWFsKGZhbHNlKTtcclxuICAgICAgY29uc3QgZXJyb3JDYWxscyA9IChhdG9tIGFzIGFueSkubm90aWZpY2F0aW9ucy5hZGRFcnJvci5nZXRDYWxscygpO1xyXG4gICAgICBleHBlY3QoZXJyb3JDYWxscy5sZW5ndGgpLnRvLmVxdWFsKDEpO1xyXG4gICAgICBleHBlY3QoZXJyb3JDYWxsc1swXS5hcmdzWzFdLmRldGFpbCkudG8uZXF1YWwoYE91dCBvZiByYW5nZSBlZGl0IG9uICR7VEVTVF9QQVRINH06MToyYCk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdfQ==