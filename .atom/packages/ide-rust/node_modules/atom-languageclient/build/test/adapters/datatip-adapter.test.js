var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _atom = require('atom');

var _chai = require('chai');

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

var _languageclient = require('../../lib/languageclient');

var ls = _interopRequireWildcard(_languageclient);

var _datatipAdapter = require('../../lib/adapters/datatip-adapter');

var _datatipAdapter2 = _interopRequireDefault(_datatipAdapter);

var _helpers = require('../helpers.js');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

describe('DatatipAdapter', () => {
  let fakeEditor;
  let connection;

  beforeEach(() => {
    connection = new ls.LanguageClientConnection((0, _helpers.createSpyConnection)());
    fakeEditor = (0, _helpers.createFakeEditor)();
  });

  describe('canAdapt', () => {
    it('returns true if hoverProvider is supported', () => {
      const result = _datatipAdapter2.default.canAdapt({ hoverProvider: true });
      (0, _chai.expect)(result).to.be.true;
    });

    it('returns false if hoverProvider not supported', () => {
      const result = _datatipAdapter2.default.canAdapt({});
      (0, _chai.expect)(result).to.be.false;
    });
  });

  describe('getDatatip', () => {
    it('calls LSP document/hover at the given position', _asyncToGenerator(function* () {
      _sinon2.default.stub(connection, 'hover').resolves({
        range: {
          start: { line: 0, character: 1 },
          end: { line: 0, character: 2 }
        },
        contents: ['test', { language: 'testlang', value: 'test snippet' }]
      });

      const grammarSpy = _sinon2.default.spy(atom.grammars, 'grammarForScopeName');

      const datatipAdapter = new _datatipAdapter2.default();
      const datatip = yield datatipAdapter.getDatatip(connection, fakeEditor, new _atom.Point(0, 0));
      (0, _chai.expect)(datatip).to.be.ok;
      (0, _assert2.default)(datatip != null);

      (0, _chai.expect)(datatip.range.start.row).equal(0);
      (0, _chai.expect)(datatip.range.start.column).equal(1);
      (0, _chai.expect)(datatip.range.end.row).equal(0);
      (0, _chai.expect)(datatip.range.end.column).equal(2);

      (0, _chai.expect)(datatip.markedStrings).to.have.lengthOf(2);
      (0, _chai.expect)(datatip.markedStrings[0]).eql({ type: 'markdown', value: 'test' });

      const snippet = datatip.markedStrings[1];
      (0, _chai.expect)(snippet.type).equal('snippet');
      (0, _assert2.default)(snippet.type === 'snippet');
      (0, _chai.expect)(snippet.grammar.scopeName).equal('text.plain.null-grammar');
      (0, _chai.expect)(snippet.value).equal('test snippet');

      (0, _chai.expect)(grammarSpy.calledWith('source.testlang')).to.be.true;
    }));
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvZGF0YXRpcC1hZGFwdGVyLnRlc3QuanMiXSwibmFtZXMiOlsibHMiLCJkZXNjcmliZSIsImZha2VFZGl0b3IiLCJjb25uZWN0aW9uIiwiYmVmb3JlRWFjaCIsIkxhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiIsIml0IiwicmVzdWx0IiwiY2FuQWRhcHQiLCJob3ZlclByb3ZpZGVyIiwidG8iLCJiZSIsInRydWUiLCJmYWxzZSIsInN0dWIiLCJyZXNvbHZlcyIsInJhbmdlIiwic3RhcnQiLCJsaW5lIiwiY2hhcmFjdGVyIiwiZW5kIiwiY29udGVudHMiLCJsYW5ndWFnZSIsInZhbHVlIiwiZ3JhbW1hclNweSIsInNweSIsImF0b20iLCJncmFtbWFycyIsImRhdGF0aXBBZGFwdGVyIiwiZGF0YXRpcCIsImdldERhdGF0aXAiLCJvayIsInJvdyIsImVxdWFsIiwiY29sdW1uIiwibWFya2VkU3RyaW5ncyIsImhhdmUiLCJsZW5ndGhPZiIsImVxbCIsInR5cGUiLCJzbmlwcGV0IiwiZ3JhbW1hciIsInNjb3BlTmFtZSIsImNhbGxlZFdpdGgiXSwibWFwcGluZ3MiOiJBQUVBOzs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7SUFBWUEsRTs7QUFDWjs7OztBQUNBOzs7Ozs7OztBQUVBQyxTQUFTLGdCQUFULEVBQTJCLE1BQU07QUFDL0IsTUFBSUMsVUFBSjtBQUNBLE1BQUlDLFVBQUo7O0FBRUFDLGFBQVcsTUFBTTtBQUNmRCxpQkFBYSxJQUFJSCxHQUFHSyx3QkFBUCxDQUFnQyxtQ0FBaEMsQ0FBYjtBQUNBSCxpQkFBYSxnQ0FBYjtBQUNELEdBSEQ7O0FBS0FELFdBQVMsVUFBVCxFQUFxQixNQUFNO0FBQ3pCSyxPQUFHLDRDQUFILEVBQWlELE1BQU07QUFDckQsWUFBTUMsU0FBUyx5QkFBZUMsUUFBZixDQUF3QixFQUFFQyxlQUFlLElBQWpCLEVBQXhCLENBQWY7QUFDQSx3QkFBT0YsTUFBUCxFQUFlRyxFQUFmLENBQWtCQyxFQUFsQixDQUFxQkMsSUFBckI7QUFDRCxLQUhEOztBQUtBTixPQUFHLDhDQUFILEVBQW1ELE1BQU07QUFDdkQsWUFBTUMsU0FBUyx5QkFBZUMsUUFBZixDQUF3QixFQUF4QixDQUFmO0FBQ0Esd0JBQU9ELE1BQVAsRUFBZUcsRUFBZixDQUFrQkMsRUFBbEIsQ0FBcUJFLEtBQXJCO0FBQ0QsS0FIRDtBQUlELEdBVkQ7O0FBWUFaLFdBQVMsWUFBVCxFQUF1QixNQUFNO0FBQzNCSyxPQUFHLGdEQUFILG9CQUFxRCxhQUFZO0FBQy9ELHNCQUFNUSxJQUFOLENBQVdYLFVBQVgsRUFBdUIsT0FBdkIsRUFBZ0NZLFFBQWhDLENBQXlDO0FBQ3ZDQyxlQUFPO0FBQ0xDLGlCQUFPLEVBQUNDLE1BQU0sQ0FBUCxFQUFVQyxXQUFXLENBQXJCLEVBREY7QUFFTEMsZUFBSyxFQUFDRixNQUFNLENBQVAsRUFBVUMsV0FBVyxDQUFyQjtBQUZBLFNBRGdDO0FBS3ZDRSxrQkFBVSxDQUFDLE1BQUQsRUFBUyxFQUFDQyxVQUFVLFVBQVgsRUFBdUJDLE9BQU8sY0FBOUIsRUFBVDtBQUw2QixPQUF6Qzs7QUFRQSxZQUFNQyxhQUFhLGdCQUFNQyxHQUFOLENBQVVDLEtBQUtDLFFBQWYsRUFBeUIscUJBQXpCLENBQW5COztBQUVBLFlBQU1DLGlCQUFpQiw4QkFBdkI7QUFDQSxZQUFNQyxVQUFVLE1BQU1ELGVBQWVFLFVBQWYsQ0FDcEIzQixVQURvQixFQUVwQkQsVUFGb0IsRUFHcEIsZ0JBQVUsQ0FBVixFQUFhLENBQWIsQ0FIb0IsQ0FBdEI7QUFLQSx3QkFBTzJCLE9BQVAsRUFBZ0JuQixFQUFoQixDQUFtQkMsRUFBbkIsQ0FBc0JvQixFQUF0QjtBQUNBLDRCQUFVRixXQUFXLElBQXJCOztBQUVBLHdCQUFPQSxRQUFRYixLQUFSLENBQWNDLEtBQWQsQ0FBb0JlLEdBQTNCLEVBQWdDQyxLQUFoQyxDQUFzQyxDQUF0QztBQUNBLHdCQUFPSixRQUFRYixLQUFSLENBQWNDLEtBQWQsQ0FBb0JpQixNQUEzQixFQUFtQ0QsS0FBbkMsQ0FBeUMsQ0FBekM7QUFDQSx3QkFBT0osUUFBUWIsS0FBUixDQUFjSSxHQUFkLENBQWtCWSxHQUF6QixFQUE4QkMsS0FBOUIsQ0FBb0MsQ0FBcEM7QUFDQSx3QkFBT0osUUFBUWIsS0FBUixDQUFjSSxHQUFkLENBQWtCYyxNQUF6QixFQUFpQ0QsS0FBakMsQ0FBdUMsQ0FBdkM7O0FBRUEsd0JBQU9KLFFBQVFNLGFBQWYsRUFBOEJ6QixFQUE5QixDQUFpQzBCLElBQWpDLENBQXNDQyxRQUF0QyxDQUErQyxDQUEvQztBQUNBLHdCQUFPUixRQUFRTSxhQUFSLENBQXNCLENBQXRCLENBQVAsRUFBaUNHLEdBQWpDLENBQXFDLEVBQUNDLE1BQU0sVUFBUCxFQUFtQmhCLE9BQU8sTUFBMUIsRUFBckM7O0FBRUEsWUFBTWlCLFVBQVVYLFFBQVFNLGFBQVIsQ0FBc0IsQ0FBdEIsQ0FBaEI7QUFDQSx3QkFBT0ssUUFBUUQsSUFBZixFQUFxQk4sS0FBckIsQ0FBMkIsU0FBM0I7QUFDQSw0QkFBVU8sUUFBUUQsSUFBUixLQUFpQixTQUEzQjtBQUNBLHdCQUFPQyxRQUFRQyxPQUFSLENBQWdCQyxTQUF2QixFQUFrQ1QsS0FBbEMsQ0FBd0MseUJBQXhDO0FBQ0Esd0JBQU9PLFFBQVFqQixLQUFmLEVBQXNCVSxLQUF0QixDQUE0QixjQUE1Qjs7QUFFQSx3QkFBT1QsV0FBV21CLFVBQVgsQ0FBc0IsaUJBQXRCLENBQVAsRUFBaURqQyxFQUFqRCxDQUFvREMsRUFBcEQsQ0FBdURDLElBQXZEO0FBQ0QsS0FuQ0Q7QUFvQ0QsR0FyQ0Q7QUFzQ0QsQ0EzREQiLCJmaWxlIjoiZGF0YXRpcC1hZGFwdGVyLnRlc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAZmxvd1xuXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge1BvaW50fSBmcm9tICdhdG9tJztcbmltcG9ydCB7ZXhwZWN0fSBmcm9tICdjaGFpJztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5pbXBvcnQgKiBhcyBscyBmcm9tICcuLi8uLi9saWIvbGFuZ3VhZ2VjbGllbnQnO1xuaW1wb3J0IERhdGF0aXBBZGFwdGVyIGZyb20gJy4uLy4uL2xpYi9hZGFwdGVycy9kYXRhdGlwLWFkYXB0ZXInO1xuaW1wb3J0IHtjcmVhdGVTcHlDb25uZWN0aW9uLCBjcmVhdGVGYWtlRWRpdG9yfSBmcm9tICcuLi9oZWxwZXJzLmpzJztcblxuZGVzY3JpYmUoJ0RhdGF0aXBBZGFwdGVyJywgKCkgPT4ge1xuICBsZXQgZmFrZUVkaXRvcjtcbiAgbGV0IGNvbm5lY3Rpb247XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY29ubmVjdGlvbiA9IG5ldyBscy5MYW5ndWFnZUNsaWVudENvbm5lY3Rpb24oY3JlYXRlU3B5Q29ubmVjdGlvbigpKTtcbiAgICBmYWtlRWRpdG9yID0gY3JlYXRlRmFrZUVkaXRvcigpO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2FuQWRhcHQnLCAoKSA9PiB7XG4gICAgaXQoJ3JldHVybnMgdHJ1ZSBpZiBob3ZlclByb3ZpZGVyIGlzIHN1cHBvcnRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IERhdGF0aXBBZGFwdGVyLmNhbkFkYXB0KHsgaG92ZXJQcm92aWRlcjogdHJ1ZSB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmJlLnRydWU7XG4gICAgfSk7XG5cbiAgICBpdCgncmV0dXJucyBmYWxzZSBpZiBob3ZlclByb3ZpZGVyIG5vdCBzdXBwb3J0ZWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBEYXRhdGlwQWRhcHRlci5jYW5BZGFwdCh7IH0pO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG8uYmUuZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdnZXREYXRhdGlwJywgKCkgPT4ge1xuICAgIGl0KCdjYWxscyBMU1AgZG9jdW1lbnQvaG92ZXIgYXQgdGhlIGdpdmVuIHBvc2l0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgc2lub24uc3R1Yihjb25uZWN0aW9uLCAnaG92ZXInKS5yZXNvbHZlcyh7XG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgc3RhcnQ6IHtsaW5lOiAwLCBjaGFyYWN0ZXI6IDF9LFxuICAgICAgICAgIGVuZDoge2xpbmU6IDAsIGNoYXJhY3RlcjogMn0sXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRzOiBbJ3Rlc3QnLCB7bGFuZ3VhZ2U6ICd0ZXN0bGFuZycsIHZhbHVlOiAndGVzdCBzbmlwcGV0J31dLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGdyYW1tYXJTcHkgPSBzaW5vbi5zcHkoYXRvbS5ncmFtbWFycywgJ2dyYW1tYXJGb3JTY29wZU5hbWUnKTtcblxuICAgICAgY29uc3QgZGF0YXRpcEFkYXB0ZXIgPSBuZXcgRGF0YXRpcEFkYXB0ZXIoKTtcbiAgICAgIGNvbnN0IGRhdGF0aXAgPSBhd2FpdCBkYXRhdGlwQWRhcHRlci5nZXREYXRhdGlwKFxuICAgICAgICBjb25uZWN0aW9uLFxuICAgICAgICBmYWtlRWRpdG9yLFxuICAgICAgICBuZXcgUG9pbnQoMCwgMCksXG4gICAgICApO1xuICAgICAgZXhwZWN0KGRhdGF0aXApLnRvLmJlLm9rO1xuICAgICAgaW52YXJpYW50KGRhdGF0aXAgIT0gbnVsbCk7XG5cbiAgICAgIGV4cGVjdChkYXRhdGlwLnJhbmdlLnN0YXJ0LnJvdykuZXF1YWwoMCk7XG4gICAgICBleHBlY3QoZGF0YXRpcC5yYW5nZS5zdGFydC5jb2x1bW4pLmVxdWFsKDEpO1xuICAgICAgZXhwZWN0KGRhdGF0aXAucmFuZ2UuZW5kLnJvdykuZXF1YWwoMCk7XG4gICAgICBleHBlY3QoZGF0YXRpcC5yYW5nZS5lbmQuY29sdW1uKS5lcXVhbCgyKTtcblxuICAgICAgZXhwZWN0KGRhdGF0aXAubWFya2VkU3RyaW5ncykudG8uaGF2ZS5sZW5ndGhPZigyKTtcbiAgICAgIGV4cGVjdChkYXRhdGlwLm1hcmtlZFN0cmluZ3NbMF0pLmVxbCh7dHlwZTogJ21hcmtkb3duJywgdmFsdWU6ICd0ZXN0J30pO1xuXG4gICAgICBjb25zdCBzbmlwcGV0ID0gZGF0YXRpcC5tYXJrZWRTdHJpbmdzWzFdO1xuICAgICAgZXhwZWN0KHNuaXBwZXQudHlwZSkuZXF1YWwoJ3NuaXBwZXQnKTtcbiAgICAgIGludmFyaWFudChzbmlwcGV0LnR5cGUgPT09ICdzbmlwcGV0Jyk7XG4gICAgICBleHBlY3Qoc25pcHBldC5ncmFtbWFyLnNjb3BlTmFtZSkuZXF1YWwoJ3RleHQucGxhaW4ubnVsbC1ncmFtbWFyJyk7XG4gICAgICBleHBlY3Qoc25pcHBldC52YWx1ZSkuZXF1YWwoJ3Rlc3Qgc25pcHBldCcpO1xuXG4gICAgICBleHBlY3QoZ3JhbW1hclNweS5jYWxsZWRXaXRoKCdzb3VyY2UudGVzdGxhbmcnKSkudG8uYmUudHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdfQ==