var _atom = require('atom');

var _signatureHelpAdapter = require('../../lib/adapters/signature-help-adapter');

var _signatureHelpAdapter2 = _interopRequireDefault(_signatureHelpAdapter);

var _helpers = require('../helpers');

var _chai = require('chai');

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('SignatureHelpAdapter', () => {
  describe('canAdapt', () => {
    it('checks for signatureHelpProvider', () => {
      (0, _chai.expect)(_signatureHelpAdapter2.default.canAdapt({})).to.equal(false);
      (0, _chai.expect)(_signatureHelpAdapter2.default.canAdapt({ signatureHelpProvider: {} })).to.equal(true);
    });
  });

  describe('can attach to a server', () => {
    it('subscribes to onPublishDiagnostics', async () => {
      const connection = (0, _helpers.createSpyConnection)();
      connection.signatureHelp = _sinon2.default.stub().resolves({ signatures: [] });

      const adapter = new _signatureHelpAdapter2.default({
        connection,
        capabilities: {
          signatureHelpProvider: {
            triggerCharacters: ['(', ',']
          }
        }
      }, ['source.js']);
      const spy = _sinon2.default.stub().returns(new _atom.Disposable());
      adapter.attach(spy);
      (0, _chai.expect)(spy.calledOnce).to.be.true;
      const provider = spy.firstCall.args[0];
      (0, _chai.expect)(provider.priority).to.equal(1);
      (0, _chai.expect)(provider.grammarScopes).to.deep.equal(['source.js']);
      (0, _chai.expect)(provider.triggerCharacters).to.deep.equal(new Set(['(', ',']));
      (0, _chai.expect)(typeof provider.getSignatureHelp).to.equal('function');

      const result = await provider.getSignatureHelp((0, _helpers.createFakeEditor)('test.txt'), new _atom.Point(0, 1));
      (0, _chai.expect)(connection.signatureHelp.calledOnce).to.be.true;
      const params = connection.signatureHelp.firstCall.args[0];
      (0, _chai.expect)(params).to.deep.equal({
        textDocument: { uri: 'file:///test.txt' },
        position: { line: 0, character: 1 }
      });
      (0, _chai.expect)(result).to.deep.equal({ signatures: [] });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvc2lnbmF0dXJlLWhlbHAtYWRhcHRlci50ZXN0LmpzIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiaXQiLCJjYW5BZGFwdCIsInRvIiwiZXF1YWwiLCJzaWduYXR1cmVIZWxwUHJvdmlkZXIiLCJjb25uZWN0aW9uIiwic2lnbmF0dXJlSGVscCIsInN0dWIiLCJyZXNvbHZlcyIsInNpZ25hdHVyZXMiLCJhZGFwdGVyIiwiY2FwYWJpbGl0aWVzIiwidHJpZ2dlckNoYXJhY3RlcnMiLCJzcHkiLCJyZXR1cm5zIiwiYXR0YWNoIiwiY2FsbGVkT25jZSIsImJlIiwidHJ1ZSIsInByb3ZpZGVyIiwiZmlyc3RDYWxsIiwiYXJncyIsInByaW9yaXR5IiwiZ3JhbW1hclNjb3BlcyIsImRlZXAiLCJTZXQiLCJnZXRTaWduYXR1cmVIZWxwIiwicmVzdWx0IiwicGFyYW1zIiwidGV4dERvY3VtZW50IiwidXJpIiwicG9zaXRpb24iLCJsaW5lIiwiY2hhcmFjdGVyIl0sIm1hcHBpbmdzIjoiQUFFQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQUEsU0FBUyxzQkFBVCxFQUFpQyxNQUFNO0FBQ3JDQSxXQUFTLFVBQVQsRUFBcUIsTUFBTTtBQUN6QkMsT0FBRyxrQ0FBSCxFQUF1QyxNQUFNO0FBQzNDLHdCQUFPLCtCQUFxQkMsUUFBckIsQ0FBOEIsRUFBOUIsQ0FBUCxFQUEwQ0MsRUFBMUMsQ0FBNkNDLEtBQTdDLENBQW1ELEtBQW5EO0FBQ0Esd0JBQU8sK0JBQXFCRixRQUFyQixDQUE4QixFQUFDRyx1QkFBdUIsRUFBeEIsRUFBOUIsQ0FBUCxFQUFtRUYsRUFBbkUsQ0FBc0VDLEtBQXRFLENBQTRFLElBQTVFO0FBQ0QsS0FIRDtBQUlELEdBTEQ7O0FBT0FKLFdBQVMsd0JBQVQsRUFBbUMsTUFBTTtBQUN2Q0MsT0FBRyxvQ0FBSCxFQUF5QyxZQUFZO0FBQ25ELFlBQU1LLGFBQWEsbUNBQW5CO0FBQ0FBLGlCQUFXQyxhQUFYLEdBQTJCLGdCQUFNQyxJQUFOLEdBQWFDLFFBQWIsQ0FBc0IsRUFBQ0MsWUFBWSxFQUFiLEVBQXRCLENBQTNCOztBQUVBLFlBQU1DLFVBQVUsbUNBQ2I7QUFDQ0wsa0JBREQ7QUFFQ00sc0JBQWM7QUFDWlAsaUNBQXVCO0FBQ3JCUSwrQkFBbUIsQ0FBQyxHQUFELEVBQU0sR0FBTjtBQURFO0FBRFg7QUFGZixPQURhLEVBU2QsQ0FBQyxXQUFELENBVGMsQ0FBaEI7QUFXQSxZQUFNQyxNQUFNLGdCQUFNTixJQUFOLEdBQWFPLE9BQWIsQ0FBcUIsc0JBQXJCLENBQVo7QUFDQUosY0FBUUssTUFBUixDQUFlRixHQUFmO0FBQ0Esd0JBQU9BLElBQUlHLFVBQVgsRUFBdUJkLEVBQXZCLENBQTBCZSxFQUExQixDQUE2QkMsSUFBN0I7QUFDQSxZQUFNQyxXQUFXTixJQUFJTyxTQUFKLENBQWNDLElBQWQsQ0FBbUIsQ0FBbkIsQ0FBakI7QUFDQSx3QkFBT0YsU0FBU0csUUFBaEIsRUFBMEJwQixFQUExQixDQUE2QkMsS0FBN0IsQ0FBbUMsQ0FBbkM7QUFDQSx3QkFBT2dCLFNBQVNJLGFBQWhCLEVBQStCckIsRUFBL0IsQ0FBa0NzQixJQUFsQyxDQUF1Q3JCLEtBQXZDLENBQTZDLENBQUMsV0FBRCxDQUE3QztBQUNBLHdCQUFPZ0IsU0FBU1AsaUJBQWhCLEVBQW1DVixFQUFuQyxDQUFzQ3NCLElBQXRDLENBQTJDckIsS0FBM0MsQ0FBaUQsSUFBSXNCLEdBQUosQ0FBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVIsQ0FBakQ7QUFDQSx3QkFBTyxPQUFPTixTQUFTTyxnQkFBdkIsRUFBeUN4QixFQUF6QyxDQUE0Q0MsS0FBNUMsQ0FBa0QsVUFBbEQ7O0FBRUEsWUFBTXdCLFNBQVMsTUFBTVIsU0FBU08sZ0JBQVQsQ0FBMEIsK0JBQWlCLFVBQWpCLENBQTFCLEVBQXdELGdCQUFVLENBQVYsRUFBYSxDQUFiLENBQXhELENBQXJCO0FBQ0Esd0JBQU9yQixXQUFXQyxhQUFYLENBQXlCVSxVQUFoQyxFQUE0Q2QsRUFBNUMsQ0FBK0NlLEVBQS9DLENBQWtEQyxJQUFsRDtBQUNBLFlBQU1VLFNBQVN2QixXQUFXQyxhQUFYLENBQXlCYyxTQUF6QixDQUFtQ0MsSUFBbkMsQ0FBd0MsQ0FBeEMsQ0FBZjtBQUNBLHdCQUFPTyxNQUFQLEVBQWUxQixFQUFmLENBQWtCc0IsSUFBbEIsQ0FBdUJyQixLQUF2QixDQUE2QjtBQUMzQjBCLHNCQUFjLEVBQUNDLEtBQUssa0JBQU4sRUFEYTtBQUUzQkMsa0JBQVUsRUFBQ0MsTUFBTSxDQUFQLEVBQVVDLFdBQVcsQ0FBckI7QUFGaUIsT0FBN0I7QUFJQSx3QkFBT04sTUFBUCxFQUFlekIsRUFBZixDQUFrQnNCLElBQWxCLENBQXVCckIsS0FBdkIsQ0FBNkIsRUFBQ00sWUFBWSxFQUFiLEVBQTdCO0FBQ0QsS0FoQ0Q7QUFpQ0QsR0FsQ0Q7QUFtQ0QsQ0EzQ0QiLCJmaWxlIjoic2lnbmF0dXJlLWhlbHAtYWRhcHRlci50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcclxuXHJcbmltcG9ydCB7RGlzcG9zYWJsZSwgUG9pbnR9IGZyb20gJ2F0b20nO1xyXG5pbXBvcnQgU2lnbmF0dXJlSGVscEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL3NpZ25hdHVyZS1oZWxwLWFkYXB0ZXInO1xyXG5pbXBvcnQge2NyZWF0ZUZha2VFZGl0b3IsIGNyZWF0ZVNweUNvbm5lY3Rpb259IGZyb20gJy4uL2hlbHBlcnMnO1xyXG5pbXBvcnQge2V4cGVjdH0gZnJvbSAnY2hhaSc7XHJcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XHJcblxyXG5kZXNjcmliZSgnU2lnbmF0dXJlSGVscEFkYXB0ZXInLCAoKSA9PiB7XHJcbiAgZGVzY3JpYmUoJ2NhbkFkYXB0JywgKCkgPT4ge1xyXG4gICAgaXQoJ2NoZWNrcyBmb3Igc2lnbmF0dXJlSGVscFByb3ZpZGVyJywgKCkgPT4ge1xyXG4gICAgICBleHBlY3QoU2lnbmF0dXJlSGVscEFkYXB0ZXIuY2FuQWRhcHQoe30pKS50by5lcXVhbChmYWxzZSk7XHJcbiAgICAgIGV4cGVjdChTaWduYXR1cmVIZWxwQWRhcHRlci5jYW5BZGFwdCh7c2lnbmF0dXJlSGVscFByb3ZpZGVyOiB7fX0pKS50by5lcXVhbCh0cnVlKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICBkZXNjcmliZSgnY2FuIGF0dGFjaCB0byBhIHNlcnZlcicsICgpID0+IHtcclxuICAgIGl0KCdzdWJzY3JpYmVzIHRvIG9uUHVibGlzaERpYWdub3N0aWNzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gY3JlYXRlU3B5Q29ubmVjdGlvbigpO1xyXG4gICAgICBjb25uZWN0aW9uLnNpZ25hdHVyZUhlbHAgPSBzaW5vbi5zdHViKCkucmVzb2x2ZXMoe3NpZ25hdHVyZXM6IFtdfSk7XHJcblxyXG4gICAgICBjb25zdCBhZGFwdGVyID0gbmV3IFNpZ25hdHVyZUhlbHBBZGFwdGVyKFxyXG4gICAgICAgICh7XHJcbiAgICAgICAgICBjb25uZWN0aW9uLFxyXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XHJcbiAgICAgICAgICAgIHNpZ25hdHVyZUhlbHBQcm92aWRlcjoge1xyXG4gICAgICAgICAgICAgIHRyaWdnZXJDaGFyYWN0ZXJzOiBbJygnLCAnLCddLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9OiBhbnkpLFxyXG4gICAgICAgIFsnc291cmNlLmpzJ10sXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHNweSA9IHNpbm9uLnN0dWIoKS5yZXR1cm5zKG5ldyBEaXNwb3NhYmxlKCkpO1xyXG4gICAgICBhZGFwdGVyLmF0dGFjaChzcHkpO1xyXG4gICAgICBleHBlY3Qoc3B5LmNhbGxlZE9uY2UpLnRvLmJlLnRydWU7XHJcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gc3B5LmZpcnN0Q2FsbC5hcmdzWzBdO1xyXG4gICAgICBleHBlY3QocHJvdmlkZXIucHJpb3JpdHkpLnRvLmVxdWFsKDEpO1xyXG4gICAgICBleHBlY3QocHJvdmlkZXIuZ3JhbW1hclNjb3BlcykudG8uZGVlcC5lcXVhbChbJ3NvdXJjZS5qcyddKTtcclxuICAgICAgZXhwZWN0KHByb3ZpZGVyLnRyaWdnZXJDaGFyYWN0ZXJzKS50by5kZWVwLmVxdWFsKG5ldyBTZXQoWycoJywgJywnXSkpO1xyXG4gICAgICBleHBlY3QodHlwZW9mIHByb3ZpZGVyLmdldFNpZ25hdHVyZUhlbHApLnRvLmVxdWFsKCdmdW5jdGlvbicpO1xyXG5cclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmF0dXJlSGVscChjcmVhdGVGYWtlRWRpdG9yKCd0ZXN0LnR4dCcpLCBuZXcgUG9pbnQoMCwgMSkpO1xyXG4gICAgICBleHBlY3QoY29ubmVjdGlvbi5zaWduYXR1cmVIZWxwLmNhbGxlZE9uY2UpLnRvLmJlLnRydWU7XHJcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGNvbm5lY3Rpb24uc2lnbmF0dXJlSGVscC5maXJzdENhbGwuYXJnc1swXTtcclxuICAgICAgZXhwZWN0KHBhcmFtcykudG8uZGVlcC5lcXVhbCh7XHJcbiAgICAgICAgdGV4dERvY3VtZW50OiB7dXJpOiAnZmlsZTovLy90ZXN0LnR4dCd9LFxyXG4gICAgICAgIHBvc2l0aW9uOiB7bGluZTogMCwgY2hhcmFjdGVyOiAxfSxcclxuICAgICAgfSk7XHJcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmRlZXAuZXF1YWwoe3NpZ25hdHVyZXM6IFtdfSk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufSk7XHJcbiJdfQ==