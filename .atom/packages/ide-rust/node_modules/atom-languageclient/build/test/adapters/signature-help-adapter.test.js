var _atom = require('atom');

var _signatureHelpAdapter = require('../../lib/adapters/signature-help-adapter');

var _signatureHelpAdapter2 = _interopRequireDefault(_signatureHelpAdapter);

var _helpers = require('../helpers');

var _chai = require('chai');

var _sinon = require('sinon');

var _sinon2 = _interopRequireDefault(_sinon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('SignatureHelpAdapter', () => {
  describe('canAdapt', () => {
    it('checks for signatureHelpProvider', () => {
      (0, _chai.expect)(_signatureHelpAdapter2.default.canAdapt({})).to.equal(false);
      (0, _chai.expect)(_signatureHelpAdapter2.default.canAdapt({ signatureHelpProvider: {} })).to.equal(true);
    });
  });

  describe('can attach to a server', () => {
    it('subscribes to onPublishDiagnostics', async () => {
      const connection = (0, _helpers.createSpyConnection)();
      connection.signatureHelp = _sinon2.default.stub().resolves({ signatures: [] });

      const adapter = new _signatureHelpAdapter2.default({
        connection,
        capabilities: {
          signatureHelpProvider: {
            triggerCharacters: ['(', ',']
          }
        }
      }, ['source.js']);
      const spy = _sinon2.default.stub().returns(new _atom.Disposable());
      adapter.attach(spy);
      (0, _chai.expect)(spy.calledOnce).to.be.true;
      const provider = spy.firstCall.args[0];
      (0, _chai.expect)(provider.priority).to.equal(1);
      (0, _chai.expect)(provider.grammarScopes).to.deep.equal(['source.js']);
      (0, _chai.expect)(provider.triggerCharacters).to.deep.equal(new Set(['(', ',']));
      (0, _chai.expect)(typeof provider.getSignatureHelp).to.equal('function');

      const result = await provider.getSignatureHelp((0, _helpers.createFakeEditor)('test.txt'), new _atom.Point(0, 1));
      (0, _chai.expect)(connection.signatureHelp.calledOnce).to.be.true;
      const params = connection.signatureHelp.firstCall.args[0];
      (0, _chai.expect)(params).to.deep.equal({
        textDocument: { uri: 'file:///test.txt' },
        position: { line: 0, character: 1 }
      });
      (0, _chai.expect)(result).to.deep.equal({ signatures: [] });
    });
  });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3Rlc3QvYWRhcHRlcnMvc2lnbmF0dXJlLWhlbHAtYWRhcHRlci50ZXN0LmpzIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiaXQiLCJjYW5BZGFwdCIsInRvIiwiZXF1YWwiLCJzaWduYXR1cmVIZWxwUHJvdmlkZXIiLCJjb25uZWN0aW9uIiwic2lnbmF0dXJlSGVscCIsInN0dWIiLCJyZXNvbHZlcyIsInNpZ25hdHVyZXMiLCJhZGFwdGVyIiwiY2FwYWJpbGl0aWVzIiwidHJpZ2dlckNoYXJhY3RlcnMiLCJzcHkiLCJyZXR1cm5zIiwiYXR0YWNoIiwiY2FsbGVkT25jZSIsImJlIiwidHJ1ZSIsInByb3ZpZGVyIiwiZmlyc3RDYWxsIiwiYXJncyIsInByaW9yaXR5IiwiZ3JhbW1hclNjb3BlcyIsImRlZXAiLCJTZXQiLCJnZXRTaWduYXR1cmVIZWxwIiwicmVzdWx0IiwicGFyYW1zIiwidGV4dERvY3VtZW50IiwidXJpIiwicG9zaXRpb24iLCJsaW5lIiwiY2hhcmFjdGVyIl0sIm1hcHBpbmdzIjoiQUFFQTs7QUFDQTs7OztBQUNBOztBQUNBOztBQUNBOzs7Ozs7QUFFQUEsU0FBUyxzQkFBVCxFQUFpQyxNQUFNO0FBQ3JDQSxXQUFTLFVBQVQsRUFBcUIsTUFBTTtBQUN6QkMsT0FBRyxrQ0FBSCxFQUF1QyxNQUFNO0FBQzNDLHdCQUFPLCtCQUFxQkMsUUFBckIsQ0FBOEIsRUFBOUIsQ0FBUCxFQUEwQ0MsRUFBMUMsQ0FBNkNDLEtBQTdDLENBQW1ELEtBQW5EO0FBQ0Esd0JBQU8sK0JBQXFCRixRQUFyQixDQUE4QixFQUFDRyx1QkFBdUIsRUFBeEIsRUFBOUIsQ0FBUCxFQUFtRUYsRUFBbkUsQ0FBc0VDLEtBQXRFLENBQTRFLElBQTVFO0FBQ0QsS0FIRDtBQUlELEdBTEQ7O0FBT0FKLFdBQVMsd0JBQVQsRUFBbUMsTUFBTTtBQUN2Q0MsT0FBRyxvQ0FBSCxFQUF5QyxZQUFZO0FBQ25ELFlBQU1LLGFBQWEsbUNBQW5CO0FBQ0FBLGlCQUFXQyxhQUFYLEdBQTJCLGdCQUFNQyxJQUFOLEdBQWFDLFFBQWIsQ0FBc0IsRUFBQ0MsWUFBWSxFQUFiLEVBQXRCLENBQTNCOztBQUVBLFlBQU1DLFVBQVUsbUNBQ2I7QUFDQ0wsa0JBREQ7QUFFQ00sc0JBQWM7QUFDWlAsaUNBQXVCO0FBQ3JCUSwrQkFBbUIsQ0FBQyxHQUFELEVBQU0sR0FBTjtBQURFO0FBRFg7QUFGZixPQURhLEVBU2QsQ0FBQyxXQUFELENBVGMsQ0FBaEI7QUFXQSxZQUFNQyxNQUFNLGdCQUFNTixJQUFOLEdBQWFPLE9BQWIsQ0FBcUIsc0JBQXJCLENBQVo7QUFDQUosY0FBUUssTUFBUixDQUFlRixHQUFmO0FBQ0Esd0JBQU9BLElBQUlHLFVBQVgsRUFBdUJkLEVBQXZCLENBQTBCZSxFQUExQixDQUE2QkMsSUFBN0I7QUFDQSxZQUFNQyxXQUFXTixJQUFJTyxTQUFKLENBQWNDLElBQWQsQ0FBbUIsQ0FBbkIsQ0FBakI7QUFDQSx3QkFBT0YsU0FBU0csUUFBaEIsRUFBMEJwQixFQUExQixDQUE2QkMsS0FBN0IsQ0FBbUMsQ0FBbkM7QUFDQSx3QkFBT2dCLFNBQVNJLGFBQWhCLEVBQStCckIsRUFBL0IsQ0FBa0NzQixJQUFsQyxDQUF1Q3JCLEtBQXZDLENBQTZDLENBQUMsV0FBRCxDQUE3QztBQUNBLHdCQUFPZ0IsU0FBU1AsaUJBQWhCLEVBQW1DVixFQUFuQyxDQUFzQ3NCLElBQXRDLENBQTJDckIsS0FBM0MsQ0FBaUQsSUFBSXNCLEdBQUosQ0FBUSxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVIsQ0FBakQ7QUFDQSx3QkFBTyxPQUFPTixTQUFTTyxnQkFBdkIsRUFBeUN4QixFQUF6QyxDQUE0Q0MsS0FBNUMsQ0FBa0QsVUFBbEQ7O0FBRUEsWUFBTXdCLFNBQVMsTUFBTVIsU0FBU08sZ0JBQVQsQ0FBMEIsK0JBQWlCLFVBQWpCLENBQTFCLEVBQXdELGdCQUFVLENBQVYsRUFBYSxDQUFiLENBQXhELENBQXJCO0FBQ0Esd0JBQU9yQixXQUFXQyxhQUFYLENBQXlCVSxVQUFoQyxFQUE0Q2QsRUFBNUMsQ0FBK0NlLEVBQS9DLENBQWtEQyxJQUFsRDtBQUNBLFlBQU1VLFNBQVN2QixXQUFXQyxhQUFYLENBQXlCYyxTQUF6QixDQUFtQ0MsSUFBbkMsQ0FBd0MsQ0FBeEMsQ0FBZjtBQUNBLHdCQUFPTyxNQUFQLEVBQWUxQixFQUFmLENBQWtCc0IsSUFBbEIsQ0FBdUJyQixLQUF2QixDQUE2QjtBQUMzQjBCLHNCQUFjLEVBQUNDLEtBQUssa0JBQU4sRUFEYTtBQUUzQkMsa0JBQVUsRUFBQ0MsTUFBTSxDQUFQLEVBQVVDLFdBQVcsQ0FBckI7QUFGaUIsT0FBN0I7QUFJQSx3QkFBT04sTUFBUCxFQUFlekIsRUFBZixDQUFrQnNCLElBQWxCLENBQXVCckIsS0FBdkIsQ0FBNkIsRUFBQ00sWUFBWSxFQUFiLEVBQTdCO0FBQ0QsS0FoQ0Q7QUFpQ0QsR0FsQ0Q7QUFtQ0QsQ0EzQ0QiLCJmaWxlIjoic2lnbmF0dXJlLWhlbHAtYWRhcHRlci50ZXN0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQGZsb3dcblxuaW1wb3J0IHtEaXNwb3NhYmxlLCBQb2ludH0gZnJvbSAnYXRvbSc7XG5pbXBvcnQgU2lnbmF0dXJlSGVscEFkYXB0ZXIgZnJvbSAnLi4vLi4vbGliL2FkYXB0ZXJzL3NpZ25hdHVyZS1oZWxwLWFkYXB0ZXInO1xuaW1wb3J0IHtjcmVhdGVGYWtlRWRpdG9yLCBjcmVhdGVTcHlDb25uZWN0aW9ufSBmcm9tICcuLi9oZWxwZXJzJztcbmltcG9ydCB7ZXhwZWN0fSBmcm9tICdjaGFpJztcbmltcG9ydCBzaW5vbiBmcm9tICdzaW5vbic7XG5cbmRlc2NyaWJlKCdTaWduYXR1cmVIZWxwQWRhcHRlcicsICgpID0+IHtcbiAgZGVzY3JpYmUoJ2NhbkFkYXB0JywgKCkgPT4ge1xuICAgIGl0KCdjaGVja3MgZm9yIHNpZ25hdHVyZUhlbHBQcm92aWRlcicsICgpID0+IHtcbiAgICAgIGV4cGVjdChTaWduYXR1cmVIZWxwQWRhcHRlci5jYW5BZGFwdCh7fSkpLnRvLmVxdWFsKGZhbHNlKTtcbiAgICAgIGV4cGVjdChTaWduYXR1cmVIZWxwQWRhcHRlci5jYW5BZGFwdCh7c2lnbmF0dXJlSGVscFByb3ZpZGVyOiB7fX0pKS50by5lcXVhbCh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NhbiBhdHRhY2ggdG8gYSBzZXJ2ZXInLCAoKSA9PiB7XG4gICAgaXQoJ3N1YnNjcmliZXMgdG8gb25QdWJsaXNoRGlhZ25vc3RpY3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gY3JlYXRlU3B5Q29ubmVjdGlvbigpO1xuICAgICAgY29ubmVjdGlvbi5zaWduYXR1cmVIZWxwID0gc2lub24uc3R1YigpLnJlc29sdmVzKHtzaWduYXR1cmVzOiBbXX0pO1xuXG4gICAgICBjb25zdCBhZGFwdGVyID0gbmV3IFNpZ25hdHVyZUhlbHBBZGFwdGVyKFxuICAgICAgICAoe1xuICAgICAgICAgIGNvbm5lY3Rpb24sXG4gICAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgICBzaWduYXR1cmVIZWxwUHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgdHJpZ2dlckNoYXJhY3RlcnM6IFsnKCcsICcsJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH06IGFueSksXG4gICAgICAgIFsnc291cmNlLmpzJ10sXG4gICAgICApO1xuICAgICAgY29uc3Qgc3B5ID0gc2lub24uc3R1YigpLnJldHVybnMobmV3IERpc3Bvc2FibGUoKSk7XG4gICAgICBhZGFwdGVyLmF0dGFjaChzcHkpO1xuICAgICAgZXhwZWN0KHNweS5jYWxsZWRPbmNlKS50by5iZS50cnVlO1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSBzcHkuZmlyc3RDYWxsLmFyZ3NbMF07XG4gICAgICBleHBlY3QocHJvdmlkZXIucHJpb3JpdHkpLnRvLmVxdWFsKDEpO1xuICAgICAgZXhwZWN0KHByb3ZpZGVyLmdyYW1tYXJTY29wZXMpLnRvLmRlZXAuZXF1YWwoWydzb3VyY2UuanMnXSk7XG4gICAgICBleHBlY3QocHJvdmlkZXIudHJpZ2dlckNoYXJhY3RlcnMpLnRvLmRlZXAuZXF1YWwobmV3IFNldChbJygnLCAnLCddKSk7XG4gICAgICBleHBlY3QodHlwZW9mIHByb3ZpZGVyLmdldFNpZ25hdHVyZUhlbHApLnRvLmVxdWFsKCdmdW5jdGlvbicpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduYXR1cmVIZWxwKGNyZWF0ZUZha2VFZGl0b3IoJ3Rlc3QudHh0JyksIG5ldyBQb2ludCgwLCAxKSk7XG4gICAgICBleHBlY3QoY29ubmVjdGlvbi5zaWduYXR1cmVIZWxwLmNhbGxlZE9uY2UpLnRvLmJlLnRydWU7XG4gICAgICBjb25zdCBwYXJhbXMgPSBjb25uZWN0aW9uLnNpZ25hdHVyZUhlbHAuZmlyc3RDYWxsLmFyZ3NbMF07XG4gICAgICBleHBlY3QocGFyYW1zKS50by5kZWVwLmVxdWFsKHtcbiAgICAgICAgdGV4dERvY3VtZW50OiB7dXJpOiAnZmlsZTovLy90ZXN0LnR4dCd9LFxuICAgICAgICBwb3NpdGlvbjoge2xpbmU6IDAsIGNoYXJhY3RlcjogMX0sXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvLmRlZXAuZXF1YWwoe3NpZ25hdHVyZXM6IFtdfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=