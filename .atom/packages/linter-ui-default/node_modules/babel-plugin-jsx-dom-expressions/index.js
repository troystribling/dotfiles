'use strict';

var SyntaxJSX = require('@babel/plugin-syntax-jsx');
var t = require('@babel/types');
var helperModuleImports = require('@babel/helper-module-imports');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var SyntaxJSX__default = /*#__PURE__*/_interopDefaultLegacy(SyntaxJSX);

var config = {
  moduleName: "dom",
  generate: "dom",
  hydratable: false,
  async: false,
  delegateEvents: true,
  nonDelegateEvents: [],
  builtIns: [],
  wrapConditionals: true,
  wrapSpreads: true,
  contextToCustomElements: false,
  hydratableEvents: null,
  staticMarker: "@once"
};

const booleans = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "truespeed"
];

const BooleanAttributes = new Set(booleans);

const Properties = new Set([
  "className",
  "indeterminate",
  "value",
  ...booleans
]);

const ChildProperties = new Set(["innerHTML", "textContent", "innerText", "children"]);

// React Compat
const Aliases = {
  className: "class",
  htmlFor: "for"
};

// list of Element events that will not be delegated
const NonComposedEvents = new Set([
  "abort",
  "animationstart",
  "animationend",
  "animationiteration",
  "blur",
  "change",
  "copy",
  "cut",
  "error",
  "focus",
  "gotpointercapture",
  "load",
  "loadend",
  "loadstart",
  "lostpointercapture",
  "mouseenter",
  "mouseleave",
  "paste",
  "pointerenter",
  "pointerleave",
  "progress",
  "reset",
  "scroll",
  "select",
  "submit",
  "toggle",
  "transitionstart",
  "transitioncancel",
  "transitionend",
  "transitionrun"
]);

const SVGElements = new Set([
  // "a",
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  // "script",
  "set",
  "stop",
  // "style",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  // "title",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]);

const SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};

var VoidElements = [
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'command',
  'embed',
  'frame',
  'hr',
  'image',
  'img',
  'input',
  'isindex',
  'keygen',
  'link',
  'menuitem',
  'meta',
  'nextid',
  'param',
  'source',
  'track',
  'wbr'
];

const reservedNameSpaces = new Set(["class", "on", "style", "use", "prop", "attr"]);

function registerImportMethod(path, name) {
  const imports =
    path.scope.getProgramParent().data.imports ||
    (path.scope.getProgramParent().data.imports = new Set());
  if (!imports.has(name)) {
    helperModuleImports.addNamed(path, name, config.moduleName, {
      nameHint: `_$${name}`
    });
    imports.add(name);
  }
}

function jsxElementNameToString(node) {
  if (t.isJSXMemberExpression(node)) {
    return `${jsxElementNameToString(node.object)}.${node.property.name}`;
  }
  if (t.isJSXIdentifier(node)) {
    return node.name;
  }
  return `${node.namespace.name}:${node.name.name}`;
}

function tagNameToIdentifier(name) {
  const parts = name.split(".");
  if (parts.length === 1) return t.identifier(name);
  let part;
  let base = t.identifier(parts.shift());
  while ((part = parts.shift())) {
    base = t.memberExpression(base, t.identifier(part));
  }
  return base;
}

function getTagName(tag) {
  const jsxName = tag.openingElement.name;
  return jsxElementNameToString(jsxName);
}

function isComponent(tagName) {
  return (
    (tagName[0] && tagName[0].toLowerCase() !== tagName[0]) ||
    tagName.includes(".") ||
    /[^a-zA-Z]/.test(tagName[0])
  );
}

function isDynamic(path, { checkMember, checkTags, checkCallExpressions = true, native }) {
  if (config.generate === "ssr" && !config.async && native) {
    checkMember = false;
    checkCallExpressions = false;
  }
  const expr = path.node;
  if (t.isFunction(expr)) return false;
  if (
    expr.leadingComments &&
    expr.leadingComments[0] &&
    expr.leadingComments[0].value.trim() === config.staticMarker
  ) {
    expr.leadingComments.shift();
    return false;
  }
  if (
    (checkCallExpressions && t.isCallExpression(expr)) ||
    (checkMember && t.isMemberExpression(expr)) ||
    (checkTags && (t.isJSXElement(expr) || t.isJSXFragment(expr)))
  )
    return true;

  let dynamic;
  path.traverse({
    Function(p) {
      p.skip();
    },
    CallExpression(p) {
      checkCallExpressions && (dynamic = true) && p.stop();
    },
    MemberExpression(p) {
      checkMember && (dynamic = true) && p.stop();
    },
    JSXElement(p) {
      checkTags ? (dynamic = true) && p.stop() : p.skip();
    },
    JSXFragment(p) {
      checkTags ? (dynamic = true) && p.stop() : p.skip();
    }
  });
  return dynamic;
}

function isStaticExpressionContainer(path) {
  const node = path.node;
  return (
    t.isJSXExpressionContainer(node) &&
    t.isJSXElement(path.parent) &&
    !isComponent(getTagName(path.parent)) &&
    (t.isStringLiteral(node.expression) ||
      t.isNumericLiteral(node.expression) ||
      (t.isTemplateLiteral(node.expression) && node.expression.expressions.length === 0))
  );
}

// remove unnecessary JSX Text nodes
function filterChildren(children, loose) {
  return children.filter(
    ({ node: child }) =>
      !(t.isJSXExpressionContainer(child) && t.isJSXEmptyExpression(child.expression)) &&
      (!t.isJSXText(child) ||
        (loose ? !/^[\r\n]\s*$/.test(child.extra.raw) : !/^\s*$/.test(child.extra.raw)))
  );
}

function checkLength(children) {
  let i = 0;
  children.forEach(path => {
    const child = path.node;
    !(t.isJSXExpressionContainer(child) && t.isJSXEmptyExpression(child.expression)) &&
      (!t.isJSXText(child) || !/^\s*$/.test(child.extra.raw)) &&
      i++;
  });
  return i > 1;
}

function trimWhitespace(text) {
  text = text.replace(/\r/g, "");
  if (/\n/g.test(text)) {
    text = text
      .split("\n")
      .map((t, i) => (i ? t.replace(/^\s*/g, "") : t))
      .filter(s => !/^\s*$/.test(s))
      .join(" ");
  }
  return text.replace(/\s+/g, " ");
}

function toEventName(name) {
  return name.slice(2).toLowerCase();
}

function toPropertyName(name) {
  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());
}

function transformCondition(path, deep) {
  const expr = path.node;
  registerImportMethod(path, "memo");
  let dTest, cond, id;
  if (
    t.isConditionalExpression(expr) &&
    (isDynamic(path.get("consequent"), {
      checkTags: true
    }) ||
      isDynamic(path.get("alternate"), { checkTags: true }))
  ) {
    dTest = isDynamic(path.get("test"), { checkMember: true });
    if (dTest) {
      cond = expr.test;
      id = path.scope.generateUidIdentifier("_c$");
      if (!t.isBinaryExpression(cond))
        cond = t.unaryExpression("!", t.unaryExpression("!", cond, true), true);
      expr.test = t.callExpression(id, []);
      if (t.isConditionalExpression(expr.consequent) || t.isLogicalExpression(expr.consequent)) {
        expr.consequent = transformCondition(path.get("consequent"), true);
      }
      if (t.isConditionalExpression(expr.alternate) || t.isLogicalExpression(expr.alternate)) {
        expr.alternate = transformCondition(path.get("alternate"), true);
      }
    }
  } else if (t.isLogicalExpression(expr)) {
    let nextPath = path;
    // handle top-level or, ie cond && <A/> || <B/>
    if (expr.operator === "||" && t.isLogicalExpression(expr.left)) {
      nextPath = nextPath.get("left");
    }
    isDynamic(nextPath.get("right"), { checkTags: true }) &&
      (dTest = isDynamic(nextPath.get("left"), {
        checkMember: true
      }));
    if (dTest) {
      cond = nextPath.node.left;
      id = path.scope.generateUidIdentifier("_c$");
      if (expr.operator !== "||" && !t.isBinaryExpression(cond))
        cond = t.unaryExpression("!", t.unaryExpression("!", cond, true), true);
      nextPath.node.left = t.callExpression(id, []);
    }
  }
  if (dTest) {
    const statements = [
      t.variableDeclaration("const", [
        t.variableDeclarator(
          id,
          t.callExpression(t.identifier("_$memo"), [
            t.arrowFunctionExpression([], cond),
            t.booleanLiteral(true)
          ])
        )
      ]),
      t.arrowFunctionExpression([], expr)
    ];
    return deep
      ? t.callExpression(
          t.arrowFunctionExpression(
            [],
            t.blockStatement([statements[0], t.returnStatement(statements[1])])
          ),
          []
        )
      : statements;
  }
  return deep ? expr : t.arrowFunctionExpression([], expr);
}

function escapeHTML(s, attr) {
  if (typeof s !== "string") return s;
  const delim = attr ? '"' : "<";
  const escDelim = attr ? "&quot;" : "&lt;";
  let iDelim = s.indexOf(delim);
  let iAmp = s.indexOf("&");

  if (iDelim < 0 && iAmp < 0) return s;

  let left = 0,
    out = "";

  while (iDelim >= 0 && iAmp >= 0) {
    if (iDelim < iAmp) {
      if (left < iDelim) out += s.substring(left, iDelim);
      out += escDelim;
      left = iDelim + 1;
      iDelim = s.indexOf(delim, left);
    } else {
      if (left < iAmp) out += s.substring(left, iAmp);
      out += "&amp;";
      left = iAmp + 1;
      iAmp = s.indexOf("&", left);
    }
  }

  if (iDelim >= 0) {
    do {
      if (left < iDelim) out += s.substring(left, iDelim);
      out += escDelim;
      left = iDelim + 1;
      iDelim = s.indexOf(delim, left);
    } while (iDelim >= 0);
  } else {
    while (iAmp >= 0) {
      if (left < iAmp) out += s.substring(left, iAmp);
      out += "&amp;";
      left = iAmp + 1;
      iAmp = s.indexOf("&", left);
    }
  }

  return left < s.length ? out + s.substring(left) : out;
}

function transformElement(path, info) {
  let tagName = getTagName(path.node),
    wrapSVG = info.topLevel && tagName != "svg" && SVGElements.has(tagName),
    voidTag = VoidElements.indexOf(tagName) > -1,
    results = {
      template: `<${tagName}`,
      decl: [],
      exprs: [],
      dynamics: [],
      postExprs: [],
      isSVG: wrapSVG
    };
  if (wrapSVG) results.template = "<svg>" + results.template;
  if (!info.skipId) results.id = path.scope.generateUidIdentifier("el$");
  transformAttributes(path, results);
  if (config.contextToCustomElements && (tagName === "slot" || tagName.indexOf("-") > -1)) {
    contextToCustomElement(path, results);
  }
  results.template += ">";
  if (!voidTag) {
    transformChildren(path, results);
    results.template += `</${tagName}>`;
  }
  if (info.topLevel && config.hydratable && results.hasHydratableEvent) {
    registerImportMethod(path, "runHydrationEvents");
    results.postExprs.push(
      t.expressionStatement(t.callExpression(t.identifier("_$runHydrationEvents"), []))
    );
  }
  if (wrapSVG) results.template += "</svg>";
  return results;
}

function setAttr(path, elem, name, value, { isSVG, dynamic, prevId, isCE }) {
  // pull out namespace
  let parts, namespace;
  if ((parts = name.split(":")) && parts[1] && reservedNameSpaces.has(parts[0])) {
    name = parts[1];
    namespace = parts[0];
  }

  if (namespace === "style") {
    return t.callExpression(
      t.memberExpression(
        t.memberExpression(elem, t.identifier("style")),
        t.identifier("setProperty")
      ),
      [t.stringLiteral(name), value]
    );
  }

  if (name === "style") {
    registerImportMethod(path, "style");
    return t.callExpression(
      t.identifier("_$style"),
      prevId ? [elem, value, prevId] : [elem, value]
    );
  }

  if (!isSVG && name === "class") {
    return t.assignmentExpression("=", t.memberExpression(elem, t.identifier("className")), value);
  }

  if (name === "classList") {
    registerImportMethod(path, "classList");
    return t.callExpression(
      t.identifier("_$classList"),
      prevId ? [elem, value, prevId] : [elem, value]
    );
  }

  if (dynamic && name === "textContent") {
    return t.assignmentExpression("=", t.memberExpression(elem, t.identifier("data")), value);
  }

  const isChildProp = ChildProperties.has(name);
  const isProp = Properties.has(name);
  if (namespace !== "attr" && (isChildProp || (!isSVG && isProp) || isCE || namespace === "prop")) {
    if (isCE && !isChildProp && !isProp && namespace !== "prop") name = toPropertyName(name);
    return t.assignmentExpression("=", t.memberExpression(elem, t.identifier(name)), value);
  }

  let isNameSpaced = name.indexOf(":") > -1;
  name = Aliases[name] || name;
  !isSVG && (name = name.toLowerCase());
  const ns = isNameSpaced && SVGNamespace[name.split(":")[0]];
  if (ns) {
    registerImportMethod(path, "setAttributeNS");
    return t.callExpression(t.identifier("_$setAttributeNS"), [
      elem,
      t.stringLiteral(ns),
      t.stringLiteral(name),
      value
    ]);
  } else {
    registerImportMethod(path, "setAttribute");
    return t.callExpression(t.identifier("_$setAttribute"), [elem, t.stringLiteral(name), value]);
  }
}

function transformAttributes(path, results) {
  let elem = results.id,
    hasHydratableEvent = false,
    children;
  const spread = t.identifier("_$spread"),
    tagName = getTagName(path.node),
    isSVG = SVGElements.has(tagName),
    isCE = tagName.includes("-"),
    hasChildren = path.node.children.length > 0,
    attributes = path.get("openingElement").get("attributes"),
    classAttributes = attributes.filter(
      a => a.node.name && (a.node.name.name === "class" || a.node.name.name === "className")
    );
  // combine class propertoes
  if (classAttributes.length > 1) {
    const first = classAttributes[0].node,
      values = [],
      quasis = [t.TemplateElement({ raw: "" })];
    for (let i = 0; i < classAttributes.length; i++) {
      const attr = classAttributes[i].node,
        isLast = i === classAttributes.length - 1;
      if (!t.isJSXExpressionContainer(attr.value)) {
        const prev = quasis.pop();
        quasis.push(
          t.TemplateElement({
            raw:
              (prev ? prev.value.raw : "") +
              (i ? " " : "") +
              `${attr.value.value}` +
              (isLast ? "" : " ")
          })
        );
      } else {
        values.push(t.logicalExpression("||", attr.value.expression, t.stringLiteral("")));
        quasis.push(t.TemplateElement({ raw: isLast ? "" : " " }));
      }
      i && attributes.splice(classAttributes[i].key, 1);
    }
    first.value = t.JSXExpressionContainer(t.TemplateLiteral(quasis, values));
  }
  path.get("openingElement").set(
    "attributes",
    attributes.map(a => a.node)
  );

  // preprocess styles
  const styleAttribute = attributes.find(
    a =>
      a.node.name &&
      a.node.name.name === "style" &&
      t.isJSXExpressionContainer(a.node.value) &&
      t.isObjectExpression(a.node.value.expression) &&
      !a.node.value.expression.properties.some(p => t.isSpreadElement(p))
  );
  if (styleAttribute) {
    let i = 0,
      leading = styleAttribute.node.value.expression.leadingComments;
    styleAttribute.node.value.expression.properties.slice().forEach((p, index) => {
      if (!p.computed) {
        if (leading) p.value.leadingComments = leading;
        path
          .get("openingElement")
          .node.attributes.splice(
            styleAttribute.key + ++i,
            0,
            t.JSXAttribute(
              t.JSXNamespacedName(
                t.JSXIdentifier("style"),
                t.JSXIdentifier(t.isIdentifier(p.key) ? p.key.name : p.key.value)
              ),
              t.JSXExpressionContainer(p.value)
            )
          );
        styleAttribute.node.value.expression.properties.splice(index - i - 1, 1);
      }
    });
    if (!styleAttribute.node.value.expression.properties.length)
      path.get("openingElement").node.attributes.splice(styleAttribute.key, 1);
  }

  path
    .get("openingElement")
    .get("attributes")
    .forEach(attribute => {
      const node = attribute.node;
      if (t.isJSXSpreadAttribute(node)) {
        registerImportMethod(attribute, "spread");
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(spread, [
              elem,
              isDynamic(attribute.get("argument"), {
                checkMember: true
              })
                ? t.arrowFunctionExpression([], node.argument)
                : node.argument,
              t.booleanLiteral(isSVG),
              t.booleanLiteral(hasChildren)
            ])
          )
        );
        //NOTE: can't be checked at compile time so add to compiled output
        hasHydratableEvent = true;
        return;
      }

      let value = node.value,
        key = t.isJSXNamespacedName(node.name)
          ? `${node.name.namespace.name}:${node.name.name.name}`
          : node.name.name,
        reservedNameSpace =
          t.isJSXNamespacedName(node.name) && reservedNameSpaces.has(node.name.namespace.name);
      if (
        t.isJSXNamespacedName(node.name) &&
        reservedNameSpace &&
        !t.isJSXExpressionContainer(value)
      ) {
        node.value = value = t.JSXExpressionContainer(value || t.JSXEmptyExpression());
      }
      if (
        t.isJSXExpressionContainer(value) &&
        (reservedNameSpace ||
          !(t.isStringLiteral(value.expression) || t.isNumericLiteral(value.expression)))
      ) {
        if (key === "ref") {
          if (t.isLVal(value.expression)) {
            const refIdentifier = path.scope.generateUidIdentifier("_ref$");
            results.exprs.unshift(
              t.variableDeclaration("const", [
                t.variableDeclarator(refIdentifier, value.expression)
              ]),
              t.expressionStatement(
                t.conditionalExpression(
                  t.binaryExpression(
                    "===",
                    t.unaryExpression("typeof", refIdentifier),
                    t.stringLiteral("function")
                  ),
                  t.callExpression(refIdentifier, [elem]),
                  t.assignmentExpression("=", value.expression, elem)
                )
              )
            );
          } else if (t.isFunction(value.expression)) {
            results.exprs.unshift(
              t.expressionStatement(t.callExpression(value.expression, [elem]))
            );
          } else if (t.isCallExpression(value.expression)) {
            const refIdentifier = path.scope.generateUidIdentifier("_ref$");
            results.exprs.unshift(
              t.variableDeclaration("const", [
                t.variableDeclarator(refIdentifier, value.expression)
              ]),
              t.expressionStatement(
                t.logicalExpression(
                  "&&",
                  t.binaryExpression(
                    "===",
                    t.unaryExpression("typeof", refIdentifier),
                    t.stringLiteral("function")
                  ),
                  t.callExpression(refIdentifier, [elem])
                )
              )
            );
          }
        } else if (key.startsWith("use:")) {
          results.exprs.unshift(
            t.expressionStatement(
              t.callExpression(t.identifier(node.name.name.name), [
                elem,
                t.arrowFunctionExpression(
                  [],
                  t.isJSXEmptyExpression(value.expression)
                    ? t.booleanLiteral(true)
                    : value.expression
                )
              ])
            )
          );
        } else if (key === "children") {
          children = value;
        } else if (key.startsWith("on")) {
          const ev = toEventName(key);
          if (!ev || ev === "capture") {
            value.expression.properties.forEach(prop => {
              const listenerOptions = [
                t.stringLiteral(prop.key.name || prop.key.value),
                prop.value
              ];
              results.exprs.push(
                t.expressionStatement(
                  t.callExpression(
                    t.memberExpression(elem, t.identifier("addEventListener")),
                    ev ? listenerOptions.concat(t.booleanLiteral(true)) : listenerOptions
                  )
                )
              );
            });
          } else if (
            config.delegateEvents &&
            !NonComposedEvents.has(ev) &&
            config.nonDelegateEvents.indexOf(ev) === -1
          ) {
            // can only hydrate delegated events
            hasHydratableEvent = config.hydratableEvents
              ? config.hydratableEvents.includes(ev)
              : true;
            const events =
              attribute.scope.getProgramParent().data.events ||
              (attribute.scope.getProgramParent().data.events = new Set());
            events.add(ev);
            let handler = value.expression;
            if (t.isArrayExpression(value.expression)) {
              handler = value.expression.elements[0];
              results.exprs.unshift(
                t.expressionStatement(
                  t.assignmentExpression(
                    "=",
                    t.memberExpression(t.identifier(elem.name), t.identifier(`__${ev}Data`)),
                    value.expression.elements[1]
                  )
                )
              );
            }
            results.exprs.unshift(
              t.expressionStatement(
                t.assignmentExpression(
                  "=",
                  t.memberExpression(t.identifier(elem.name), t.identifier(`__${ev}`)),
                  handler
                )
              )
            );
          } else {
            let handler = value.expression;
            if (t.isArrayExpression(value.expression)) {
              handler = t.arrowFunctionExpression(
                [t.identifier("e")],
                t.callExpression(value.expression.elements[0], [
                  value.expression.elements[1],
                  t.identifier("e")
                ])
              );
            }
            results.exprs.unshift(
              t.expressionStatement(
                t.assignmentExpression(
                  "=",
                  t.memberExpression(t.identifier(elem.name), t.identifier(`on${ev}`)),
                  handler
                )
              )
            );
          }
        } else if (
          isDynamic(attribute.get("value").get("expression"), {
            checkMember: true
          })
        ) {
          let nextElem = elem;
          if (key === "textContent") {
            const textId = attribute.scope.generateUidIdentifier("el$");
            results.exprs.push(
              t.expressionStatement(
                t.assignmentExpression(
                  "=",
                  t.memberExpression(elem, t.identifier("textContent")),
                  value.expression
                )
              ),
              t.variableDeclaration("const", [
                t.variableDeclarator(textId, t.memberExpression(elem, t.identifier("firstChild")))
              ])
            );
            nextElem = textId;
          }
          results.dynamics.push({ elem: nextElem, key, value: value.expression, isSVG, isCE });
        } else {
          results.exprs.push(
            t.expressionStatement(setAttr(attribute, elem, key, value.expression, { isSVG, isCE }))
          );
        }
      } else {
        if (t.isJSXExpressionContainer(value)) value = value.expression;
        key = Aliases[key] || key;
        if (value && ChildProperties.has(key)) {
          results.exprs.push(
            t.expressionStatement(setAttr(attribute, elem, key, value, { isSVG, isCE }))
          );
        } else {
          !isSVG && (key = key.toLowerCase());
          results.template += ` ${key}`;
          results.template += value ? `="${value.value}"` : `=""`;
        }
      }
    });
  if (!hasChildren && children) {
    path.node.children.push(children);
  }

  results.hasHydratableEvent = results.hasHydratableEvent || hasHydratableEvent;
}

function wrappedByText(list, startIndex) {
  let index = startIndex,
    wrapped;
  while (--index >= 0) {
    const node = list[index];
    if (!node) continue;
    if (node.text) {
      wrapped = true;
      break;
    }
    if (node.id) return false;
  }
  if (!wrapped) return false;
  index = startIndex;
  while (++index < list.length) {
    const node = list[index];
    if (!node) continue;
    if (node.text) return true;
    if (node.id) return false;
  }
  return false;
}

function transformChildren(path, results) {
  const { generate, hydratable } = config;
  let tempPath = results.id && results.id.name,
    nextPlaceholder,
    i = 0;
  const filteredChildren = filterChildren(path.get("children"), true),
    childNodes = filteredChildren
      .map(
        (child, index) =>
          transformNode(child, {
            skipId: !results.id || !detectExpressions(filteredChildren, index)
          })
        // combine adjacent textNodes
      )
      .reduce((memo, child) => {
        if (!child) return memo;
        const i = memo.length;
        if (child.text && i && memo[i - 1].text) {
          memo[i - 1].template += child.template;
        } else memo.push(child);
        return memo;
      }, []);

  childNodes.forEach((child, index) => {
    if (!child) return;
    results.template += child.template;
    if (child.id) {
      results.decl.push(
        t.variableDeclarator(
          child.id,
          t.memberExpression(
            t.identifier(tempPath),
            t.identifier(i === 0 ? "firstChild" : "nextSibling")
          )
        )
      );
      results.decl.push(...child.decl);
      results.exprs.push(...child.exprs);
      results.dynamics.push(...child.dynamics);
      results.hasHydratableEvent = results.hasHydratableEvent || child.hasHydratableEvent;
      tempPath = child.id.name;
      nextPlaceholder = null;
      i++;
    } else if (child.exprs.length) {
      registerImportMethod(path, "insert");
      const multi = checkLength(filteredChildren),
        markers = hydratable && multi;
      // boxed by textNodes
      if (markers || wrappedByText(childNodes, index)) {
        let exprId, contentId;
        if (markers) tempPath = createPlaceholder(path, results, tempPath, i++, "#")[0].name;
        if (nextPlaceholder) {
          exprId = nextPlaceholder;
        } else {
          [exprId, contentId] = createPlaceholder(path, results, tempPath, i++, markers ? "/" : "");
        }
        if (!markers) nextPlaceholder = exprId;
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(
              t.identifier("_$insert"),
              contentId
                ? [results.id, child.exprs[0], exprId, contentId]
                : [results.id, child.exprs[0], exprId]
            )
          )
        );
        tempPath = exprId.name;
      } else if (multi) {
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(t.identifier("_$insert"), [
              results.id,
              child.exprs[0],
              nextChild(childNodes, index) || t.nullLiteral()
            ])
          )
        );
      } else {
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(
              t.identifier("_$insert"),
              hydratable
                ? [
                    results.id,
                    child.exprs[0],
                    t.identifier("undefined"),
                    t.callExpression(
                      t.memberExpression(
                        t.memberExpression(
                          t.memberExpression(t.identifier("Array"), t.identifier("prototype")),
                          t.identifier("slice")
                        ),
                        t.identifier("call")
                      ),
                      [
                        t.memberExpression(results.id, t.identifier("childNodes")),
                        t.numericLiteral(0)
                      ]
                    )
                  ]
                : [results.id, child.exprs[0]]
            )
          )
        );
      }
    } else nextPlaceholder = null;
  });
}

function createPlaceholder(path, results, tempPath, i, char) {
  const exprId = path.scope.generateUidIdentifier("el$");
  let contentId;
  results.template += `<!${char}>`;
  if (config.hydratable && char === "/") {
    registerImportMethod(path, "getNextMarker");
    contentId = path.scope.generateUidIdentifier("co$");
    results.decl.push(
      t.variableDeclarator(
        t.arrayPattern([exprId, contentId]),
        t.callExpression(t.identifier("_$getNextMarker"), [
          t.memberExpression(t.identifier(tempPath), t.identifier("nextSibling"))
        ])
      )
    );
  } else
    results.decl.push(
      t.variableDeclarator(
        exprId,
        t.memberExpression(
          t.identifier(tempPath),
          t.identifier(i === 0 ? "firstChild" : "nextSibling")
        )
      )
    );
  return [exprId, contentId];
}

function nextChild(children, index) {
  return children[index + 1] && (children[index + 1].id || nextChild(children, index + 1));
}

// reduce unnecessary refs
function detectExpressions(children, index) {
  if (children[index - 1]) {
    const node = children[index - 1].node;
    if (
      t.isJSXExpressionContainer(node) &&
      !t.isJSXEmptyExpression(node.expression) &&
      !isStaticExpressionContainer(children[index - 1])
    )
      return true;
    let tagName;
    if (t.isJSXElement(node) && (tagName = getTagName(node)) && isComponent(tagName)) return true;
  }
  for (let i = index; i < children.length; i++) {
    const child = children[i].node;
    if (t.isJSXExpressionContainer(child)) {
      if (!t.isJSXEmptyExpression(child.expression) && !isStaticExpressionContainer(children[i]))
        return true;
    } else if (t.isJSXElement(child)) {
      const tagName = getTagName(child);
      if (isComponent(tagName)) return true;
      if (config.contextToCustomElements && (tagName === "slot" || tagName.indexOf("-") > -1))
        return true;
      if (
        child.openingElement.attributes.some(
          attr =>
            t.isJSXSpreadAttribute(attr) ||
            ["textContent", "innerHTML", "innerText"].includes(attr.name.name) ||
            (t.isJSXExpressionContainer(attr.value) &&
              !(
                t.isStringLiteral(attr.value.expression) ||
                t.isNumericLiteral(attr.value.expression)
              ))
        )
      )
        return true;
      const nextChildren = filterChildren(children[i].get("children"), true);
      if (nextChildren.length) if (detectExpressions(nextChildren, 0)) return true;
    }
  }
}

function contextToCustomElement(path, results) {
  registerImportMethod(path, "currentContext");
  results.exprs.push(
    t.expressionStatement(
      t.assignmentExpression(
        "=",
        t.memberExpression(results.id, t.identifier("_context")),
        t.callExpression(t.identifier("_$currentContext"), [])
      )
    )
  );
}

function createTemplate(path, result, wrap) {
  if (result.id) {
    registerTemplate(path, result);
    if (
      !(result.exprs.length || result.dynamics.length || result.postExprs.length) &&
      result.decl.declarations.length === 1
    ) {
      return result.decl.declarations[0].init;
    } else {
      return t.callExpression(
        t.arrowFunctionExpression(
          [],
          t.blockStatement([
            result.decl,
            ...result.exprs.concat(
              wrapDynamics(path, result.dynamics) || [],
              result.postExprs || []
            ),
            t.returnStatement(result.id)
          ])
        ),
        []
      );
    }
  }
  if (wrap && result.dynamic) {
    registerImportMethod(path, "memo");
    return t.callExpression(t.identifier("_$memo"), [result.exprs[0]]);
  }
  return result.exprs[0];
}

function appendTemplates(path, templates) {
  const declarators = templates.map(template => {
    const tmpl = {
      cooked: template.template,
      raw: template.template
    };
    registerImportMethod(path, "template");
    return t.variableDeclarator(
      template.id,
      t.callExpression(
        t.identifier("_$template"),
        [
          t.templateLiteral([t.templateElement(tmpl, true)], []),
          t.numericLiteral(template.elementCount)
        ].concat(template.isSVG ? t.booleanLiteral(template.isSVG) : [])
      )
    );
  });
  path.node.body.unshift(t.variableDeclaration("const", declarators));
}

function registerTemplate(path, results) {
  const { generate, hydratable } = config;
  let decl;
  if (results.template.length) {
    const templates =
      path.scope.getProgramParent().data.templates ||
      (path.scope.getProgramParent().data.templates = []);
    let templateDef, templateId;
    if ((templateDef = templates.find(t => t.template === results.template))) {
      templateId = templateDef.id;
    } else {
      templateId = path.scope.generateUidIdentifier("tmpl$");
      templates.push({
        id: templateId,
        template: results.template,
        elementCount: results.template.split("<").length - 1,
        isSVG: results.isSVG
      });
    }
    hydratable && registerImportMethod(path, "getNextElement");
    decl = t.variableDeclarator(
      results.id,
      hydratable
        ? t.callExpression(
            t.identifier("_$getNextElement"),
            [templateId]
          )
        : t.callExpression(t.memberExpression(templateId, t.identifier("cloneNode")), [
            t.booleanLiteral(true)
          ])
    );
  }
  results.decl.unshift(decl);
  results.decl = t.variableDeclaration("const", results.decl);
}

function wrapDynamics(path, dynamics) {
  if (!dynamics.length) return;
  registerImportMethod(path, "effect");
  if (dynamics.length === 1) {
    const prevValue =
      dynamics[0].key === "classList" || dynamics[0].key === "style"
        ? t.identifier("_$p")
        : undefined;
    return t.expressionStatement(
      t.callExpression(t.identifier("_$effect"), [
        t.arrowFunctionExpression(
          prevValue ? [prevValue] : [],
          setAttr(
            path,
            dynamics[0].elem,
            dynamics[0].key,
            dynamics[0].value,
            {
              isSVG: dynamics[0].isSVG,
              isCE: dynamics[0].isCE,
              dynamic: true,
              prevId: prevValue
            }
          )
        )
      ])
    );
  }
  const decls = [],
    statements = [],
    identifiers = [],
    prevId = t.identifier("_p$");
  dynamics.forEach(({ elem, key, value, isSVG, isCE }) => {
    const identifier = path.scope.generateUidIdentifier("v$");
    identifiers.push(identifier);
    decls.push(t.variableDeclarator(identifier, value));
    if (key === "classList" || key === "style") {
      const prev = t.memberExpression(prevId, identifier);
      statements.push(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            prev,
            setAttr(path, elem, key, identifier, { isSVG, isCE, dynamic: true, prevId: prev })
          )
        )
      );
    } else {
      statements.push(
        t.expressionStatement(
          t.logicalExpression(
            "&&",
            t.binaryExpression("!==", identifier, t.memberExpression(prevId, identifier)),
            setAttr(
              path,
              elem,
              key,
              t.assignmentExpression("=", t.memberExpression(prevId, identifier), identifier),
              { isSVG, isCE, dynamic: true }
            )
          )
        )
      );
    }
  });

  return t.expressionStatement(
    t.callExpression(t.identifier("_$effect"), [
      t.arrowFunctionExpression(
        [prevId],
        t.blockStatement([
          t.variableDeclaration("const", decls),
          ...statements,
          t.returnStatement(prevId)
        ])
      ),
      t.objectExpression(identifiers.map(id => t.objectProperty(id, t.identifier("undefined"))))
    ])
  );
}

function appendToTemplate(template, value) {
  let array;
  if (Array.isArray(value)) {
    [value, ...array] = value;
  }
  template[template.length - 1] += value;
  if (array && array.length) template.push.apply(template, array);
}

function transformElement$1(path, info) {
  let tagName = getTagName(path.node),
    voidTag = VoidElements.indexOf(tagName) > -1,
    results = {
      template: [`<${tagName}`],
      templateValues: [],
      decl: [],
      exprs: [],
      dynamics: []
    };
  if (info.topLevel && config.hydratable) {
    registerImportMethod(path, "getHydrationKey");
    appendToTemplate(results.template, ` data-hk="`);
    results.template.push(`"`);
    results.templateValues.push(t.callExpression(t.identifier("_$getHydrationKey"), []));
  }
  transformAttributes$1(path, results);
  appendToTemplate(results.template, ">");
  if (!voidTag) {
    transformChildren$1(path, results);
    appendToTemplate(results.template, `</${tagName}>`);
  }
  return results;
}

function toAttribute(key, isSVG) {
  key = Aliases[key] || key;
  !isSVG && (key = key.toLowerCase());
  return key;
}

function setAttr$1(results, name, value, isSVG) {
  // strip out namespaces for now, everything at this point is an attribute
  let parts, namespace;
  if ((parts = name.split(":")) && parts[1] && reservedNameSpaces.has(parts[0])) {
    name = parts[1];
    namespace = parts[0];
  }

  name = toAttribute(name, isSVG);
  appendToTemplate(results.template, ` ${name}="`);
  results.template.push(`"`);
  results.templateValues.push(value);
}

function escapeExpression(path, expression, attr) {
  if (t.isStringLiteral(expression) || t.isNumericLiteral(expression)) {
    return expression;
  } else if (t.isFunction(expression)) {
    expression.body = escapeExpression(path, expression.body, attr);
    return expression;
  } else if (t.isTemplateLiteral(expression)) {
    expression.expressions = expression.expressions.map(e => escapeExpression(path, e, attr));
    return expression;
  } else if (t.isUnaryExpression(expression)) {
    expression.argument = escapeExpression(path, expression.argument, attr);
    return expression;
  } else if (t.isBinaryExpression(expression)) {
    expression.left = escapeExpression(path, expression.left, attr);
    expression.right = escapeExpression(path, expression.right, attr);
    return expression;
  } else if (t.isConditionalExpression(expression)) {
    expression.consequent = escapeExpression(path, expression.consequent, attr);
    expression.alternate = escapeExpression(path, expression.alternate, attr);
    return expression;
  } else if (t.isLogicalExpression(expression)) {
    expression.right = escapeExpression(path, expression.right, attr);
    if (expression.operator !== "&&") {
      expression.left = escapeExpression(path, expression.left, attr);
    }
    return expression;
  } else if (t.isCallExpression(expression) && t.isFunction(expression.callee)) {
    if (t.isBlockStatement(expression.callee.body)) {
      expression.callee.body.body = expression.callee.body.body.map(e => {
        if (t.isReturnStatement(e)) e.argument = escapeExpression(path, e.argument, attr);
        return e;
      });
    } else expression.callee.body = escapeExpression(path, expression.callee.body, attr);
    return expression;
  }

  registerImportMethod(path, "escape");
  return t.callExpression(
    t.identifier("_$escape"),
    [expression].concat(attr ? [t.booleanLiteral(true)] : [])
  );
}

function transformAttributes$1(path, results) {
  let children;
  const tagName = getTagName(path.node),
    isSVG = SVGElements.has(tagName),
    hasChildren = path.node.children.length > 0,
    attributes = path.get("openingElement").get("attributes"),
    classAttributes = attributes.filter(
      a => a.node.name && (a.node.name.name === "class" || a.node.name.name === "className")
    ),
    styleAttributes = attributes.filter(
      a => t.isJSXNamespacedName(a.node.name) && a.node.name.namespace.name === "style"
    );
  // combine class propertoes
  if (classAttributes.length > 1) {
    const first = classAttributes[0].node,
      values = [],
      quasis = [t.TemplateElement({ raw: "" })];
    for (let i = 0; i < classAttributes.length; i++) {
      const attr = classAttributes[i].node,
        isLast = i === classAttributes.length - 1;
      if (!t.isJSXExpressionContainer(attr.value)) {
        const prev = quasis.pop();
        quasis.push(
          t.TemplateElement({
            raw:
              (prev ? prev.value.raw : "") +
              (i ? " " : "") +
              `${attr.value.value}` +
              (isLast ? "" : " ")
          })
        );
      } else {
        values.push(t.logicalExpression("||", attr.value.expression, t.stringLiteral("")));
        quasis.push(t.TemplateElement({ raw: isLast ? "" : " " }));
      }
      i && attributes.splice(classAttributes[i].key, 1);
    }
    first.value = t.JSXExpressionContainer(t.TemplateLiteral(quasis, values));
  }
  if (styleAttributes.length) {
    const properties = [];
    const styleAttribute = attributes.find(a => a.node.name.name === "style");
    for (let i = 0; i < styleAttributes.length; i++) {
      const attr = styleAttributes[i].node;
      const computed = !t.isValidIdentifier(attr.name.name.name);
      properties.push(
        t.objectProperty(
          computed ? t.stringLiteral(attr.name.name.name) : t.identifier(attr.name.name.name),
          t.isJSXExpressionContainer(attr.value) ? attr.value.expression : attr.value
        )
      );
      (styleAttribute || i) && attributes.splice(styleAttributes[i].key, 1);
    }
    if (
      styleAttribute &&
      t.isJSXExpressionContainer(styleAttribute.node.value) &&
      t.isObjectExpression(styleAttribute.node.value.expression)
    ) {
      styleAttribute.node.value.expression.properties.push(...properties);
    } else {
      styleAttributes[0].node = t.jsxAttribute(
        t.jsxIdentifier("style"),
        t.jsxExpressionContainer(t.objectExpression(properties))
      );
    }
  }

  attributes.forEach(attribute => {
    const node = attribute.node;
    if (t.isJSXSpreadAttribute(node)) {
      registerImportMethod(attribute, "ssrSpread");
      appendToTemplate(results.template, " ");
      results.template.push("");
      results.templateValues.push(
        t.callExpression(t.identifier("_$ssrSpread"), [
          isDynamic(attribute.get("argument"), {
            checkMember: true,
            native: true
          })
            ? t.arrowFunctionExpression([], node.argument)
            : node.argument,
          t.booleanLiteral(isSVG),
          t.booleanLiteral(hasChildren)
        ])
      );
      return;
    }

    let value = node.value,
      key = t.isJSXNamespacedName(node.name)
        ? `${node.name.namespace.name}:${node.name.name.name}`
        : node.name.name,
      reservedNameSpace =
        t.isJSXNamespacedName(node.name) && reservedNameSpaces.has(node.name.namespace.name);
    if (
      ((t.isJSXNamespacedName(node.name) && reservedNameSpace) || ChildProperties.has(key)) &&
      !t.isJSXExpressionContainer(value)
    ) {
      node.value = value = t.JSXExpressionContainer(value || t.JSXEmptyExpression());
    }

    if (
      t.isJSXExpressionContainer(value) &&
      (reservedNameSpace ||
        ChildProperties.has(key) ||
        !(t.isStringLiteral(value.expression) || t.isNumericLiteral(value.expression)))
    ) {
      if (
        key === "ref" ||
        key.startsWith("use:") ||
        key.startsWith("prop:") ||
        key.startsWith("on")
      )
        return;
      else if (ChildProperties.has(key)) {
        children = value;
        if (key === "innerHTML") path.doNotEscape = true;
      } else {
        let dynamic = false,
          doEscape = true;
        if (
          isDynamic(attribute.get("value").get("expression"), {
            checkMember: true,
            native: true
          })
        )
          dynamic = true;

        if (BooleanAttributes.has(key)) {
          registerImportMethod(attribute, "ssrBoolean");
          results.template.push("");
          const fn =  t.callExpression(t.identifier("_$ssrBoolean"), [
            t.stringLiteral(key), value.expression
          ]);
          results.templateValues.push(
            dynamic ? t.arrowFunctionExpression([], fn) : fn
          );
          return;
        }
        if (key === "style") {
          if (
            t.isJSXExpressionContainer(value) &&
            t.isObjectExpression(value.expression) &&
            !value.expression.properties.some(p => t.isSpreadElement(p))
          ) {
            registerImportMethod(path, "escape");
            const props = value.expression.properties.map((p, i) =>
              t.binaryExpression(
                "+",
                t.stringLiteral(
                  (i ? ";" : "") + (t.isIdentifier(p.key) ? p.key.name : p.key.value) + ":"
                ),
                t.isStringLiteral(p.value)
                  ? t.stringLiteral(escapeHTML(p.value.value))
                  : t.isNumericLiteral(p.value)
                  ? p.value
                  : t.isTemplateLiteral(p.value) && p.value.expressions.length === 0
                  ? t.stringLiteral(escapeHTML(p.value.quasis[0].value.raw))
                  : t.callExpression(t.identifier("_$escape"), [p.value, t.booleanLiteral(true)])
              )
            );
            let res = props[0];
            for (let i = 1; i < props.length; i++) {
              res = t.binaryExpression("+", res, props[i]);
            }
            value.expression = res;
          } else {
            registerImportMethod(path, "ssrStyle");
            value.expression = t.callExpression(t.identifier("_$ssrStyle"), [value.expression]);
          }
          doEscape = false;
        }
        if (key === "classList") {
          registerImportMethod(path, "ssrClassList");
          value.expression = t.callExpression(t.identifier("_$ssrClassList"), [value.expression]);
          key = "class";
          doEscape = false;
        }
        if (dynamic)
          value.expression = t.arrowFunctionExpression(
            [],
            doEscape ? escapeExpression(path, value.expression, true) : value.expression
          );
        else if (doEscape) value.expression = escapeExpression(path, value.expression, true);
        setAttr$1(results, key, value.expression, isSVG);
      }
    } else {
      if (t.isJSXExpressionContainer(value)) value = value.expression;
      key = toAttribute(key, isSVG);
      appendToTemplate(results.template, ` ${key}`);
      appendToTemplate(results.template, value ? `="${escapeHTML(value.value, true)}"` : `=""`);
    }
  });
  if (!hasChildren && children) {
    path.node.children.push(children);
  }
}

function transformChildren$1(path, results) {
  const { hydratable, async } = config,
    doEscape = !path.doNotEscape;
  const filteredChildren = filterChildren(path.get("children"), true);
  filteredChildren.forEach(node => {
    const child = transformNode(node);
    appendToTemplate(results.template, child.template);
    results.templateValues.push.apply(results.templateValues, child.templateValues || []);
    if (child.exprs.length) {
      const multi = checkLength(filteredChildren),
        markers = hydratable && multi;

      if (doEscape && !child.component) child.exprs[0] = escapeExpression(path, child.exprs[0]);

      // boxed by textNodes
      if (markers) {
        appendToTemplate(results.template, `<!--#-->`);
        results.template.push("");
        results.templateValues.push(child.exprs[0]);
        appendToTemplate(results.template, `<!--/-->`);
      } else {
        results.template.push("");
        results.templateValues.push(child.exprs[0]);
      }
    }
  });
}

function createTemplate$1(path, result) {
  if (!result.template) {
    return result.exprs[0];
  }

  // uncomment to optimize non-hoisted, needs more thorough testing
  // if (!config.async) {
  //   if (!Array.isArray(result.template)) return t.stringLiteral(result.template);
  //   if (result.template.length === 1) return t.stringLiteral(result.template[0]);
  //   const quasis = result.template.map(tmpl => t.TemplateElement({ raw: tmpl }));
  //   return t.TemplateLiteral(quasis, result.templateValues);
  // }

  registerImportMethod(path, "ssr");
  if (!Array.isArray(result.template))
    return t.callExpression(t.identifier(`_$ssr`), [t.stringLiteral(result.template)]);
  if (result.template.length === 1)
    return t.callExpression(t.identifier(`_$ssr`), [t.stringLiteral(result.template[0])]);
  const strings = result.template.map(tmpl => t.stringLiteral(tmpl));
  return t.callExpression(t.identifier(`_$ssr`), [
    t.arrayExpression(strings),
    ...result.templateValues
  ]);
}

function transformComponent(path) {
  let props = [],
    runningObject = [],
    exprs = [],
    tagName = getTagName(path.node);

  if (config.builtIns.indexOf(tagName) > -1 && !path.scope.hasBinding(tagName)) {
    registerImportMethod(path, tagName);
    tagName = `_$${tagName}`;
  }

  path
    .get("openingElement")
    .get("attributes")
    .forEach(attribute => {
      const node = attribute.node;
      if (t.isJSXSpreadAttribute(node)) {
        if (runningObject.length) {
          props.push(t.objectExpression(runningObject));
          runningObject = [];
        }
        if (!config.wrapSpreads) props.push(node.argument);
        else {
          const key = t.identifier("k$"),
            memo = t.identifier("m$");
          registerImportMethod(path, "dynamicProperty");
          props.push(
            t.callExpression(
              t.memberExpression(
                t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("keys")), [
                  node.argument
                ]),
                t.identifier("reduce")
              ),
              [
                t.arrowFunctionExpression(
                  [memo, key],
                  t.sequenceExpression([
                    t.assignmentExpression(
                      "=",
                      t.memberExpression(memo, key, true),
                      t.arrowFunctionExpression([], t.memberExpression(node.argument, key, true))
                    ),
                    t.callExpression(t.identifier("_$dynamicProperty"), [memo, key])
                  ])
                ),
                t.objectExpression([])
              ]
            )
          );
        }
      } else {
        const value = node.value || t.booleanLiteral(true),
          key = t.isJSXNamespacedName(node.name)
            ? `${node.name.namespace.name}:${node.name.name.name}`
            : node.name.name,
          wrapName = t.isValidIdentifier(key) ? t.identifier : t.stringLiteral;
        if (t.isJSXExpressionContainer(value))
          if (key === "ref") {
            if (config.generate === "ssr") return;
            if (t.isLVal(value.expression)) {
              const refIdentifier = path.scope.generateUidIdentifier("_ref$");
              runningObject.push(
                t.objectMethod(
                  "method",
                  t.identifier("ref"),
                  [t.identifier("r$")],
                  t.blockStatement([
                    t.variableDeclaration("const", [
                      t.variableDeclarator(refIdentifier, value.expression)
                    ]),
                    t.expressionStatement(
                      t.conditionalExpression(
                        t.binaryExpression(
                          "===",
                          t.unaryExpression("typeof", refIdentifier),
                          t.stringLiteral("function")
                        ),
                        t.callExpression(refIdentifier, [t.identifier("r$")]),
                        t.assignmentExpression("=", value.expression, t.identifier("r$"))
                      )
                    )
                  ])
                )
              );
            } else if (t.isFunction(value.expression)) {
              runningObject.push(t.objectProperty(t.identifier("ref"), value.expression));
            } else if (t.isCallExpression(value.expression)) {
              const refIdentifier = path.scope.generateUidIdentifier("_ref$");
              runningObject.push(
                t.objectMethod(
                  "method",
                  t.identifier("ref"),
                  [t.identifier("r$")],
                  t.blockStatement([
                    t.variableDeclaration("const", [
                      t.variableDeclarator(refIdentifier, value.expression)
                    ]),
                    t.expressionStatement(
                      t.logicalExpression(
                        "&&",
                        t.binaryExpression(
                          "===",
                          t.unaryExpression("typeof", refIdentifier),
                          t.stringLiteral("function")
                        ),
                        t.callExpression(refIdentifier, [t.identifier("r$")])
                      )
                    )
                  ])
                )
              );
            }
          } else if (
            isDynamic(attribute.get("value").get("expression"), {
              checkMember: true,
              checkTags: true
            })
          ) {
            let expr =
              config.wrapConditionals &&
              (config.generate !== "ssr" || config.async) &&
              (t.isLogicalExpression(value.expression) ||
                t.isConditionalExpression(value.expression))
                ? transformCondition(attribute.get("value").get("expression"))
                : t.arrowFunctionExpression([], value.expression);
            if (expr.length > 1) {
              exprs.push(expr[0]);
              expr = expr[1];
            }
            runningObject.push(
              t.objectMethod(
                "get",
                wrapName(key),
                [],
                t.blockStatement([t.returnStatement(expr.body)]),
                !t.isValidIdentifier(key)
              )
            );
          } else runningObject.push(t.objectProperty(wrapName(key), value.expression));
        else runningObject.push(t.objectProperty(wrapName(key), value));
      }
    });

  const childResult = transformComponentChildren(path.get("children"));
  if (childResult && childResult[0]) {
    if (childResult[1]) {
      const body =
        t.isCallExpression(childResult[0]) && t.isFunction(childResult[0].callee)
          ? childResult[0].callee.body
          : childResult[0].body;
      runningObject.push(
        t.objectMethod(
          "get",
          t.identifier("children"),
          [],
          t.isExpression(body) ? t.blockStatement([t.returnStatement(body)]) : body
        )
      );
    } else runningObject.push(t.objectProperty(t.identifier("children"), childResult[0]));
  }
  props.push(t.objectExpression(runningObject));

  if (props.length > 1) {
    registerImportMethod(path, "assignProps");
    props = [t.callExpression(t.identifier("_$assignProps"), props)];
  }
  registerImportMethod(path, "createComponent");
  const componentArgs = [tagNameToIdentifier(tagName), props[0]];
  exprs.push(t.callExpression(t.identifier("_$createComponent"), componentArgs));

  // handle hoisting conditionals
  if (exprs.length > 1) {
    const ret = exprs.pop();
    exprs = [
      t.callExpression(
        t.arrowFunctionExpression([], t.blockStatement([...exprs, t.returnStatement(ret)])),
        []
      )
    ];
  }
  return { exprs, template: "", component: true };
}

function transformComponentChildren(children) {
  const createTemplate$2 = config.generate === "ssr" ? createTemplate$1 : createTemplate,
    filteredChildren = filterChildren(children);
  if (!filteredChildren.length) return;
  let dynamic = false;

  let transformedChildren = filteredChildren.map(path => {
    if (t.isJSXText(path.node)) {
      return t.stringLiteral(trimWhitespace(path.node.extra.raw));
    } else {
      const child = transformNode(path, {
        topLevel: true,
        componentChild: true
      });
      dynamic = dynamic || child.dynamic;
      return createTemplate$2(path, child, filteredChildren.length > 1);
    }
  });

  if (filteredChildren.length === 1) {
    transformedChildren = transformedChildren[0];
    if (
      !t.isJSXExpressionContainer(filteredChildren[0]) &&
      !t.isJSXSpreadChild(filteredChildren[0]) &&
      !t.isJSXText(filteredChildren[0])
    ) {
      transformedChildren =
        t.isCallExpression(transformedChildren) && !transformedChildren.arguments.length
          ? transformedChildren.callee
          : t.arrowFunctionExpression([], transformedChildren);
      dynamic = true;
    }
  } else {
    transformedChildren = t.arrowFunctionExpression([], t.arrayExpression(transformedChildren));
    dynamic = true;
  }
  return [transformedChildren, dynamic];
}

function transformFragmentChildren(children, results) {
  const createTemplate$2 = config.generate === "ssr" ? createTemplate$1 : createTemplate,
    filteredChildren = filterChildren(children),
    singleChild = filteredChildren.length === 1,
    childNodes = filteredChildren.map(path => {
      if (t.isJSXText(path.node)) return t.stringLiteral(trimWhitespace(path.node.extra.raw));
      const child = transformNode(path, { topLevel: true, fragmentChild: true });
      return createTemplate$2(path, child, !singleChild);
    });
  results.exprs.push(singleChild ? childNodes[0] : t.arrayExpression(childNodes));
}

function transformJSX(path, { opts }) {
  Object.assign(config, opts);
  const replace = transformThis(path);
  const result = transformNode(
    path,
    t.isJSXFragment(path.node)
      ? {}
      : {
          topLevel: true
        }
  );
  const template = config.generate === "ssr" ? createTemplate$1 : createTemplate;
  path.replaceWith(replace(template(path, result, false)));
}

function transformThis(path) {
  let thisId;
  path.traverse({
    ThisExpression(path) {
      thisId || (thisId = path.scope.generateUidIdentifier("self$"));
      path.replaceWith(thisId);
    }
  });
  return node => {
    if (thisId) {
      let parent = path.getStatementParent();
      const decl = t.variableDeclaration("const", [
        t.variableDeclarator(thisId, t.thisExpression())
      ]);
      parent.insertBefore(decl);
    }
    return node;
  };
}

function transformNode(path, info = {}) {
  const node = path.node;
  if (t.isJSXElement(node)) {
    let tagName = getTagName(node);
    if (isComponent(tagName)) return transformComponent(path);
    const element = config.generate === "ssr" ? transformElement$1 : transformElement;
    return element(path, info);
  } else if (t.isJSXFragment(node)) {
    let results = { template: "", decl: [], exprs: [], dynamics: [] };
    transformFragmentChildren(path.get("children"), results);
    return results;
  } else if (t.isJSXText(node) || isStaticExpressionContainer(path)) {
    const text = trimWhitespace(
      t.isJSXExpressionContainer(node)
        ? t.isTemplateLiteral(node.expression)
          ? node.expression.quasis[0].value.raw
          : node.expression.value.toString()
        : node.extra.raw
    );
    if (!text.length) return null;
    const results = {
      template: text,
      decl: [],
      exprs: [],
      dynamics: [],
      postExprs: [],
      text: true
    };
    if (!info.skipId && config.generate !== "ssr")
      results.id = path.scope.generateUidIdentifier("el$");
    return results;
  } else if (t.isJSXExpressionContainer(node)) {
    if (t.isJSXEmptyExpression(node.expression)) return null;
    if (
      !isDynamic(path.get("expression"), {
        checkMember: true,
        checkTags: !!info.componentChild,
        native: !info.componentChild
      })
    ) {
      return { exprs: [node.expression], template: "" };
    }
    const expr =
      config.wrapConditionals &&
      (config.generate !== "ssr" || config.async) &&
      (t.isLogicalExpression(node.expression) || t.isConditionalExpression(node.expression))
        ? transformCondition(path.get("expression"))
        : !info.componentChild &&
          (config.generate !== "ssr" || info.fragmentChild) &&
          t.isCallExpression(node.expression) &&
          !t.isMemberExpression(node.expression.callee) &&
          node.expression.arguments.length === 0
        ? node.expression.callee
        : t.arrowFunctionExpression([], node.expression);
    return {
      exprs:
        expr.length > 1
          ? [
              t.callExpression(
                t.arrowFunctionExpression(
                  [],
                  t.blockStatement([expr[0], t.returnStatement(expr[1])])
                ),
                []
              )
            ]
          : [expr],
      template: "",
      dynamic: true
    };
  } else if (t.isJSXSpreadChild(node)) {
    if (
      !isDynamic(path.get("expression"), {
        checkMember: true,
        native: !info.componentChild
      })
    )
      return { exprs: [node.expression], template: "" };
    const expr = t.arrowFunctionExpression([], node.expression);
    return {
      exprs: [expr],
      template: "",
      dynamic: true
    };
  }
}

// add to the top/bottom of the module.
var postprocess = path => {
  if (path.scope.data.events) {
    registerImportMethod(path, "delegateEvents");
    path.node.body.push(
      t.expressionStatement(
        t.callExpression(t.identifier("_$delegateEvents"), [
          t.arrayExpression(Array.from(path.scope.data.events).map(e => t.stringLiteral(e)))
        ])
      )
    );
  }
  if (path.scope.data.templates) appendTemplates(path, path.scope.data.templates);
};

var index = () => {
  return {
    name: "JSX DOM Expressions",
    inherits: SyntaxJSX__default['default'],
    visitor: {
      JSXElement: transformJSX,
      JSXFragment: transformJSX,
      Program: {
        exit: postprocess
      }
    }
  };
};

module.exports = index;
