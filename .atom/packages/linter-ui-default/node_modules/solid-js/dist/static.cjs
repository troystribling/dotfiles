'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const equalFn = (a, b) => a === b;
const ERROR = Symbol("error");
const UNOWNED = {
  context: null,
  owner: null
};
let Owner = null;
function createRoot(fn, detachedOwner) {
  detachedOwner && (Owner = detachedOwner);
  const owner = Owner,
        root = fn.length === 0 ? UNOWNED : {
    context: null,
    owner
  };
  Owner = root;
  let result;
  try {
    result = fn(() => {});
  } catch (err) {
    const fns = lookup(Owner, ERROR);
    if (!fns) throw err;
    fns.forEach(f => f(err));
  } finally {
    Owner = owner;
  }
  return result;
}
function createSignal(value, areEqual) {
  return [() => value, v => value = v];
}
function createComputed(fn, value) {
  Owner = {
    owner: Owner,
    context: null
  };
  fn(value);
  Owner = Owner.owner;
}
function createRenderEffect(fn, value) {
  Owner = {
    owner: Owner,
    context: null
  };
  fn(value);
  Owner = Owner.owner;
}
function createEffect(fn, value) {}
function createMemo(fn, value, areEqual) {
  Owner = {
    owner: Owner,
    context: null
  };
  const v = fn(value);
  Owner = Owner.owner;
  return () => v;
}
function createDeferred(source, options) {
  return source;
}
function createSelector(source, fn) {
  return source;
}
function batch(fn) {
  return fn();
}
function untrack(fn) {
  return fn();
}
function on(...args) {
  const fn = args.pop();
  let deps;
  let isArray = true;
  let prev;
  if (args.length < 2) {
    deps = args[0];
    isArray = false;
  } else deps = args;
  return prevResult => {
    let value;
    if (isArray) {
      value = [];
      if (!prev) prev = [];
      for (let i = 0; i < deps.length; i++) value.push(deps[i]());
    } else value = deps();
    return fn(value, prev, prevResult);
  };
}
function onMount(fn) {}
function onCleanup(fn) {}
function onError(fn) {
  if (Owner === null)  console.warn("error handlers created outside a `createRoot` or `render` will never be run");else if (Owner.context === null) Owner.context = {
    [ERROR]: [fn]
  };else if (!Owner.context[ERROR]) Owner.context[ERROR] = [fn];else Owner.context[ERROR].push(fn);
}
function getListener() {
  return null;
}
function createContext(defaultValue) {
  const id = Symbol("context");
  return {
    id,
    Provider: createProvider(id),
    defaultValue
  };
}
function useContext(context) {
  return lookup(Owner, context.id) || context.defaultValue;
}
function getContextOwner() {
  return Owner;
}
function lookup(owner, key) {
  return owner && (owner.context && owner.context[key] || owner.owner && lookup(owner.owner, key));
}
function resolveChildren(children) {
  if (typeof children === "function") return resolveChildren(children());
  if (Array.isArray(children)) {
    const results = [];
    for (let i = 0; i < children.length; i++) {
      let result = resolveChildren(children[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children;
}
function createProvider(id) {
  return function provider(props) {
    let rendered;
    createRenderEffect(() => {
      Owner.context = {
        [id]: props.value
      };
      rendered = resolveChildren(props.children);
    });
    return rendered;
  };
}
function requestCallback(fn, options) {
  return {
    id: 0,
    fn: () => {},
    startTime: 0,
    expirationTime: 0
  };
}
const $RAW = Symbol("state-raw");
function isWrappable(obj) {
  return obj != null && typeof obj === "object" && (obj.__proto__ === Object.prototype || Array.isArray(obj));
}
function unwrap(item) {
  return item;
}
function setProperty(state, property, value, force) {
  if (!force && state[property] === value) return;
  if (value === undefined) {
    delete state[property];
  } else state[property] = value;
}
function mergeState(state, value, force) {
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    setProperty(state, key, value[key], force);
  }
}
function updatePath(current, path, traversed = []) {
  let part,
      next = current;
  if (path.length > 1) {
    part = path.shift();
    const partType = typeof part,
          isArray = Array.isArray(current);
    if (Array.isArray(part)) {
      for (let i = 0; i < part.length; i++) {
        updatePath(current, [part[i]].concat(path), [part[i]].concat(traversed));
      }
      return;
    } else if (isArray && partType === "function") {
      for (let i = 0; i < current.length; i++) {
        if (part(current[i], i)) updatePath(current, [i].concat(path), [i].concat(traversed));
      }
      return;
    } else if (isArray && partType === "object") {
      const {
        from = 0,
        to = current.length - 1,
        by = 1
      } = part;
      for (let i = from; i <= to; i += by) {
        updatePath(current, [i].concat(path), [i].concat(traversed));
      }
      return;
    } else if (path.length > 1) {
      updatePath(current[part], path, [part].concat(traversed));
      return;
    }
    next = current[part];
    traversed = [part].concat(traversed);
  }
  let value = path[0];
  if (typeof value === "function") {
    value = value(next, traversed);
    if (value === next) return;
  }
  if (part === undefined && value == undefined) return;
  if (part === undefined || isWrappable(next) && isWrappable(value) && !Array.isArray(value)) {
    mergeState(next, value);
  } else setProperty(current, part, value);
}
function createState(state) {
  function setState(...args) {
    updatePath(state, args);
  }
  return [state, setState];
}
function reconcile(value, options = {}) {
  return state => {
    if (!isWrappable(state)) return value;
    const targetKeys = Object.keys(value);
    for (let i = 0, len = targetKeys.length; i < len; i++) {
      const key = targetKeys[i];
      setProperty(state, key, value[key]);
    }
    const previousKeys = Object.keys(state);
    for (let i = 0, len = previousKeys.length; i < len; i++) {
      if (value[previousKeys[i]] === undefined) setProperty(state, previousKeys[i], undefined);
    }
  };
}
function produce(fn) {
  return state => {
    if (isWrappable(state)) fn(state);
    return state;
  };
}
function mapArray(list, mapFn, options = {}) {
  const items = list();
  let s = [];
  if (items.length) {
    for (let i = 0, len = items.length; i < len; i++) s.push(mapFn(items[i], () => i));
  } else if (options.fallback) s = [options.fallback()];
  return () => s;
}

function resolveSSRNode(node) {
  const t = typeof node;
  if (t === "string") return node;
  if (node == null || t === "boolean") return "";
  if (Array.isArray(node)) return node.map(resolveSSRNode).join("");
  if (t === "object") return resolveSSRNode(node.t);
  if (t === "function") return resolveSSRNode(node());
  return String(node);
}
function createComponent(Comp, props) {
  return Comp(props);
}
function assignProps(target, ...sources) {
  for (let i = 0; i < sources.length; i++) {
    const descriptors = Object.getOwnPropertyDescriptors(sources[i]);
    Object.defineProperties(target, descriptors);
  }
  return target;
}
function splitProps(props, ...keys) {
  const descriptors = Object.getOwnPropertyDescriptors(props),
        split = k => {
    const clone = {};
    for (let i = 0; i < k.length; i++) {
      const key = k[i];
      if (descriptors[key]) {
        Object.defineProperty(clone, key, descriptors[key]);
        delete descriptors[key];
      }
    }
    return clone;
  };
  return keys.map(split).concat(split(Object.keys(descriptors)));
}
function simpleMap(props, wrap) {
  const list = props.each || [],
        len = list.length,
        fn = props.children;
  if (len) {
    let mapped = "";
    for (let i = 0; i < len; i++) mapped += resolveSSRNode(wrap(fn, list[i], i));
    return {
      t: mapped
    };
  }
  return props.fallback || "";
}
function For(props) {
  return simpleMap(props, (fn, item, i) => fn(item, () => i));
}
function Index(props) {
  return simpleMap(props, (fn, item, i) => fn(() => item, i));
}
function Show(props) {
  let c;
  return props.when ? typeof (c = props.children) === "function" ? c(props.when) : c : props.fallback || "";
}
function Switch(props) {
  let conditions = props.children;
  Array.isArray(conditions) || (conditions = [conditions]);
  for (let i = 0; i < conditions.length; i++) {
    const w = conditions[i].when;
    if (w) {
      const c = conditions[i].children;
      return typeof c === "function" ? c(w) : c;
    }
  }
  return props.fallback || "";
}
function Match(props) {
  return props;
}
function ErrorBoundary(props) {
  return props.children;
}
function createResource(value) {
  const resource = () => value;
  resource.loading = false;
  function load(fn) {
    if (!globalThis._$HYDRATION.streamSSR) return {
      then() {}
    };
    resource.loading = true;
    const p = fn();
    if ("then" in p) {
      globalThis._$HYDRATION.register && globalThis._$HYDRATION.register(p);
      return p;
    }
    return Promise.resolve(value = p);
  }
  return [resource, load];
}
function createResourceState(state) {
  state.loading = {};
  function setState(...args) {
    updatePath(state, args);
  }
  function loadState(v, reconcilerFn) {
    const keys = Object.keys(v);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i],
            [, l] = createResource(state[k]);
      l(v[k]);
    }
  }
  return [state, loadState, setState];
}
function lazy(fn) {
  let p;
  return props => {
    (p || (p = fn())).then(mod => mod.default(props));
    return "";
  };
}
function useTransition() {
  return [() => false, fn => {
    fn();
  }];
}
function SuspenseList(props) {
  return props.children;
}
function Suspense(props) {
  props.children;
  return props.fallback;
}

exports.$RAW = $RAW;
exports.ErrorBoundary = ErrorBoundary;
exports.For = For;
exports.Index = Index;
exports.Match = Match;
exports.Show = Show;
exports.Suspense = Suspense;
exports.SuspenseList = SuspenseList;
exports.Switch = Switch;
exports.assignProps = assignProps;
exports.batch = batch;
exports.createComponent = createComponent;
exports.createComputed = createComputed;
exports.createContext = createContext;
exports.createDeferred = createDeferred;
exports.createEffect = createEffect;
exports.createMemo = createMemo;
exports.createRenderEffect = createRenderEffect;
exports.createResource = createResource;
exports.createResourceState = createResourceState;
exports.createRoot = createRoot;
exports.createSelector = createSelector;
exports.createSignal = createSignal;
exports.createState = createState;
exports.equalFn = equalFn;
exports.getContextOwner = getContextOwner;
exports.getListener = getListener;
exports.lazy = lazy;
exports.mapArray = mapArray;
exports.on = on;
exports.onCleanup = onCleanup;
exports.onError = onError;
exports.onMount = onMount;
exports.produce = produce;
exports.reconcile = reconcile;
exports.requestCallback = requestCallback;
exports.splitProps = splitProps;
exports.untrack = untrack;
exports.unwrap = unwrap;
exports.useContext = useContext;
exports.useTransition = useTransition;
