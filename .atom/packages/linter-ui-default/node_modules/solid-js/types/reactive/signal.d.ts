export declare const equalFn: <T>(a: T, b: T) => boolean;
export declare var Owner: Owner | null;
export declare var Listener: Computation<any> | null;
interface Signal<T> {
    value?: T;
    observers: Computation<any>[] | null;
    observerSlots: number[] | null;
    pending: T | {};
    tValue?: T;
    comparator?: (prev: T, next: T) => boolean;
    name?: string;
}
interface Owner {
    owned: Computation<any>[] | null;
    cleanups: (() => void)[] | null;
    owner: Owner | null;
    context: any | null;
    attached?: boolean;
    sourceMap?: Record<string, {
        value: unknown;
    }>;
    name?: string;
}
interface Computation<T> extends Owner {
    fn: (v?: T) => T;
    state: number;
    sources: Signal<T>[] | null;
    sourceSlots: number[] | null;
    value?: T;
    updatedAt: number | null;
    pure: boolean;
    user?: boolean;
    suspense?: SuspenseContextType;
}
export declare function createRoot<T>(fn: (dispose: () => void) => T, detachedOwner?: Owner): T;
export declare function createSignal<T>(): [() => T | undefined, (v?: T) => T];
export declare function createSignal<T>(value: T, areEqual?: boolean | ((prev: T, next: T) => boolean), options?: {
    name?: string;
    internal?: boolean;
}): [() => T, (v: T) => T];
export declare function createComputed<T>(fn: (v?: T) => T, value?: T): void;
export declare function createRenderEffect<T>(fn: (v?: T) => T, value?: T): void;
export declare function createEffect<T>(fn: (v?: T) => T, value?: T): void;
export declare function resumeEffects(e: Computation<any>[]): void;
export declare function createMemo<T>(fn: (v?: T) => T, value?: undefined, areEqual?: boolean | ((prev: T, next: T) => boolean)): () => T;
export declare function createMemo<T>(fn: (v: T) => T, value: T, areEqual?: boolean | ((prev: T, next: T) => boolean)): () => T;
export declare function createDeferred<T>(source: () => T, options?: {
    timeoutMs: number;
}): () => unknown;
export declare function createSelector<T, U>(source: () => T, fn?: (a: U, b: T) => boolean): (key: U) => boolean;
export declare function batch<T>(fn: () => T): T;
export declare function useTransition(): [() => boolean, (fn: () => void) => void];
export declare function untrack<T>(fn: () => T): T;
export declare function on<T, U>(w: () => T, fn: (v: T, prev: T, prevResult: U) => U): (prev?: U) => U;
export declare function on<T1, T2, U>(w1: () => T1, w2: () => T2, fn: (v: [T1, T2], prev: [T1, T2], prevResult: U) => U): (prev?: U) => U;
export declare function on<T1, T2, T3, U>(w1: () => T1, w2: () => T2, w3: () => T3, fn: (v: [T1, T2, T3], p: [T1, T2, T3], prevResult: U) => U): (prev?: U) => U;
export declare function on<T1, T2, T3, T4, U>(w1: () => T1, w2: () => T2, w3: () => T3, w4: () => T4, fn: (v: [T1, T2, T3, T4], p: [T1, T2, T3, T4], prevResult: U) => U): (prev?: U) => U;
export declare function on<T1, T2, T3, T4, T5, U>(w1: () => T1, w2: () => T2, w3: () => T3, w4: () => T4, w5: () => T5, fn: (v: [T1, T2, T3, T4, T5], p: [T1, T2, T3, T4, T5], prevResults: U) => U): (prev?: U) => U;
export declare function onMount(fn: () => void): void;
export declare function onCleanup(fn: () => void): () => void;
export declare function onError(fn: (err: any) => void): void;
export declare function getListener(): Computation<any> | null;
export declare function getContextOwner(): Owner | null;
export declare function hashValue(v: any): string;
export declare function registerGraph(name: string, value: {
    value: unknown;
}): string;
interface GraphRecord {
    [k: string]: GraphRecord | unknown;
}
export declare function serializeGraph(owner?: Owner | null): GraphRecord;
export interface Context<T> {
    id: symbol;
    Provider: (props: {
        value: T;
        children: any;
    }) => any;
    defaultValue?: T;
}
export declare function createContext<T>(defaultValue?: T): Context<T>;
export declare function useContext<T>(context: Context<T>): T;
declare type SuspenseContextType = {
    increment?: () => void;
    decrement?: () => void;
    inFallback?: () => boolean;
    effects?: Computation<any>[];
    resolved?: boolean;
};
export declare function getSuspenseContext(): Context<SuspenseContextType> & {
    active?(): boolean;
    increment?(): void;
    decrement?(): void;
};
export interface Resource<T> {
    (): T | undefined;
    loading: boolean;
}
export declare function createResource<T>(init?: T, options?: {
    name?: string;
    notStreamed?: boolean;
}): [Resource<T>, (fn: () => Promise<T> | T) => Promise<T>];
export {};
