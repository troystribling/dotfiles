import { createMemo, createRoot, splitProps, untrack } from 'solid-js';
export { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, assignProps, createComponent, getContextOwner as currentContext, createRenderEffect as effect } from 'solid-js';

function memo(fn, equal) {
  return createMemo(fn, undefined, equal);
}

const booleans = ["allowfullscreen", "allowpaymentrequest", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "ismap", "itemscope", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected", "truespeed"];
const BooleanAttributes = new Set(booleans);
const Aliases = {
  className: "class",
  htmlFor: "for"
};

function dynamicProperty(props, key) {
  const src = props[key];
  Object.defineProperty(props, key, {
    get() {
      return src();
    },
    enumerable: true
  });
  return props;
}
function getHydrationKey() {
  return globalThis._$HYDRATION.context.id;
}

function ssrClassList(value) {
  let classKeys = Object.keys(value),
      result = "";
  for (let i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i],
          classValue = !!value[key];
    if (!key || !classValue) continue;
    i && (result += " ");
    result += key;
  }
  return result;
}
function ssrStyle(value) {
  if (typeof value === "string") return value;
  let result = "";
  const k = Object.keys(value);
  for (let i = 0; i < k.length; i++) {
    const s = k[i];
    if (i) result += ";";
    result += `${s}:${escape(value[s], true)}`;
  }
  return result;
}
function ssrSpread(props) {
  return () => {
    if (typeof props === "function") props = props();
    const keys = Object.keys(props);
    let result = "";
    for (let i = 0; i < keys.length; i++) {
      const prop = keys[i];
      if (prop === "children") {
        console.warn(`SSR currently does not support spread children.`);
        continue;
      }
      const value = props[prop];
      if (prop === "style") {
        result += `style="${ssrStyle(value)}"`;
      } else if (prop === "classList") {
        result += `class="${ssrClassList(value)}"`;
      } else if (BooleanAttributes.has(prop)) {
        if (value) result += prop;else continue;
      } else {
        result += `${Aliases[prop] || prop}="${escape(value, true)}"`;
      }
      if (i !== keys.length - 1) result += " ";
    }
    return result;
  };
}
function ssrBoolean(key, value) {
  return value ? " " + key : "";
}
function escape(s, attr) {
  const t = typeof s;
  if (t !== "string") {
    if (attr && t === "boolean") return String(s);
    return s;
  }
  const delim = attr ? '"' : "<";
  const escDelim = attr ? "&quot;" : "&lt;";
  let iDelim = s.indexOf(delim);
  let iAmp = s.indexOf("&");
  if (iDelim < 0 && iAmp < 0) return s;
  let left = 0,
      out = "";
  while (iDelim >= 0 && iAmp >= 0) {
    if (iDelim < iAmp) {
      if (left < iDelim) out += s.substring(left, iDelim);
      out += escDelim;
      left = iDelim + 1;
      iDelim = s.indexOf(delim, left);
    } else {
      if (left < iAmp) out += s.substring(left, iAmp);
      out += "&amp;";
      left = iAmp + 1;
      iAmp = s.indexOf("&", left);
    }
  }
  if (iDelim >= 0) {
    do {
      if (left < iDelim) out += s.substring(left, iDelim);
      out += escDelim;
      left = iDelim + 1;
      iDelim = s.indexOf(delim, left);
    } while (iDelim >= 0);
  } else while (iAmp >= 0) {
    if (left < iAmp) out += s.substring(left, iAmp);
    out += "&amp;";
    left = iAmp + 1;
    iAmp = s.indexOf("&", left);
  }
  return left < s.length ? out + s.substring(left) : out;
}
function resolveSSRNode(node) {
  const t = typeof node;
  if (t === "string") return node;
  if (node == null || t === "boolean") return "";
  if (Array.isArray(node)) return node.map(resolveSSRNode).join("");
  if (t === "object") return resolveSSRNode(node.t);
  if (t === "function") return resolveSSRNode(node());
  return String(node);
}

function renderToString(code, options = {}) {
  options = {
    timeoutMs: 30000,
    ...options
  };
  const hydration = globalThis._$HYDRATION || (globalThis._$HYDRATION = {});
  hydration.context = {
    id: "0",
    count: 0
  };
  hydration.asyncSSR = true;
  hydration.resources = {};
  return createRoot(() => {
    const rendered = code();
    if (typeof rendered === "object" && "then" in rendered) {
      const timeout = new Promise((_, reject) => setTimeout(() => reject("renderToString timed out"), options.timeoutMs));
      return Promise.race([rendered, timeout]).then(resolveSSRNode);
    }
    return resolveSSRNode(rendered);
  });
}
function ssr(t, ...nodes) {
  if (!nodes.length) return {
    t
  };
  for (let i = 0; i < nodes.length; i++) {
    const n = nodes[i];
    if (typeof n === "function") nodes[i] = memo(() => {
      let v = n();
      if (typeof v === "function") {
        return memo(() => {
          let val = v();
          while (typeof val === "function") val = val();
          return resolveSSRNode(val);
        });
      }
      return resolveSSRNode(v);
    });
  }
  return {
    t: () => {
      let result = "";
      for (let i = 0; i < t.length; i++) {
        result += t[i];
        const node = nodes[i];
        if (node !== undefined) result += resolveSSRNode(node);
      }
      return result;
    }
  };
}
function generateHydrationScript({
  eventNames = ["click", "input", "blur"]
} = {}) {
  let s = `(()=>{_$HYDRATION={events:[],completed:new WeakSet};const t=e=>e&&e.hasAttribute&&(e.hasAttribute("data-hk")&&e||t(e.host&&e.host instanceof Node?e.host:e.parentNode)),e=e=>{let o=e.composedPath&&e.composedPath()[0]||e.target,s=t(o);s&&!_$HYDRATION.completed.has(s)&&_$HYDRATION.events.push([s,e])};["${eventNames.join('","')}"].forEach(t=>document.addEventListener(t,e))})();`;
  s += `_$HYDRATION.resources = JSON.parse('${JSON.stringify(_$HYDRATION.resources || {}).replace(/'/g, "\\'").replace(/\\\"/g, '\\\\\\"')}');`;
  return s;
}

const isServer = true;
function spread() {}
function Dynamic(props) {
  const [p, others] = splitProps(props, ["component"]);
  return createMemo(() => {
    const comp = p.component,
          t = typeof comp;
    if (comp) {
      if (t === "function") return untrack(() => comp(others));else if (t === "string") {
        const [local, sOthers] = splitProps(others, ["children"]);
        return ssr([`<${comp} `, ">", `</${comp}>`], ssrSpread(sOthers), local.children || "");
      }
    }
  });
}
function Portal(props) {
  return "";
}

export { Dynamic, Portal, dynamicProperty, escape, generateHydrationScript, getHydrationKey, isServer, memo, renderToString, resolveSSRNode, spread, ssr, ssrBoolean, ssrClassList, ssrSpread, ssrStyle };
